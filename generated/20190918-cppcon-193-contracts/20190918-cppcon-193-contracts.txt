Contract Use: Past, Present, and Future

   Joshua Berne - jberne4@bloomberg.net



                2019-09-18




                                          1 / 51   1 / 248
                                Copyright Notice



©2019 Bloomberg L.P. Permission is granted to copy, distribute, and display this
material, and to make derivative works and commercial use of it. The information in
this material is provided “AS IS”, without warranty of any kind. Neither Bloomberg
nor any employee guarantees the correctness or completeness of such information.
Bloomberg, its employees, and its aﬀiliated entities and persons shall not be liable,
directly or indirectly, in any way, for any inaccuracies, errors or omissions in such
information. Nothing herein should be interpreted as stating the opinions, policies,
recommendations, or positions of Bloomberg.




                                                                                   2 / 51   2 / 248
                                 Who am I?



Software developer all century




I have a purple house.
First time presenting at CppCon
First time presenting at a Conference




                                             3 / 51   3 / 248
                                 Who am I?



Software developer all century




I have a purple house.
First time presenting at CppCon
First time presenting at a Conference (Be gently please)




                                                           3 / 51   4 / 248
                              Who am I?



Bloomberg LP since 2017
Joined BDE team in 2018
Contract checking and deployment with BSLS_REVIEW
WG21 participation to make contracts better
SG21 participation with same goal




                                                    4 / 51   5 / 248
1   Introduction

2   Basic Contracts
      English Contracts
      In Code Contracts

3   Doing Stuff With Contracts

4   SG21

5   Conclusion




                                 5 / 51   6 / 248
                              English Contracts
Contracts are an agreement between two parties




                                                  6 / 51   7 / 248
                               English Contracts
Software contracts are an agreement between a library writer and client




                                                                          6 / 51   8 / 248
                               English Contracts
Function contracts can be rendered in english




T* binsearch(T*begin, T*end, const T& val);
  // Return a pointer to an element between the
  // specified 'begin' and 'end' that is greater
  // than or equal to the specified 'val', or 'end'
  // if no such value exists. This function will
  // perform no more than log(distance(begin,end))
  // comparisons. The behavior is undefined
  // unless '[begin,end)' is a contiguous sorted
  // range.

                                                      6 / 51   9 / 248
                               English Contracts
Describe what a function will do




T* binsearch(T*begin, T*end, const T& val);
  // Return a pointer to an element between the
  // specified 'begin' and 'end' that is greater
  // than or equal to the specified 'val', or 'end'
  // if no such value exists. This function will
  // perform no more than log(distance(begin,end))
  // comparisons. The behavior is undefined
  // unless '[begin,end)' is a contiguous sorted
  // range.

                                                      6 / 51   10 / 248
                               English Contracts
Describe what behavior is not supported




T* binsearch(T*begin, T*end, const T& val);
  // Return a pointer to an element between the
  // specified 'begin' and 'end' that is greater
  // than or equal to the specified 'val', or 'end'
  // if no such value exists. This function will
  // perform no more than log(distance(begin,end))
  // comparisons. The behavior is undefined
  // unless '[begin,end)' is a contiguous sorted
  // range.

                                                      6 / 51   11 / 248
                      Undefined Behavior



undefined behavior
behavior for which this document imposes no requirements
                   N4830 - Working Draft, Standard for Programming Language C++




                                                                          7 / 51   12 / 248
                       Undefined Behavior



undefined behavior
behavior for which this document imposes no requirements
                   N4830 - Working Draft, Standard for Programming Language C++



library undefined behavior
behavior for which a library contract provides no guarantees
                                                           John Lakos - CppCon 2014




                                                                              7 / 51   13 / 248
                       Undefined Behavior



language undefined behavior
behavior for which this document imposes no requirements
                   N4830 - Working Draft, Standard for Programming Language C++



library undefined behavior
behavior for which a library contract provides no guarantees
                                                           John Lakos - CppCon 2014




                                                                              7 / 51   14 / 248
                               English Contracts
Describe what behavior is not supported




T* binsearch(T*begin, T*end, const T& val);
  // Return a pointer to an element between the
  // specified 'begin' and 'end' that is greater
  // than or equal to the specified 'val', or 'end'
  // if no such value exists. This function will
  // perform no more than log(distance(begin,end))
  // comparisons. The behavior is undefined
  // unless '[begin,end)' is a contiguous sorted
  // range.

                                                      8 / 51   15 / 248
                         English Contracts
Preconditions




T* binsearch(T*begin, T*end, const T& val);
  // Return a pointer to an element between the
  // specified 'begin' and 'end' that is greater
  // than or equal to the specified 'val', or 'end'
  // if no such value exists. This function will
  // perform no more than log(distance(begin,end))
  // comparisons. The behavior is undefined
  // unless '[begin,end)' is a contiguous sorted
  // range.

                                                      8 / 51   16 / 248
                         English Contracts
Postconditions




T* binsearch(T*begin, T*end, const T& val);
  // Return a pointer to an element between the
  // specified 'begin' and 'end' that is greater
  // than or equal to the specified 'val', or 'end'
  // if no such value exists. This function will
  // perform no more than log(distance(begin,end))
  // comparisons. The behavior is undefined
  // unless '[begin,end)' is a contiguous sorted
  // range.

                                                      8 / 51   17 / 248
                         English Contracts
Essential Behavior




T* binsearch(T*begin, T*end, const T& val);
  // Return a pointer to an element between the
  // specified 'begin' and 'end' that is greater
  // than or equal to the specified 'val', or 'end'
  // if no such value exists. This function will
  // perform no more than log(distance(begin,end))
  // comparisons. The behavior is undefined
  // unless '[begin,end)' is a contiguous sorted
  // range.

                                                      8 / 51   18 / 248
Violating a contract is a bug




                                9 / 51   19 / 248
Violating a contract is a bug

Bugs are contract violations




                                9 / 51   20 / 248
Violating a contract is a bug

Bugs are contract violations

   Possibly a contract no one wrote down




                                           9 / 51   21 / 248
                       What can be checked?




Parts of the english contract might be checkable with standard C++ expressions.




                                                                           10 / 51   22 / 248
                       What can be checked?




Parts of the english contract might be checkable with standard C++ expressions.
Parts might have readbale representations that cannot be implemented




                                                                           10 / 51   23 / 248
                       What can be checked?




Parts of the english contract might be checkable with standard C++ expressions.
Parts might have readbale representations that cannot be implemented
Parts might be statements beyond the scope of a single function execution




                                                                            10 / 51   24 / 248
                              In code contracts
Some parts can be rendered with code




T* binsearch(T*begin, T*end, const T& val);
  // Return a pointer to an element between the
  // specified 'begin' and 'end' that is greater
  // than or equal to the specified 'val', or 'end'
  // if no such value exists. This function will
  // perform no more than log(distance(begin,end))
  // comparisons. The behavior is undefined
  // unless '[begin,end)' is a contiguous sorted
  // range.

                                                      11 / 51   25 / 248
                            In code contracts
Simple boolean predicates

begin != nullptr
end != nullptr
begin <= end

T* binsearch(T*begin, T*end, const T& val);
  // Return a pointer to an element between the
  // specified 'begin' and 'end' that is greater
  // than or equal to the specified 'val', or 'end'
  // if no such value exists. This function will
  // perform no more than log(distance(begin,end))
  // comparisons. The behavior is undefined
  // unless '[begin,end)' is a contiguous sorted
  // range.

                                                      11 / 51   26 / 248
                                  In code contracts
Predicates about returned value

return_val >= begin
return_val <= end
return_val == end *return_val >= val

T* binsearch(T*begin, T*end, const T& val);
  // Return a pointer to an element between the
  // specified 'begin' and 'end' that is greater
  // than or equal to the specified 'val', or 'end'
  // if no such value exists. This function will
  // perform no more than log(distance(begin,end))
  // comparisons. The behavior is undefined
  // unless '[begin,end)' is a contiguous sorted
  // range.

                                                      11 / 51   27 / 248
                         In code contracts
Hard to check things

is_sorted(begin,end)




T* binsearch(T*begin, T*end, const T& val);
  // Return a pointer to an element between the
  // specified 'begin' and 'end' that is greater
  // than or equal to the specified 'val', or 'end'
  // if no such value exists. This function will
  // perform no more than log(distance(begin,end))
  // comparisons. The behavior is undefined
  // unless '[begin,end)' is a contiguous sorted
  // range.

                                                      11 / 51   28 / 248
                         In code contracts
Uncheckable things?

is_reachable_from(begin,end)




T* binsearch(T*begin, T*end, const T& val);
  // Return a pointer to an element between the
  // specified 'begin' and 'end' that is greater
  // than or equal to the specified 'val', or 'end'
  // if no such value exists. This function will
  // perform no more than log(distance(begin,end))
  // comparisons. The behavior is undefined
  // unless '[begin,end)' is a contiguous sorted
  // range.

                                                      11 / 51   29 / 248
                                   In code contracts
Properties of repeated execution

        ??????????????????




T* binsearch(T*begin, T*end, const T& val);
  // Return a pointer to an element between the
  // specified 'begin' and 'end' that is greater
  // than or equal to the specified 'val', or 'end'
  // if no such value exists. This function will
  // perform no more than log(distance(begin,end))
  // comparisons. The behavior is undefined
  // unless '[begin,end)' is a contiguous sorted
  // range.

                                                       11 / 51   30 / 248
1   Introduction

2   Basic Contracts

3   Doing Stuff With Contracts
      A Dream
      Less Bugs
      Deploying it
      Faster Code

4   SG21

5   Conclusion


                                 12 / 51   31 / 248
                             Proven contracts


Prove software correctness




                                                13 / 51   32 / 248
                          Proven contracts


Prove software correctness
Encode contracts completely




                                             13 / 51   33 / 248
                          Proven contracts


Prove software correctness
Encode contracts completely
    All preconditions




                                             13 / 51   34 / 248
                          Proven contracts


Prove software correctness
Encode contracts completely
    All preconditions
    All postconditions




                                             13 / 51   35 / 248
                             Proven contracts


Prove software correctness
Encode contracts completely
    All preconditions
    All postconditions
    All essential behavior




                                                13 / 51   36 / 248
                              Proven contracts


Prove software correctness
Encode contracts completely
    All preconditions
    All postconditions
    All essential behavior
Statically prove everything




                                                 13 / 51   37 / 248
                              Proven contracts


Prove software correctness
Encode contracts completely
    All preconditions
    All postconditions
    All essential behavior
Statically prove everything
    For each function, prove postconditions and essential behavior




                                                                     13 / 51   38 / 248
                              Proven contracts


Prove software correctness
Encode contracts completely
    All preconditions
    All postconditions
    All essential behavior
Statically prove everything
    For each function, prove postconditions and essential behavior
    Use called functions contracst in proofs of larger functions




                                                                     13 / 51   39 / 248
                              Proven contracts


Prove software correctness
Encode contracts completely
    All preconditions
    All postconditions
    All essential behavior
Statically prove everything
    For each function, prove postconditions and essential behavior
    Use called functions contracst in proofs of larger functions
PROFIT




                                                                     13 / 51   40 / 248
Dream Benefit #1 - Less Bugs




                               14 / 51   41 / 248
                   Dream Benefit #1 - Less Bugs



Compiler identifies all violated contracts




                                                  14 / 51   42 / 248
                   Dream Benefit #1 - Less Bugs



Compiler identifies all violated contracts
Edge cases must be throught through




                                                  14 / 51   43 / 248
                   Dream Benefit #1 - Less Bugs



Compiler identifies all violated contracts
Edge cases must be throught through
All assumptions are captured in compiled code




                                                  14 / 51   44 / 248
                   Dream Benefit #1 - Less Bugs



Compiler identifies all violated contracts
Edge cases must be throught through
All assumptions are captured in compiled code
Mostly, if it compiles, it doesn’t have bugs (contract violations)




                                                                     14 / 51   45 / 248
                   Dream Benefit #1 - Less Bugs



Compiler identifies all violated contracts
Edge cases must be throught through
All assumptions are captured in compiled code
Mostly, if it compiles, it doesn’t have bugs (contract violations)
If there is a bug, contracts just need to be elaborated




                                                                     14 / 51   46 / 248
Dream Benefit #2 - Less Heat Generation




                                          15 / 51   47 / 248
          Dream Benefit #2 - Less Heat Generation



No need for any checks




                                                    15 / 51   48 / 248
          Dream Benefit #2 - Less Heat Generation



No need for any checks
More knowledge for the compiler




                                                    15 / 51   49 / 248
          Dream Benefit #2 - Less Heat Generation



No need for any checks
More knowledge for the compiler
    __builtin_assume




                                                    15 / 51   50 / 248
          Dream Benefit #2 - Less Heat Generation



No need for any checks
More knowledge for the compiler
    __builtin_assume
    Removing excess branches




                                                    15 / 51   51 / 248
           Dream Benefit #2 - Less Heat Generation



No need for any checks
More knowledge for the compiler
    __builtin_assume
    Removing excess branches
    Vectorization/SIMD instructions




                                                     15 / 51   52 / 248
           Dream Benefit #2 - Less Heat Generation



No need for any checks
More knowledge for the compiler
    __builtin_assume
    Removing excess branches
    Vectorization/SIMD instructions
Smaller code size




                                                     15 / 51   53 / 248
           Realizing parts of the dream



WARNING:




                                          16 / 51   54 / 248
              Realizing parts of the dream



WARNING: MACROS INCOMING




                                             16 / 51   55 / 248
                   Realizing parts of the dream



WARNING: MACROS INCOMING
How to leverage contracts without a language feature




                                                       16 / 51   56 / 248
                   Realizing parts of the dream



WARNING: MACROS INCOMING
How to leverage contracts without a language feature
Bloomberg has been doing this for 15 years




                                                       16 / 51   57 / 248
                    Realizing parts of the dream



WARNING: MACROS INCOMING
How to leverage contracts without a language feature
Bloomberg has been doing this for 15 years
See the BDE open source repostory for the real implementation
    https://github.com/bloomberg/bde/blob/master/groups/bsl/bsls/bsls_assert.h
    https://github.com/bloomberg/bde/blob/master/groups/bsl/bsls/bsls_review.h




                                                                                 16 / 51   58 / 248
What do you do if you can’t prove a contract is being followed?




                                                                  17 / 51   59 / 248
What do you do if you can’t prove a contract is being followed?



                              Experiment



                                                                  17 / 51   60 / 248
1   Introduction

2   Basic Contracts

3   Doing Stuff With Contracts
      A Dream
      Less Bugs
      Deploying it
      Faster Code

4   SG21

5   Conclusion


                                 18 / 51   61 / 248
                       Documenting expectations
Initial benefit of contracts in code




                                                  19 / 51   62 / 248
                          Documenting expectations
   Initial benefit of contracts in code




#define ASSERT(X)




                                                     19 / 51   63 / 248
                          Documenting expectations
   Initial benefit of contracts in code
   Bloomberg specific naming




#define BSLS_ASSERT(X)




                                                     19 / 51   64 / 248
                          Documenting expectations
   Initial benefit of contracts in code
   Bloomberg specific naming
   Avoid code rot




#define BSLS_ASSERT(X) sizeof( (X)?true:false )




                                                     19 / 51   65 / 248
                          Documenting expectations
   Initial benefit of contracts in code
   Bloomberg specific naming
   Avoid code rot
   ... wish we had done that originally




#ifdef BSLS_ASSERT_VALIDATE_DISABLED_MACROS
#define BSLS_ASSERT(X) sizeof( (X)?true:false )
#else
#define BSLS_ASSERT(X)
#endif


                                                     19 / 51   66 / 248
                          Documenting expectations
   Initial benefit of contracts in code
   Bloomberg specific naming
   Avoid code rot
   ... wish we had done that originally
   ... or at least this to require a ;



#define BSLS_ASSERT(X) ((void)0)




                                                     19 / 51   67 / 248
                          Documenting expectations
   Initial benefit of contracts in code
   Bloomberg specific naming
   Avoid code rot
   ... wish we had done that originally
   ... or at least this to require a ;
   For simplicity


#define ASSERT(X)




                                                     19 / 51   68 / 248
                            Aborting on bugs



Identifying violations would be nice




                                               20 / 51   69 / 248
                               Aborting on bugs



   Identifying violations would be nice
   The safest thing to do is stop immediately




#define ASSERT(X) if (!(X)) { std::abort(); }




                                                  20 / 51   70 / 248
                               Aborting on bugs



   Identifying violations would be nice
   The safest thing to do is stop immediately
   Nice if ASSERT(X) needs a semicolon



#define ASSERT(X) do { if (!(X)) { std::abort(); } } while (false)




                                                                20 / 51   71 / 248
                               Aborting on bugs



   Identifying violations would be nice
   The safest thing to do is stop immediately
   Nice if ASSERT(X) needs a semicolon
   For simplicity


#define ASSERT(X) if (!(X)) { std::abort(); }




                                                  20 / 51   72 / 248
                        ... only in some builds
Checks of contracts are redundant if they’re not broken




                                                          21 / 51   73 / 248
                           ... only in some builds
   Checks of contracts are redundant if they’re not broken
   NDEBUG might be a way to control enablement




#ifdef NDEBUG
#define ASSERT(X)
#else
#define ASSERT(X) if (!(X)) { std::abort(); }
#endif




                                                             21 / 51   74 / 248
                           ... only in some builds
   Checks of contracts are redundant if they’re not broken
   NDEBUG might be a way to control enablement
   This reminds me of something



#include <cassert>
#define ASSERT(X) assert(X)




                                                             21 / 51   75 / 248
                           ... only in some builds
   Checks of contracts are redundant if they’re not broken
   NDEBUG might be a way to control enablement
   This reminds me of something
   Separating out controls from behavior helps


#define ASSERT_IMP(X)                if (!(X)) { std::abort(); }




                                                                   21 / 51   76 / 248
                           ... only in some builds
   Checks of contracts are redundant if they’re not broken
   NDEBUG might be a way to control enablement
   This reminds me of something
   Separating out controls from behavior helps


#define ASSERT_IMP(X)          if (!(X)) { std::abort(); }
#define ASSERT_DISABLED_IMP(X)




                                                             21 / 51   77 / 248
                           ... only in some builds
   Checks of contracts are redundant if they’re not broken
   NDEBUG might be a way to control enablement
   This reminds me of something
   Separating out controls from behavior helps


#define ASSERT_IMP(X)          if (!(X)) { std::abort(); }
#define ASSERT_DISABLED_IMP(X)

#ifdef ASSERT_LEVEL_ASSERT
#define ASSERT(X) ASSERT_IMP(X)
#else
#define ASSERT(X) ASSERT_DISABLED_IMP(X)
#endif

                                                             21 / 51   78 / 248
                         ... but what happened?

   Aborting with no information sucks




#define ASSERT_IMP(X) if (!(X)) {                           \
    /*POOF*/ ;                                              \
    std::abort();                                           \
}




                                                  22 / 51   79 / 248
                          ... but what happened?

    Aborting with no information sucks
    Logging something helps




#define ASSERT_IMP(X) if (!(X)) {                            \
    printf("ASSERTION FAILED!\n");                           \
                                                             \
    std::abort();                                            \
}



                                                   22 / 51   80 / 248
                         ... but what happened?

   Aborting with no information sucks
   Logging something helps
   The preprocessor can give us more help




#define ASSERT_IMP(X) if (!(X)) {                                  \
    printf("ASSERTION FAILED (" __FILE__ ":%d): %s\n",             \
                                __LINE__, #X);                     \
    std::abort();                                                  \
}



                                                         22 / 51   81 / 248
What about this guy?




                       23 / 51   82 / 248
                           ... but what happened?

    Aborting with no information sucks
    Logging something helps
    The preprocessor can give us more help
    Delegating to a pluggable function helps that



#define ASSERT_IMP(X) if (!(X)) {                                         \
    bb::Assert::invoke_violation_handler(__FILE__, __LINE__, #X);         \
                                                                          \
    std::abort();                                                         \
}



                                                                24 / 51   83 / 248
                          ... but what happened?

   Aborting with no information sucks
   Logging something helps
   The preprocessor can give us more help
   Delegating to a pluggable function helps that



#define ASSERT_IMP(X) if (!(X)) {                                         \
    bb::assert_violation violation(__FILE__, __LINE__, #X); \
    bb:Assert::invoke_violation_handler(violation);                       \
    std::abort();                                                         \
}



                                                                24 / 51       84 / 248
                          ... but what happened?

   Aborting with no information sucks
   Logging something helps
   The preprocessor can give us more help
   Delegating to a pluggable function helps that
   Leave all behavior up to the violation handler


#define ASSERT_IMP(X) if (!(X)) {                                       \
    bb::assert_violation violation(__FILE__, __LINE__, #X);             \
    bb::Assert::invoke_violation_handler(violation);                    \
}




                                                              24 / 51   85 / 248
                          ... but what happened?

   Aborting with no information sucks
   Logging something helps
   The preprocessor can give us more help
   Delegating to a pluggable function helps that
   Leave all behavior up to the violation handler


void bb::Assert::invoke_violation_handler(
                            const bb::assert_violation &violation) {
    getViolationHandler()(violation);
}




                                                                24 / 51   86 / 248
                          ... but what happened?

   Aborting with no information sucks
   Logging something helps
   The preprocessor can give us more help
   Delegating to a pluggable function helps that
   Leave all behavior up to the violation handler


void xkcd::violationHandler(const bb::assert_violation &violation) {
  printf("Error\n");
  printf("If you're seeing this, the code is in what\n");
  printf("I thought was an unreachable state.");
  //...
}


                                                                24 / 51   87 / 248
                        ... but what happened?

 Aborting with no information sucks
 Logging something helps
 The preprocessor can give us more help
 Delegating to a pluggable function helps that
 Leave all behavior up to the violation handler


int main() {
  bb::Assert::setViolationHandler(&xkcd::violationHandler);
  //..
}




                                                              24 / 51   88 / 248
                 ... that doesn’t work everywhere!


The violation handler can notify in different ways




                                                     25 / 51   89 / 248
                 ... that doesn’t work everywhere!


The violation handler can notify in different ways
    Custom logging frameworks




                                                     25 / 51   90 / 248
                  ... that doesn’t work everywhere!


The violation handler can notify in different ways
    Custom logging frameworks
    GUI messages (abort, retry, fail?)




                                                      25 / 51   91 / 248
                  ... that doesn’t work everywhere!


The violation handler can notify in different ways
    Custom logging frameworks
    GUI messages (abort, retry, fail?)
    Hardware notifications




                                                      25 / 51   92 / 248
                   ... that doesn’t work everywhere!


The violation handler can notify in different ways
     Custom logging frameworks
     GUI messages (abort, retry, fail?)
     Hardware notifications
... do different things




                                                       25 / 51   93 / 248
                   ... that doesn’t work everywhere!


The violation handler can notify in different ways
     Custom logging frameworks
     GUI messages (abort, retry, fail?)
     Hardware notifications
... do different things
     std::abort()




                                                       25 / 51   94 / 248
                   ... that doesn’t work everywhere!


The violation handler can notify in different ways
     Custom logging frameworks
     GUI messages (abort, retry, fail?)
     Hardware notifications
... do different things
     std::abort()
     while (true) {std::this_thread::sleep_for(std::chrono::years(1));}




                                                                    25 / 51   95 / 248
                   ... that doesn’t work everywhere!


The violation handler can notify in different ways
     Custom logging frameworks
     GUI messages (abort, retry, fail?)
     Hardware notifications
... do different things
     std::abort()
     while (true) {std::this_thread::sleep_for(std::chrono::years(1));}
     throw std:::exception("Oops?");




                                                                    25 / 51   96 / 248
                   ... that doesn’t work everywhere!


The violation handler can notify in different ways
     Custom logging frameworks
     GUI messages (abort, retry, fail?)
     Hardware notifications
... do different things
     std::abort()
     while (true) {std::this_thread::sleep_for(std::chrono::years(1));}
     throw std:::exception("Oops?");
... or try to recover?




                                                                    25 / 51   97 / 248
                   ... that doesn’t work everywhere!


The violation handler can notify in different ways
     Custom logging frameworks
     GUI messages (abort, retry, fail?)
     Hardware notifications
... do different things
     std::abort()
     while (true) {std::this_thread::sleep_for(std::chrono::years(1));}
     throw std:::exception("Oops?");
... or try to recover?
main gets to decide




                                                                    25 / 51   98 / 248
                               Checking is slow!
   Checks use state already in cache, are often very fast




T* binsearch(T*begin, T*end, const T& val) {
  ASSERT(begin);
  ASSERT(end);
  ASSERT(begin < end)7
  //..
}



                                                            26 / 51   99 / 248
                               Checking is slow!
   Checks use state already in cache, are often very fast
   Algorithmic complexity can still ruin that




T* binsearch(T*begin, T*end, const T& val) {
  ASSERT(is_sorted_range(begin,end));
  //..
}




                                                            26 / 51   100 / 248
                               Checking is slow!
   Checks use state already in cache, are often very fast
   Algorithmic complexity can still ruin that
   3 levels of complexity




#define ASSERT_OPT(X) ...
#define ASSERT(X) ...
#define ASSERT_SAFE(X) ...




                                                            26 / 51   101 / 248
                               Checking is slow!
   Checks use state already in cache, are often very fast
   Algorithmic complexity can still ruin that
   3 levels of complexity
   ... 2 levels probably suﬀicient




[[ assert default : X ]];
[[ assert audit : X ]];




                                                            26 / 51   102 / 248
                               Checking is slow!
   Checks use state already in cache, are often very fast
   Algorithmic complexity can still ruin that
   3 levels of complexity
   ... 2 levels probably suﬀicient
   Linear scale of enablement



#if defined(ASSERT_LEVEL_NONE)   ? 1 : 0 \
  + defined(ASSERT_LEVEL_OPT)    ? 1 : 0 \
  + defined(ASSERT_LEVEL_ASSERT) ? 1 : 0 \
  + defined(ASSERT_LEVEL_SAFE)   ? 1 : 0 \
  > 1
#error Multiple ASSERT_LEVEL macros defined
#endif


                                                            26 / 51   103 / 248
                               Checking is slow!
   Checks use state already in cache, are often very fast
   Algorithmic complexity can still ruin that
   3 levels of complexity
   ... 2 levels probably suﬀicient
   Linear scale of enablement



#if !defined(ASSERT_LEVEL_NONE)   \
 && !defined(ASSERT_LEVEL_OPT)    \
 && !defined(ASSERT_LEVEL_ASSERT) \
 && !defined(ASSERT_LEVEL_SAFE)
#define ASSERT_LEVEL_ASSERT
#endif



                                                            26 / 51   104 / 248
                               Checking is slow!
   Checks use state already in cache, are often very fast
   Algorithmic complexity can still ruin that
   3 levels of complexity
   ... 2 levels probably suﬀicient
   Linear scale of enablement



#if defined(ASSERT_LEVEL_NONE)
#define ASSERT_OPT(X) ASSERT_DISABLED_IMP(X)
#define ASSERT(X)      ASSERT_DISABLED_IMP(X)
#define ASSERT_SAFE(X) ASSERT_DISABLED_IMP(X)
//..




                                                            26 / 51   105 / 248
                               Checking is slow!
   Checks use state already in cache, are often very fast
   Algorithmic complexity can still ruin that
   3 levels of complexity
   ... 2 levels probably suﬀicient
   Linear scale of enablement



//..
#elif defined(ASSERT_LEVEL_OPT)
#define ASSERT_OPT(X) ASSERT_IMP(X)
#define ASSERT(X)      ASSERT_DISABLED_IMP(X)
#define ASSERT_SAFE(X) ASSERT_DISABLED_IMP(X)
//..



                                                            26 / 51   106 / 248
                               Checking is slow!
   Checks use state already in cache, are often very fast
   Algorithmic complexity can still ruin that
   3 levels of complexity
   ... 2 levels probably suﬀicient
   Linear scale of enablement



//..
#elif defined(ASSERT_LEVEL_ASSERT)
#define ASSERT_OPT(X) ASSERT_IMP(X)
#define ASSERT(X)      ASSERT_IMP(X)
#define ASSERT_SAFE(X) ASSERT_DISABLED_IMP(X)
//..



                                                            26 / 51   107 / 248
                               Checking is slow!
   Checks use state already in cache, are often very fast
   Algorithmic complexity can still ruin that
   3 levels of complexity
   ... 2 levels probably suﬀicient
   Linear scale of enablement



//..
#elif defined(ASSERT_LEVEL_SAFE)
#define ASSERT_OPT(X) ASSERT_IMP(X)
#define ASSERT(X)      ASSERT_IMP(X)
#define ASSERT_SAFE(X) ASSERT_IMP(X)
#endif



                                                            26 / 51   108 / 248
                               Checking is slow!
   Checks use state already in cache, are often very fast
   Algorithmic complexity can still ruin that
   3 levels of complexity
   ... 2 levels probably suﬀicient
   Linear scale of enablement



#if defined(ASSERT_LEVEL_OPT)    \
  defined(ASSERT_LEVEL_ASSERT) \
  defined(ASSERT_LEVEL_SAFE)
#define ASSERT_OPT(X) ASSERT_IMP(X)
#else
 // defined(ASSERT_LEVEL_NONE)
#define ASSERT_OPT(X) ASSERT_DISABLED_IMP(X)
#endif
                                                            26 / 51   109 / 248
                               Checking is slow!
   Checks use state already in cache, are often very fast
   Algorithmic complexity can still ruin that
   3 levels of complexity
   ... 2 levels probably suﬀicient
   Linear scale of enablement



#if defined(ASSERT_LEVEL_ASSERT) \
  defined(ASSERT_LEVEL_SAFE)
#define ASSERT(X) ASSERT_IMP(X)
#else
 // defined(ASSERT_LEVEL_OPT)
 // defined(ASSERT_LEVEL_NONE)
#define ASSERT(X) ASSERT_DISABLED_IMP(X)
#endif
                                                            26 / 51   110 / 248
                               Checking is slow!
   Checks use state already in cache, are often very fast
   Algorithmic complexity can still ruin that
   3 levels of complexity
   ... 2 levels probably suﬀicient
   Linear scale of enablement
   Bloomberg 2005-2018

#if defined(ASSERT_LEVEL_SAFE)
#define ASSERT_SAFE(X) ASSERT_IMP(X)
#else
 // defined(ASSERT_LEVEL_OPT)
 // defined(ASSERT_LEVEL_ASSERT)
 // defined(ASSERT_LEVEL_NONE)
#define ASSERT_SAFE(X) ASSERT_DISABLED_IMP(X)
#endif
                                                            26 / 51   111 / 248
1   Introduction

2   Basic Contracts

3   Doing Stuff With Contracts
      A Dream
      Less Bugs
      Deploying it
      Faster Code

4   SG21

5   Conclusion


                                 27 / 51   112 / 248
                       Choosing Levels in code


Original Suggestion:




                                                 28 / 51   113 / 248
                        Choosing Levels in code


Original Suggestion:
    OPT: 5% most critical tests




                                                  28 / 51   114 / 248
                       Choosing Levels in code


Original Suggestion:
    OPT: 5% most critical tests
    ASSERT: 90% tests <2x performance hit




                                                 28 / 51   115 / 248
                       Choosing Levels in code


Original Suggestion:
    OPT: 5% most critical tests
    ASSERT: 90% tests <2x performance hit
    SAFE: 5% anything slower




                                                 28 / 51   116 / 248
                       Choosing Levels in code


Original Suggestion:
    OPT: 5% most critical tests
    ASSERT: 90% tests <2x performance hit
    SAFE: 5% anything slower
Current Suggestion:




                                                 28 / 51   117 / 248
                       Choosing Levels in code


Original Suggestion:
    OPT: 5% most critical tests
    ASSERT: 90% tests <2x performance hit
    SAFE: 5% anything slower
Current Suggestion:
    OPT: 0-0.5% absolutely critical and 0-impact




                                                   28 / 51   118 / 248
                       Choosing Levels in code


Original Suggestion:
    OPT: 5% most critical tests
    ASSERT: 90% tests <2x performance hit
    SAFE: 5% anything slower
Current Suggestion:
    OPT: 0-0.5% absolutely critical and 0-impact
    ASSERT: 99% non O(n)-impacting




                                                   28 / 51   119 / 248
                       Choosing Levels in code


Original Suggestion:
    OPT: 5% most critical tests
    ASSERT: 90% tests <2x performance hit
    SAFE: 5% anything slower
Current Suggestion:
    OPT: 0-0.5% absolutely critical and 0-impact
    ASSERT: 99% non O(n)-impacting
    SAFE: 0.5-1% algorithmicly slow




                                                   28 / 51   120 / 248
                       Choosing Levels in code


Original Suggestion:
    OPT: 5% most critical tests
    ASSERT: 90% tests <2x performance hit
    SAFE: 5% anything slower
Current Suggestion:
    OPT: 0-0.5% absolutely critical and 0-impact
    ASSERT: 99% non O(n)-impacting
    SAFE: 0.5-1% algorithmicly slow
Changing is hard




                                                   28 / 51   121 / 248
              Choosing Levels in builds


What we did




                                          29 / 51   122 / 248
                    Choosing Levels in builds


What we did
    Developement - ASSERT_LEVEL_ASSERT




                                                29 / 51   123 / 248
                     Choosing Levels in builds


What we did
    Developement - ASSERT_LEVEL_ASSERT
    Unit tests - ASSERT_LEVEL_ASSERT hopefully




                                                 29 / 51   124 / 248
                     Choosing Levels in builds


What we did
    Developement - ASSERT_LEVEL_ASSERT
    Unit tests - ASSERT_LEVEL_ASSERT hopefully
    Beta testing - ASSERT_LEVEL_ASSERT_OPT




                                                 29 / 51   125 / 248
                     Choosing Levels in builds


What we did
    Developement - ASSERT_LEVEL_ASSERT
    Unit tests - ASSERT_LEVEL_ASSERT hopefully
    Beta testing - ASSERT_LEVEL_ASSERT_OPT
    Production - ASSERT_LEVEL_ASSERT_OPT




                                                 29 / 51   126 / 248
                     Choosing Levels in builds


What we did
    Developement - ASSERT_LEVEL_ASSERT
    Unit tests - ASSERT_LEVEL_ASSERT hopefully
    Beta testing - ASSERT_LEVEL_ASSERT_OPT
    Production - ASSERT_LEVEL_ASSERT_OPT
What we wanted




                                                 29 / 51   127 / 248
                     Choosing Levels in builds


What we did
    Developement - ASSERT_LEVEL_ASSERT
    Unit tests - ASSERT_LEVEL_ASSERT hopefully
    Beta testing - ASSERT_LEVEL_ASSERT_OPT
    Production - ASSERT_LEVEL_ASSERT_OPT
What we wanted
    Developement - ASSERT_LEVEL_ASSERT or ASSERT_LEVEL_SAFE




                                                              29 / 51   128 / 248
                     Choosing Levels in builds


What we did
    Developement - ASSERT_LEVEL_ASSERT
    Unit tests - ASSERT_LEVEL_ASSERT hopefully
    Beta testing - ASSERT_LEVEL_ASSERT_OPT
    Production - ASSERT_LEVEL_ASSERT_OPT
What we wanted
    Developement - ASSERT_LEVEL_ASSERT or ASSERT_LEVEL_SAFE
    Unit tests - ASSERT_LEVEL_ASSERT or ASSERT_LEVEL_SAFE




                                                              29 / 51   129 / 248
                     Choosing Levels in builds


What we did
    Developement - ASSERT_LEVEL_ASSERT
    Unit tests - ASSERT_LEVEL_ASSERT hopefully
    Beta testing - ASSERT_LEVEL_ASSERT_OPT
    Production - ASSERT_LEVEL_ASSERT_OPT
What we wanted
    Developement - ASSERT_LEVEL_ASSERT or ASSERT_LEVEL_SAFE
    Unit tests - ASSERT_LEVEL_ASSERT or ASSERT_LEVEL_SAFE
    Beta testing - ASSERT_LEVEL_ASSERT or ASSERT_LEVEL_SAFE




                                                              29 / 51   130 / 248
                     Choosing Levels in builds


What we did
    Developement - ASSERT_LEVEL_ASSERT
    Unit tests - ASSERT_LEVEL_ASSERT hopefully
    Beta testing - ASSERT_LEVEL_ASSERT_OPT
    Production - ASSERT_LEVEL_ASSERT_OPT
What we wanted
    Developement - ASSERT_LEVEL_ASSERT or ASSERT_LEVEL_SAFE
    Unit tests - ASSERT_LEVEL_ASSERT or ASSERT_LEVEL_SAFE
    Beta testing - ASSERT_LEVEL_ASSERT or ASSERT_LEVEL_SAFE
    Production - ASSERT_LEVEL_ASSERT




                                                              29 / 51   131 / 248
                      Choosing Levels in builds


What we did
    Developement - ASSERT_LEVEL_ASSERT
    Unit tests - ASSERT_LEVEL_ASSERT hopefully
    Beta testing - ASSERT_LEVEL_ASSERT_OPT
    Production - ASSERT_LEVEL_ASSERT_OPT
What we wanted
    Developement - ASSERT_LEVEL_ASSERT or ASSERT_LEVEL_SAFE
    Unit tests - ASSERT_LEVEL_ASSERT or ASSERT_LEVEL_SAFE
    Beta testing - ASSERT_LEVEL_ASSERT or ASSERT_LEVEL_SAFE
    Production - ASSERT_LEVEL_ASSERT
... which is where we are



                                                              29 / 51   132 / 248
                         The Next Step


Adding more assertions




                                         30 / 51   133 / 248
                         The Next Step


Adding more assertions
    ~bsl::string() { ASSERT(m_data[m_size] == 0); }




                                                      30 / 51   134 / 248
                         The Next Step


Adding more assertions
    ~bsl::string() { ASSERT(m_data[m_size] == 0); }
    Time ABI change




                                                      30 / 51   135 / 248
                                The Next Step


Adding more assertions
    ~bsl::string() { ASSERT(m_data[m_size] == 0); }
    Time ABI change
Changing levels of assertions




                                                      30 / 51   136 / 248
                                The Next Step


Adding more assertions
    ~bsl::string() { ASSERT(m_data[m_size] == 0); }
    Time ABI change
Changing levels of assertions
    SAFE to ASSERT




                                                      30 / 51   137 / 248
                                The Next Step


Adding more assertions
    ~bsl::string() { ASSERT(m_data[m_size] == 0); }
    Time ABI change
Changing levels of assertions
    SAFE to ASSERT
    ASSERT to OPT




                                                      30 / 51   138 / 248
                                The Next Step


Adding more assertions
    ~bsl::string() { ASSERT(m_data[m_size] == 0); }
    Time ABI change
Changing levels of assertions
    SAFE to ASSERT
    ASSERT to OPT
Changing deployed assertion levels




                                                      30 / 51   139 / 248
                                The Next Step


Adding more assertions
    ~bsl::string() { ASSERT(m_data[m_size] == 0); }
    Time ABI change
Changing levels of assertions
    SAFE to ASSERT
    ASSERT to OPT
Changing deployed assertion levels
Everyone will need to do this in 202x!




                                                      30 / 51   140 / 248
                                The Next Step


Adding more assertions
    ~bsl::string() { ASSERT(m_data[m_size] == 0); }
    Time ABI change
Changing levels of assertions
    SAFE to ASSERT
    ASSERT to OPT
Changing deployed assertion levels
Everyone will need to do this in 202x!
    Using language contracts when they come will be a case of adding new assertions to
    existing code.




                                                                                30 / 51   141 / 248
                             Mis-Step #1




Continuing violation handler (2008-2015)




                                           31 / 51   142 / 248
                              Mis-Step #1




Continuing violation handler (2008-2015)
    Requires cooperation from main




                                            31 / 51   143 / 248
                              Mis-Step #1




Continuing violation handler (2008-2015)
    Requires cooperation from main
    Allows new bugs to go through unnoticed




                                              31 / 51   144 / 248
                              Mis-Step #1




Continuing violation handler (2008-2015)
    Requires cooperation from main
    Allows new bugs to go through unnoticed
    At least 1 major Bloomberg (WP) bug was because of this




                                                              31 / 51   145 / 248
                              Mis-Step #1




Continuing violation handler (2008-2015)
    Requires cooperation from main
    Allows new bugs to go through unnoticed
    At least 1 major Bloomberg (WP) bug was because of this
    Blanket continuation unsafe




                                                              31 / 51   146 / 248
                             Mis-Step #2



Extra Smart violation handler ( 2016)




                                           32 / 51   147 / 248
                               Mis-Step #2



Extra Smart violation handler ( 2016)
    Configuration to allow continuation




                                             32 / 51   148 / 248
                               Mis-Step #2



Extra Smart violation handler ( 2016)
    Configuration to allow continuation
    Tracking failure counts




                                             32 / 51   149 / 248
                               Mis-Step #2



Extra Smart violation handler ( 2016)
    Configuration to allow continuation
    Tracking failure counts
    Alternate logging




                                             32 / 51   150 / 248
                                Mis-Step #2



Extra Smart violation handler ( 2016)
     Configuration to allow continuation
     Tracking failure counts
     Alternate logging
Still unsuccessful




                                              32 / 51   151 / 248
                                Mis-Step #2



Extra Smart violation handler ( 2016)
     Configuration to allow continuation
     Tracking failure counts
     Alternate logging
Still unsuccessful
     Requires even more cooperation from main




                                                32 / 51   152 / 248
                                Mis-Step #2



Extra Smart violation handler ( 2016)
     Configuration to allow continuation
     Tracking failure counts
     Alternate logging
Still unsuccessful
     Requires even more cooperation from main
     No way to indicate in code that a check is “new”




                                                        32 / 51   153 / 248
                                Mis-Step #2



Extra Smart violation handler ( 2016)
     Configuration to allow continuation
     Tracking failure counts
     Alternate logging
Still unsuccessful
     Requires even more cooperation from main
     No way to indicate in code that a check is “new”
     Rarely used, minimal progress




                                                        32 / 51   154 / 248
                     Step?




BSLS_REVIEW (2018)




                             33 / 51   155 / 248
                                   Step?




BSLS_REVIEW (2018)
    No explicit cooperation from main needed




                                               33 / 51   156 / 248
                                  Step?




BSLS_REVIEW (2018)
    No explicit cooperation from main needed
    Contracts can be marked as “new” in code




                                               33 / 51   157 / 248
                                     Step?




BSLS_REVIEW (2018)
    No explicit cooperation from main needed
    Contracts can be marked as “new” in code
    Build-time controls to mark all assertions at a level as “new”




                                                                     33 / 51   158 / 248
                                     Step?




BSLS_REVIEW (2018)
    No explicit cooperation from main needed
    Contracts can be marked as “new” in code
    Build-time controls to mark all assertions at a level as “new”




                                                                     33 / 51   159 / 248
                     BSLS_REVIEW overview




Parallel structure to BSLS_ASSERT




                                            34 / 51   160 / 248
                      BSLS_REVIEW overview




Parallel structure to BSLS_ASSERT
Separate violation handler, defaults to logging




                                                  34 / 51   161 / 248
                      BSLS_REVIEW overview




Parallel structure to BSLS_ASSERT
Separate violation handler, defaults to logging
Lifecycle BSLS_ASSERT_SAFE to BSLS_REVIEW to BSLS_ASSERT




                                                           34 / 51   162 / 248
                      BSLS_REVIEW overview




Parallel structure to BSLS_ASSERT
Separate violation handler, defaults to logging
Lifecycle BSLS_ASSERT_SAFE to BSLS_REVIEW to BSLS_ASSERT
Alternately, <nothing> to BSLS_REVIEW_? to BSLS_ASSERT_?




                                                           34 / 51   163 / 248
                                BSLS_REVIEW
   Initially a copy of ASSERT




#define REVIEW_IMP(X) if (!(X)) {                                       \
    bb::assert_violation violation(__FILE__, __LINE__, #X);             \
    bb::Review::invoke_violation_handler(violation);                    \
}




                                                              35 / 51   164 / 248
                              BSLS_REVIEW
   Initially a copy of ASSERT
   Number of failures is important




#define REVIEW_IMP(X) if (!(X)) {                                   \
    static std::atomic<int> count;                                  \
    bb::review_violation violation(__FILE__, __LINE__, ++count, #X);\
    bb::Review::invoke_violation_handler(violation);                \
}




                                                                35 / 51   165 / 248
                                BSLS_REVIEW
   Initially a copy of ASSERT
   Number of failures is important
   Default violation handler logs only



void Review::default_violation_handler(
                              const bb::review_violation &violation)
{
  // Log a message, with contents of violation
  // Log a stack trace
  // Return
}




                                                                35 / 51   166 / 248
                                BSLS_REVIEW
   Initially a copy of ASSERT
   Number of failures is important
   Default violation handler logs only
   With expeonential backoff

void Review::default_violation_handler(
                              const bb::review_violation &violation)
{
  int count = violation.count();
  if (0 == (count & (count-1))) {
    // Log a message, with contents of violation
    // Log a stack trace
  }
  // Return
}
                                                                35 / 51   167 / 248
                   BSLS_REVIEW Build time control
   Mutually exlusive




#if defined(REVIEW_LEVEL_NONE)   ? 1 : 0 \
  + defined(REVIEW_LEVEL_OPT)    ? 1 : 0 \
  + defined(REVIEW_LEVEL_REVIEW) ? 1 : 0 \
  + defined(REVIEW_LEVEL_SAFE)   ? 1 : 0 \
  > 1
#error Multiple REVIEW_LEVEL macros defined
#endif




                                                    36 / 51   168 / 248
                    BSLS_REVIEW Build time control
   Mutually exlusive
   Default to assert level



#if defined(ASSERT_LEVEL_NONE)
#define REVIEW_LEVEL_NONE
#elif defined(ASSERT_LEVEL_OPT)
#define REVIEW_LEVEL_OPT
#elif defined(ASSERT_LEVEL_ASSERT)
#define REVIEW_LEVEL_REVIEW
#elif defined(ASSERT_LEVEL_SAFE)
#define REVIEW_LEVEL_SAFE
#else
#define REVIEW_LEVEL_REVIEW
#endif
                                                     36 / 51   169 / 248
                    BSLS_REVIEW Build time control
   Mutually exlusive
   Default to assert level (In reality copies assert logic)



#if defined(ASSERT_LEVEL_NONE)
#define REVIEW_LEVEL_NONE
#elif defined(ASSERT_LEVEL_OPT)
#define REVIEW_LEVEL_OPT
#elif defined(ASSERT_LEVEL_ASSERT)
#define REVIEW_LEVEL_REVIEW
#elif defined(ASSERT_LEVEL_SAFE)
#define REVIEW_LEVEL_SAFE
#else
#define REVIEW_LEVEL_REVIEW
#endif
                                                              36 / 51   170 / 248
                  BSLS_REVIEW Build time control
   Mutually exlusive
   Default to assert level
   Controls just like ASSERT

#if defined(REVIEW_LEVEL_NONE)
#define REVIEW_OPT(X) REVIEW_DISABLED_IMP(X)
#define REVIEW(X)      REVIEW_DISABLED_IMP(X)
#define REVIEW_SAFE(X) REVIEW_DISABLED_IMP(X)
//..




                                                   36 / 51   171 / 248
                  BSLS_REVIEW Build time control
   Mutually exlusive
   Default to assert level
   Controls just like ASSERT

//..
#elif defined(REVIEW_LEVEL_OPT)
#define REVIEW_OPT(X) REVIEW_IMP(X)
#define REVIEW(X)      REVIEW_DISABLED_IMP(X)
#define REVIEW_SAFE(X) REVIEW_DISABLED_IMP(X)
//..




                                                   36 / 51   172 / 248
                  BSLS_REVIEW Build time control
   Mutually exlusive
   Default to assert level
   Controls just like ASSERT

//..
#elif defined(REVIEW_LEVEL_REVIEW)
#define REVIEW_OPT(X) REVIEW_IMP(X)
#define REVIEW(X)      REVIEW_IMP(X)
#define REVIEW_SAFE(X) REVIEW_DISABLED_IMP(X)
//..




                                                   36 / 51   173 / 248
                  BSLS_REVIEW Build time control
   Mutually exlusive
   Default to assert level
   Controls just like ASSERT

//..
#elif defined(REVIEW_LEVEL_SAFE)
#define REVIEW_OPT(X) REVIEW_IMP(X)
#define REVIEW(X)      REVIEW_IMP(X)
#define REVIEW_SAFE(X) REVIEW_IMP(X)
#endif




                                                   36 / 51   174 / 248
                  BSLS_REVIEW Build time control
   Mutually exlusive
   Default to assert level
   Controls just like ASSERT

#if defined(REVIEW_LEVEL_OPT)    \
  defined(REVIEW_LEVEL_REVIEW) \
  defined(REVIEW_LEVEL_SAFE)
#define REVIEW_OPT(X) REVIEW_IMP(X)
#else
 // defined(REVIEW_LEVEL_NONE)
#define REVIEW_OPT(X) REVIEW_DISABLED_IMP(X)
#endif




                                                   36 / 51   175 / 248
                  BSLS_REVIEW Build time control
   Mutually exlusive
   Default to assert level
   Controls just like ASSERT

#if defined(REVIEW_LEVEL_REVIEW) \
  defined(REVIEW_LEVEL_SAFE)
#define REVIEW(X) REVIEW_IMP(X)
#else
 // defined(REVIEW_LEVEL_OPT)
 // defined(REVIEW_LEVEL_NONE)
#define REVIEW(X) REVIEW_DISABLED_IMP(X)
#endif




                                                   36 / 51   176 / 248
                  BSLS_REVIEW Build time control
   Mutually exlusive
   Default to assert level
   Controls just like ASSERT

#if defined(REVIEW_LEVEL_SAFE)
#define REVIEW_SAFE(X) REVIEW_IMP(X)
#else
 // defined(REVIEW_LEVEL_OPT)
 // defined(REVIEW_LEVEL_REVIEW)
 // defined(REVIEW_LEVEL_NONE)
#define REVIEW_SAFE(X) REVIEW_DISABLED_IMP(X)
#endif




                                                   36 / 51   177 / 248
                 ASSERT and REVIEW interaction
Changing build levels requires reviewing all asserts at the target level




                                                                           37 / 51   178 / 248
                    ASSERT and REVIEW interaction
   Changing build levels requires reviewing all asserts at the target level
   BSLS_ASSERT again



#if defined(BSLS_ASSERT_LEVEL_ASSERT) \
  defined(BSLS_ASSERT_LEVEL_SAFE)
#define BSLS_ASSERT(X) ASSERT_IMP(X)
#else
#define BSLS_ASSERT(X)
#endif




                                                                              37 / 51   179 / 248
                    ASSERT and REVIEW interaction
   Changing build levels requires reviewing all asserts at the target level
   BSLS_ASSERT again



#if defined(BSLS_ASSERT_LEVEL_ASSERT) \
  defined(BSLS_ASSERT_LEVEL_SAFE)
#define BSLS_ASSERT(X) ASSERT_IMP(X)
#elif defined(BSLS_REVIEW_LEVEL_REVIEW) \
    defined(BSLS_REVIEW_LEVEL_SAFE)
#define BSLS_ASSERT(X) REVIEW_IMP(X)
#else
#define BSLS_ASSERT(X) ASSERT_DISABLED_IMP(X)
#endif



                                                                              37 / 51   180 / 248
                    ASSERT and REVIEW interaction
   Changing build levels requires reviewing all asserts at the target level
   BSLS_ASSERT again
   Same for BSLS_ASSERT_OPT and BSLS_ASSERT_SAFE

#if defined(BSLS_ASSERT_LEVEL_OPT)    \
  defined(BSLS_ASSERT_LEVEL_ASSERT) \
  defined(BSLS_ASSERT_LEVEL_SAFE)
#define BSLS_ASSERT_OPT(X) ASSERT_IMP(X)
#elif defined(BSLS_REVIEW_LEVEL_OPT) \
  defined(BSLS_REVIEW_LEVEL_REVIEW) \
  defined(BSLS_REVIEW_LEVEL_SAFE)
#define BSLS_ASSERT_OPT(X) REVIEW_IMP(X)
#else
#define BSLS_ASSERT_OPT(X) ASSERT_DISABLED_IMP(X)
#endif
                                                                              37 / 51   181 / 248
                    ASSERT and REVIEW interaction
   Changing build levels requires reviewing all asserts at the target level
   BSLS_ASSERT again
   Same for BSLS_ASSERT_OPT and BSLS_ASSERT_SAFE

#if defined(BSLS_ASSERT_LEVEL_SAFE)
#define BSLS_ASSERT_SAFE(X) ASSERT_IMP(X)
#elif defined(BSLS_REVIEW_LEVEL_SAFE)
#define BSLS_ASSERT_SAFE(X) REVIEW_IMP(X)
#else
#define BSLS_ASSERT_SAFE(X) ASSERT_DISABLED_IMP(X)
#endif




                                                                              37 / 51   182 / 248
                   BSLS_REVIEW Takeaways


So far a success




                                           38 / 51   183 / 248
                   BSLS_REVIEW Takeaways


So far a success
    Thousands of BSLS_ASSERT_SAFE instances have become BSLS_REVIEW




                                                                      38 / 51   184 / 248
                   BSLS_REVIEW Takeaways


So far a success
    Thousands of BSLS_ASSERT_SAFE instances have become BSLS_REVIEW
    More than 90% are now BSLS_ASSERT




                                                                      38 / 51   185 / 248
                   BSLS_REVIEW Takeaways


So far a success
    Thousands of BSLS_ASSERT_SAFE instances have become BSLS_REVIEW
    More than 90% are now BSLS_ASSERT
    Dozens of reported bugs have been fixed/are being fixed




                                                                      38 / 51   186 / 248
                   BSLS_REVIEW Takeaways


So far a success
    Thousands of BSLS_ASSERT_SAFE instances have become BSLS_REVIEW
    More than 90% are now BSLS_ASSERT
    Dozens of reported bugs have been fixed/are being fixed
    No crashes have been introduced by these changes




                                                                      38 / 51   187 / 248
                   BSLS_REVIEW Takeaways


So far a success
    Thousands of BSLS_ASSERT_SAFE instances have become BSLS_REVIEW
    More than 90% are now BSLS_ASSERT
    Dozens of reported bugs have been fixed/are being fixed
    No crashes have been introduced by these changes
Why?




                                                                      38 / 51   188 / 248
                      BSLS_REVIEW Takeaways


So far a success
    Thousands of BSLS_ASSERT_SAFE instances have become BSLS_REVIEW
    More than 90% are now BSLS_ASSERT
    Dozens of reported bugs have been fixed/are being fixed
    No crashes have been introduced by these changes
Why?
    Ability to make a check a review alongside existing asserts.




                                                                      38 / 51   189 / 248
                      BSLS_REVIEW Takeaways


So far a success
    Thousands of BSLS_ASSERT_SAFE instances have become BSLS_REVIEW
    More than 90% are now BSLS_ASSERT
    Dozens of reported bugs have been fixed/are being fixed
    No crashes have been introduced by these changes
Why?
    Ability to make a check a review alongside existing asserts.
    Can conrol from code




                                                                      38 / 51   190 / 248
                      BSLS_REVIEW Takeaways


So far a success
    Thousands of BSLS_ASSERT_SAFE instances have become BSLS_REVIEW
    More than 90% are now BSLS_ASSERT
    Dozens of reported bugs have been fixed/are being fixed
    No crashes have been introduced by these changes
Why?
    Ability to make a check a review alongside existing asserts.
    Can conrol from code
    Can control at build time




                                                                      38 / 51   191 / 248
What do you do if you can’t prove a contract is being followed?




                                                                  39 / 51   192 / 248
What do you do if you can’t prove a contract is being followed?



                                   Believe



                                                                  39 / 51   193 / 248
1   Introduction

2   Basic Contracts

3   Doing Stuff With Contracts
      A Dream
      Less Bugs
      Deploying it
      Faster Code

4   SG21

5   Conclusion


                                 40 / 51   194 / 248
                 We were promised performance



Performance improvements come from the compiler knowing something will be
true




                                                                      41 / 51   195 / 248
                 We were promised performance



Performance improvements come from the compiler knowing something will be
true
[[noreturn]] on invoke_violation_handler lets you safely trade the cost of
checking for the benefit of assumption




                                                                      41 / 51   196 / 248
                  We were promised performance



Performance improvements come from the compiler knowing something will be
true
[[noreturn]] on invoke_violation_handler lets you safely trade the cost of
checking for the benefit of assumption
If you believe the contract is being followed, __builtin_assume can give you the
benefit without the costt




                                                                          41 / 51   197 / 248
                   We were promised performance



Performance improvements come from the compiler knowing something will be
true
[[noreturn]] on invoke_violation_handler lets you safely trade the cost of
checking for the benefit of assumption
If you believe the contract is being followed, __builtin_assume can give you the
benefit without the costt
The risk is the strength of your belief




                                                                          41 / 51   198 / 248
                 BSLS_ASSERT_LEVEL_ASSUME

   Let’s add another choice for mapping the BSLS_ASSERT macros




#define BSLS_ASSERT_ASSUME(X) if (!(X)) { std::unreachable(); }




                                                                  42 / 51   199 / 248
                   BSLS_ASSERT_LEVEL_ASSUME

   Let’s add another choice for mapping the BSLS_ASSERT macros
   Lots of ways to impelement, different tradeoffs and portability




#define BSLS_ASSERT_ASSUME(X) if (!(X)) { std::unreachable(); }
#define BSLS_ASSERT_ASSUME(X) __builtin_assume(X)
#define BSLS_ASSERT_ASSUME(X) if (!(X)) { int *p = nullptr; *p = 17; }




                                                                     42 / 51   200 / 248
                   BSLS_ASSERT_LEVEL_ASSUME

   Let’s add another choice for mapping the BSLS_ASSERT macros
   Lots of ways to impelement, different tradeoffs and portability
   This almost made it to the standard



#define BSLS_ASSERT_ASSUME(X) [[ assert assume : X ]]




                                                                     42 / 51   201 / 248
                   BSLS_ASSERT_LEVEL_ASSUME

   Let’s add another choice for mapping the BSLS_ASSERT macros
   Lots of ways to impelement, different tradeoffs and portability
   This almost made it to the standard
   Coming to BDE with an extended BSLS_ASSERT_LEVEL scale


//..
#elif defined(ASSERT_LEVEL_ASSUME_OPT)
#define ASSERT_OPT(X) ASSERT_ASSUME(X)
#define ASSERT(X)      ASSERT_DISABLED_IMP(X)
#define ASSERT_SAFE(X) ASSERT_DISABLED_IMP(X)
//..



                                                                     42 / 51   202 / 248
                   BSLS_ASSERT_LEVEL_ASSUME

   Let’s add another choice for mapping the BSLS_ASSERT macros
   Lots of ways to impelement, different tradeoffs and portability
   This almost made it to the standard
   Coming to BDE with an extended BSLS_ASSERT_LEVEL scale


//..
#elif defined(ASSERT_LEVEL_ASSUME_OPT)
#define ASSERT_OPT(X) ASSERT_ASSUME(X)
#define ASSERT(X)      ASSERT_ASSUME(X)
#define ASSERT_SAFE(X) ASSERT_DISABLED_IMP(X)
//..



                                                                     42 / 51   203 / 248
                   BSLS_ASSERT_LEVEL_ASSUME

   Let’s add another choice for mapping the BSLS_ASSERT macros
   Lots of ways to impelement, different tradeoffs and portability
   This almost made it to the standard
   Coming to BDE with an extended BSLS_ASSERT_LEVEL scale


//..
#elif defined(ASSERT_LEVEL_ASSUME_OPT)
#define ASSERT_OPT(X) ASSERT_ASSUME(X)
#define ASSERT(X)      ASSERT_ASSUME(X)
#define ASSERT_SAFE(X) ASSERT_ASSUME(X)
//..



                                                                     42 / 51   204 / 248
1   Introduction

2   Basic Contracts

3   Doing Stuff With Contracts

4   SG21

5   Conclusion




                                 43 / 51   205 / 248
                          What happened?



Coming into Kona, contracts (in N4800) had a number of issues




                                                                44 / 51   206 / 248
                             What happened?



Coming into Kona, contracts (in N4800) had a number of issues
    Continuation was a global flag, and its very existence was contentious




                                                                             44 / 51   207 / 248
                             What happened?



Coming into Kona, contracts (in N4800) had a number of issues
    Continuation was a global flag, and its very existence was contentious
    Assumption of any unchecked contracts




                                                                             44 / 51   208 / 248
                             What happened?



Coming into Kona, contracts (in N4800) had a number of issues
    Continuation was a global flag, and its very existence was contentious
    Assumption of any unchecked contracts
    Axiom was isomorphic to __builtin_assume




                                                                             44 / 51   209 / 248
                           What happened?



Coming into Kona, contracts (in N4800) had a number of issues
    Continuation was a global flag, and its very existence was contentious
    Assumption of any unchecked contracts
    Axiom was isomorphic to __builtin_assume
    default/audit/axiom were both too simplistic and too complicated for many




                                                                            44 / 51   210 / 248
                            What happened?



Coming into Kona, contracts (in N4800) had a number of issues
    Continuation was a global flag, and its very existence was contentious
    Assumption of any unchecked contracts
    Axiom was isomorphic to __builtin_assume
    default/audit/axiom were both too simplistic and too complicated for many
    Numerous edge case decisions had been made without publicizing clearly their
    reasoning




                                                                               44 / 51   211 / 248
                         What happened?



Numerous papers in Kona and Cologne attempted to fix these problems




                                                                      45 / 51   212 / 248
                         What happened?



Numerous papers in Kona and Cologne attempted to fix these problems
On Monday, July 15th in Cologne a number of options were presented to EWG




                                                                      45 / 51   213 / 248
                            What happened?



Numerous papers in Kona and Cologne attempted to fix these problems
On Monday, July 15th in Cologne a number of options were presented to EWG
    P1711, by Bjarne Stroustrup, proposed some small fixes




                                                                      45 / 51   214 / 248
                             What happened?



Numerous papers in Kona and Cologne attempted to fix these problems
On Monday, July 15th in Cologne a number of options were presented to EWG
    P1711, by Bjarne Stroustrup, proposed some small fixes
    P1429, revised after Kona, proposed adding literal semantics




                                                                      45 / 51   215 / 248
                            What happened?



Numerous papers in Kona and Cologne attempted to fix these problems
On Monday, July 15th in Cologne a number of options were presented to EWG
    P1711, by Bjarne Stroustrup, proposed some small fixes
    P1429, revised after Kona, proposed adding literal semantics
    P1607 proposed two options - remove all but a nicer c assert, or remove all but add
    in literal semantics




                                                                                 45 / 51   216 / 248
                            What happened?



Numerous papers in Kona and Cologne attempted to fix these problems
On Monday, July 15th in Cologne a number of options were presented to EWG
    P1711, by Bjarne Stroustrup, proposed some small fixes
    P1429, revised after Kona, proposed adding literal semantics
    P1607 proposed two options - remove all but a nicer c assert, or remove all but add
    in literal semantics
P1607’s two options were the only consensus reached that day by EWG




                                                                                 45 / 51   217 / 248
                         What happened?




On Wednesday, July 17th in Cologne P1823 was proposed and accepted by a
massive margin




                                                                      46 / 51   218 / 248
                          What happened?




On Wednesday, July 17th in Cologne P1823 was proposed and accepted by a
massive margin
On Saturday, July 20th, P1823 was ratified and SG21 was announced to pursue
contracts again




                                                                        46 / 51   219 / 248
                           What’s the plan?

SG21 is getting off the ground:




                                              47 / 51   220 / 248
                            What’s the plan?

SG21 is getting off the ground:
    Very active reflector




                                               47 / 51   221 / 248
                            What’s the plan?

SG21 is getting off the ground:
    Very active reflector
    One telecon so far




                                               47 / 51   222 / 248
                              What’s the plan?

SG21 is getting off the ground:
    Very active reflector
    One telecon so far
    First oﬀicial meeting will be in Belfast




                                                 47 / 51   223 / 248
                              What’s the plan?

SG21 is getting off the ground:
    Very active reflector
    One telecon so far
    First oﬀicial meeting will be in Belfast
Rough sketch of plan:




                                                 47 / 51   224 / 248
                                What’s the plan?

SG21 is getting off the ground:
    Very active reflector
    One telecon so far
    First oﬀicial meeting will be in Belfast
Rough sketch of plan:
    Gather use cases publicly




                                                   47 / 51   225 / 248
                              What’s the plan?

SG21 is getting off the ground:
    Very active reflector
    One telecon so far
    First oﬀicial meeting will be in Belfast
Rough sketch of plan:
    Gather use cases publicly (Done!)




                                                 47 / 51   226 / 248
                              What’s the plan?

SG21 is getting off the ground:
    Very active reflector
    One telecon so far
    First oﬀicial meeting will be in Belfast
Rough sketch of plan:
    Gather use cases publicly (Done!)
    Poll on prioritization of use cases




                                                 47 / 51   227 / 248
                              What’s the plan?

SG21 is getting off the ground:
    Very active reflector
    One telecon so far
    First oﬀicial meeting will be in Belfast
Rough sketch of plan:
    Gather use cases publicly (Done!)
    Poll on prioritization of use cases (In progress!)




                                                         47 / 51   228 / 248
                              What’s the plan?

SG21 is getting off the ground:
    Very active reflector
    One telecon so far
    First oﬀicial meeting will be in Belfast
Rough sketch of plan:
    Gather use cases publicly (Done!)
    Poll on prioritization of use cases (In progress!)
    Gather proposed solutions (Future)




                                                         47 / 51   229 / 248
                              What’s the plan?

SG21 is getting off the ground:
    Very active reflector
    One telecon so far
    First oﬀicial meeting will be in Belfast
Rough sketch of plan:
    Gather use cases publicly (Done!)
    Poll on prioritization of use cases (In progress!)
    Gather proposed solutions (Future)
         Refinements on P1607, N4830




                                                         47 / 51   230 / 248
                              What’s the plan?

SG21 is getting off the ground:
    Very active reflector
    One telecon so far
    First oﬀicial meeting will be in Belfast
Rough sketch of plan:
    Gather use cases publicly (Done!)
    Poll on prioritization of use cases (In progress!)
    Gather proposed solutions (Future)
         Refinements on P1607, N4830
         Changes in syntax? Scope? Behaviors?




                                                         47 / 51   231 / 248
                              What’s the plan?

SG21 is getting off the ground:
    Very active reflector
    One telecon so far
    First oﬀicial meeting will be in Belfast
Rough sketch of plan:
    Gather use cases publicly (Done!)
    Poll on prioritization of use cases (In progress!)
    Gather proposed solutions (Future)
         Refinements on P1607, N4830
         Changes in syntax? Scope? Behaviors?
    Review and vote on solutions based on satisfying use cases
         Hopefullly no more “union of minimal solutions”




                                                                 47 / 51   232 / 248
                              What’s the plan?

SG21 is getting off the ground:
    Very active reflector
    One telecon so far
    First oﬀicial meeting will be in Belfast
Rough sketch of plan:
    Gather use cases publicly (Done!)
    Poll on prioritization of use cases (In progress!)
    Gather proposed solutions (Future)
         Refinements on P1607, N4830
         Changes in syntax? Scope? Behaviors?
    Review and vote on solutions based on satisfying use cases
         Hopefullly no more “union of minimal solutions”
         Hopefully no more “I don’t need this so it can’t happen”




                                                                    47 / 51   233 / 248
                              What’s the plan?

SG21 is getting off the ground:
    Very active reflector
    One telecon so far
    First oﬀicial meeting will be in Belfast
Rough sketch of plan:
    Gather use cases publicly (Done!)
    Poll on prioritization of use cases (In progress!)
    Gather proposed solutions (Future)
         Refinements on P1607, N4830
         Changes in syntax? Scope? Behaviors?
    Review and vote on solutions based on satisfying use cases
         Hopefullly no more “union of minimal solutions”
         Hopefully no more “I don’t need this so it can’t happen”
Land revised contracts in standard


                                                                    47 / 51   234 / 248
                              What’s the plan?

SG21 is getting off the ground:
    Very active reflector
    One telecon so far
    First oﬀicial meeting will be in Belfast
Rough sketch of plan:
    Gather use cases publicly (Done!)
    Poll on prioritization of use cases (In progress!)
    Gather proposed solutions (Future)
         Refinements on P1607, N4830
         Changes in syntax? Scope? Behaviors?
    Review and vote on solutions based on satisfying use cases
         Hopefullly no more “union of minimal solutions”
         Hopefully no more “I don’t need this so it can’t happen”
Land revised contracts in standard (WG21 SG21 2021!)


                                                                    47 / 51   235 / 248
                                Use Cases

Use cases were gathered from all SG21 participants and edited for clarity




                                                                            48 / 51   236 / 248
                                Use Cases

Use cases were gathered from all SG21 participants and edited for clarity
All of the form “As an X in order to Y I need to Z”.




                                                                            48 / 51   237 / 248
                                Use Cases

Use cases were gathered from all SG21 participants and edited for clarity
All of the form “As an X in order to Y I need to Z”.
This hopefully be the first wg21 paper published “by” SG21.




                                                                            48 / 51   238 / 248
                                 Use Cases

Use cases were gathered from all SG21 participants and edited for clarity
All of the form “As an X in order to Y I need to Z”.
This hopefully be the first wg21 paper published “by” SG21.
29 different classes of users with 196 different use cases




                                                                            48 / 51   239 / 248
                                 Use Cases

Use cases were gathered from all SG21 participants and edited for clarity
All of the form “As an X in order to Y I need to Z”.
This hopefully be the first wg21 paper published “by” SG21.
29 different classes of users with 196 different use cases
Use cases range from very general to very specific:




                                                                            48 / 51   240 / 248
                                 Use Cases

Use cases were gathered from all SG21 participants and edited for clarity
All of the form “As an X in order to Y I need to Z”.
This hopefully be the first wg21 paper published “by” SG21.
29 different classes of users with 196 different use cases
Use cases range from very general to very specific:
    As a Developer, in order to Have readable annotations, I want to Have annotations
    with a succinct and elegant syntax




                                                                                48 / 51   241 / 248
                                 Use Cases

Use cases were gathered from all SG21 participants and edited for clarity
All of the form “As an X in order to Y I need to Z”.
This hopefully be the first wg21 paper published “by” SG21.
29 different classes of users with 196 different use cases
Use cases range from very general to very specific:
    As a Developer, in order to Have readable annotations, I want to Have annotations
    with a succinct and elegant syntax
    As a C++ API Developer, in order to Maintain a class hierarchy, I want to Ensure
    overriding methods have same or wider preconditions




                                                                                48 / 51   242 / 248
                                 Use Cases

Use cases were gathered from all SG21 participants and edited for clarity
All of the form “As an X in order to Y I need to Z”.
This hopefully be the first wg21 paper published “by” SG21.
29 different classes of users with 196 different use cases
Use cases range from very general to very specific:
    As a Developer, in order to Have readable annotations, I want to Have annotations
    with a succinct and elegant syntax
    As a C++ API Developer, in order to Maintain a class hierarchy, I want to Ensure
    overriding methods have same or wider preconditions
Some require vastly more than was possible before:




                                                                                48 / 51   243 / 248
                                  Use Cases

Use cases were gathered from all SG21 participants and edited for clarity
All of the form “As an X in order to Y I need to Z”.
This hopefully be the first wg21 paper published “by” SG21.
29 different classes of users with 196 different use cases
Use cases range from very general to very specific:
    As a Developer, in order to Have readable annotations, I want to Have annotations
    with a succinct and elegant syntax
    As a C++ API Developer, in order to Maintain a class hierarchy, I want to Ensure
    overriding methods have same or wider preconditions
Some require vastly more than was possible before:
    As a C++ API Developer In Order to Enforce contracts in async code I want to
    Express contracts on callbacks such as std::function, function pointers, or references
    to functions, lambdas, or function objects


                                                                                    48 / 51   244 / 248
                            Prioritization



SG21 members have been asked to rate each use case on behalf of whatever users
they feel they best represent:
    Not important
    Nice to have
    Must have




                                                                        49 / 51   245 / 248
                              Prioritization



SG21 members have been asked to rate each use case on behalf of whatever users
they feel they best represent:
    Not important
    Nice to have
    Must have
Expect these results to be ready to analyze and discuss by Belfast.




                                                                        49 / 51   246 / 248
1   Introduction

2   Basic Contracts

3   Doing Stuff With Contracts

4   SG21

5   Conclusion




                                 50 / 51   247 / 248
                                Conclusion




Bloomberg’s BSLS_ASSERT and BSLS_REVIEW provide a rich set of contract
enforcement utility. Grab the open source BDE to play with it today
The needs of that facility will hopefully be met by language level contracts in the
future, SG21 is working hard to see that happen




                                                                              51 / 51   248 / 248

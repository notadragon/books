    i                                                                          i
                    “emcpps-internal” — 2021/1/16 — 3:34 — page i — #1

i




        Contents

        Chapter 1 Safe Features                                           1
          C++11
                alignof                                                    2
                Attribute Syntax                                          12
                Consecutive >s                                            22
                Delegating Ctors                                          25
                Inheriting Ctors                                          31
                decltype                                                  51
                Defaulted Functions                                       58
                Deleted Functions                                         70
                explicit Operators                                        75
                inline namespace                                          81
                Local Types ’11                                          109
                long long                                                114
                noreturn                                                 119
                nullptr                                                  123
                override                                                 127
                Raw String Literals ’14                                  130
                static_assert                                            136
                Trailing Return                                          144
                Unicode Literals                                         149
                using Aliases                                            152
                C++14
                Aggregate Init ’14                                       159
                Binary Literals                                          163
                deprecated                                               168
                Digit Separators                                         172
                Lambda Captures                                          177
                Variable Templates                                       185
                constexpr Functions ’14                                  193

        Chapter 2 Conditionally Safe Features                            203
          2.1 C++11                                                      203
                alignas                                                  204
                                                                           i


i



    i                                                                          i
    i                                                                            i
                     “emcpps-internal” — 2021/1/16 — 3:34 — page ii — #2

i



        Contents

                auto Variables                                             217
                Braced Init                                                218
                constexpr Functions                                        219
                constexpr Variables                                        220
                Default Member Init                                        221
                enum class                                                 222
                Opaque enums                                               240
                Underlying Type ’11                                        257
                friend ’11                                                 262
                Forwarding References                                      284
                Lambdas                                                    305
                rvalue References                                          306
                union ’11                                                  307
                Variadic Templates                                         314
          2.2 C++14                                                        314
                Generic Lambdas                                            315

        Chapter 3 Unsafe Features                                          317
          3.1 C++11                                                        317
                carries_dependency                                         318
          3.2 C++14                                                        319
                Deduced Return Type                                        320




                                             ii


i



    i                                                                            i
    i                                                                          i
                      “emcpps-internal” — 2021/1/16 — 3:34 — page 1 — #3

i




        Chapter 1
        Safe Features
        Intro text should be here.




                                                                           1


i



    i                                                                          i
    i                                                                                                                i
                          “emcpps-internal” — 2021/1/16 — 3:34 — page 2 — #4

i



        alignof                                                                 Chapter 1      Safe Features



        The (Compile-Time) alignof Operator
        The keyword alignof serves as a compile-time operator used to query the alignment
        requirements of a type on the current platform.

        Description
        The alignof operator, when applied to a type, evaluates to an integral constant ex-
        pression that represents the alignment requirements of its argument type. Similar to
        sizeof, the (compile-time) value of alignof is of type std::size_t; unlike sizeof (which
        can accept an arbitrary expressions), alignof is defined (in the C++ Standard) on only a
        type identifier but often works on expressions anyway (see Annoyances on page 10). The ar-
        gument type, T, supplied to alignof must be either a complete type, a reference type,
        or an array type. If T is a complete type, the result is the alignment requirement for T.
        If T is a reference type, the result is the alignment requirement for the referenced type. If
        T is an array type, the result is the alignment requirement for every element in the array1 :
          static_assert(alignof(short)             ==   2,   "");   //   complete type     (sizeof    is 2)
          static_assert(alignof(short&)            ==   2,   "");   //   reference type    (sizeof    is 2)
          static_assert(alignof(short[5])          ==   2,   "");   //   array type        (sizeof    is 2)
          static_assert(alignof(short[])           ==   2,   "");   //   array type        (sizeof    fails)


        alignof Fundamental Types
        Like their size, the alignment requirements of a char, signed char, and unsigned char
        are all guaranteed to be 1 (i.e., 1-byte aligned) on every conforming platform. For any
        other fundamental or pointer type FPT, alignof(FPT) (like sizeof(FPT)) is platform-
        dependent but is typically approximated well by the type’s natural alignment — i.e.,
        sizeof(FPT) == alignof(FPT):
          static_assert(alignof(char)            ==   1,   "");   // guaranteed to be 1
          static_assert(alignof(short)           ==   2,   "");   // platform­dependent
          static_assert(alignof(int)             ==   4,   "");   //    "         "
          static_assert(alignof(double)          ==   8,   "");   //    "         "
          static_assert(alignof(void*)           >=   4,   "");   //    "         "


        alignof User-Defined Types
        When applied to user-defined types, alignment is always at least that of the strictest align-
        ment of any of its arguments’ base or member objects. Empty types are defined to have
        a size (and alignment) of 1 to ensure that every object has a unique address.2 Compilers
            1 According to the C++11 Standard, “An object of array type contains a contiguously allocated non-

        empty set of N subobjects of type T” (cpp11, section 8.3.4, “Arrays,” paragraph 1, p. 188). Note that, for
        every type T, sizeof(T) is always a multiple of alignof(T); otherwise, storing multiple T instances in an
        array would be impossible without padding, and the Standard explicitly prohibits padding between array
        elements.
            2 An exception is made for an object of a type derived from an empty (base) class in that neither the

        size nor the alignment of the derived object is affected by the derivation:
                                                             2


i



    i                                                                                                                i
    i                                                                                                                    i
                         “emcpps-internal” — 2021/1/16 — 3:34 — page 3 — #5

i



        C++11                                                                                               alignof


        will (by default) avoid nonessential padding because any extra padding would be wasteful
        of (e.g., cache) memory3 :
          struct   S0   {   };                                   //   sizeof(S0)   is    1;   alignof(S0)   is 1
          struct   S1   {   char c; };                           //   sizeof(S1)   is    1;   alignof(S1)   is 1
          struct   S2   {   short s; };                          //   sizeof(S2)   is    2;   alignof(S2)   is 2
          struct   S3   {   char c; short s; };                  //   sizeof(S3)   is    4;   alignof(S3)   is 2
          struct   S4   {   short s1; short s2; };               //   sizeof(S4)   is    4;   alignof(S4)   is 2
          struct   S5   {   int i; char c; };                    //   sizeof(S5)   is    8;   alignof(S5)   is 4
          struct   S6   {   char c1; int i; char c2};            //   sizeof(S6)   is   12;   alignof(S6)   is 4
          struct   S7   {   char c; short s; int i; };           //   sizeof(S7)   is    8;   alignof(S7)   is 4
          struct   S8   {   double d; };                         //   sizeof(S8)   is    8;   alignof(S8)   is 8
          struct   S9   {   double d; char c};                   //   sizeof(S9)   is   16;   alignof(S9)   is 8
          struct   SA   {   long double; };                      //   sizeof(SA)   is   16;   alignof(SA)   is 16
          struct   SB   {   long double; char c};                //   sizeof(SB)   is   32;   alignof(SB)   is 16


        Use Cases
        Probing the alignment of a type during development
        Both sizeof and alignof are often used informally during development and debugging
        to confirm the compiler’s understanding of those attributes for a given type on the current
        platform. For example:
          #include <iostream>


          struct S { int i; }          // size = 4; alignment = 4
          struct E { };                // size = 1; alignment = 1
          struct D : E { int i };      // size = 4; alignment = 4


            3 Compilers are permitted to increase alignment (e.g., in the presence of virtual functions) but have

        certain restrictions on padding. For example, they must ensure that each comprised type is itself suﬀiciently
        aligned and that the alignment of the parent type divides its size. This ensures that the fundamental identity
        for arrays holds for all types, T, and positive integers, N:
          T a[N]; static_assert(n == sizeof(a) / sizeof(*a));            // guaranteed

        The alignment of user-defined types can be made artificially stricter (but not weaker) using the alignas
        (see “alignas” on page 204) specifier. Also note that, for standard-layout types, the address of the first
        member object is guaranteed to be the same as that of the parent object:
          struct S { int i; }
          class T { public: S s; }
          T t;
          static_assert(&t.s == &t,     "");         // guaranteed
          static_assert(&t.s == &t.s.i, "");         // guaranteed

        This property also holds for (e.g., anonymous) unions:
          struct { union {    char c; float f; double d; } } u;
          static_assert(&u    == &u.c, ""); // guaranteed
          static_assert(&u    == &u.f, ""); // guaranteed
          static_assert(&u    == &u.d, ""); // guaranteed


                                                                                                                    3


i



    i                                                                                                                    i
    i                                                                                                 i
                         “emcpps-internal” — 2021/1/16 — 3:34 — page 4 — #6

i



        alignof                                                       Chapter 1    Safe Features


         void f()
         {
         std::cout << " sizeof(double): " << sizeof(double) << '\n';          // always 8
         std::cout << "alignof(double): " << alignof(double) << '\n';         // usually 8
         }

        Printing the size and alignment of a struct along with those of each of its individual data
        members can lead to the discovery of suboptimal ordering of data members (resulting in
        wasteful extra padding). As an example, consider two structs, Wasteful and Optimal,
        having the same three data members but in different order:

         struct   Wasteful
         {
         char     d_c;   // size = 1; alignment = 1
         double   d_d;   // size = 8; alignment = 8
         int      d_i;   // size = 4; alignment = 4
         };                  // size = 24; alignment = 8

         struct   Optimal
         {
         double   d_d;   // size = 8; alignment = 8
         int      d_i;   // size = 4; alignment = 4
         char     d_c;   // size = 1; alignment = 1
         };                  // size = 16; alignment = 8

        Both alignof(Wasteful) and alignof(Optimal) are 8 but sizeof(Wasteful) is 24,
        whereas sizeof(Optimal) is only 16. Even though these two structs contain the very
        same data members, the individual alignment requirements of these members forces the
        compiler to insert more total padding between the data members in Wasteful than is
        necessary in Optimal:

         struct   Wasteful
         {
         char     d_c;            //   size = 1; alignment = 1
         char     padding_0[7];   //   size = 7
         double   d_d;            //   size = 8; alignment = 8
         int      d_i;            //   size = 4; alignment = 4
         char     padding_1[4];   //   size = 4
         };                             // size = 24; alignment = 8

         struct   Optimal
         {
         double   d_d;            //   size = 8; alignment = 8
         int      d_i;            //   size = 4; alignment = 4
         char     d_c;            //   size = 1; alignment = 1
         char     padding_0[3];   //   size = 3
         };                             // size = 16; alignment = 8


                                                     4


i



    i                                                                                                 i
    i                                                                                                                  i
                        “emcpps-internal” — 2021/1/16 — 3:34 — page 5 — #7

i



        C++11                                                                                            alignof


        Determining if a given buffer is sufficiently aligned
        The alignof operator can be used to determine if a given (e.g., char) buffer is suitably
        aligned for storing an object of arbitrary type. As an example, consider the task of creating
        a value-semantic class, MyAny, that represents an object of arbitrary type4 :
          void f()
          {
          MyAny obj = 10;                        // can be initialized with values of any type
          assert(obj.as<int>() == 10);           // inner data can be retrieved at runtime

          obj = std::string{"hello"};   // can be reassigned from a value of any type
          assert(obj.as<std::string>() == "hello");
          }

        A straightforward implementation of MyAny would be to allocate an appropriately sized block
        of dynamic memory each time a value of a new type is assigned. Such a naive implementation
        would force memory allocations even though the vast majority of values assigned in practice
        are small (e.g., fundamental types), most of which would fit within the space that would
        otherwise be occupied by just the pointer needed to refer to dynamic memory. As a practical
        optimization, we might instead consider reserving a small buffer (say, roughly5 32 bytes)
        within the footprint of the MyAny object to hold the value provided (1) it will fit and (2)
        the buffer is suﬀiciently aligned. The natural implementation of this type — the union of
        a char array and a struct (containing a char pointer and a size) — will naturally result
        in the minimal alignment requirement of the char* (i.e., 4 on a 32-bit platform and 8 on a
        64-bit one)6 :
          class MyAny      // nontemplate class
          {
          union
          {
            4 The C++17 Standard Library provides the (nontemplate) class std::any, which is a type-safe container

        for single values of any regular type. The implementation strategies surrounding alignment for std::any
        in both libstdc++ and libc++ closely mirror those used to implement the simplified MyAny class presented
        here. Note that std::any also records the current typeid (on construction or assignment) so that it can
        implement a const template member function, bool is<T>() const, to query, at runtime, whether a specified
        type is currently the active one:
          void f(const std::any& object)
          {
          if (object.is<int>()) { /* ... */ }
          }


           5 We would likely choose a slightly larger value, e.g., 35 or 39, if that space would otherwise be filled

        with essential padding due to overall alignment requirements.
           6 We could, in addition, use the alignas attribute to ensure that the minimal alignment of d_buffer

        was at least 8 (or even 16):
          // ...
          alignas(8) char d_buffer[39];       // small buffer aligned to (at least) 8
          // ...


                                                                                                                  5


i



    i                                                                                                                  i
    i                                                                                                                i
                           “emcpps-internal” — 2021/1/16 — 3:34 — page 6 — #8

i



        alignof                                                                 Chapter 1      Safe Features


          struct
          {
          char*       d_buf_p; // pointer to dynamic memory if needed
          std::size_t d_size;  // for d_buf_p; same alignment as (char*)
          } d_imp; // Size/alignment of d_imp is sizeof(d_buf_p) (e.g., 4 or 8).

          char d_buffer[39];        // small buffer aligned as a (char*)
          }; // Size of union is 39; alignment of union is alignof(char*).

          bool d_onHeapFlag;                      // boolean (discriminator) for union (above)

          public:
          template <typename T>
          MyAny(const T& x);                         // (member template) constructor

          template <typename T>
          MyAny& operator=(const T& rhs);            // (member template) assignment operator

          template <typename T>
          const T& as() const;                       // (member template) accessor

          // ...

          };      // Size of MyAny is 40; alignment of MyAny is alignof(char*) (e.g., 8).

        The (templated) constructor7 of MyAny can then decide (potentially at compile time) whether
        to store the given object x in the internal small buffer storage or on the heap, depending on
        x’s size and alignment:
          template <typename T>
          MyAny::MyAny(const T& x)
          {
          if (sizeof(x) <= 39 && alignof(T) <= alignof(char*))
          {
          // Store x in place in the small buffer.
          new(d_buffer) T(x);
          d_onHeapFlag = false;
          }
          else
          {
          // Store x on the heap and a pointer to it in the small buffer.
          d_imp.d_buf_p = new T(x);
          d_imp.d_size = sizeof(x);
          d_onHeapFlag = true;
          }
          }

           7 In   a real-world implementation, a forwarding reference would be used as the parameter type of
        MyAny’s constructor to perfectly forward the argument object into the appropriate storage; see “Forwarding
        References” on page 2.
                                                            6


i



    i                                                                                                                i
    i                                                                                                               i
                        “emcpps-internal” — 2021/1/16 — 3:34 — page 7 — #9

i



        C++11                                                                                          alignof


        Using the (compile-time) alignof operator in the constructor above to check whether the
        alignment of T is compatible with the alignment of the small buffer is necessary to avoid
        attempting to store overly aligned objects in place — even if they would fit in the 39-
        byte buffer. As an example, consider long double, which on typical platforms has both a
        size and alignment of 16. Even though sizeof(long double) (16) is not greater than 39,
        alignof(long double) (16) is greater than that of d_buffer (8); hence, attempting to
        store an instance of long double in the small buffer, d_buffer, might — depending on
        where the MyAny object resides in memory — result in undefined behavior. User-defined
        types that either contain a long double or have had their alignments artificially extended
        beyond 8 bytes are also unsuitable candidates for the internal buffer even if they might
        otherwise fit:
          struct Unsuitable1 { long double d_value };
          // Size is 16 (<= 39), but alignment is 16 (> 8).

          struct alignas(32) Unsuitable2 { };
          // Size is 1 (<= 39), but alignment is 32 (> 8).


        Monotonic memory allocation
        A common pattern in software — e.g., request/response in client/server architectures —
        is to quickly build up a complex data structure, use it, and then quickly destroy it. A
        monotonic allocator is a special-purpose memory allocator that returns a monotonically
        increasing sequence of addresses into an arbitrary buffer, subject to specific size and align-
        ment requirements.8 Especially when the memory is allocated by a single thread, there are
        prodigious9 performance benefits to having unsynchronized raw memory be taken directly
        off the (always hot) program stack. In what follows, we will provide the building blocks of
        a monotonic memory allocator wherein the alignof operator plays an essential role.
            As a practically useful example, suppose that we want to create a lightweight
        MonotonicBuffer class template that will allow us to allocate raw memory directly from
        the footprint of the object. Just by creating an object of an (appropriately sized) instance
        of this type on the program stack, memory will naturally come from the stack. For didactic
        reasons, we will start with a first pass at this class — ignoring alignment — and then go
        back and fix it using alignof so that it returns properly aligned memory:
          template <std::size_t N>
          struct MonotonicBuffer // first pass at a monotonic memory buffer
          {
          char d_buffer[N]; // fixed­size buffer
          char* d_top_p;      // next available address

          MonotonicBuffer() : d_top_p(d_buffer) { }

            8 C++17 introduces an alternate interface to supply memory allocators via an abstract base class. The

        C++17 Standard Library provides a complete version of standard containers using this more interopera-
        ble design in a sub-namespace, std::pmr, where pmr stands for polymorphic memory resource. Also
        adopted as part of C++17 are two concrete memory resources, std::pmr::monotonic_buffer_resource
        and std::pmr::unsynchronized_pool_resource.
            9 see lakos16

                                                                                                               7


i



    i                                                                                                               i
    i                                                                                                    i
                        “emcpps-internal” — 2021/1/16 — 3:34 — page 8 — #10

i



        alignof                                                         Chapter 1    Safe Features


          // Initialize the next available address to be the start of the buffer.

          template <typename T>
          void* allocate()                 // BAD IDEA ­­­ doesn't address alignment
          {
          void* result = d_top_p;     // Remember the current next­available address.
          d_top_p += sizeof(T);       // Reserve just enough space for this type.
          return result;              // Return the address of the reserved space.
          }
          };

        MonotonicBuffer is a class template with one integral template parameter that controls
        the size of the d_buffer member from which it will dispense memory. Note that, while
        d_buffer has an alignment of 1, the d_top_p member, used to keep track of the next
        available address, has an alignment that is typically 4 or 8 (corresponding to 32-bit and 64-
        bit architectures, respectively). The constructor merely initializes the next-address pointer,
        d_top_p, to the start of the local memory pool, d_buffer[N]. The interesting part is how
        the allocate function manages to return a sequence of addresses corresponding to objects
        allocated sequentially from the local pool:
          MonotonicBuffer<20> mb; // On a 64­bit platform, the alignment will be 8.
          char*   cp = static_cast<char* >(mb.allocate<char >()); // &d_buffer[ 0]
          double* dp = static_cast<double*>(mb.allocate<double>()); // &d_buffer[ 1]
          short* sp = static_cast<short* >(mb.allocate<short >()); // &d_buffer[ 9]
          int*    ip = static_cast<int*   >(mb.allocate<int   >()); // &d_buffer[11]
          float* fp = static_cast<float* >(mb.allocate<float >()); // &d_buffer[15]

        The predominant problem with this first attempt at an implementation of allocate is that
        the addresses returned do not necessarily satisfy the minimum alignment requirements of
        the supplied type. A secondary concern is that there is no internal check to see if suﬀicient
        room remains. To patch this faulty implementation, we will need a function that, given an
        initial address and an alignment requirement, returns the amount by which the address must
        be rounded up (i.e., necessary padding) for an object having that alignment requirement to
        be properly aligned:
          std::size_t calculatePadding(const char* address, std::size_t alignment)
          // Requires: alignment is a (non­negative, integral) power of 2.
          {
          // rounding up X to N (where N is a power of 2): (x + N ­ 1) & ~(N ­ 1)
          const std::size_t maxA = alignof(std::max_align_t);
          const std::size_t a = reinterpret_cast<std::size_t>(address) & (maxA ­ 1);
          const std::size_t am1 = alignment ­ 1;
          const std::size_t alignedAddress = (a + am1) & ~am1; // round up
          return alignedAddress ­ a;                            // return padding
          }

        Armed with the calculatePadding helper function (above), we are all set to write the final
        (correct) version of the allocate method of the MonotonicBuffer class template:
          template <typename T>
          void* MonotonicBuffer::allocate()
                                                      8


i



    i                                                                                                    i
    i                                                                                                                  i
                        “emcpps-internal” — 2021/1/16 — 3:34 — page 9 — #11

i



        C++11                                                                                            alignof


          {
          // Calculate just the padding space needed for alignment.
          const std::size_t padding = calculatePadding(d_top_p, alignof(T));

          // Calculate the total amount of space needed.
          const std::size_t delta = padding + sizeof(T);

          // Check to make sure the properly aligned object will fit.
          if (delta > d_buffer + N ­ d_top_p) // if (Needed > Total ­ Used)
          {
          return 0; // not enough properly aligned unused space remaining
          }

          // Reserve needed space; return the address for a properly aligned object.
          void* alignedAddress = d_top_p + padding; // Align properly for T object.
          d_top_p += delta;                          // Reserve memory for T object.
          return alignedAddress;                     // Return memory for T object.
          }

        Using this corrected implementation that uses alignof to pass the alignment of the supplied
        type T to the calculatePadding function, the addresses returned from the benchmark
        example (above) would be different10 :
          MonotonicBuffer<20> mb; // Assume 64­bit platform (8­byte                     aligned).
          char*   cp = static_cast<char* >(mb.allocate<char >());                       // &d_buffer[ 0]
          double* dp = static_cast<double*>(mb.allocate<double>());                     // &d_buffer[ 8]
          short* sp = static_cast<short* >(mb.allocate<short >());                      // &d_buffer[16]
          int*    ip = static_cast<int*   >(mb.allocate<int   >());                     // 0 (out of space)
          bool*   bp = static_cast<bool* >(mb.allocate<bool >());                       // &d_buffer[18]

        In practice, an object that allocates memory, such as a vector or a list, will be constructed
        with an object that allocates and deallocates memory that is guaranteed to be either maxi-
        mally aligned, naturally aligned, or suﬀiciently aligned to satisfy an optionally specified
        alignment requirement.
            Finally, instead of returning a null pointer when the buffer was exhausted, we would
        typically have the concrete allocator fall back to a geometrically growing sequence of dy-
        namically allocated blocks; the allocate method would then fail (i.e., a std::bad_alloc
        exception would somehow be thrown) only if all available memory were exhausted and the
        new handler were unable to acquire more memory yet still opted to return control to its
        caller.




           10 Note that on a 32-bit architecture, the d_top_p character pointer would be only four-byte aligned,

        which means that the entire buffer might be only four-byte aligned. In that case, the respective offsets for
        cp, dp, sp, ip, and bp in the example for the aligned use case might sometimes instead be 0, 4, 12, 16,
        and nullptr, respectively. If desired, we can use the alignas attribute/keyword to artificially constrain
        the d_buffer data member always to reside on a maximally aligned address boundary, thereby improving
        consistency of behavior, especially on 32-bit platforms.
                                                                                                                  9


i



    i                                                                                                                  i
    i                                                                                                                     i
                          “emcpps-internal” — 2021/1/16 — 3:34 — page 10 — #12

i



        alignof                                                                    Chapter 1        Safe Features


        Annoyances
        alignof (unlike sizeof) is defined only on types
        The (compile-time) sizeof operator comes in two different forms: one accepting a type
        and the other accepting an expression. The C++ Standard currently requires that alignof
        support only the former11 :
          static_assert(sizeof(int) ==             4,   "");       //   OK, int is a     type.
          static_assert(alignof(int) ==            4,   "");       //   OK, int is a     type.
          static_assert(sizeof(3 + 2))             ==   4, "");    //   OK, 3 + 2 is     an expression.
          static_assert(alignof(3 + 2))            ==   4, "");    //   Error, 3 + 2     is not a type.

        This asymmetry can result in a need to leverage decltype (see “decltype” on page 51)
        when inspecting an expression instead of a type:
          int f()
          {
          enum { e_SUCCESS, e_FAILURES } result;
          std::cout << "size: " << sizeof(result) << '\n';
          std::cout << "alignment:" << alignof(decltype(result)) << '\n';
          }

        The same sort of issue occurs in conjunction with modern type inference features such as
        auto (see “auto Variables” on page 217) and generic lambdas (see “Generic Lambdas” on
        page 315). As a real-world example, consider the generic lambda (C++14) being used to
        introduce a small local function that prints out information regarding the size and alignment
        of a given object, likely for debugging purposes:
          auto printTypeInformation = [](auto object)
          {
          std::cout << "     size: " << sizeof(object) << '\n'
          << "alignment: " << alignof(decltype(object)) << '\n';
          };

        Because there is no explicit type available within the body of the printTypeInformation
        lambda,12 a programmer wishing to remain entirely within the C++ Standard13 is forced
        to use the decltype construct explicitly to first obtain the type of object before passing
        it on to alignof.

           11 Although the Standard does not require alignof to work on arbitrary expressions, alignof is a common

        GNU extension and most compilers support it. Both Clang and GCC will warn only if ­Wpedantic is set.
           12 In C++20, referring to the type of a generic lambda parameter explicitly is possible (due to the addition

        to lambdas of some familiar template syntax):
          auto printTypeInformation = []<typename T>(T object)
          {
          std::cout << "     size: " << sizeof(T) << '\n'
          << "alignment: " << alignof(T) << '\n';
          };


           13 Note that alignof(object) will work on every major compiler (GCC 10.x, Clang 10.x, and MSVC 19.x)

        as a nonstandard extension.
                                                              10


i



    i                                                                                                                     i
    i                                                                                             i
                      “emcpps-internal” — 2021/1/16 — 3:34 — page 11 — #13

i



        C++11                                                                         alignof


        See Also
          • “alignas” — Safe C++11 feature that can be used to provide an artificially stricter
            alignment (e.g., more than natural alignment).

          • “decltype” — Safe C++11 feature that helps work around alignof’s limitation of
            accepting only a type, not an expression (see Annoyances on page 10).

        Further Reading
        None so far




                                                                                            11


i



    i                                                                                             i
    i                                                                                                                  i
                         “emcpps-internal” — 2021/1/16 — 3:34 — page 12 — #14

i



        Attribute Syntax                                                         Chapter 1       Safe Features



        Generalized Attribute Support
        An attribute is an annotation (e.g., of a statement or named entity) used to provide sup-
        plementary information.

        Description
        Developers are often aware of information that is not deducible directly from the source code
        within a given translation unit. Some of this information might be useful to certain compilers,
        say, to inform diagnostics or optimizations; typical attributes, however, are designed to avoid
        affecting the semantics14 of a well-written program. Customized annotations targeted at
        external (e.g., static-analysis) tools15 might be beneficial as well.

        C++ attribute syntax
        C++ supports a standard syntax for attributes, introduced via a matching pair of [[ and
        ]], the simplest of which is a single attribute represented using a simple identifier, e.g.,
        attribute_name:
          [[attribute_name]]

        A single annotation can consist of zero or more attributes:
          [[]]                // permitted in every position where any attribute is allowed
          [[foo, bar]]        // equivalent to [[foo]] [[bar]]

        An attribute may have an (optional) argument list consisting of an arbitrary sequence of
        tokens:
          [[attribute_name()]]                      //   same as attribute_name
          [[deprecated("too ugly")]]                //   single­argument attribute
          [[theoretical(1, "two", 3.0)]]            //   multiple­argument attributes
          [[complicated({1, 2, 3} + 5)]]            //   arbitrary tokens (fails on GCC <= 9.2)

        Note that having an incorrect number of arguments or an incompatible argument type
        is a compile-time error for all standard attributes; the behavior for all other attributes,




           14 By semantics, here we typically mean any observable behavior apart from runtime performance. Gen-

        erally, ignoring an attribute is a valid (and safe) choice for a compiler to make. Sometimes, however, an
        attribute will not affect the behavior of a correct program but might affect the behavior of a well-formed
        yet incorrect one (see Use Cases: Delineating explicit assumptions in code to achieve better optimizations
        on page 17).
           15 Such static-analysis tools include Clang sanitizers, Coverity, and other proprietary, open-source, and

        commercial products.
                                                             12


i



    i                                                                                                                  i
    i                                                                                                                i
                          “emcpps-internal” — 2021/1/16 — 3:34 — page 13 — #15

i



        C++11                                                                                   Attribute Syntax


        however, is implementation-defined (see Potential Pitfalls: Unrecognized attributes have
        implementation-defined behavior on page 20).
           Any attribute may be namespace qualified16 (using any arbitrary identifier):
          [[gnu::const]]       // (GCC­specific) namespace­gnu­qualified const attribute
          [[my::own]]          // (user­specified) namespace­my­qualified own attribute


        C++ attribute placement
        Attributes can, in principle, be introduced almost anywhere within the C++ syntax to an-
        notate almost anything, including an entity, statement, code block, and even entire trans-
        lation unit; however, most contemporary compilers do not support arbitrary placement of
        attributes (see Use Cases: Probing where attributes are permitted in the compiler’s C++
        grammar on page 19) outside of a declaration statement. Furthermore, in some cases, the
        entity to which an unrecognized attribute pertains might not be clear from its syntactic
        placement alone.
            In the case of a declaration statement, however, the intended entity is well specified; an
        attribute placed in front of the statement applies to every entity being declared, whereas an
        attribute placed immediately after the named entity applies to just that one entity:
          [[noreturn]] void f(), g();          // Both f() and g() are noreturn.
          void u(), v() [[noreturn]];          // Only v() is noreturn.

        Attributes placed in front of a declaration statement and immediately behind the name17
        of an individual entity in the same statement are additive (for that entity). The behavior
        of attributes associated with an entity across multiple declaration statements, however,
        depends on the attributes themselves. As an example, [[noreturn]] is required to be
        present on the first declaration of a function. Other attributes might be additive, such as
        the hypothetical foo and bar shown here:
          [[foo]] void f(), g(); // declares both f() and g() to be foo
          void f [[bar]](), g(); // Now f() is both foo and bar while
          //     g() is still just foo.




          16 Attributes having a namespace-qualified name (e.g., [[gnu::const]]) were only conditionally sup-
        ported in C++11 and C++14, but historically they were supported by all major compilers, including both
        Clang and GCC; all C++17-conforming compilers must support namespace-qualified names.
          17 There are rare edge cases in which an entity (e.g., an anonymous union or enum) is declared without a

        name:
          struct S { union [[attribute_name]] { int a; float b }; };
          enum [[attribute_name]] { SUCCESS, FAIL } result;


                                                                                                               13


i



    i                                                                                                                i
    i                                                                                                                  i
                         “emcpps-internal” — 2021/1/16 — 3:34 — page 14 — #16

i



        Attribute Syntax                                                         Chapter 1       Safe Features


        Redundant attributes are not themselves necessarily considered an error; however, most
        standard attributes do consider redundancy an error18 :
          [[attr1]] void f [[attr2]](), f [[attr3]](int);
          // f()    is attr1 and attr2.
          // f(int) is attr1 and attr3.

          [[a1]][[a1]] int [[a1]][[a1]] & x;                // x (the reference itself) is a1.

          void g [[noreturn]] [[noreturn]]();               // g() is noreturn.

          void h [[noreturn, noreturn]]();                  // error: repeated (standard) attribute

        In most other cases, an attribute will typically apply to the statement (including a block
        statement) that immediately (apart from other attributes) follows it:
          [[attr1]];                                              //   null statement
          [[attr2]] return 0;                                     //   return statement
          [[attr3]] for (int i = 0; i < 10; ++i);                 //   for statement
          [[attr4]] [[attr5]] { /* ... */ }                       //   block statement

        The valid positions of any particular attribute, however, will be constrained by whatever
        entities to which it applies. That is, an attribute such as noreturn, which pertains only to
        functions, would be valid syntactically but not semantically were it placed so as to annotate
        any other kind of entity or syntactic element. Misplacement of standard attributes results
        in an ill-formed program19 :
          void [[noreturn]] g() { throw; }             // error: appertains to type specifier
          void i() [[noreturn]] { throw; }             // error: appertains to type specifier


        Common compiler-dependent attributes
        Prior to C++11, no standardized syntax was available to support conveying externally
        sourced       information,     and      nonportable      compiler intrinsics   (such     as
        __attribute__((fallthrough)), which is GCC-specific syntax) had to be used instead.
        Given the new standard syntax, vendors are now able to express these extensions in a more
        (syntactically) consistent manner. If an unknown attribute is encountered during compila-
        tion, it is ignored, emitting a (likely20 ) nonfatal diagnostic.
            Table 1 provides a brief survey of popular compiler-specific attributes that have been
        standardized or have migrated to the standard syntax. (For additional compiler-specific
        attributes, see Further Reading on page 21.)
            The requirement (as of C++17) to ignore unknown attributes helps to ensure porta-
        bility of useful compiler-specific and external-tool annotations without necessarily having
           18 Redundancy of standard attributes might no longer be an error in future revisions of the C++ Standard;

        see iso20a.
           19 As of this writing, GCC is lax and merely warns when it sees the standard noreturn attribute in an

        unauthorized syntactic position, whereas Clang (correctly) fails to compile. Hence creative use of even a
        standard attribute might lead to different behavior on different compilers.
           20 Prior to C++17, a conforming implementation was permitted to treat an unknown attribute as ill

        formed and terminate translation; to the authors’ knowledge, however, none of them did.
                                                             14


i



    i                                                                                                                  i
    i                                                                                                             i
                        “emcpps-internal” — 2021/1/16 — 3:34 — page 15 — #17

i



        C++11                                                                                  Attribute Syntax


                    Table 1: Some standardized compiler-specific attributes

                     Compiler             Compiler-Specific               Standard-Conforming
                       GCC             __attribute__((pure))                  [[gnu::pure]]
                       Clang       __attribute__((no_sanitize))          [[clang::no_sanitize]]
                      MSVC              declspec(deprecated)                 [[deprecated]]




        to employ conditional compilation so long as that attribute is permitted at that specific
        syntactic location by all relevant compilers (with some caveats; see Potential Pitfalls: Not
        every syntactic location is viable for an attribute on page 21).

        Use Cases
        Eliciting useful compiler diagnostics
        Decorating entities with certain attributes can give compilers enough additional context to
        provide     more     detailed     diagnostics.    For     example,    the     GCC-specific
        [[gnu::warn_unused_result]] attribute21 can be used to inform the compiler (and de-
        velopers) that a function’s return value should not be ignored22 :
         struct UDPListener
         {
         [[gnu::warn_unused_result]] int start();
         // Start the UDP listener's background thread (which can fail for a
         // variety of reasons). Return 0 on success and a nonzero value
         // otherwise.

         void bind(int port);
         // The behavior is undefined unless start was called successfully.
         };




          21 For   compatibility with GCC, Clang supports [[gnu::warn_unused_result]] as well.
          22 The    C++17 Standard [[nodiscard]] attribute serves the same purpose and is portable.
                                                                                                            15


i



    i                                                                                                             i
    i                                                                                                                      i
                          “emcpps-internal” — 2021/1/16 — 3:34 — page 16 — #18

i



        Attribute Syntax                                                            Chapter 1       Safe Features


        Such annotation of the client-facing declaration can prevent defects caused by a client’s
        forgetting to inspect the result of a function23 :
          void init()
          {
          UDPListener listener;
          listener.start();              // Might fail; return value must be checked!
          listener.bind(27015);          // Possible undefined behavior; BAD IDEA!
          }

        For the code above, GCC produces a useful warning:
          warning: ignoring return value of 'bool HttpClient::start()' declared
          with attribute 'warn_unused_result' [­Wunused­result]


        Hinting at additional optimization opportunities
        Some annotations can affect compiler optimizations leading to more eﬀicient or smaller
        binaries. For example, decorating the function reportError (below) with the GCC-specific
        [[gnu::cold]] attribute (also available on Clang) tells the compiler that the developer
        believes the function is unlikely to be called often:
          [[gnu::cold]] void reportError(const char* message) { /* ... */ }

        Not only might the definition of reportError itself be optimized differently (e.g., for
        space over speed), any use of this function will likely be given lower priority during branch
        prediction:
          void checkBalance(int balance)
          {
          if (balance >= 0) // likely branch
          {
          // ...
          }
          else // unlikely branch
          {
          reportError("Negative balance.");
          }
          }




           23 Because the [[gnu::warn_unused_result]] attribute does not affect code generation, it is explicitly

        not ill formed for a client to make use of an unannotated declaration and yet compile its corresponding
        definition in the context of an annotated one (or vice versa); such is not always the case for other attributes,
        however, and best practice might argue in favor of consistency regardless.
                                                               16


i



    i                                                                                                                      i
    i                                                                                                                    i
                       “emcpps-internal” — 2021/1/16 — 3:34 — page 17 — #19

i



        C++11                                                                                       Attribute Syntax


        Because the (annotated) reportError(const char*) appears on the else branch of the if
        statement (above), the compiler knows to expect that balance is likely not to be negative
        and therefore optimizes its predictive branching accordingly. Note that even if our hint to
        the compiler turns out to be misleading at run time, the semantics of every well-formed
        program remain the same.

        Delineating explicit assumptions in code to achieve better optimizations
        Although the presence (or absence) of an attribute usually has no effect on the behavior of
        any well-formed program (besides runtime performance), an attribute sometimes imparts
        knowledge to the compiler which, if incorrect, could alter the intended behavior of the
        program (or perhaps mask the defective behavior of an incorrect one). As an example of this
        more forceful form of attribute, consider the GCC-specific [[gnu::const]] attribute (also
        available on Clang). When applied to a function, this (atypically) powerful (and dangerous,
        see Potential Pitfalls: Some attributes, if misused, can affect program correctness on page 20)
        attribute instructs the compiler to assume that the function is a pure function (i.e., that
        it always returns the same value for any given set of arguments) and has no side effects
        (i.e., the globally reachable state24 of the program is unaltered by calling this function):
          [[gnu::const]]
          double linearInterpolation(double start, double end, double factor)
          {
          return (start * (1.0 ­ factor)) + (end * factor);
          }

        The vectorLerp function (below) performs linear interpolation (referred to as LERP) be-
        tween two bidimensional vectors. The body of this function comprises two invocations to
        the linearInterpolation function (above) — one per vector component:
          Vector2D vectorLerp(const Vector2D& start, const Vector2D& end, double factor)
          {
          return Vector2D(linearInterpolation(start.x, end.x, factor),
          linearInterpolation(start.y, end.y, factor));
          }




           24 Absolutely no external state changes are allowed in a function decorated with [[gnu::const]], in-

        cluding global state changes or mutation via any of the function’s arguments. (The arguments themselves
        are considered local state and hence can be modified.) The (more lenient) [[gnu::pure]] attribute allows
        changes to the state of the function’s arguments but still forbids any global state mutation. For example, any
        sort of (even temporary) global memory allocation would render a function ineligible for [[gnu::const]]
        or [[gnu::pure]].
                                                                                                                   17


i



    i                                                                                                                    i
    i                                                                                                                 i
                         “emcpps-internal” — 2021/1/16 — 3:34 — page 18 — #20

i



        Attribute Syntax                                                         Chapter 1      Safe Features


        In the (possibly frequent) case where the values of the two components are the same, the
        compiler is allowed to invoke linearInterpolation only once — even if its body is not
        visible in vectorLerp’s translation unit:
          // pseudocode (hypothetical compiler transformation)
          Vector2D vectorLerp(const Vector2D& start, const Vector2D& end, double factor)
          {
          if (start.x == start.y && end.x == end.y)
          {
          const double cache = linearInterpolation(start.x, end.x, factor);
          return Vector2D(cache, cache);
          }

          return Vector2D(linearInterpolation(start.x, end.x, factor),
          linearInterpolation(start.y, end.y, factor));
          }

        If the implementation of a function tagged with the [[gnu::pure]] attribute does not
        satisfy limitations imposed by the attribute, however, the compiler will not be able to detect
        this and a runtime defect will be the likely result25 ; see Potential Pitfalls: Some attributes,
        if misused, can affect program correctness on page 20.

        Using attributes to control external static analysis
        Since unknown attributes are ignored by the compiler, external static-analysis tools can de-
        fine their own custom attributes that can be used to embed detailed information to influence
        or control those tools without affecting program semantics. For example, the Microsoft-
        specific [[gsl::suppress(/* rules */)]] attribute can be used to suppress unwanted
        warnings from static-analysis tools that verify Guidelines Support Library26 rules. In par-
        ticular, consider GSL C26481 (Bounds rule #1),27 which forbids any pointer arithmetic,
        instead suggesting that users rely on the gsl::span type28 :
          void hereticalFunction()
          {
          int array[] = {0, 1, 2, 3, 4, 5};

          printElements(array, array + 6);            // elicits warning C26481
          }
           25 The briefly adopted — and then unadopted — contract-checking facility proposed for C++20 contem-

        plated incorporating a feature similar in spirit to [[gnu::const]] in which preconditions (in addition to
        being runtime checked or ignored) could be assumed to be true by the compiler for the purposes of opti-
        mization; this unique use of attribute-like syntax also required that a conforming implementation could not
        unilaterally ignore these precondition-checking attributes since that would make attempting to test them
        result in hard (language) undefined behavior.
           26 Guidelines Support Library (see microsoft) is an open-source library, developed by Microsoft, that

        implements functions and types suggested for use by the “C++ Core Guidelines” (see stroustrup20).
           27 microsoftC26481
           28 gsl::span is a lightweight reference type that observes a contiguous sequence (or subsequence) of

        objects of homogeneous type. gsl::span can be used in interfaces as an alternative to both pointer/size or
        iterator-pair arguments and in implementations as an alternative to (raw) pointer arithmetic. Since C++20,
        the standard std::span template can be used instead.
                                                            18


i



    i                                                                                                                 i
    i                                                                                                      i
                     “emcpps-internal” — 2021/1/16 — 3:34 — page 19 — #21

i



        C++11                                                                           Attribute Syntax


        Any block of code for which validating rule C26481 is considered undesirable can be deco-
        rated with the [[gsl::suppress(bounds.1)]] attribute:
          void hereticalFunction()
          {
          int array[] = {0, 1, 2, 3, 4, 5};

          [[gsl::suppress(bounds.1)]]                 // Suppress GSL C26481.
          {
          printElements(array, array + 6);       // Silence!
          }
          }


        Creating new attributes to express semantic properties
        Other uses of attributes for static analysis include statements of properties that cannot other-
        wise be deduced within a single translation unit. Consider a function, f, that takes two point-
        ers, p1 and p2, and has a precondition that both pointers must refer to the same contigu-
        ous block of memory (as the two addresses are compared internally). Accordingly, we might
        annotate the function f with our own attribute home_grown::in_same_block(p1, p2):
          // lib.h

          [[home_grown::in_same_block(p1, p2)]]
          int f(double* p1, double* p2);

        Now imagine that some client calls this function from some other translation unit but passes
        in two unrelated pointers:
          // client.cpp
          #include <lib.h>

          void client()
          {
          double a[10], b[10];
          f(a, b); // Oops, this is UB.
          }

        Because our static-analysis tool knows from the home_grown::in_same_block attribute
        that a and b must point into the same contiguous block, however, it has enough information
        to report, at compile time, what might otherwise have resulted in undefined behavior at
        run time.

        Probing where attributes are permitted in the compiler’s C++ grammar
        An attribute can generally appear syntactically at the beginning of any statement — e.g.,
        [[attr]] x = 5; — or in almost any position relative to a type or expression (e.g.,
        const int&) but typically cannot be associated within named objects outside of a dec-
        laration statement:
          [[]] static [[]] int [[]] a [[]], /*[[]]*/ b [[]];           // declaration statement
                                                                                                     19


i



    i                                                                                                      i
    i                                                                                                                       i
                          “emcpps-internal” — 2021/1/16 — 3:34 — page 20 — #22

i



        Attribute Syntax                                                             Chapter 1       Safe Features


        Notice how we have used the empty attribute syntax [[]] above to probe for positions
        allowed for arbitrary attributes by the compiler (in this case, GCC) — the only invalid one
        being immediately following the comma, shown above as /*[[]]*/. Outside of a declaration
        statement, however, viable attribute locations are typically far more limited:
          [[]]   void [[]]     f [[]] ( [[]] int [[]] n [[]] )
          [[]]   {
          [[]]   n /**/ *=     /**/ sizeof /**/ ( [[]] const [[]] int [[]] & [[]] ) /**/;
          [[]]   for ([[]]     int [[]] i [[]] = /**/ 0 /**/ ;
          /**/   i /**/ <      /**/ n /**/ ;
          /**/   ++ /**/ i     /**/ )
          [[]]   {
          [[]]   ;                  // [[]] denotes viable attribute location (on GCC)
          /**/   }
          /**/   }                             // /**/ denotes no attribute allowed (on GCC)

        Type expressions — e.g., the argument to sizeof (above) — are a notable exception; see
        Potential Pitfalls: Not every syntactic location is viable for an attribute on page 21.

        Potential Pitfalls
        Unrecognized attributes have implementation-defined behavior
        Although standard attributes work well and are portable across all platforms, the behavior
        of compiler-specific and user-specified attributes is entirely implementation defined, with
        unrecognized attributes typically resulting in compiler warnings. Such warnings can typically
        be disabled (e.g., on GCC using ­Wno­attributes), but, if they are, misspellings in even
        standard attributes will go unreported.29

        Some attributes, if misused, can affect program correctness
        Many attributes are benign in that they might improve diagnostics or performance but
        cannot themselves cause a program to behave incorrectly. Some, however, if misused, can
        lead to incorrect results and/or undefined behavior.
            For example, consider the myRandom function that is intended to return a new random
        number between [0.0 and 0.1] on each successive call:
          double myRandom()
          {
          static std::random_device randomDevice;
          static std::mt19937 generator(randomDevice());

          std::uniform_real_distribution<double> distribution(0, 1);
          return distribution(generator);
          }

        Suppose that we somehow observed that decorating myRandom with the [[gnu::const]]
        attribute occasionally improved runtime performance and innocently but naively decided

          29 Ideally, every relevant platform would offer a way to silently ignore a specific attribute on a case-by-case

        basis.
                                                               20


i



    i                                                                                                                       i
    i                                                                                                     i
                      “emcpps-internal” — 2021/1/16 — 3:34 — page 21 — #23

i



        C++11                                                                          Attribute Syntax


        to use it in production. This is clearly a misuse of the [[gnu::const]] attribute because
        the function doesn’t inherently satisfy the requirement of producing the same result when
        invoked with the same arguments (in this case, none). Adding this attribute tells the compiler
        that it need not call this function repeatedly and is free to treat the first value returned as
        a constant for all time.

        Not every syntactic location is viable for an attribute
        For a fairly limited subset of syntactic locations, most conforming implementations are likely
        to tolerate the double-bracketed attribute-list syntax. The ubiquitously available locations
        include the beginning of any statement, immediately following a named entity in a decla-
        ration statement, and (typically) arbitrary positions relative to a type expression but,
        beyond that, caveat emptor. For example, GCC allowed all of the positions indicated in the
        example shown in Use Cases: Probing where attributes are permitted in the compiler’s C++
        grammar on page 20, yet Clang had issues with the third line in two places:
          <source>:3:39: error: expected variable name or 'this' in lambda capture list
          [[]] n /**/ *= /**/ sizeof /**/ ([[]] const [[]] int [[]] & [[]] ) /**/;
          ^

          <source>:3:48: error: an attribute list cannot appear here
          [[]] n /**/ *= /**/ sizeof /**/ (/**/ const [[]] int [[]] & [[]] ) /**/;
          ^~~~

        Hence, just because an arbitrary syntactic location is valid for an attribute on one compiler
        doesn’t mean that it is necessarily valid on another.a

        Annoyances
        None so far

        See Also
          • Section 1.1, “noreturn” on page 119 — Safe C++11 standard attribute for functions
            that never return control flow to the caller
          • Section 3.1, “carries_dependency” on page 318 — Unsafe C++11 standard attribute
            used to communicate release-consume dependency-chain information to the compiler
            to avoid unnecessary memory-fence instructions
          • Section 1.1, “alignas” on page 204 — Safe C++11 attribute (with a keyword-like
            syntax) used to widen the alignment of a type or an object
          • Section 1.2, “deprecated” on page 168 — Safe C++14 standard attribute that dis-
            courages the use of an entity via compiler diagnostics

        Further Reading
          • For more information on commonly supported function attributes, see section 6.33.1,
            “Common Function Attributes,” freesoftwarefdn20.

                                                                                                    21


i



    i                                                                                                     i
    i                                                                                                      i
                         “emcpps-internal” — 2021/1/16 — 3:34 — page 22 — #24

i



        Consecutive >s                                                    Chapter 1    Safe Features




        Consecutive Right-Angle Brackets
        In the context of template argument lists, >> is parsed as two separate closing angle brackets.

        Description
        Prior to C++11, a pair of consecutive right-pointing angle brackets anywhere in the source
        code was always interpreted as a bitwise right-shift operator, making an intervening space
        mandatory for them to be treated as separate closing-angle-bracket tokens:
          // C++03
          std::vector<std::vector<int>> v0;         // annoying compile­time error in C++03
          std::vector<std::vector<int> > v1;        // OK

        To facilitate the common use case above, a special rule was added whereby, when parsing
        a template-argument expression, non-nested (i.e., within parentheses) appearances of >, >>,
        >>>, and so on are to be treated as separate closing angle brackets:

          // C++11
          std::vector<std::vector<int>> v0;                       // OK
          std::vector<std::vector<std::vector<int>>> v1;          // OK



        Using the greater-than or right-shift operators
        within template-argument expressions
        For templates that take only type parameters, there’s no issue. When the template parameter
        is a non-type, however, the greater-than or right-shift operators might be useful. In the
        unlikely event that we need either the greater-than operator (>) or the right-shift operator
        (>>) within a non-type template-argument expression, we can achieve our goal by nesting
        that expression within parentheses:
          const int i = 1, j = 2;        // arbitrary integer values (used below)

          template <int I> class C { /*...*/ };
          // class C taking non­type template parameter I of type int

          C<i > j>       a1;   //   compile­time error (always has been)
          C<i >> j>      b1;   //   compile­time error in C++11 (OK in C++03)
          C<(i > j)>     a2;   //   OK
          C<(i >> j)>    b2;   //   OK

        In the definition of a1 above, the first > is interpreted as a closing angle bracket, and the
        subsequent j is (and always has been) a syntax error. In the case of b1, the >> is, as of C++11,
        parsed as a pair of separate tokens in this context, so the second > is now considered an error.
        For both a2 and b2, however, the would-be operators appear nested within parentheses and
        thus are blocked from matching any active open angle bracket to the left of the parenthesized
        expression.
                                                       22


i



    i                                                                                                      i
    i                                                                                                    i
                       “emcpps-internal” — 2021/1/16 — 3:34 — page 23 — #25

i



        C++11                                                                          Consecutive >s


        Use Cases
        Avoiding annoying whitespace when composing template types
        When using nested templated types (e.g., nested containers) in C++03, having to remember
        to insert an intervening space between trailing angle brackets added no value. What made it
        even more galling was that every popular compiler was able to tell you confidently that you
        had forgotten to leave the space. With this new feature (rather, this repaired defect), we can
        now render closing angle brackets contiguously, just like parentheses and square brackets:
          // OK in both C++03 and C++11
          std::list<std::map<int, std::vector<std::string> > > idToNameMappingList;

          // OK in C++11, compile­time error in C++03
          std::list<std::map<int, std::vector<std::string>>> idToNameMappingList;


        Potential Pitfalls
        Some C++03 programs may stop compiling in C++11
        If a right-shift operator is used in a template expression, the newer parsing rules may result
        in a compile-time error where before there was none:
          T<1 >> 5>;      // worked in C++03, compile­time error in C++11

        The easy fix is simply to parenthesize the expression:
          T<(1 >> 5)>;      // OK

        This rare syntax error is invariably caught at compile time, avoiding undetected surprises
        at run time.

        The meaning of a C++03 program can, in theory, silently change in C++11
        Though pathologically rare, the same valid expression can, in theory, have a different inter-
        pretation in C++11 than it had when compiled for C++03. Consider the case30 where the
        >> token is embedded as part of an expression involving templates:

          S<G< 0 >>::c>::b>::a
          //   ^~~~~~~

        In the expression above, 0 >>::c will be interpreted as a bitwise right-shift operator in
        C++03 but not in C++11. Writing a program that (1) compiles under both C++03 and
        C++11 and (2) exposes the difference in parsing rules is possible:
          enum Outer { a = 1, b = 2, c = 3 };

          template <typename> struct S
          {
          enum Inner { a = 100, c = 102 };
          };

          30 Example   adapted from ?
                                                                                                   23


i



    i                                                                                                    i
    i                                                                                                i
                         “emcpps-internal” — 2021/1/16 — 3:34 — page 24 — #26

i



        Consecutive >s                                               Chapter 1    Safe Features



         template <int> struct G
         {
         typedef int b;
         };

         int main()
         {
         std::cout << (S<G< 0 >>::c>::b>::a) << '\n';
         }

        The program above will print 100 when compiled for C++03 and 0 for C++11:
         // C++03

         //     (2) instantiation of G<0>
         //    ∥~~~~~~~~~~~~
         //    ∥| ∥   (4) instantiation of S<int>
         // ~~∥ ↓ ∥~~~~~~~~~~~~~~↓
         S< G< 0 >>::c > ::b >::a
         //    ~~∥ ↑ ∥~~~~~~~~~↑
         //      ∥ | ∥ (3) type alias for int
         //      ∥~~~~~~~
         // (1) bitwise right­shift (0 >> 3)

         // C++11

         //
         //
         // (2) compare (>) Inner::c and Outer::b
         // ↓ ~~~~~~~~~~~~~~~~~~
         S< G< 0 >>::c > ::b >::a
         // ↑ ~~~~~~~~~
         // (1) instantiation of S<G<0>>
         //
         //

        Though theoretically possible, programs that (1) are syntactically valid in both C++03 and
        C++11 and (2) have distinct semantics have not emerged in practice anywhere that we are
        aware of.

        Annoyances


        See Also


        Further Reading
          • Daveed Vandevoorde, Right Angle Brackets, ?
                                                    24


i



    i                                                                                                i
    i                                                                                                             i
                      “emcpps-internal” — 2021/1/16 — 3:34 — page 25 — #27

i



        C++11                                                                                Delegating Ctors




        Constructors Calling Other Constructors
        Delegating constructors are constructors of a class that delegate initialization to another
        constructor of the same class.

        Description
        A delegating constructor is a constructor of a user-defined type (UDT) (i.e., class,
        struct, or union) that invokes another constructor defined for the same UDT as part of its
        initialization of an object of that type. The syntax for invoking another constructor within
        a type is to specify the name of the type as the only element in the member initializer
        list:
          struct S0
          {
          int d_i;

          S0(int i) : d_i(i)       { }           // non­delegating constructor
          S0()      : S0(0)        { }           // OK, delegates to S0(int)
          S0(bool) : S0(0), d_i(0) { }           // error: delegation must be on its own
          };

        Multiple delegating constructors can be chained together (one calling exactly one other)
        so long as cycles are avoided (see Potential Pitfalls: Delegation cycles on page 29). Once a
        target (i.e., invoked via delegation) constructor returns, the body of the delegator is invoked:
          #include <iostream>       // std::cout

          struct S1
          {
          S1(int, int)            { std::cout << 'a'; }
          S1(int)      : S1(0, 0) { std::cout << 'b'; }
          S1()         : S1(0)    { std::cout << 'c'; }
          };

          void f()
          {
          S1 s; // OK, prints "abc" to stdout
          }

        If an exception is thrown while executing a nondelegating constructor, the object being
        initialized is considered only partially constructed (i.e., the object is not yet known to
        be in a valid state) and hence its destructor will not be invoked31 :

           31 The destructor of a partially constructed object will not be invoked. However, the destructors of

        each successfully constructed base and of data members will still be invoked:
         #include <iostream>

         using std::cout;
                                                                                                            25


i



    i                                                                                                             i
    i                                                                                                                 i
                         “emcpps-internal” — 2021/1/16 — 3:34 — page 26 — #28

i



        Delegating Ctors                                                         Chapter 1      Safe Features


          #include <iostream>        // std::cout

          struct S2
          {
          S2() { std::cout << "S2() "; throw 0; }
          ~S2() { std::cout << "~S2() ";        }
          };

          void f() try { S2 s; } catch(int) { }
          // prints only "S2() " to stdout (i.e., the destructor of S2 is never
          // invoked)

        However, if an exception is thrown in the body of a delegating constructor, the object being
        initialized is considered fully constructed, as the target constructor must have returned
        control to the delegator; hence the overall object’s destructor will be invoked:
          #include <iostream>        // std::cout

          struct S3
          {
          S3()           { std::cout << "S3() "              }
          S3(int) : S3() { std::cout << "S3(int) "; throw 0; }
          ~S3()          { std::cout << "~S3() "             }
          };

          void f() try { S3 s(0); } catch(int) { }
          // prints "S3() S3(int) ~S3() " to stdout


        Use Cases
        Avoiding code duplication among constructors
        Avoiding gratuitous code duplication is considered by many to be a best practice. Hav-
        ing one ordinary member function call another has always been an option, but having one
        constructor invoke another constructor directly has not. Classic workarounds included re-
        peating the code or else factoring the code into a private member function that would be
          struct A { A() { cout << "A() "; } ~A() { cout << "~A() "; } };
          struct B { B() { cout << "B() "; } ~B() { cout << "~B() "; } };

          struct C : B
          {
          A d;

          C() { cout << "C() "; throw 0; }        // non­delegating constructor that throws
          ~C() { cout << "~C() ";        }        // destructor that never gets called
          };

          void f() try { C c; } catch(int) { }
          // prints "B() A() C() ~A() ~B()" to stdout

        Notice that base-class B and member d of type a were fully constructed, and so their respective destructors
        are called, even though the destructor for class C itself is never executed.
                                                            26


i



    i                                                                                                                 i
    i                                                                                                                   i
                       “emcpps-internal” — 2021/1/16 — 3:34 — page 27 — #29

i



        C++11                                                                                     Delegating Ctors


        called from multiple constructors. The drawback with this workaround is that the private
        method, not being a constructor, would be unable to make use of member initialization
        lists to construct base-class and member objects eﬀiciently. As of C++11, delegating con-
        structors can be used to minimize code duplication when some of the same operations are
        performed across multiple constructors without having to forgo eﬀicient initialization.
            As an example, consider an IPV4Host class representing a network endpoint that can
        either be constructed by (1) a 32-bit address and a 16-bit port or (2) an IPV4 string with
        XXX.XXX.XXX.XXX:XXXXX format32 :
          #include <cstdint>         // std::uint16_t, std::uint32_t

          class IPV4Host
          {
          // ...

          public:
          IPV4Host(std::uint32_t address, std::uint16_t port)
          {
          if (!connect(address, port)) // code repetition: BAD IDEA
          {
          throw ConnectionException{address, port};
          }
          }

          IPV4Host(const std::string& ip)
          {
          std::uint32_t address = extractAddress(ip);
          std::uint16_t port = extractPort(ip);

          if (!connect(address, port)) // code repetition: BAD IDEA
          {
          throw ConnectionException{address, port};
          }
          }
          };

        Prior to C++11, working around such code duplication would require the introduction of
        a separate, subordinate (private) helper function, that would, in turn, be called by each of
        the constructors:
          #include <cstdint>         // std::uint16_t, std::uint32_t

          class IPV4Host
          {
          // ...

          private:
          32 Note  that this initial design might itself be suboptimal in that the representation of the IPV4 address
        and port value might profitably be factored out into a separate value-semantic class, say, IPV4Host, that
        itself might be constructed in multiple ways; see Potential Pitfalls: Suboptimal factoring on page 29.
                                                                                                                  27


i



    i                                                                                                                   i
    i                                                                                                     i
                       “emcpps-internal” — 2021/1/16 — 3:34 — page 28 — #30

i



        Delegating Ctors                                                Chapter 1     Safe Features


          void validate(std::uint32_t address, std::uint16_t port) // helper function
          {
          if (!connect(address, port)) // factored implementation of needed logic
          {
          throw ConnectionException{address, port};
          }
          }

          public:
          IPV4Host(std::uint32_t address, std::uint16_t port)
          {
          validate(address, port); // Invoke factored private helper function.
          }

          IPV4Host(const std::string& ip)
          {
          std::uint32_t address = extractAddress(ip);
          std::uint16_t port = extractPort(ip);

          validate(address, port);      // Invoke factored private helper function.
          }
          };

        Alternatively, the constructor accepting a string can be rewritten to delegate to the one
        accepting address and port, avoiding repetition without having to delegate to a private
        function:
          #include <cstdint>     // std::uint16_t, std::uint32_t

          class IPV4Host
          {
          // ...

          public:
          IPV4Host(std::uint32_t address, std::uint16_t port)
          {
          if(!connect(address, port))
          {
          throw ConnectionException{address, port};
          }
          }

          IPV4Host(const std::string& ip)
          : IPV4Host{extractAddress(ip), extractPort(ip)}
          {
          }
          };

        Compared to the pre-C++11 workaround of introducing a private init function containing
        the duplicated logic, use of delegating constructors results in less boilerplate and fewer run-
                                                      28


i



    i                                                                                                     i
    i                                                                                                                      i
                        “emcpps-internal” — 2021/1/16 — 3:34 — page 29 — #31

i



        C++11                                                                                        Delegating Ctors


        time operations, as data members (and base classes) can be initialized directly through the
        member initialization list, rather than be assigned-to in the body of init (assuming
        copy assignment is even supported on that type), but see Potential Pitfalls: Suboptimal
        factoring on page 29.

        Potential Pitfalls
        Delegation cycles
        If a constructor delegates to itself either directly or indirectly, the program is ill-formed,
        no diagnostic required. While some compilers can detect delegation cycles at compile
        time, they are not required (nor necessarily able) to do so. For example, consider a simple
        delegation cycle comprising two constructors:
          struct S // Object
          {
          S(int) : S(true) { }           // delegating constructor
          S(bool) : S(0)   { }           // delegating constructor
          };

        Not all popular compilers will warn you that the program above is ill-formed.33 Therefore
        the programmer is responsible for ensuring that no delegation cycles are present.

        Suboptimal factoring
        The need for delegating constructors might result from initially suboptimal factoring —
        e.g., in the case where the same value is being presented in different forms to a variety
        of different mechanisms. For example, consider the IPV4Host class in Use Cases (which
        starts on page 26). While having two constructors to initialize the host might be appropriate,
        if either (1) the number of ways of expressing the same value increases or (2) the number
        of consumers of that value increases, we might be well advised to create a separate value
        semantic type, e.g., IPV4Address, to represent that value34 :
          #include <cstdint>         // std::uint16_t, std::uint32_t

          struct IPV4Address
          {
          std::uint32_t d_address;
          std::uint16_t d_port;

          IPV4Address(std::uint32_t address, std::uint16_t port)
          : d_address{address}, d_port{port}

          33 GCC   10.x does not detect this delegation cycle at compile time and produces a binary that, if run, will
        necessarily exhibit undefined behavior. Clang 10.x, on the other hand, halts compilation with a helpful
        error message:
          error: constructor for S creates a delegation cycle

          34 The  notion that each component in a subsystem ideally performs one focused function well is sometimes
        referred to as separation of (logical) concerns or fine-grained (physical) factoring; see lakos20, sections 0.4,
        3.2.7, and 3.5.9, pp. 20–28, 529–530, and 674–676, respectively.
                                                                                                                     29


i



    i                                                                                                                      i
    i                                                                                                i
                       “emcpps-internal” — 2021/1/16 — 3:34 — page 30 — #32

i



        Delegating Ctors                                             Chapter 1    Safe Features


         {
         }

         IPV4Address(const std::string& ip)
         : IPV4Address{extractAddress(ip), extractPort(ip)}
         {
         }
         };

        Note that IPV4Address itself makes use of delegating constructors but as a purely private,
        encapsulated implementation detail. With the introduction of IPV4Address into the code-
        base, IPV4Host (and similar components requiring an IPV4Address value) can be redefined
        to have a single constructor (or other previously overloaded member function) accepting an
        IPV4Address object as an argument.

        Annoyances
        None so far

        See Also
        None so far

        Further Reading
        None so far




                                                    30


i



    i                                                                                                i
    i                                                                                                                  i
                       “emcpps-internal” — 2021/1/16 — 3:34 — page 31 — #33

i



        C++11                                                                                      Inheriting Ctors




        Inheriting Base Class Constructors
        The term inheriting constructors refers to the use of a using-declaration to expose nearly
        all of the constructors of a base class in the scope of a derived class.

        Description
        In a class definition, a using declaration naming a base class’s constructor results in
        the derived class “inheriting” all of the nominated base class’s constructors, except for
        copy and move constructors. Just like other using declarations, the nominated base class’s
        constructors will be searched when no matching constructor is found in the derived class.
        When a base class constructor is selected in this way, that constructor will be used to
        construct the base class and the remaining bases and data members of the subclass will be
        initialized as if by the default constructor (e.g., applying default initializers; see “Default
        Member Init” on page 221).
          struct B0
          {
          B0() = default;             // public, default constructor
          B0(int)         { }         // public, one argument (implicit) value constructor
          B0(int, int)    { }         // public, two argument value constructor

          private:
          B0(const char*) { }         // private, one argument constructor
          };

          struct D0 : B0
          {
          using B0::B0; // using declaration
          D0(double d); // suppress implicit default constructor
          };

          D0 t(1);         // OK, inherited from B0::B0(int)
          D0 u(2, 3);      // OK, inherited from B0::B0(int, int)
          D0 v("hi");      // Error: Base constructor is declared private.

        The only constructors that are explicitly not inheritable by the derived class are the (po-
        tentially compiler-generated) copy and move constructors35 :
          #include <utility>        // std::move

          B0   b1(1);                   //   OK,   base­class   object   can   be   created.
          B0   b2(2, 3);                //   OK,   base­class   object   can   be   created.
          B0   b3(b1);                  //   OK,   base­class   object   can   be   copied (from *lvalue*).
          B0   b4(std::move(b1));       //   OK,   base­class   object   can   be   moved (from *rvalue).
           35 Note that we use braced initialization (see “Braced Init” on page 218) in D0 x(B0); to ensure that a

        variable x of type D0 is declared. D0 x(B0()); would instead be interpreted as a declaration of a function x
        returning D0 and accepting a pointer to a nullary function returning B0, which is referred to as the most
        vexing parse.
                                                                                                                 31


i



    i                                                                                                                  i
    i                                                                                                   i
                           “emcpps-internal” — 2021/1/16 — 3:34 — page 32 — #34

i



        Inheriting Ctors                                               Chapter 1     Safe Features



          D0 w(b1);         // Error: Base­class copy constructor is not inherited.
          D0 v;             // OK, base­class default constructor is inherited.
          D0 x(B0{});       // Error: Base­class move constructor is not inherited.

          D0 y(B0(4));       // Error: Base­class move constructor is not inherited.
          D0 z(t);           // OK, uses compiler­generated D0::D0(const D0&)
          D0 j(D0(5));       // OK, uses compiler­generated DO::D0(D&&)

        The constructors inherited by the derived class have the same effect on whether the compiler
        implicitly generates special member functions as explicitly implemented ones would. For
        example, D0’s default constructor would be implicitly deleted (see “Deleted Functions” on
        page 70) if B0 doesn’t have a default constructor. Note that since the copy and move
        constructors are not inherited, their presence in the base class wouldn’t suppress implicit
        generation of copy and move assignment in the derived class. For instance, D0’s implicitly
        generated assignment operators obliviously hide their counterparts in B0:
          void f()
          {
          B0 b(0), bb(0);       // Create destination and source B0 objects.
          D0 d(0), dd(0);       //   "         "       "    "    D0    ".

          b = bb;               // OK, assign base from lvalue base.
          b = B0(0);            // OK,   "       "   " rvalue    "

          d = bb;               // Error: B0::operator= is hidden by D0::operator=.
          d = B0(0);            // Error:       "         "    "     "        "

          d.B0::operator=(bb);          // OK, explicit slicing is still possible.
          d.B0::operator=(B0(0));       // OK,    "         "      "   "      "

          d = dd;               // OK, assign derived from lvalue derived.
          d = D0(0);            // OK,   "        "     " rvalue     "
          }

        Note that, when inheriting constructors, private constructors in the base class are accessed
        as private constructors of that base class and are subject to the same access controls; see
        Annoyances: Access levels of inherited constructors are the same as in base class on page 44.
           Inheriting constructors having the same signature from multiple base classes lead to
        ambiguity errors:
          struct B1A { B1A(int); };
          struct B1B { B1B(int); };

          struct D1 : B1A, B1B
          {
          using B1A::B1A;
          using B1B::B1B;
          };

                                                     32


i



    i                                                                                                   i
    i                                                                                                     i
                      “emcpps-internal” — 2021/1/16 — 3:34 — page 33 — #35

i



        C++11                                                                          Inheriting Ctors


          D1 d1(0);     // Error: Call of overloaded D1(int) is ambiguous.

        Each inherited constructor shares the same characteristics as the corresponding one in the
        nominated base class’s constructors and then delegates to it. This means the access spec-
        ifiers, the explicit specifier, the constexpr specifier, the default arguments, and the
        exception specification are also preserved by constructor inheritance; see “??” on page ??
        and “constexpr Functions” on page 219. For template constructors, the template parameter
        list and the default template arguments are preserved as well:
          struct B2
          {
          template <typename T = int>
          explicit B2(T) { }
          };

          struct D2 : B2 { using B2::B2; };

        The declaration using B2::B2 above behaves as if a constructor template that delegates to
        its nominated base class’s template was provided in D2:
          // pseudocode
          struct D2 : B2
          {
          template <typename T = int>
          explicit D2(T i) : B2(i) { }
          }

        When deriving from a base class in which inheriting most (but not all) of its constructors is
        desirable, suppressing inheritance of one or more of them is possible by providing construc-
        tors in the derived class having the same signature as the ones that would be inherited:
          struct B2
          {
          B2()         { std::cout << "B2()\n"; }
          B2(int)      { std::cout << "B2(int)\n"; }
          B2(int, int) { std::cout << "B2(int, int)\n"; }
          };

          struct D2 : B2
          {
          using B2::B2;
          D2(int) { std::cout << "D2(int)\n"; }
          };

          D2 d;          // prints "B2()"
          D2 e(0);       // Prints "D2(int)" ­­­ The derived constructor is invoked.
          D2 f(0, 0);    // prints "B2(int, int)"

        In other words, we can suppress what would otherwise be an inherited constructor from
        a nominated base class by simply declaring a replacement with the same signature in the
        derived class. We can then choose to either implement it ourselves, default it (see “Defaulted
        Functions” on page 58), or delete it (see “Deleted Functions” on page 70).
                                                                                                    33


i



    i                                                                                                     i
    i                                                                                                                    i
                           “emcpps-internal” — 2021/1/16 — 3:34 — page 34 — #36

i



        Inheriting Ctors                                                           Chapter 1       Safe Features


           If we have chosen to inherit the constructors from multiple base classes, we can disam-
        biguate conflicts by declaring the offending constructor(s) explicitly in the derived class and
        then delegating to the base classes if and as appropriate:
          struct B1A { B1A(int); };           // Here we have two bases classes, each of which
          struct B1B { B1B(int); };           // provides a conversion constructor from an int.

          struct D1 : B1A, B1B
          {
          using B1A::B1A; // Inherit the int constructor from base class B1A.
          using B1B::B1B; // Inherit the int constructor from base class B1B.

          D1(int i) : B1A(i), B1B(i) { }             // Declare the int conversion constructor
          };                                             // explicitly, and then delegate to bases.

          D1 d1(0);      // OK, calls D1(int)

        Lastly, inheriting constructors from a dependent type affords a capability over C++03
        that is more than just convenience and avoidance of boilerplate code.36 In all of the example
        code in Description thus far, we know how to spell the base-class constructor; we are simply
        automating some drudge work. In the case of a dependent base class, however, we do not
        know how to spell the constructors, so we must rely on inheriting constructors if that is
        the forwarding semantic we seek:
          template <class T>
          struct S : T // The base type, T, is a *dependent type*.
          {
          using T::T; // inheriting constructors (generically) from a dependent type
          };

          #include <string>
          #include <vector>

          S<std::string>        ss("hello");                  // OK, uses constructor from base
          S<std::vector<char>> svc("goodbye");               // Error: no suitable constructor in base

        In this example, we created a class template, S, that derived publicly from its template
        argument, T. Then, when creating an object of type S parameterized by std::string, we
        were able to pass it a string literal via the inherited std::string constructor overloaded
        on a const char*. Notice, however, that no such constructor is available in std::vector;
        hence, attempting to create the derived class from a literal string results in a compile-time
        error. See Use Cases: Incorporating reusable functionality via a mix-in on page 39.
           36 A decidedly more complex alternative affording a different set of tradeoffs would involve variadic tem-

        plate constructors (see “Variadic Templates” on page 314) having forwarding references (see “Forwarding
        References” on page 284) as parameters. In this alternative approach, all of the constructors from the public,
        protected, and private regions of the bases class would now appear under the same access specifier — i.e.,
        the one in which the perfectly forwarding constructor is declared. What’s more, this approach would not
        retain other constructor characteristics, such as explicit, noexcept, constexpr, and so on. The forwarding
        can, however, be restricted to inheriting just the public constructors (without characteristics) by constrain-
        ing on std::is_constructible using SFINAE; see Annoyances: Access levels of inherited constructors
        are the same as in base class on page 44.
                                                              34


i



    i                                                                                                                    i
    i                                                                                                                  i
                       “emcpps-internal” — 2021/1/16 — 3:34 — page 35 — #37

i



        C++11                                                                                      Inheriting Ctors


        Use Cases
        Abstract use case
        Use of this form of using declaration to inherit a nominated base class’s constructors
        — essentially verbatim — suggests that one or more of those constructors is suﬀicient to
        initialize the entire derived-class object to a valid useful state. Typically, such will pertain
        only when the derived class adds no member data of its own. While additional derived-class
        member data could possibly default, this state must be orthogonal to any modifiable state
        initialized in the base class, as such state is subject to independent change via slicing,
        which might in turn invalidate object invariants. Derived-class data will need either to
        default or to have its value set using member initializers (see “Default Member Init” on
        page 221). Hence, most typical use cases will involve wrapping an existing class by deriving
        from it (either publicly or privately), adding only defaulted data members having orthogonal
        values, and then adjusting the derived class’s behavior via overriding its virtual or hiding
        its and non-virtual member functions.

        Avoiding boilerplate code when employing structural inheritance
        A key indication for the use of inheriting constructors is that the derived class addresses only
        auxiliary or optional, rather than required or necessary, functionality to its self-suﬀicient base
        class. As an interesting, albeit mostly pedagogical,37 example, suppose we want to provide
        a proxy for a std::vector that performs explicit checking of indices supplied to its index
        operator:
          #include <vector>
          #include <cassert>

          template <typename T>
          struct CheckedVector : std::vector<T>
          {
          using std::vector<T>::vector;      // Inherit std::vector's constructors.

          T& operator[](std::size_t index)   // Hide std::vector's index operator.
          {
          assert(index < std::vector<T>::size());
          return std::vector<T>::operator[](index);
          }

          const T& operator[](std::size_t index) const                 // Hide const index operator.
          {
          assert(index < std::vector<T>::size());
          return std::vector<T>::operator[](index);
          }
          };

           37 Although this example might be compelling, it suffers from inherent deficiencies making it insuﬀicient

        for general use in practice: Passing the derived class to a function — whether by value or reference – will
        strip it of its auxiliary functionality. The best-known solution — a C++2x language-based contract-checking
        facility — is exactly what’s needed ubiquitously. We plan to cover this topic in lakos23.
                                                                                                                 35


i



    i                                                                                                                  i
    i                                                                                                                     i
                           “emcpps-internal” — 2021/1/16 — 3:34 — page 36 — #38

i



        Inheriting Ctors                                                           Chapter 1        Safe Features


        In the example above, inheriting constructors allowed us to use public (structural) inheri-
        tance to readily create a distinct new type having all of the functionality of its base type
        except for a couple of functions where we chose to augment the original behavior.

        Avoiding boilerplate code when employing implementation inheritance
        Sometimes it can be cost effective to adapt a concrete class having virtual functions38 to
        a specialized purpose using inheritance.39 As an example, consider a concrete base class,
        NetworkDataStream, that allows overriding its virtual functions for processing a stream of
        data from an expanding variety of arbitrary sources over the network:
          class NetworkDataStream
          {
          private:
          // ...                            (member data)

          public:
          explicit NetworkDataStream(TCPConnection* tcpConnection);
          explicit NetworkDataStream(UDPConnection* udpConnection);
          explicit NetworkDataStream(RawDataStreamHandle* rawDataStreamHandle);

          virtual ~NetworkDataStream();

          virtual void onPacketReceived(DataPacket& dataPacket) = 0;
          // Derived classes must override this method.

        The concrete class above now provides three constructors (with more under development)
        that can be used assuming no per-packet processing is required. Now, imagine the need for
        logging information about received packets (e.g., for auditing purposes). Inheriting construc-
        tors make deriving from NetworkDataStream and overriding (see “override” on page 127)
        onPacketReceived(DataPacket&) more convenient — i.e., without having to reimplement
        each of the constructors, which are anticipated to increase in number over time:
          class LoggedNetworkDataStream : public NetworkDataStream
          {
          public:
          using NetworkDataStream::NetworkDataStream;

          void onPacketReceived(DataPacket& dataPacket) override
          {
          LOG_TRACE << "Received packet " << dataPacket;    // local log facility
          NetworkDataStream::onPacketReceived(dataPacket); // Delegate to base.
          }
          };



           38 Useful design patterns exist where a partial implementation class, derived from a pure abstract in-

        terface (a.k.a. a protocol), contains data, constructors, and pure virtual functions; see lakos2a, section 4.7.
           39 Such inheritance, known as implementation inheritance, is decidedly distinct from pure interface

        inheritance, which is often the preferred design pattern in practice; see lakos2b, section 4.6.
                                                              36


i



    i                                                                                                                     i
    i                                                                                                                      i
                        “emcpps-internal” — 2021/1/16 — 3:34 — page 37 — #39

i



        C++11                                                                                         Inheriting Ctors


        Implementing a strong typedef
        Classic typedef declarations — just like C++11 using declarations (see “using Aliases”
        on page 152) — are just synonyms; they offer absolutely no type safety. A commonly desired
        capability is to provide an alias to an existing type T that is uniquely interoperable with
        itself, explicitly convertible from T, but not implicitly convertible from T. This somewhat
        more “type-safe” form of alias is sometimes referred to as a strong typedef.40
            As a practical example, suppose we are exposing, to a fairly wide and varied audience,
        a class, PatientInfo, that associates two Date objects to a given hospital patient:
          class Date
          {
          // ...

          public:
          Date(int year, int month, int day);

          // ...
          };

          class PatientInfo
          {
          private:
          Date d_birthday;
          Date d_appointment;

          public:
          PatientInfo(Date birthday, Date appointment);
          // Please pass the birthday as the first date and the appointment as
          // the second one!
          };

        For the sake of argument, imagine that our users are not as assiduous as they should be in
        reading documentation to know which constructor argument is which:
          PatientInfo client1(Date birthday, Date appointment)
          {
          return PatientInfo(birthday, appointment); // OK
          }

          int client2(PatientInfo* result, Date birthday, Date appointment)
          {
          *result = PatientInfo(appointment, birthday); // Oops! wrong order
          return 0;
           40 A so-called strong typedef is similar to a classic, C-style enumeration in that it is (1) its own type and

        (2) implicitly convertible to its base type (which for enumerators corresponds to its underlying type; see
        “Underlying Type ’11” on page 257). Unlike a classic enum, however, a typical implementation of a strong
        typedef allows only for explicit conversion from its base type. An analogy to the more strongly typed
        enum class (see “enum class” on page 222) would suppress conversion in either direction, e.g., via private
        inheritance and then explicit conversion constructors and explicit conversion operators (see “explicit
        Operators” on page 75).
                                                                                                                     37


i



    i                                                                                                                      i
    i                                                                                                                      i
                           “emcpps-internal” — 2021/1/16 — 3:34 — page 38 — #40

i



        Inheriting Ctors                                                            Chapter 1       Safe Features


          }

        Now suppose that we continue to get complaints, from folks like client2 in the example
        above, that our code doesn’t work. What can we do?41
            One way is to force clients to make a conscious and explicit decision in their own source
        code as to which Date is the birthday and which is the appointment. Employing a strong
        typedef can help us to achieve this goal. Inheriting constructors provide a concise way to
        define a strong typedef; for the example above, they can be used to define two new types
        to represent, uniquely, a birthday and an appointment date:
          struct Birthday : Date // somewhat type­safe alias for a Date
          {
          using Date::Date; // inherit Date's three integer ctor
          explicit Birthday(Date d) : Date(d) { } // explicit conversion from Date
          };

          struct Appointment : Date // somewhat type­safe alias for a Date
          {
          using Date::Date; // inherit Date's three integer ctor
          explicit Appointment(Date d) : Date(d) { } // explicit conv. from Date
          };

        The Birthday and Appointment types expose the same interface of Date, yet, given our
        inheritance-based design, Date is not implicitly convertible to either. Most importantly,
        however, these two new types are not implicitly convertible to each other:
          Birthday b0(1994, 10, 4);            //   OK, thanks to inheriting constructors
          Date d0 = b0;                        //   OK, thanks to public inheritance
          Birthday b1 = d0;                    //   error: no implicit conversion from Date
          Appointment a0;                      //   Error: Appointment has no default ctor.
          Appointment a1 = b0;                 //   error: no implicit conversion from Birthday
          Birthday n2(d0);                     //   OK, thanks to an explicit constructor in Birthday
          Birthday b3(a0);                     //   OK, an Appointment (unfortunately) is a Date.

        We can now reimagine a PatientInfo class that exploits this newfound (albeit artificially
        manufactured42 ) type-safety:
          class PatientInfo
          {
          private:
          Birthday d_birthday;
          Appointment d_appointment;


           41 Although this example is presented lightheartedly, misuse by clients is a perennial problem in large-scale

        software organizations. Choosing the same type for both arguments might well be the right choice in some
        environments but not in others. We are not advocating use of this technique; we are merely acknowledging
        that it exists.
           42 Replicating types that have identical behavior in the name of type safety can run afoul of interoper-

        ability. Distinct types that are otherwise physically similar are often most appropriate when their respec-
        tive behaviors are inherently distinct and unlikely to interact in practice (e.g., a CartesianPoint and a
        RationalNumber, each implemented as having two integral data members); see lakos2a, section 4.4.
                                                               38


i



    i                                                                                                                      i
    i                                                                                                    i
                     “emcpps-internal” — 2021/1/16 — 3:34 — page 39 — #41

i



        C++11                                                                         Inheriting Ctors


          public:
          PatientInfo(Birthday birthday, Appointment appointment);
          // Why should I bother to write documentation you won't read anyway!?
          };

        Now our clients have no choice but to make their intentions clear at the call site:
          PatientInfo client0(Date birthday, Date appointment)
          {
          return PatientInfo(birthday, appointment); // Sorry, doesn't compile.
          }

          int client1(PatientInfo* result, Date birthday, Date appointment)
          {
          *result = PatientInfo(appointment, birthday); // Nope! Doesn't compile.
          return 0;
          }

          PatientInfo client3(Date birthday, Date appointment)
          {
          return PatientInfo(Birthday(birthday), Appointment(appointment));           // OK
          }

          int client4(PatientInfo* result, Date birthday, Date appointment)
          {
          Birthday b(birthday);
          Appointment a(appointment)
          *result = PatientInfo(b, a); // OK
          }

        This example works because the value constructor takes three arguments and cannot
        be invoked as part of an implicit conversion sequence; see Potential Pitfalls: Beware of
        inheriting implicit constructors on page 41. Note that, in an ideal world where thorough
        unit testing is ubiquitous, such machinations would most likely be supererogatory.

        Incorporating reusable functionality via a mix-in
        Some classes are designed to generically enhance the behavior of a class just by inheriting
        from it; such classes are sometimes referred to as mix-ins. If we wish to adapt a class to
        support the additional behavior of the mix-in, with no other change to its behavior, we
        can use simple structural inheritance (e.g., to preserve reference compatibility through
        function calls). To preserve the public interface, however, we will need it to inherit the
        constructors as well.
           Consider, for example, a simple class to track the total number of objects created:
          template <typename T>
          struct CounterImpl // mix­in used to augment implementation of arbitrary type
          {
          static int s_constructed; // count of the number of T objects constructed

          CounterImpl()                       { ++s_constructed; }
                                                                                                   39


i



    i                                                                                                    i
    i                                                                                                    i
                           “emcpps-internal” — 2021/1/16 — 3:34 — page 40 — #42

i



        Inheriting Ctors                                                Chapter 1    Safe Features


          CounterImpl(const CounterImpl&) { ++s_constructed; }
          };

          template <typename T>
          CounterImpl<T>::s_constructed;      // required member definition

        The class template CounterImpl, in the example above, counts the number of times an
        object of type T was constructed during a run of the program. We can then write a generic
        adapter, Counted, to facilitate use of CounterImpl as a mix-in:
          template <class T>
          struct Counted : T, CounterImpl<T>
          {
          using T::T;
          };

        Note that the Counted adaptor class inherits all of the constructors of the dependent class,
        T, that it wraps, without its having to know what those constructors are:
          #include <string>       // std::string
          #include <vector>       // std::vector
          #include "myfoo.h"      // MyFoo

          Counted<std::string>        cs;      // Construct a counted string.
          Counted<std::vector<char>> cvc;      // Construct a counted vector of char.
          Counted<MyFoo>             cmf;      // Construct a counted MyFoo object.

        While inheriting constructors are a convenience in nongeneric programming, they can be an
        essential tool for generic idioms.

        Potential Pitfalls
        Newly introduced constructors in the base class can silently alter
        program behavior
        The introduction of a new constructor in a base class might silently change a program’s run-
        time behavior if that constructor happens to be a better match during overload resolution of
        an existing instantiation of a derived class. Consider a Session class that initially provides
        only two constructors:
          struct Session
          {
          Session();
          explicit Session(RawSessionHandle* rawSessionHandle);
          };

        Now, imagine that a class, AuthenticatedSession, derived from Session, inherits the
        two constructors of its base class and provides its own constructor that accepts an integral
        authentication token:
          struct AuthenticatedSession : Session
          {
                                                      40


i



    i                                                                                                    i
    i                                                                                                    i
                     “emcpps-internal” — 2021/1/16 — 3:34 — page 41 — #43

i



        C++11                                                                         Inheriting Ctors


          using Session::Session;
          explicit AuthenticatedSession(long long authToken);
          };

        Finally, consider an instantiation of AuthenticatedSession in user-facing code:
          AuthenticatedSession authSession(45100);

        In the line above and the example above that, authSession will be initialized by invoking
        the constructor accepting a long long (see “long long” on page 114) authentication token.
        If, however, a new constructor having the signature Session(int) is added to the base
        class, it will be invoked instead because it is a better match to the literal 45100 (of type
        int) than the constructor taking a long long supplied explicitly in the derived class; hence,
        adding a constructor to a base class might lead to a potential latent (runtime) defect that
        would go unreported at compile time.
            Note that this problem with shifting implicit conversions is not unique to inheriting
        constructors; any form of using declaration or invocation of an overloaded function carries
        a similar risk. Imposing stronger typing — e.g., by using strong typedefs (see Use Cases:
        Implementing a strong typedef on page 37) — might sometimes, however, help to prevent
        such unfortunate missteps.

        Beware of inheriting implicit constructors
        Inheriting from a class that has implicit constructors can cause surprises. Consider again
        the use of inheriting constructors to implement a strong typedef from Use Cases: Imple-
        menting a strong typedef on page 37. This time, however, let’s suppose we are exposing,
        to a fairly wide and varied audience, a class PointOfInterest, that associates the name
        and address of a given popular tourist attraction:
          #include <string>    // std::string

          class PointOfInterest
          {
          private:
          std::string d_name;
          std::string d_address;

          public:
          PointOfInterest(const std::string& name, const std::string& address);
          // Please pass the name as the *first* and the address *second*!
          };

        Again imagine that our users are not always careful about inspecting the function prototype:
          PointOfInterested client1(const char* name, const char* address)
          {
          return PointOfInterest(name, address); // OK
          }

          int client2(PointOfInterest* result, const char* name, const char* address)
          {
                                                                                                   41


i



    i                                                                                                    i
    i                                                                                                     i
                           “emcpps-internal” — 2021/1/16 — 3:34 — page 42 — #44

i



        Inheriting Ctors                                                Chapter 1     Safe Features


          *result = PointOfInterest(address, name);        // Oops! wrong order
          return 0;
          }

        We might think to again use strong typedefs here as we did for PatientAppointment in
        Use Cases: Implementing a strong typedef on page 37:
          struct Name : std::string // somewhat type­safe alias for a std::string
          {
          using std::string::string; // Inherit, as is, all of std::string's ctors.
          explicit Name(const std::string& s) : std::string(s) { } // conversion
          };

          struct Address : std::string // somewhat type­safe alias for a std::string
          {
          using std::string::string; // Inherit, as is, all of std::string's ctors.
          explicit Address(const std::string& s) : std::string(s) { } // conversion
          };

        The Name and Address types are not interconvertible; they expose the same interfaces as
        std::string but are not implicitly convertible from it:
          Name n0 = "Big Tower";      //   OK, thanks to inheriting constructors
          std::string s0 = n0;        //   OK, thanks to public inheritance
          Name n1 = s0;               //   error: no implicit conversion from std::string
          Address a0;                 //   OK, unfortunately a std::string has a default ctor.
          Address a1 = n0;            //   error: no implicit conversion from Name
          Name n2(s0);                //   OK, thanks to an explicit constructor in Name
          Name b3(a0);                //   OK, an Address (unfortunately) is a std::string.

        We can rework the PointOfInterest class to use the strong typedef idiom:
          class PointOfInterest
          {
          private:
          Name    d_name;
          Address d_address;

          public:
          PointOfInterest(const Name& name, const Address& address);
          };

        Now if our clients use the base class itself as a parameter, they will again need to make their
        intentions known:
          PointOfInterested client1(const std::string& name, const std::string address)
          {
          return PointOfInterest(address, name); // sorry, doesn't compile
          }

          PointOfInterested client2(const char* name, const char* address)
          {
          return PointOfInterest(Name(name), Address(address)); // OK
                                                      42


i



    i                                                                                                     i
    i                                                                                                      i
                     “emcpps-internal” — 2021/1/16 — 3:34 — page 43 — #45

i



        C++11                                                                           Inheriting Ctors


          }

        But suppose that some clients instead pass the arguments by const char* instead of
        const std::string&:
          PointOfInterested client3(const char* name, const char* address)
          {
          return PointOfInterest(address, name); // Oops! compiles but runtime error
          }

        In the case of client3 in the code snippet above, passing the arguments through does
        compile because the const char* constructors are inherited; hence, there is no attempt
        to convert to a std::string before matching the implicit conversion constructor. Had
        the std::string conversion constructor been declared to be explicit, the code would not
        have compiled. In short, inheriting constructors from types that perform implicit conversions
        seriously undermine the effectiveness of the strong typedef idiom.

        Annoyances
        Inherited constructors cannot be selected individually
        The inheriting-constructors feature does not allow the programmer to select a subset of con-
        structors to inherit; all of the base class’s eligible constructors are always inherited unless
        a constructor with the same signature is provided in the derived class. If the programmer
        desires to inherit all constructors of a base class except for perhaps one or two, the straight-
        forward workaround would be to declare the undesired constructors in the derived class and
        then use deleted functions (see “Deleted Functions” on page 70) to explicitly exclude them.
            For example, suppose we have a general class, Datum, that can be constructed from a
        variety of types:
          struct Datum
          {
          Datum(bool);
          Datum(char);
          Datum(short);
          Datum(int);
          Datum(long);
          Datum(long long);
          };

        If we wanted to create a version of Datum, call it NumericalDatum, that inherits all but the
        one constructor taking a bool, our derived class would (1) inherit publicly, (2) declare the
        unwanted constructor, and then (3) mark it with = delete:
          struct NumericalDatum : Datum
          {
          using Datum::Datum;                  // Inherit all the constructors...
          NumericalDatum(bool) = delete;       // ...except the one taking a bool.
          };

        Note that the subsequent addition of any non-numerical constructor to Datum (e.g., a con-
        structor taking std::string) would defeat the purpose of NumericalDatum.
                                                                                                     43


i



    i                                                                                                      i
    i                                                                                                                 i
                           “emcpps-internal” — 2021/1/16 — 3:34 — page 44 — #46

i



        Inheriting Ctors                                                         Chapter 1      Safe Features


        Access levels of inherited constructors are the same as in base class
        Unlike base-class member functions that can be introduced with a using directive with an
        arbitrary access level into the derived class (as long as they are accessible by the derived
        class), the access level of the using declaration for inherited constructors is ignored.43 The
        inherited constructor overload is instead accessible if the corresponding base-class construc-
        tor would be accessible:
          struct Base
          {
          private:
          Base(int) { } // This constructor is declared private in the base class.
          void pvt0() { }
          void pvt1() { }

          public:
          Base() { }      // This constructor is declared public in the base class.
          void pub0() { }
          void pub1() { }
          };

        Note that, when employing using to (1) inherit constructors or (2) elevate base-class defini-
        tions in the presence of private inheritance, public clients of the class might find it necessary
        to look at what are ostensibly private implementation details of the derived class to make
        proper use of that type through its public interface:
          struct Derived : private Base
          {
          using Base::Base; // OK, inherited Base() as public constructor
          // and Base(int) as private constructor

          private:
          using Base::pub0;        // OK, pub0 is declared private in derived class.
          using Base::pvt0;        // Error: pvt0 was declared private in base class.

          public:
          using Base::pub1;        // OK, pub1 is declared public in derived class.
          using Base::pvt1;        // Error: pvt1 was declared private in base class.
          };

          void client()
          {
          Derived x(0);      //   Error: Constructor was declared private in base class.
          Derived d;         //   OK, constructor was declared public in base class.
          d.pub0();          //   Error: pub0 was declared private in derived class.
          d.pub1();          //   OK, pub1 was declared public in derived class.

           43 Alisdair Meredith, one of the authors of the Standards paper that proposed this feature (meredith08),

        suggests that placing the using declaration for inheriting constructors as the very first member decla-
        ration and preceding any access specifiers might be the least confusing location. Programmers might still
        be confused by the disparate default access levels of class versus struct.
                                                            44


i



    i                                                                                                                 i
    i                                                                                                  i
                     “emcpps-internal” — 2021/1/16 — 3:34 — page 45 — #47

i



        C++11                                                                       Inheriting Ctors


         d.pvt0();        // Error: pvt0 was declared private in base class.
         d.pvt1();        // Error: pvt1 was declared private in base class.
         }

        This C++11 feature was itself created because the previously proposed solution — which
        also involved a couple of features new in C++11, namely forwarding the arguments to base-
        class constructors with forwarding references (see “Forwarding References” on page 284)
        and variadic templates (see “Variadic Templates” on page 314) — made somewhat different
        tradeoffs and was considered too onerous and fragile to be practically useful:
         #include <utility>     // std::forward

         struct Base
         {
         Base(int) { }
         };

         struct Derived : private Base
         {
         protected:
         template <typename... Args>
         Derived(Args&&... args) : Base(std::forward<Args>(args)...)
         {
         }
         };

        In the example above, we have used forwarding references (see “Forwarding References”
        on page 284) to properly delegate the implementation of a constructor that is declared
        protected in the derived class to a public constructor of a privately inherited base class.
        Although this approach fails to preserve many of the characteristics of the inheriting con-
        structors (e.g., explicit, constexpr, noexcept, and so on), the functionality described
        in the code snippet above is simply not possible using the C++11 inheriting-constructors
        feature.

        See Also
          • “override” on page 127 — Used to ensure that a member function intended to over-
            ride a virtual function actual does

          • “Deleted Functions” on page 70 — Can be used to exclude inherited constructors that
            are unwanted entirely

          • “Defaulted Functions” on page 58 — Used to implement functions that might otherwise
            have been suppressed by inherited constructors

          • “Delegating Ctors” on page 25 — Related feature used to call one constructor from
            another from within the same user-defined type

          • “Default Member Init” on page 221 — Useful in conjunction with this feature when a
            derived class adds member data
                                                                                                 45


i



    i                                                                                                  i
    i                                                                                                              i
                           “emcpps-internal” — 2021/1/16 — 3:34 — page 46 — #48

i



        Inheriting Ctors                                                       Chapter 1      Safe Features


           • “Forwarding References” on page 284 — Used in alternative (workaround) when access
             levels differ from those for base-class constructors
           • “Variadic Templates” on page 314 — Used in alternative (workaround) when access
             levels differ from those for base-class constructors
           • “Default Member Init” on page 221 — Can be used to provide nondefault values for
             data members in derived classes that make use of inheriting constructors

        Further Reading
        None so far

        Appendix: C++17 Improvements Made Retroactive to C++11/14
        The original specification of inheriting constructors in C++11 had a significant number
        of problems with general use. As originally specified, inherited constructors were treated
        as if they were redeclared in the derived class. For C++17, a significant rewording of this
        feature44 happened to instead find the base class constructors and then define how they
        are used to construct an instance of the derived class, as we have presented here. With a
        final fix in C++20 with the resolution of CWG issue #2356,45 a complete working feature
        was specified. All of these fixes for C++17 were accepted as defect reports and thus apply
        retroactively to C++11 and C++14. For the major compilers, this was either standardizing
        already existing practice or quickly adopting the changes.46
            The subsections that follow describe the subtle bugs that came with the previous spec-
        ification, both for completeness and to give a better understanding of what to expect on
        very old compilers, though none fully implemented the original specification as written.

        Inheriting constructors declared with a C-style ellipsis
        Forwarding arguments from a constructor declared using a C-style ellipsis cannot forward
        correctly. Arguments passed through the ellipsis are not available as named arguments but
        must instead be accessed through the va_arg family of macros. Without named arguments,
        no easily supported way is available to call the base-class constructor with the additional
        arguments:
          struct Base
          {
          Base(int x, ...) { }        // constructor taking C­style variadic args
          };

          struct Derived : Base
          {
          using Base::Base; // Error: Prior to C++17 fixes, standard wording
          // does not allow forwarding C­style variadic args.

          44 smith15b
          45 smith18
          46 For example, GCC versions above 7.0 and Clang versions above 4.0 all have the modern behavior fully

        implemented regardless of which standard version is chosen when compiling.
                                                           46


i



    i                                                                                                              i
    i                                                                                                    i
                     “emcpps-internal” — 2021/1/16 — 3:34 — page 47 — #49

i



        C++11                                                                         Inheriting Ctors


          };

        This problem is sidestepped in C++17 because the base-class constructor becomes available
        just like any other base-class function made available through a using declaration in the
        derived class.

        Inheriting constructors that rely on friendship to declare
        function parameters
        When a constructor depends on access to a private member of a class (e.g., a typedef),
        an inheriting constructor does not implicitly grant friendship that the base class might have
        that makes the constructor valid. For example, consider the following class template, which
        grants friendship to class B:
          template <typename T>
          struct S
          {
          private:
          typedef int X;
          friend struct B;
          };

        Then, we can create a class with a constructor that relies on that friendship. In this case,
        we consider a constructor template using the dependent member X, assuming that, in the
        normal case, X would be publicly accessible:
          struct B
          {
          template <typename T>
          B(T, typename T::X);
          };

        Now consider class D derived from B and inheriting its constructors:
          struct D : B
          {
          using B::B;
          };

        Without friendship, we cannot construct a D from an S, but we can construct a B from
        an S, suggesting something is wrong with the inheritance. Note that the SFINAE rules for
        templates mean that the inheriting constructor is a problem only if we try to construct an S
        with the problem type and does not cause a hard error without that use case. The following
        example illustrates the problematic usage:
          S<int> s;      // full specialization of S for type int
          B b(s, 2);     // OK, thanks to friendship
          D d(s, 2);     // Error: Prior to C++17 fixes, friendship is not inherited.

        As C++17 redefines the semantics of the inheriting constructor as if the base class’s con-
        structors were merely exposed in the derived one, friendship is evaluated within the scope
        of the base class.
                                                                                                   47


i



    i                                                                                                    i
    i                                                                                                i
                           “emcpps-internal” — 2021/1/16 — 3:34 — page 48 — #50

i



        Inheriting Ctors                                             Chapter 1    Safe Features


        Inheriting constructor templates would be ill formed for a local class
        A class declared within a function is a local class. Local classes have many restrictions,
        one of which is that they cannot declare member templates. If we inherit constructors from
        a base class with constructor templates, even private ones, the implicit declaration of
        a constructor template to forward arguments to the base-class constructor would be ill
        formed:
         struct Base
         {
         template <typename T>
         Base(T);
         };

         void f()
         {
         class Local : Base
         {
         using Base::Base; // Error: Prior to C++17 fixes, we cannot redeclare
         // the constructor template in local class.
         };
         }

        C++17 resolves this by directly exposing the base-class constructors, rather than defining
        new constructors to forward arguments.

        SFINAE evaluation context with default function arguments
        Constructors that employ SFINAE tricks in default function arguments perform SFINAE
        checks in the wrong context and therefore inherit ill-formed constructors. No such issues
        occur when these SFINAE tricks are performed on default template arguments instead. As
        an example, consider a class template Wrap that has a template constructor with a SFINAE
        constraint:
         struct S { };

         template <typename T>
         struct Wrap
         {
         template <typename U>
         Wrap(U, typename std::enable_if<
         std::is_constructible<T, U>::value>::type* = nullptr)
         // This constructor is enabled only if T is constructible from U.
         {
         std::cout << "SFINAE ctor\n";
         }

         Wrap(S)
         {
         std::cout << "S ctor\n";
         }
                                                    48


i



    i                                                                                                i
    i                                                                                                       i
                     “emcpps-internal” — 2021/1/16 — 3:34 — page 49 — #51

i



        C++11                                                                            Inheriting Ctors


          };

        If we derive from Wrap and inherit its constructors, we would expect the SFINAE constraint
        to behave exactly as in the base class, i.e., the template constructor overload would be silently
        discarded if std::is_constructible<T, U>::value evaluates to false:
          template <typename T>
          struct Derived : Wrap<T>
          {
          using Wrap<T>::Wrap;
          };

        However, prior to C++17’s retroactive fixes, SFINAE was triggered only for Wrap, not for
        Derived:
          void f()
          {
          S s;
          Wrap<int> w(s);        // prints "S ctor"
          Derived<int> d(s);     // error prior to fixes; prints "S ctor" afterward
          }


        Suppression of constructors in the presence of default arguments
        A constructor having one or more default arguments in the derived class does not suppress
        any corresponding constructors matching only the nondefaulted arguments in the base class,
        leading to ambiguities:
          struct B             // base class
          {
          B(int, int);    // value constructor with two (required) int parameters
          };

          struct D : B
          {
          using B::B;
          D(int, int, int = 0);      // doesn't suppress D(int, int) from B(int, int)
          };

        In the code example above, the original defective behavior was that there would be two
        overloaded constructors in D; attempting to construct a D from two integers became ambigu-
        ous. In the corrected behavior, the inheriting D(int, int) from the base-class constructor
        B(int, int), whose domain is fully subsumed by the derived class’s explicitly specified
        constructor D(int, int, int = 0), is suppressed.

        Suprising behavior with unary constructor templates
        Because inherited constructors are redeclarations within the derived class and expect to
        forward properly to the corresponding base-class constructors, constructor templates may
        do very surprising things. In particular, a gregarious, templated constructor can appear
        to cause inheritance of a base-class copy constructor. Consider the following class with a
        constructor template:
                                                                                                      49


i



    i                                                                                                       i
    i                                                                                                           i
                           “emcpps-internal” — 2021/1/16 — 3:34 — page 50 — #52

i



        Inheriting Ctors                                                    Chapter 1      Safe Features


          struct A
          {
          A() = default;
          A(const A&) { std::cout << "copy\n"; }

          template <typename T>
          A(T) { std::cout << "convert\n"; }
          };

        This simple class can convert from any type and prints those of its constructors that were
        called. Now consider we want to make a strong typedef for A:
          struct B : A
          {
          using A::A; // inherited base class A's constructors
          };

        The problem is that because A can convert from anything, when B inherits A’s constructor
        template, B can then use the inherited constructor to construct an instance of B from A.
        Perhaps more surprising, because the definition of the inherited constructor in B is to ini-
        tialize the A subobject with its parameters, the nontemplate inherited constructor will be
        chosen as the best match, not the templated, converting constructor!47




          47 Note that if the template constructor for A were a copy or move constructor for A, then it would

        be excluded from being an inherited constructor and this odd behavior would be avoided. The by-value
        parameter of this constructor is also why "copy" is output twice in this example.
         A x;
         B y = x;   // Surprise! This compiles, and it prints "copy" twice!


                                                         50


i



    i                                                                                                           i
    i                                                                                                         i
                      “emcpps-internal” — 2021/1/16 — 3:34 — page 51 — #53

i



        C++11                                                                                   decltype




        Operator for Extracting Expression Types
        The keyword decltype enables the compile-time inspection of the declared type of an
        entity or the type and value category of an expression.48

        Description
        What results from the use of decltype depends on the nature of its operand.

        Use with (typically named) entities
        If the operand is an unparenthesized id-epression or unparenthesized member access,
        decltype yields the declared type (the type of the entity indicated by the operand):

          int i;                // decltype(i)           ­>   int
          std::string s;        // decltype(s)           ­>   std::string
          int* p;               // decltype(p)           ­>   int*
          const int& r = *p;    // decltype(r)           ­>   const int&
          struct { char c; } x; // decltype(x.c)         ­>   char
          double f();           // decltype(f)           ­>   double()
          double g(int);        // decltype(g)           ­>   double(int)


        Use with expressions (unnamed entities)
        When decltype is used with any other expression E of type T, including parenthesized id-
        expression or parenthesized member access, the result incorporates both the expression’s
        type and its value category (see Section 2.1.“rvalue References” on page 306):

                                 Value category of E     Result of decltype(E)
                                       prvalue                      T
                                        lvalue                     T\&
                                        xvalue                    T\&\&

        In general, prvalues can be passed to decltype in a number of ways, including numeric
        literals, function calls that return by value, and explicitly created temporaries:
          decltype(0);       // ­> int
          int f();
          decltype(f());     // ­> int
          struct S{};
          decltype(S());     // ­> S

        An entity name passed to decltype, as mentioned above, produces the type of the entity.
        If an entity name is enclosed in an additional set of (), however, decltype interprets its
        argument as an expression and its result incorporates the value category:


          48 Note that the special construct decltype(auto) has a separate meaning, see Section 3.2.“??” on

        page ??.
                                                                                                        51


i



    i                                                                                                         i
    i                                                                                                       i
                        “emcpps-internal” — 2021/1/16 — 3:34 — page 52 — #54

i



        decltype                                                          Chapter 1     Safe Features


          int i;
          decltype(i);       // ­> int
          decltype((i));      // ­> int&

        Similarly, the result of decltype will be an lvalue reference for other lvalue expressions:
          int* pi = &i;
          decltype(*pi); // ­> int&
          decltype(++i); // ­> int&

        Finally, the value category of the expression will be an xvalue if it is a cast to or a function
        returning an rvalue reference:
          int i;
          decltype(static_cast<int&&>(i));        // ­> int&&
          int&& g();
          decltype(g());                                // ­> int&&

        Much like the sizeof operator (which too is resolved at compile time), the expression
        operand to decltype is not evaluated:
          int i = 0;
          decltype(i++) j;     // equivalent to int j;
          assert(i == 0);      // The expression i++ was not evaluated.

        Note that the choice of using the post-fix increment is significant; the prefix increment
        defines a different type:
          int m = 1;
          decltype(++i) k = m; // equivalent to int& k = m;
          assert(i == 0); // The expression ++1 is not evaluated.



        Use Cases
        Avoiding unnecessary use of explicit typenames
        Consider two logically equivalent ways of declaring a vector of iterators into a list of Widgets:
          std::list<Widget> widgets;
          std::vector<std::list<Widget>::iterator> widgetIterators;
          // (1) The full type of widgets needs to be restated, and iterator
          // needs to be explicitly named.

          std::list<Widget> widgets;
          std::vector<decltype(widgets.begin())> widgetIterators;
          // (2) Neither std::list nor Widget nor iterator need be named
          // explicitly.

        Notice that, when using decltype, if the C++ type representing the widget changes (e.g.,
        from Widget to, say, ManagedWidget) or the container used changes (e.g., from std::list to
        std::vector), the declaration of widgetIterators need not necessarily change.
                                                       52


i



    i                                                                                                       i
    i                                                                                                                  i
                       “emcpps-internal” — 2021/1/16 — 3:34 — page 53 — #55

i



        C++11                                                                                           decltype


        Expressing type-consistency explicitly
        In some situations, repetition of explicit type names might inadvertently result in latent
        defects caused by mismatched types during maintenance. For example, consider a Packet
        class exposing a const member function that returns a std::uint8_t representing the length
        of the packet’s checksum:
          class Packet
          {
          // ...
          public:
          std::uint8_t checksumLength() const;
          };

        This unsigned 8-bit type was selected to minimize bandwidth usage as the checksum length is
        sent over the network. Next, picture a loop that computes the checksum of a Packet, using the
        same type for its iteration variable (to match the type returned by Packet::checksumLength):
          void f()
          {
          Checksum sum;
          Packet data;

          for (std::uint8_t i = 0; i < data.checksumLength(); ++i)                    // brittle
          {
          sum.appendByte(data.nthByte(i));
          }
          }

           Now suppose that, over time, the data transmitted by the Packet type grows to the point
        where the range of a std::uint8_t value might not be enough to ensure a suﬀiciently reli-
        able checksum. If the type returned by checksumLength() is changed to, say, std::uint16_t
        without updating the type of the iteration variable i in lockstep, the loop might silently49
        become infinite.50
           Had decltype(packet.checksumLength()) been used to express the type of i, the types
        would have remained consistent and the ensuing defect would naturally have been avoided:
          // ...
          for (decltype(data.checksumLength()) i = 0; i < data.checksumLength(); ++i)
          // ...


        Creating an auxiliary variable of generic type
        Consider the task of implementing a generic loggedSum function template that returns the
        sum of two arbitrary objects a and b after logging both the operands and the result value
           49 As of this writing, neither GCC 9.3 nor Clang 10.0.0 provide a warning (using ­Wall, ­Wextra, and

        ­Wpedantic) for the comparison between std::uint8_t and std::uint16_t — even if both (1) the
        value returned by checksumLength does not fit in a 8-bit integer and (2) the body of the function is visible
        to the compiler. Decorating checksumLength with constexpr causes clang++ to issue a warning, but
        this is clearly not a general solution.
           50 The loop variable is promoted to an unsigned int for comparison purposes but wraps (to 0) whenever

        its value prior to being incremented is 255.
                                                                                                                 53


i



    i                                                                                                                  i
    i                                                                                                              i
                         “emcpps-internal” — 2021/1/16 — 3:34 — page 54 — #56

i



        decltype                                                               Chapter 1      Safe Features


        (e.g., for debugging or monitoring purposes). To avoid computing the (possibly expensive)
        sum twice, we decide to create an auxiliary function-scope variable, result. Since the type
        of the sum depends on both a and b, we can use decltype(a + b) to infer the type for both
        the (trailing) return type51 of the function (see Section 1.1.“Trailing Return” on page 144)
        and the auxiliary variable:
          template <typename A, typename B>
          auto loggedSum(const A& a, const B& b)
          ­> decltype(a + b)                 // (1) exploiting trailing return types
          {
          decltype(a + b) result = a + b;    // (2) auxiliary generic variable
          LOG_TRACE << a << " + " << b << " = " << result;
          return result;
          }

        Note that this particular use involves significant repetition of the expression a+b. See Annoyances —
        Mechanical repetition of expressions might be required on page 56 for a discussion of ways
        in which this might be avoided.

        Determining the validity of a generic expression
        In the context of generic-library development, decltype can be used in conjunction with
        SFINAE52 to validate an expression involving a template parameter.
           For example, consider the task of writing a generic sortRange function template that,
        given a range, invokes either the sort member function of the argument (the one specifically
        optimized for that type) if it is available, or else falls back to the more general std::sort:
          template <typename Range>
          void sortRange(Range& range)
          {
          sortRangeImpl(range, 0);
          }

        The client-facing sortRange function (above) delegates its behavior to an overloaded sortRangeImpl
        function (below), invoking the latter with the range and a disambiguator of type int. The
        type of this additional parameter (its value is arbitrary) is used to give priority to the sort
        member function at compile time by exploiting overload resolution rules in the presence of
        an implicit (standard) conversion from int to long:
          template <typename Range>
          void sortRangeImpl(Range& range,
          long)                  // low priority: standard conversion
          {
          // fallback implementation
          std::sort(std::begin(range), std::end(range));
          }


          51 Using  decltype(a + b) as a return type is significantly different from relying on automatic return
        type deduction. See Section 2.1.“auto Variables” on page 217 for more information.
           52 “Substitution Failure Is Not An Error”

                                                           54


i



    i                                                                                                              i
    i                                                                                                                  i
                       “emcpps-internal” — 2021/1/16 — 3:34 — page 55 — #57

i



        C++11                                                                                           decltype


        The fallback overload of sortRangeImpl (above) will accept a long disambiguator, requiring
        a standard conversion from int, and will simply invoke std::sort. The more specialized
        overload of sortRangeImpl (below) will accept an int disambiguator requiring no conversions
        and thus will be a better match, provided a range-specific sort is available:
          template <typename Range>
          void sortRangeImpl(Range& range,
          int,                          // high priority: exact match
          decltype(range.sort())* = 0) // check expression validity
          {
          // optimized implementation
          range.sort();
          }

        Note that, by exposing53 decltype(range.sort()) as part of sortRangeImpl’s declaration,
        the more specialized overload will be discarded during template substitution if range.sort()
        is not a valid expression for the deduced Range type.54
            Putting it all together, we see that exactly two possible outcomes exist for the original
        client-facing sortRange function invoked with a range argument of type R:

           • If R does have a sort member function, the more specialized overload (of
             sortRangeImpl) will be viable (as range.sort() is a well-formed expression) and pre-
             ferred because the disambiguator 0 (of type int) requires no conversion.
           • Otherwise, the more specialized overload will be discarded during template substitu-
             tion (as range.sort() is not a well-formed expression) and the only remaining (more
             general) sortRangeImpl overload will be chosen instead.

        Potential pitfalls
        Perhaps surprisingly, decltype(x) and decltype((x)) will sometimes yield different results
        for the same expression x:
           53 The relative position of decltype(range.sort()) in the signature of sortRangeImpl is not sig-

        nificant, as long as it is visible to the compiler during template substitution. The example shown in the
        main text makes use of a function parameter that is defaulted to nullptr. Alternatives involving a trailing
        return type or a default template argument are also viable:
          template <typename Range>
          auto sortRangeImpl(Range& range, int) ­> decltype(range.sort(), void());
          // The comma operator is used to force the return type to void,
          // regardless of the return type of range.sort().

          template <typename Range, typename = decltype(std::declval<Range&>().sort())>
          auto sortRangeImpl(Range& range, int) ­> void;
          // std::declval is used to generate a reference to Range that can
          // be used in an unevaluated expression.


           54 The technique of exposing a (possibly unused) unevaluated expression (e.g., using decltype) in a

        function’s declaration for the purpose of expression-validity detection prior to template instantiation is
        commonly known as expression SFINAE, is a restricted form of the more general (classical) SFINAE,
        and acts exclusively on expressions visible in a function’s signature rather than on often obscure template-
        based type computations.
                                                                                                                 55


i



    i                                                                                                                  i
    i                                                                                                    i
                       “emcpps-internal” — 2021/1/16 — 3:34 — page 56 — #58

i



        decltype                                                        Chapter 1    Safe Features


          int i = 0; // decltype(i) yields int.
          // decltype((i)) yields int&.

        In the case where the unparenthesized operand is an entity having a declared type T and the
        parenthesized operand is an expression whose value category is represented (by decltype)
        as the same type T, the results will coincidentally be the same:
          int& ref = i; // decltype(ref) yields int&.
          // decltype((ref)) yields int&.

        Wrapping its operand with parentheses ensures decltype yields the value category of
        a given expression. This technique can be useful in the context of metaprogramming —
        particularly in the case of value category propagation.

        Annoyances
        Mechanical repetition of expressions might be required
        As mentioned in Use Cases — Creating an auxiliary variable of generic type on page 53,
        using decltype to capture a value of an expression that is about to be used, or for the return
        value of an expression, can often lead to repeating the same expression in multiple places
        (3 distinct ones in the earlier example).
            An alternate solution to this problem is to capture the result of the decltype expression
        in a typedef, using type alias, or as a defaulted template parameter — but that runs into
        the problem that it can only be used once the expression is valid. A defaulted template
        parameter cannot reference parameter names as it is written before them, and a type alias
        cannot be introduced prior to the return type being needed. A solution to this problem lies
        in using standard library function std::declval to create expressions of the appropriate
        type without needing to reference the actual function parameters by name:
          template <typename A, typename B,
          typename Result = decltype(std::declval<const A&>() +
          std::declval<const B&>())>
          Result loggedSum(const A& a, const B& b)
          {
          Result result = a + b; // No duplication of the decltype expression
          LOG_TRACE << a << " + " << b << "=" << result;
          return result;
          }

            Here, std::declval, a function that cannot be executed at runtime and is only appropri-
        ate for use in unevaluated contexts, produces an expression of the specified type. When
        mixed with decltype this lets us determine the result types for expressions without needing
        to construct (or even to be able to construct) objects of the needed types.

        See Also
          • “rvalue References” (Section 2.1, p. 306) ♦ NEEDS VERBIAGE
          • “using Aliases” (Section 1.1, p. 152) ♦ NEEDS VERBIAGE
          • “auto Variables” (Section 2.1, p. 217) ♦ NEEDS VERBIAGE
                                                      56


i



    i                                                                                                    i
    i                                                                                   i
                      “emcpps-internal” — 2021/1/16 — 3:34 — page 57 — #59

i



        C++11                                                                decltype


          • “??” (Section 3.2, p. ??) ♦ NEEDS VERBIAGE

        Further reading
        None so far




                                                                                   57


i



    i                                                                                   i
    i                                                                                                                   i
                          “emcpps-internal” — 2021/1/16 — 3:34 — page 58 — #60

i



        Defaulted Functions                                                       Chapter 1       Safe Features



        Using =default for Special Member Functions
        Use of = default in a special member function’s declaration instructs the compiler to
        attempt generating the function automatically.

        Description
        Intrinsic to the design of C++ classes is the understanding that the compiler will attempt
        to generate certain member functions pertaining to creating, copying, destroying, and now
        moving (see Section 2, “rvalue References”) an object unless developers intercede by im-
        plementing some or all of these functions themselves. Determining which of the special
        member functions will continue to be generated and which will be suppressed in the
        presence of other user-provided special member functions requires remembering the
        same rules the compiler uses.

        Declaring a special member function explicitly
        The rules specifying what happens in the presence of one or more user-provided special
        member functions are inherently complex and not necessarily intuitive; in fact, some are
        already deprecated.55 Here, we will briefly illustrate a few common cases and then refer you
        to Howard Hinnant’s now famous table (see page 69 of Appendix: Implicit Generation of
        Special Member Functions) to demystify what’s going on under the hood.
        Example 1: Providing just the default constructor                     Consider a struct with a user-
        provided default constructor:
          struct S1
          {
          S1(); // user­provided default constructor
          };

        A user-provided default constructor has no effect on other special member functions. Pro-
        viding any other constructor, however, will suppress automatic declaration56 of the default
        constructor. We can, however, use = default to restore the constructor as a trivial oper-
        ation; see Use Cases: Restoring the generation of a special member function suppressed by
        another on page 61.
        Example 2: Providing just a copy constructor                    Now, consider a struct with a user-
        provided copy constructor:
          struct S2

           55 Even in the presence of a user-provided destructor, both the copy constructor and copy-assignment op-

        erator have historically been generated implicitly. Relying on such generated behavior is not recommended
        because it is unlikely that a class requiring a user-provided destructor will function correctly without cor-
        responding user-provided copy operations. As of C++11, reliance on such dubious implicitly generated
        behavior is deprecated.
           56 A nondeclared function is nonexistent, which means that it will not participate in overload resolution

        at all. In contrast, a deleted function participates in overload resolution and, if selected, results in a
        compilation failure; see Section 1, “Deleted Functions.”
                                                             58


i



    i                                                                                                                   i
    i                                                                                                                i
                       “emcpps-internal” — 2021/1/16 — 3:34 — page 59 — #61

i



        C++11                                                                               Defaulted Functions


          {
          S2(const S2&);       // user­provided copy constructor
          };

        A user-provided copy constructor (1) suppresses the declaration of the default constructor
        and both move operations and (2) allows implicit generation of both the copy-assignment
        operator and the destructor. Similarly, providing just the copy-assignment operator would
        allow the compiler to implicitly generate both the copy constructor and the destructor,
        but, in this case, it would also generate the default constructor (see S6 in the example.h
        code snippet on page 60). Note that — in either of these cases — relying on the compiler’s
        implicitly generated copy operation is deprecated.
        Example 3: Providing just the destructor                 Finally, consider a struct with a user-
        provided destructor:
          struct S3
          {
          ~S3(); // user­provided destructor
          };

        A user-provided destructor suppresses the declaration of move operations but still allows
        copy operations to be generated. Again, relying on either of these (implicitly) compiler-
        generated copy operations is deprecated.
        Example 4: Providing more than one special member function When more than
        one special member function is declared explicitly, the union of their respective declaration
        suppressions and the intersection of their respective implicit generations pertain — e.g., if
        just the default constructor and destructor are provided (S1 + S3 in Examples 1 and 3),
        then the declarations of both move operations are suppressed and both copy operations are
        generated implicitly.

        Defaulting the first declaration of a special member function explicitly
        Using the = default syntax with the first declaration of a special member function instructs
        the compiler to synthesize such a function automatically (if possible) without treating it as
        being user provided.57
            For example, consider struct S4 (in the code snippet below) in which we have chosen
        to make explicit that the copy operations are to be autogenerated by the compiler; note,
        in particular, that implicit declaration and generation of each of the other special member
        functions is left unaffected.
          struct S4
          {
          S4(const S4&) = default;                        // copy constructor
          S4& operator=(const S4&) = default;             // copy­assignment operator


          57 The compiler-generated version for a special member function is required to call the corresponding

        special member functions on (1) every base class in base-class-declaration order and then (2) every data
        member of the encapsulating type in declaration order (regardless of any access specifiers). Note that the
        destructor calls will be in exactly the opposite order of the other special-member-function calls.
                                                                                                               59


i



    i                                                                                                                i
    i                                                                                                    i
                       “emcpps-internal” — 2021/1/16 — 3:34 — page 60 — #62

i



        Defaulted Functions                                             Chapter 1    Safe Features


          // has no effect on other other four special member functions, i.e.,
          // implicitly generates the default constructor, the destructor,
          // the move constructor, and the move­assignment operator
          };

        A defaulted declaration may appear with any access specifier — i.e., private,
        protected, or public — and, hence, access to that generated function will be regulated
        accordingly:
          struct S5
          {
          private:
          S5(const S5&) = default;                  // private copy constructor
          S5& operator=(const S1&) = default;       // private copy­assignment operator

          protected:
          ~S5() = default;                          // protected destructor

          public:
          S5() = default;                          // public default constructor
          };

        In the example above, copy operations exist for use by member and friend functions only.
        Declaring the destructor protected or private limits which functions can create automatic
        variables of the specified type to those functions with the appropriately privileged access to
        the class. Declaring the default constructor public is necessary to avoid its declaration’s
        being suppressed by another constructor (e.g., the private copy constructor in the code
        snippet above) or any move operation.
            In short, use of = default on first declaration denotes that a special member function is
        intended to be generated by the compiler — irrespective of any user-provided declarations;
        in conjunction with = delete (see Section 1, “Deleted Functions”), use of = default affords
        the fine-grained control over which special member functions are to be generated and/or
        made publicly available.

        Defaulting the implementation of a user-provided special member func-
        tion
        The = default syntax can also be used after the first declaration, but with a distinctly
        different meaning: The compiler will treat the first declaration as a user-provided spe-
        cial member function and thus will suppress the generation of other special member
        functions accordingly.
          // example.h

          struct S6
          {
          S6& operator=(const S6&);      // user­provided copy­assignment operator

          // suppresses the declaration of both move operations
          // implicitly generates the default and copy constructors, and destructor
                                                      60


i



    i                                                                                                    i
    i                                                                                                     i
                     “emcpps-internal” — 2021/1/16 — 3:34 — page 61 — #63

i



        C++11                                                                      Defaulted Functions


          };

          inline S6& S6::operator=(const S6&) = default;
          // Explicitly request the compiler to generate the default implementation
          // for this copy­assignment operator. This request might fail (e.g., if S6
          // were to contain a non­copyable­assignable data member).

        Alternatively, an explicitly defaulted non-inline implementation of this copy-assignment op-
        erator may appear in a separate (.cpp) file; see Use Cases: Physically decoupling the interface
        from the implementation on page 66.

        Use Cases
        Restoring the generation of a special member function suppressed by an-
        other
        Incorporating = default in the declaration of a special member function instructs the
        compiler to generate its definition regardless of any other user-provided special member
        functions. As an example, consider a value-semantic SecureToken class that wraps a
        standard string (std::string) and an arbitrary-precision-integer (BigInt) token code that
        satisfy certain invariants:
          class SecureToken
          {
          std::string d_value;     // The default­constructed value is the empty string.
          BigInt d_code;           // The default­constructed value is the integer zero.

          public:
          // All six special member functions are (implicitly) defaulted.

          void setValue(const char* value);
          const char* value() const;
          BigInt code() const;
          };

        By default, a secure token’s value will be the empty-string value and the token’s code
        will be the numerical value of zero (because those are, respectively, the default initialized
        values of the two data members, d_value and d_tokenCode):
          void f()
          {
          SecureToken token;                             // default constructed         (1)
          assert(token.value() == std::string());        // default value: empty string (2)
          assert(token.code() == BigInt());              // default value: zero         (3)
          }

        Now suppose that we get a request to add a value constructor that creates and initializes
        a SecureToken from a specified token string:
          class SecureToken
          {
          std::string d_value;     // The default­constructed value is the empty string.
                                                                                                    61


i



    i                                                                                                     i
    i                                                                                                 i
                       “emcpps-internal” — 2021/1/16 — 3:34 — page 62 — #64

i



        Defaulted Functions                                           Chapter 1    Safe Features


         BigInt d_tokenCode;      // The default­constructed value is the integer zero.

         public:
         SecureToken(const char* value);      // newly added value constructor

         // suppresses the declaration of just the default constructor ­­­ i.e.,
         // implicitly generates all of the other five special member functions

         void setValue(const char* value);
         const char* value() const;
         const BigInt& code() const;
         };

        Attempting to compile function f (from page 61) would now fail on the first line, where
        it attempts to default-construct the token. Using the = default feature, however, we can
        reinstate the default constructor to work trivially, just as it did before:
         class SecureToken
         {
         std::string d_value;     // The default­constructed value is the empty string.
         BigInt d_code;           // The default­constructed value is the integer zero.

         public:
         SecureToken() = default;             // newly defaulted default constructor
         SecureToken(const char *value);      // newly added value constructor

         // implicitly generates all of the other five special member functions

         void setValue(const char *value);
         const char *value() const;
         const BigInt& code() const;
         };


        Making class APIs explicit at no runtime cost
        In the early days of C++, coding standards sometimes required that each special member
        function be declared explicitly so that it could be documented or even just to know that it
        hadn’t been forgotten:
         class C1
         {
         // ...

         public:
         C1();
         // Create an empty object.

         C1(const C1& rhs);
         // Create an object having the same value as the specified rhs object.

                                                    62


i



    i                                                                                                 i
    i                                                                                                   i
                     “emcpps-internal” — 2021/1/16 — 3:34 — page 63 — #65

i



        C++11                                                                     Defaulted Functions


          ~C1();
          // Destroy this object.

          C1& operator=(const C1& rhs);
          // Assign to this object the value of the specified rhs object.
          };

        Over time, explicitly writing out what the compiler could do more reliably itself became more
        clearly an ineﬀicient use of developer time. What’s more, even if the function definition
        was empty, implementing it explicitly often had performance implications over allowing
        implementations to provide a trivial default. Hence, such standards tended to evolve toward
        conventionally commenting out (e.g., using //!) the declarations of a function having an
        empty body rather than providing it explicitly:
          class C2
          a{
          // ...

          public:
          //! C2();
          // Create an empty object.

          //! C2(const C2& rhs);
          // Create an object having the same value as the specified rhs object.

          //! ~C2();
          // Destroy this object.

          //! C2& operator=(const C2& rhs);
          // Assign to this object the value of the specified rhs object.
          };

        Note, however, that the compiler does not check the commented code, which is easily suscep-
        tible to copy-paste and other errors. By uncommenting the code and defaulting it explicitly
        in class scope, we regain the compiler’s syntactic checking of the function signatures with-
        out incurring the cost of turning what would have been trivial (i.e., compiler-generated)
        functions into equivalent non-trivial ones:
          class C3
          {
          // ...

          public:
          C3() = default;
          // Create an empty object.

          C3(const C3& rhs) = default;
          // Create an object having the same value as the specified rhs object.

          ~C3() = default;
                                                                                                  63


i



    i                                                                                                   i
    i                                                                                                                    i
                          “emcpps-internal” — 2021/1/16 — 3:34 — page 64 — #66

i



        Defaulted Functions                                                        Chapter 1       Safe Features


          // Destroy this object.

          C3& operator=(const C3& rhs) = default;
          // Assign to this object the value of the specified rhs object.
          };


        Preserving trivial copyability
        In some situations, a particular type must be usable with std::memcpy (e.g., runtime perfor-
        mance, serialization to binary, or interoperability with C code). Only trivially copyable
        types are safe to use with std::memcpy; use with any other types results in undefined
        behavior. A type T is trivially copyable if it exposes a trivial copy constructor:
           1. the copy constructor for T is not user provided
           2. the type T itself has no virtual member functions or virtual base classes
           3. any member or base class of T is itself trivially copyable (recursively).
            As an example, the EntityHandle class (in the code snippet below) represents an integer
        handle (to an entity of opaque type) that must be usable with std::memcpy for the purpose
        of eﬀicient serialization (the capacity of the encapsulated fundamental integral type is subject
        to change)58 :
          class EntityHandle
          {
          short int d_id; // Note: Implementation size may increase over time.

          public:
          EntityHandle(int id);          // value constructor

          // suppresses the declaration of just the default constructor ­­­ i.e.,
          // implicitly generates all of the other five special member functions

          // ...
          }

        The presence of any other constructor, except a move constructor, never affects implicit
        generation of a copy constructor, and short int (like all enumerated, pointer, and other
        fundamental types) is a trivial type, thus establishing the triviality of copying an Entity­
        Handle. Now imagine that, to monitor the places in the codebase where temporary entity
        handles are exchanged (with the goal of ultimately optimizing those), a user-provided move
        constructor is added59 :
          class EntityHandle
          {

          58 Objects of this type are sometimes said to hold “dumb data”; see lakos20, section 3.5.5, pp. 629–633.
          59 Note that a move constructor will be preferred over a copy constructor when the type category of the
        argument is an xvalue (i.e., expiring value) or prvalue (i.e., pure rvalue), which are the value categories to
        which a temporary can pertain. See Section 2, “rvalue References,” for more information.
                                                              64


i



    i                                                                                                                    i
    i                                                                                                      i
                     “emcpps-internal” — 2021/1/16 — 3:34 — page 65 — #67

i



        C++11                                                                       Defaulted Functions


          short int d_id;     // Note: Implementation size may increase over time.

          public:
          EntityHandle(int id);                    // value constructor
          EntityHandle(EntityHandle&& rhs);        // user­provided move constructor

          // implicitly generates only the destructor
          // suppresses synthesis of all four other special member functions

          // ...
          };

        As illustrated by Table 2 on page 69, the presence of a user-provided move constructor sup-
        pressed the automatic generation of a copy constructor along with the destructor and both
        the copy- and move-assignment operators, thereby rendering the EntityHandle unusable.
        Replacing these four previously generated functions with seemingly equivalent user-provided
        ones might appear to work as intended:
          class EntityHandle
          {
          short int d_id; // Note: Implementation size may increase over time.

          public:
          EntityHandle(int id);      // value constructor

          EntityHandle(const EntityHandle& rhs);         // user­provided copy constructor
          EntityHandle(EntityHandle&& rhs);              // user­provided move constructor

          EntityHandle& operator=(const EntityHandle& rhs);
          // user­provided copy­assignment operator

          EntityHandle& operator=(EntityHandle&& rhs);
          // user­provided move­assignment operator

          // implicitly generates only the destructor
          // suppresses synthesis of the default constructor

          // ...
          };

        The user-provided nature of the copy constructor, however, renders the EntityHandle class
        ineligible for copy triviality — even if the definitions are identical! Hence, any direct use of
        std::memcpy with an EntityHandle object will result in undefined behavior. We could
        have instead explicitly requested that these four special member functions be generated
        using = default:
          class EntityHandle
          {
          short int d_id; // Note: Implementation size may increase over time.

                                                                                                     65


i



    i                                                                                                      i
    i                                                                                                                   i
                          “emcpps-internal” — 2021/1/16 — 3:34 — page 66 — #68

i



        Defaulted Functions                                                       Chapter 1       Safe Features


          public:
          EntityHandle(int id);         // value constructor

          EntityHandle(const EntityHandle& rhs) = default;
          // defaulted (trivial) copy constructor

          EntityHandle(EntityHandle&& rhs);
          // user­provided move constructor

          EntityHandle& operator=(const EntityHandle& rhs) = default;
          // default (trivial) copy­assignment operator

          EntityHandle& operator=(EntityHandle&& rhs);
          // user­provided move­assignment operator

          // Implicitly generates only the destructor.
          // suppresses synthesis of the default constructor

          // ...
          };

        By explicitly defaulting these three special member functions in class scope, we (1) re-enable
        their generation and (2) preserve the copy triviality of the class.

        Physically decoupling the interface from the implementation
        Sometimes, especially during large-scale development, avoiding compile-time coupling clients
        to the implementations of individual methods offers distinct maintenance advantages. Spec-
        ifying that a special member function is defaulted on its first declaration (i.e., in class scope)
        implies that making any change to this implementation will force all clients to recompile60 :
          // smallscale.h

          struct SmallScale
          {
          SmallScale() = default;          // explicitly defaulted default constructor
          };

        Alternatively, we can choose to declare the function but deliberately not default it in class
        scope (or anywhere in the .h file):
          // largescale.h

          struct LargeScale
          {
          LargeScale(); // user­provided default constructor
          };


          60 The issue here is not just compile time, per se, but compile-time coupling; see lakos20, section 3.10.5,

        pp. 783–789.
                                                             66


i



    i                                                                                                                   i
    i                                                                                                                      i
                        “emcpps-internal” — 2021/1/16 — 3:34 — page 67 — #69

i



        C++11                                                                                    Defaulted Functions


        We can then default just the (non-inline) implementation in a corresponding61 .cpp file:
          // largescale.cpp
          #include <largescale.h>

          LargeScale::LargeScale() = default;
          // Generate the default implementation for this default destructor.

        Using this insulation technique, we are free to change our minds and implement the de-
        fault constructor ourselves in any way we see fit without necessarily forcing our clients to
        recompile.

        Potential Pitfalls
        Generation of defaulted functions is not guaranteed
        Use of = default does not guarantee that the special member function of a type, T, will
        be generated. For example, a noncopyable member variable (or base class) of T will inhibit
        generation of T’s copy constructor even when = default is used. Such behavior can be
        observed in the presence of a std::unique_ptr62 data member:
          class Connection
          {
          private:
          std::unique_ptr<Impl> d_impl;             // noncopyable data member

          public:
          Connection() = default;
          Connection(const Connection&) = default;
          };

        Despite the defaulted copy constructor, Connection will not be copy-constructible as
        std::unique_ptr is a noncopyable type. Some compilers may produce a warning on the
        declaration of Connection(const Connection&), but they are not required to do so since
        the example code above is well formed and would produce a compilation failure only if an
        attempt were made to default-construct or copy Connection.63
            If desired, a possible way to ensure that a defaulted special member function has indeed
        been generated is to use static_assert (see Section 1, “static_assert”) in conjunction
           61 In practice, every .cpp file (other than the one containing main) typically has a unique associated header

        (.h) file and often vice versa (a.k.a., a component); see lakos20, sections 1.6 and 1.11, pages 209–216 and
        256–259, respectively.
           62 std::unique_ptr<T> is a move-only (movable but noncopyable) class template introduced in C++11. It

        models unique ownership over a dynamically allocated T instance, leveraging rvalue references (see Section 2,
        “rvalue References”) to represent ownership transfer between instances:
          int* p = new int(42);
          std::unique_ptr<int> up(p);                             // OK, take ownership of p.
          std::unique_ptr<int> upCopy = up;                       // compile­time error
          std::unique_ptr<int> upMove = std::move(up);            // OK, transfer ownership.


           63 Clang 8.x produces a diagnostic with no warning flags specified. GCC 8.x produces no warning, even

        with both ­Wall and ­Wextra enabled.
                                                                                                                     67


i



    i                                                                                                                      i
    i                                                                                                 i
                      “emcpps-internal” — 2021/1/16 — 3:34 — page 68 — #70

i



        Defaulted Functions                                          Chapter 1     Safe Features


        with an appropriate trait from the <type_traits> header:
         class IdCollection
         {
         std::vector<int> d_ids;

         public:
         IdCollection() = default;
         IdCollection(const IdCollection&) = default;
         // ...
         };

         static_assert(std::is_default_constructible<IdCollection>::value,
         "IdCollection must be default constructible.");

         static_assert(std::is_copy_constructible<IdCollection>::value,
         "IdCollection must be copy constructible.");

         // ...

        Routine use of such compile-time testing techniques can help to ensure that a type will
        continue to behave as expected (at no additional runtime cost) even when member (and
        base) types evolve as a result of ongoing software maintenance.

        See Also
          • Section 2, “rvalue References” — Conditionally Safe C++11 feature that is the foun-
            dation of move semantics — the move-constructor and move-assignment special
            member functions can be defaulted

          • Section 1, “Deleted Functions” — Safe C++11 feature that, among other use cases,
            allows the prevention of generation of special member functions, providing fine-grained
            control over the interface of a class if used in conjunction with = default

          • Section 1, “static_assert” — Safe C++11 feature that checks a predicate at compile
            time; useful to verify that a class’s special copy and move operations are available as
            expected

        Further Reading
          • Howard Hinnant, “Everything You Ever Wanted to Know About Move Semantics (and
            Then Some),” hinnant14

          • Howard Hinnant, “Everything You Ever Wanted to Know About Move Semantics,”
            hinnant16

        Appendix: Implicit Generation of Special Member Functions
        The rules a compiler uses to decide if a special member function should be generated im-
        plicitly are not entirely intuitive. Howard Hinnant, lead designer and author of the C++11
                                                    68


i



    i                                                                                                 i
    i                                                                                                               i
                         “emcpps-internal” — 2021/1/16 — 3:34 — page 69 — #71

i



        C++11                                                                               Defaulted Functions


        proposal for move semantics64 (among other proposals), produced a tabular representation
        of such rules in the situation where the user provides a single special member function and
        leaves the rest to the compiler. To understand Table 2, after picking a special member func-
        tion in the first column, the corresponding row will show what is implicitly generated by the
        compiler. (When selecting multiple rows, the intersection of the defaulted functions results.)

        Table 2: Implicit generation of special member functions. NEEDS A CREDIT LINE TO HIN-
        NANT.

                           Default       Destructor     Copy         Copy            Move          Move
                           Ctor                         Ctor         Assignment      Ctor          Assignment
            Nothing        Defaulted     Defaulted      Defaulted    Defaulted       Defaulted     Defaulted
            Any            Not           Defaulted      Defaulted    Defaulted       Defaulted     Defaulted
            Ctor           Declared
            Default        User          Defaulted      Defaulted    Defaulted       Defaulted     Defaulted
            Ctor           Declared
            Destructor     Defaulted     User           Defaulteda   Defaulteda      Not           Not
                                         Declared                                    Declared      Declared
            Copy           Not           Defaulted      User         Defaulteda      Not           Not
            Ctor           Declared                     Declared                     Declared      Declared
            Copy           Defaulted     Defaulted      Defaulteda   User            Not           Not
            Assignment                                               Declared        Declared      Declared
            Move           Not           Defaulted      Deleted      Deleted         User          Not
            Ctor           Declared                                                  Declared      Declared
            Move           Defaulted     Defaulted      Deleted      Deleted         Not           User
            Assignment                                                               Declared      Declared
        a   Deprecated behavior: compilers might warn upon reliance of this implicitly generated member function.



            As an example, explicitly declaring a copy-assignment operator would result in the default
        constructor, destructor, and copy constructor being defaulted and in the move operations
        not being declared. If more than one special member function is user declared (regardless
        of whether or how it is implemented), the remaining generated member functions are those
        in the intersection of the corresponding rows. For example, explicitly declaring both the
        destructor and the default constructor would still result in the copy constructor and the
        copy-assignment operator being defaulted and both move operations not being declared.
        Relying on the compiler-generated copy operations when the destructor is anything but
        defaulted is dubious; if correct, defaulting them explicitly makes both their existence and
        intended definition clear.




            64 hinnant02

                                                                                                               69


i



    i                                                                                                               i
    i                                                                                                    i
                       “emcpps-internal” — 2021/1/16 — 3:34 — page 70 — #72

i



        Deleted Functions                                               Chapter 1    Safe Features



        Using = delete for Arbitrary Functions
        Using = delete in a function’s first declaration forces a compilation error upon any attempt
        to use or access it.

        Description
        Declaring a particular function or function overload to result in a fatal diagnostic upon
        invocation can be useful — e.g., to suppress the generation of a special member function
        or to limit the types of arguments a particular overload set is able to accept. In such cases,
        = delete followed by a semicolon (;) can be used in place of the body of any function on
        first declaration only to force a compile-time error if any attempt is made to invoke it or
        take its address.
          void g(double) { }
          void g(int) = delete;

          void f()
          {
          g(3.14);   // OK, f(double) is invoked.
          g(0);      // Error, f(int) is deleted.
          }

        Notice that deleted functions participate in overload resolution and produce a compile-
        time error when selected as the best candidate.

        Use Cases
        Suppressing special member function generation
        When instantiating an object of user-defined type, special member functions that have
        not been declared explicitly are often generated automatically by the compiler. The gen-
        eration of individual special member functions can be affected by the existence of other
        user-defined special member functions or by limitations imposed by the specific types of any
        data members or base types; see Section 1.1.“Defaulted Functions” on page 58. For certain
        kinds of types, the notion of copy semantics including move semantics is not mean-
        ingful, and hence permitting the generation of copy operations is contraindicated. The two
        special member functions controlling move operations, introduced in C++11, are some-
        times implemented as effective optimizations of copy operations and much less frequently
        with copy operations explicitly deleted; see Section 2.1.“rvalue References” on page 306.
            Consider a class, FileHandle, that uses the RAII idiom to safely acquire and release an
        I/O stream. As copy semantics are typically not meaningful for such resources, we will
        want to suppress generation of both the copy constructor and copy assignment opera-
        tor. Prior to C++11, there was no direct way to express suppression of special functions
        in C++. The commonly recommended workaround was to declare the two methods private
        and leave them unimplemented, typically resulting in a compile-time or link-time error when
        accessed:
                                                      70


i



    i                                                                                                    i
    i                                                                                                   i
                     “emcpps-internal” — 2021/1/16 — 3:34 — page 71 — #73

i



        C++11                                                                      Deleted Functions


          class FileHandle
          {
          private:
          // ...

          FileHandle(const FileHandle&);                  // not implemented
          FileHandle& operator=(const FileHandle&);       // not implemented

          public:
          explicit FileHandle(FILE* filePtr);
          ~FileHandle();

          // ...
          };

        Not implementing a special member function that is declared to be private ensures that
        there will be at least a link-time error in case that function is inadvertently accessed from
        within the implementation of the class itself. With the = delete syntax, we are able to (1)
        explicitly express our intention to make these special member functions unavailable, (2) do
        so directly in the public region of the class, and (3) enable clearer compiler diagnostics:
          class FileHandle
          {
          private:
          // ...
          // Declarations of copy constructor and copy assignment are now public.

          public:
          explicit FileHandle(FILE* filePtr);
          ~FileHandle();

          FileHandle(const FileHandle&) = delete;                    // make unavailable
          FileHandle& operator=(const FileHandle&) = delete;         // make unavailable

          // ...
          };

        Using the = delete syntax on declarations that are private results in error messages concern-
        ing privacy, not the use of deleted functions. Care must be exercised to make both changes
        when converting code from the old style to the new syntax.

        Preventing a particular implicit conversion
        Certain functions — especially those that take a char as an argument — are prone to
        inadvertent misuse. As a truly classic example, consider the C library function memset,
        which may be used to write the character * five times in a row, starting at a specified
        memory address, buf:
          #include <cstdio> // puts
          #include <cstring> // memset

                                                                                                  71


i



    i                                                                                                   i
    i                                                                                                 i
                       “emcpps-internal” — 2021/1/16 — 3:34 — page 72 — #74

i



        Deleted Functions                                               Chapter 1   Safe Features


         void f()
         {
         char buf[] = "Hello World!";
         memset(buf, 5, '*'); // undefined behavior: buffer overflow
         puts(buf);            // expected output: "***** World!"
         }

        Sadly, inadvertently reversing the order of the last two arguments is a commonly recurring
        error, and the C language provides no help. As shown above, memset writes the nonprinting
        character 5 (e.g., the integer value of ASCII '*') 42 times — way past the end of buf. In
        C++, we can target such observed misuse using an extra deleted overload:
         #include <cstring> // memset
         void* memset(void* str, int ch, size_t n);            // standard library function
         void* memset(void* str, int n, char) = delete;        // defense against misuse

        Pernicious user errors can now be reported during compilation:
         // ...
         memset(buf, 5, '*');     // Error, memset(void, int, char) is deleted.
         // ...


        Preventing all implicit conversions
        The ByteStream::send member function below is designed to work with 8-bit unsigned
        integers only. Providing a deleted overload accepting an int forces a caller to ensure that
        the argument is always of the appropriate type:
         class ByteStream
         {
         public:
         void send(unsigned char byte) { /* ... */ }
         void send(int) = delete;

         // ...
         };

         void f()
         {
         ByteStream stream;
         stream.send(0);    //   Error,   send(int) is deleted.         (1)
         stream.send('a'); //    Error,   send(int) is deleted.         (2)
         stream.send(0L); //     Error,   ambiguous                     (3)
         stream.send(0U); //     Error,   ambiguous                     (4)
         stream.send(0.0); //    Error,   ambiguous                     (5)
         stream.send(
         static_cast<unsigned    char>(100));   // OK             (6)
         }

        Invoking send with an int (noted with (1) in the code above) or any integral type (other
        than unsigned char) that promotes to int (2) will map exclusively to the deleted send(int)
                                                    72


i



    i                                                                                                 i
    i                                                                                                                i
                       “emcpps-internal” — 2021/1/16 — 3:34 — page 73 — #75

i



        C++11                                                                                 Deleted Functions


        overload; all other integral (3 and 4) and floating-point types (5) are convertible to both
        via a standard conversion and hence will be ambiguous. Note that implicitly converting
        from unsigned char to either a long or unsigned integer involves a standard conversion
        (not just an integral promotion), the same as converting to a double. An explicit cast to
        unsigned char (6) can always be pressed into service if needed.

        Hiding a structural (nonpolymorphic) base class’s member function
        It is commonly advised to avoid deriving publicly from concrete classes because by doing
        so, we do not hide the underlying capabilities, which can easily be accessed (potentially
        breaking any invariants the derived class may want to keep) via assignment to a pointer
        or reference to a base class, with no casting required. Worse, inadvertently passing such
        a class to a function taking the base class by value will result in slicing, which can be
        especially problematic when the derived class holds data. A more robust approach would be
        to use layering or at least private inheritance.65 Best practices notwithstanding,66 it can be
        cost-effective in the short term to provide an elided “view” on a concrete class for trusted
        clients. Imagine a class AudioStream designed to play sounds and music that — in addition
        to providing basic “play” and “rewind” operations — sports a large, robust interface:
          struct AudioStream
          {
          void play();
          void rewind();
          // ...
          // ... (large, robust interface)
          // ...
          };

            Now suppose that, on short notice, we need to whip up a similar class,
        ForwardAudioStream,    to use with audio samples that cannot be rewound (e.g., coming di-
        rectly from a live feed). Realizing that we can readily reuse most of AudioStream’s interface,
        we pragmatically decide to prototype the new class simply by exploiting public structural
        inheritance and then deleting just the lone unwanted rewind member function:
          struct ForwardAudioStream : AudioStream
          {
          void rewind() = delete; // Make just this one function unavailable.
          };

          void f()
          {
          ForwardAudioStream stream = FMRadio::getStream();
          stream.play();   // fine
          stream.rewind(); // Error, rewind() is deleted.
          }


          65 For more on improving compositional designs at scale, see ?, sections 3.5.10.5 and 3.7.3, pp. 687–703
        and 726–727, respectively.
          66 See “Inheritance and Object-Oriented Programming,” Item 38, ?, pp. 132–135.

                                                                                                               73


i



    i                                                                                                                i
    i                                                                                                    i
                       “emcpps-internal” — 2021/1/16 — 3:34 — page 74 — #76

i



        Deleted Functions                                               Chapter 1    Safe Features


        If the need for a ForwardAudioStream type persists, we can always consider reimplementing it
        more carefully later.67 As discussed at the beginning of this section, the protection provided
        by this example is easily circumvented:
          AudioStream fullStream = stream;
          fullStream.play();   // OK
          fullStream.rewind(); // compiles OK, but what happens at run time?

        Hiding nonvirtual functions is something one undertakes only after attaining a complete
        understanding of what makes such an unorthodox endeavor safe; see, in particular, the
        appendix of Section 3.1.“??” on page ??.

        Potential Pitfalls


        Annoyances


        See Also
          • “Defaulted Functions” (Section 1.1, p. 58) ♦ Companion feature that enables de-
            faulting, as opposed to deleting, special member functions.
          • “rvalue References” (Section 2.1, p. 306) ♦ The two move variants of special mem-
            ber functions, which use rvalue references in their signatures, may also be subject to
            deletion.

        Further Reading
          • “Item 27” of ?




          67 ?

                                                      74


i



    i                                                                                                    i
    i                                                                                                                   i
                       “emcpps-internal” — 2021/1/16 — 3:34 — page 75 — #77

i



        C++11                                                                                explicit Operators




        Explicit Conversion Operators
        Ensure that a (user-defined) type is convertible to another type only in contexts where the
        conversion is made obvious in the code.

        Description
        Though sometimes desirable, implicit conversions achieved via (user-defined) conversion
        functions — either (1) converting constructors (accepting a single argument) or (2)
        conversion operators — can also be problematic, especially when the conversion involves
        a commonly used type (e.g., int or double)68 :
          class Point // implicitly convertible from an int or to a double
          {
          int d_x, d_y;

          public:
          Point(int x = 0, int y = 0); // default, conversion, & value constructor
          // ...
          operator double() const; // Return distance from origin as a double.
          };

        As ever, calling a function g that takes a Point but accidentally passing an int can lead to
        surprises:
          void g0(Point p);                 // arbitrary function taking a Point object by value
          void g1(const Point& p);          // arbitrary function taking a Point by const reference

          void f1(int i)
          {
          g0(i); // oops, called g0 with Point(i, 0) by mistake
          g1(i); // oops, called g1 with Point(i, 0) by mistake
          }

        This problem could have been solved even in C++98 by declaring the constructor to be
        explicit:
          explicit Point(int x = 0, int y = 0);               // explicit converting constructor

        If the conversion is desired, it must now be specified explicitly:
          void f2(int i)
          {
          g0(i)               //   error: could not convert i from int to Point
          g1(i);              //   error: invalid initialization of reference type
          g0(Point(i));       //   OK
          g1(Point(i));       //   OK
          }
          68 Use of a conversion operator to calculate distance from the origin in this unrealistically simple Point
        example is for didactic purposes only. In practice, we would typically use a named function for this purpose;
        see Potential Pitfalls: Sometimes a named function is better on page 80.
                                                                                                                  75


i



    i                                                                                                                   i
    i                                                                                                                   i
                          “emcpps-internal” — 2021/1/16 — 3:34 — page 76 — #78

i



        explicit Operators                                                        Chapter 1       Safe Features


        The companion problem stemming from an implicit conversion operator, albeit less severe,
        remained:
          void h(double d);

          double f3(const P& p)
          {
          h(p);      // OK? Or maybe called h with a "hypotenuse" by mistake
          return p; // OK? Or maybe this is a mistake too.
          }

        As of C++11, we can now use the explicit specifier when declaring conversion opera-
        tors (as well as converting constructors), thereby forcing the client to request conversion
        explicitly — e.g., using direct initialization or static_cast):
          struct S0 { explicit operator int(); };

          void g()
          {
          S0 s0;
          int i = s0;                              //   error (copy initialization)
          double d = s0;                           //   error (copy initialization)
          int j = static_cast<int>(s0);            //   OK (static cast)
          if (s0) { }                              //   error (contextual conversion to bool)
          int k(s0);                               //   OK (direct initialization)
          double e(s0);                            //   error (direct initialization)
          }

        In contrast, had the conversion operator above not been declared to be explicit, all con-
        versions shown above would compile:
          struct S1 { /* implicit */ operator int(); };

          void f()
          {
          S1 s1;
          int i = s1;                              //   OK   (copy initialization)
          double d = s1;                           //   OK   (copy initialization)
          int j = static_cast<int>(s1);            //   OK   (static cast)
          if (s1) { }                              //   OK   (contextual conversion to bool)
          int k(s1);                               //   OK   (direct initialization)
          double e(s1);                            //   OK   (direct initialization)
          }

        Additionally, the notion of contextual convertibility to bool69 applicable to arguments
        of logical operations (e.g., &&, ||, and !) and conditions of most control-flow constructs
           69 Since the early days of C++, a common idiom to test for validity of an object has been to use it in a

        context where it can (implicitly) convert itself to a type whose value can be interpreted (contextually) as a
        boolean, with true implying validity (and false otherwise). Implicit conversion to bool (an integral type)
        was considered too dangerous, so the cumbersome safe-bool idiom was used instead, converting to a type
        that — while contextually convertible to bool — could not (by design) participate in any other operations.
        While making the conversion to bool (or const bool) explicit solves the safety issue, the benefit of the
                                                              76


i



    i                                                                                                                   i
    i                                                                                                                  i
                       “emcpps-internal” — 2021/1/16 — 3:34 — page 77 — #79

i



        C++11                                                                               explicit Operators


        (e.g., if, while) was extended in C++11 to admit explicit (user-defined) bool conversion
        operators (see Use Cases: Enabling contextual conversions to bool as a test for validity on
        page 77):
          struct S2 { explicit operator bool(); };

          void h()
          {
          S2 s2;
          int i = s2;                              //   error (copy initialization)
          double d = s2;                           //   error (copy initialization)
          int j = static_cast<int>(s2);            //   error (static cast)
          if (s2) { }                              //   OK (contextual conversion to bool)
          int k(s2);                               //   error (direct initialization)
          double fd(s2);                           //   error (direct initialization)
          }

        Prior to C++11, essentially the same effect as having an explicit operator bool() member
        was achieved (albeit far less conveniently) via the safe-bool idiom.

        Use Cases
        Enabling contextual conversions to bool as a test for validity
        Having a conventional test for validity that involves testing whether the object itself evalu-
        ates to true or false is an idiom that goes back to the origins of C++. The <iostream>
        library, for example, uses this idiom to determine if a given stream is valid:
          // C++03
          #include <iostream>         // std::ostream

          std::ostream& printTypeValue(std::ostream& stream, double value)
          {
          if (stream) // relies on an implicit conversion to bool
          {
          stream << "double(" << value << ')';
          }
          else
          {
          // ... (handle stream failure)
          }

          return stream;
          }

        Implementing the implicit conversion to bool was, however, problematic as the straight-
        forward approach of using a conversion operator could easily allow accidental misuse to
        idiom would be entirely lost if an explicit cast would have to be performed to test for validity. To address
        this, C++11 extends contextual conversion to bool for a given expression E to include an application of
        static_cast<const volatile bool> to E, thus enabling explicit conversion to bool to be used in lieu of the
        (now deprecated) safe-bool idiom; see sharpe13.
                                                                                                                 77


i



    i                                                                                                                  i
    i                                                                                                                  i
                         “emcpps-internal” — 2021/1/16 — 3:34 — page 78 — #80

i



        explicit Operators                                                       Chapter 1       Safe Features


        go undetected:
          class ostream
          {
          // ...

          /* implicit */ operator bool();            // hypothetical (bad) idea
          };

          int client(std::ostream& out)
          {
          // ...
          return out + 1; // likely a latent runtime bug: always returns 1 or 2
          }

        The classic workaround, the safe-bool idiom, was to return some obscure pointer
        type (e.g., pointer to member) that could not possibly be useful in any context other
        than one in which false and a null pointer-to-member value (e.g.,
        static_cast<(ostream*::operator bool)()>(0)) are treated equivalently.
            When implementing this idiom in a user-defined type ourselves, we need not go to such
        lengths to avoid inviting unintended use via an implicit conversion to bool. As discussed
        in Description on page 75, a conversion operator to type bool that is declared explicit
        continues to act as if it were implicit only in those places where we might want it to do
        so and nowhere else — i.e., exactly those places that enable contextual conversion to
        bool.70
            As a concrete example, consider a ConnectionHandle class that can be in either a valid
        or invalid state. For the user’s convenience and consistency with other proxy types (e.g.,
        raw pointers) that have a similar invalid state, representing the invalid (or null) state via
        an explicit conversion to bool might be desirable:
          struct ConnectionHandle
          {
          std::size_t maxThroughput() const;
          // Return the maximum throughput (in bytes) of the connection.

          explicit operator bool() const;
          // Return true if the handle is valid and false otherwise.
          };

        Instances of ConnectionHandle will convert to bool only where one might reasonably want
        them to do so, say, as the predicate of an if statement:
          int ping(const ConnectionHandle& handle)
          {
          if (handle) // OK (contextual conversion to bool)
          {
          // ...

          70 Note   that two consecutive ! operators can be used to synthesize a contextual conversion to bool
        — i.e., if X is an expression that is explicitly convertible to bool, then (!!(X)) will be (true) or (false)
        accordingly.
                                                             78


i



    i                                                                                                                  i
    i                                                                                                    i
                      “emcpps-internal” — 2021/1/16 — 3:34 — page 79 — #81

i



        C++11                                                                    explicit Operators


          return 0;   // success
          }

          std::cerr << "Invalid connection handle.\n";
          return ­1; // failure
          }


        Having an explicit conversion operator prevents unwanted conversions to bool that might
        otherwise happen inadvertently:

          bool hasEnoughThroughput(const ClientConnection& connection,
          const ResourceHandle&   handle)
          {
          return connection.throughput() <= handle; // Compilation error, thankfully
          //                                    ^~~~~~
          }


        After the relational operator (<=) in the example above, the programmer mistakenly wrote
        handle instead of handle.maxThroughput(). Fortunately the conversion operation of
        ResourceHandle was declared to be explicit and a compile-time error (thankfully) en-
        sued; if the conversion had been implicit, the example code above would have compiled,
        and, if executed, the very same source for the hasEnoughThroughput function would have
        silently exhibited well-defined but incorrect behavior.


        Potential Pitfalls
        Sometimes implicit conversion is indicated
        Implicit conversions to and from common arithmetic types, especially int, are generally ill
        advised given the likelihood of accidental misuse. However, sometimes implicit conversion
        is exactly what is needed. Such cases occur frequently with wrapper and proxy types that
        might need to interoperate with a large legacy codebase. Consider, for example, an initial
        implementation of memory allocators in which each constructor takes, as an optional trail-
        ing argument, a pointer to an abstract memory resource that itself provides pure virtual
        allocate and deallocate member functions. Later, we decide to move in the direction
        of the std::pmr (C++17) standard and wrap those pointers in classes that support addi-
        tional operations. Making such constructors on the wrapper explicit would force every client
        supplying an allocator to a container to rework their code (e.g., by using static_cast).
        An implicit conversion in this case is further justified because the likelihood of accidental
        spontaneous conversion to an Allocator is all but nonexistent.
            The same sort of stability argument favors implicit conversion for proxy types intended to
        be dropped in and used in existing codebases. If, for example, we wanted to provide a proxy
        for a writeable std::string that, say, also logged, we might want an implicit conversion to
        a std::string&& (perhaps using Section 3.1.“??” on page ??). In such cases, making the
        conversion explicit would entirely defeat the purpose of the proxy, which is to achieve new
        functionality with minimal effect on existing client code.
                                                                                                   79


i



    i                                                                                                    i
    i                                                                                                              i
                         “emcpps-internal” — 2021/1/16 — 3:34 — page 80 — #82

i



        explicit Operators                                                     Chapter 1      Safe Features


        Sometimes a named function is better
        Other kinds of overuses of even explicit conversion operators exist. Like any user-defined
        operator, when the operation being implemented is not somehow either canonical or ubiqui-
        tously idiomatic for that operator, expressing that operation by a named (i.e., non-operator)
        function is often better. Recall from Description on page 75 that we used a conversion op-
        erator of class Point to represent the distance from the origin. This example serves both
        to illustrate how conversion operators can be used and also how they probably should not
        be. Consider that (1) many mathematical operations on a 2-D integral point might return a
        double (e.g., magnitude, angle) and (2) we might want to represent the same information
        but in different units (e.g., angleInDegrees, angleInRadians).71
            Rather than employing any conversion operator (explicit or otherwise), consider in-
        stead providing a named function, which (1) is automatically explicit and (2) affords both
        flexibility (in writing) and clarity (in reading) for a variety of domain-specific functions —
        now and in the future — that might well have had overlapping return types:
          class Point // only explicitly convertible (and from only an int)
          {
          int d_x, d_y;

          public:
          explicit Point(int x = 0, int y = 0); // explicit converting constructor
          // ...
          double magnitude() const; // Return distance from origin as a double.
          };

        Note that defining nonprimitive functionality, like magnitude, in a separate utility at a
        higher level in the physical hierarchy might be better still.72

        Annoyances
        None so far

        See Also
        None so far

        Further Reading
        None so far




           71 Another valid design decision is returning an object of type Angle that captures the amplitude and

        provides named accessory to the different units (e.g., asDegrees, asRadians).
           72 For more on separating out nonprimitive functionality, see lakos20, sections 3.2.7–3.2.8, pp 529–

        552.
                                                           80


i



    i                                                                                                              i
    i                                                                                                              i
                       “emcpps-internal” — 2021/1/16 — 3:34 — page 81 — #83

i



        C++11                                                                              inline namespace




        Transparently Nested Namespaces
        An inline namespace is a nested namespace whose member entities closely behave as if
        they were declared directly within the enclosing namespace.

        Description
        To a first approximation, an inline namespace (e.g., v2 in the code snippet below) acts
        a lot like a conventional nested namespace (e.g., v1) followed by a using directive for that
        namespace in its enclosing namespace73 :
          // example.cpp
          namespace n
          {
          namespace v1 // conventional nested namespace followed by using directive
          {
          struct T { };    // nested type declaration (identified as ::n::v1::T)
          int d;           // ::n::v1::d at, e.g., 0x01a64e90
          }

          using namespace v1;         // import names T and d into namespace n
          }

          namespace n
          {
          inline namespace v2   // similar to being followed by using namespace v2
          {
          struct T { };     // nested type declaration (identified as ::n::v2::T)
          int d;            // ::n::v2::d at, e.g., 0x01a64e94
          }

          // using namespace v2;         // redundant when used with an inline namespace
          }

        Four subtle details distinguish these approaches:
          73 C++17   allows developers to concisely declare nested namespaces with shorthand notation:
         namespace a::b { /* ... */ }
         // is the same as
         namespace a { namespace b { /* ... */ } }

        C++20 expands on the above syntax by allowing the insertion of the inline keyword in front of any of the
        namespaces, except the first one:
         namespace a::inline b::inline c { /* ... */ }
         // is the same as
         namespace a { inline namespace b { inline namespace c { /* ... */ } } }

         inline namespace a::b { }      // error: cannot start with inline for compound namespace names
         namespace inline a::b { }      // error: inline at front of sequence explicitly disallowed


                                                                                                             81


i



    i                                                                                                              i
    i                                                                                                              i
                         “emcpps-internal” — 2021/1/16 — 3:34 — page 82 — #84

i



        inline namespace                                                       Chapter 1      Safe Features


           1. Name collisions with existing names behave differently due to differing name-lookup
              rules.
           2. Argument-dependent lookup (ADL) gives special treatment to inline names-
              paces.
           3. Template specializations can refer to the primary template in an inline namespace
              even if written in the enclosing namespace.
           4. Reopening namespaces might reopen an inline namespace.
        One important aspect that all forms of namespaces share, however, is that (1) nested sym-
        bolic names (e.g., n::v1::T) at the API level, (2) mangled names (e.g., _ZN1n2v11dE,
        _ZN1n2v21dE), and (3) assigned relocatable addresses (e.g., 0x01a64e90, 0x01a64e94) at
        the ABI level remain unaffected by the use of either inline or using or both.74 Note
        that a using directive immediately following an inline namespace is superfluous; name
        lookup will always consider names in inline namespaces before those imported by a using
        directive. Such a directive can, however, be used to import the contents of an inline name-
        space to some other namespace, albeit only in the conventional, using directive sense; see
        Annoyances: Only one namespace can contain any given inline namespace on page 106.
            More generally, each namespace has what is called its inline namespace set, which
        is the transitive closure of all inline namespaces within the namespace. All names in
        the inline namespace set are roughly intended to behave as if they are defined in the
        enclosing namespace. Conversely, each inline namespace has an enclosing namespace set
        that comprises all enclosing namespaces up to and including the first non-inline namespace.

        Loss of access to duplicate names in enclosing namespace
        When both a type and a variable are declared with the same name in the same scope, the
        variable name hides the type name — such behavior can be demonstrated by using the form
        of sizeof that accepts a nonparenthesized expression75 :
          struct A { double d; };          static_assert(sizeof( A) == 8, "");            // type
          // static_assert(sizeof           A == 8, ""); // ERROR!

          int A;                           static_assert(sizeof(       A) == 4, "");      // data
          static_assert(sizeof         A    == 4, ""); // OK

        Unless both type and variable entities are declared within the same scope, no preference is
        given to variable names; the name of an entity in an inner scope hides a like-named entity
        in an enclosing scope:
          void f()
          {

           74 Compiling source files containing, alternately, namespace n { inline namespace v { int d; } } and

        namespace n { namespace v { int d; } using namespace v }, will produce identical assembly. This can be
        seen with GCC by running g++ ­S <file>.cpp and viewing the contents of the generated <file>.s. Note
        that Compiler Explorer is another valuable tool for learning about what comes out the other end of a C++
        compiler: see https://godbolt.org/.
           75 The form of sizeof that accepts a type as its argument specifically requires parentheses.

                                                           82


i



    i                                                                                                              i
    i                                                                                                   i
                     “emcpps-internal” — 2021/1/16 — 3:34 — page 83 — #85

i



        C++11                                                                    inline namespace


          double B;                    static_assert(sizeof(B) == 8, ""); // variable
          {                            static_assert(sizeof(B) == 8, ""); // variable
          struct B { int d; };     static_assert(sizeof(B) == 4, ""); // type
          }                            static_assert(sizeof(B) == 8, ""); // variable
          }

        When an entity is declared in an enclosing namespace and another entity having the same
        name hides it in a lexically nested scope, then (apart from inline namespaces) access to a
        hidden element can generally be recovered by using scope resolution:
          struct C { double d; };     static_assert(sizeof(     C) == 8, "");

          void g()
          {                        static_assert(sizeof( C) == 8, ""); // type
          int C;               static_assert(sizeof( C) == 4, ""); // variable
          static_assert(sizeof(::C) == 8, ""); // type
          }                        static_assert(sizeof( C) == 8, ""); // type

        A conventional nested namespace behaves as one might expect:
          namespace outer
          {
          struct D { double d; }; static_assert(sizeof(              D) == 8, ""); // type

          namespace inner
          {                       static_assert(sizeof(        D) == 8, ""); // type
          int D;              static_assert(sizeof(        D) == 4, ""); // var
          }                       static_assert(sizeof(        D) == 8, ""); // type
          static_assert(sizeof(inner::D) == 4, ""); // var
          static_assert(sizeof(outer::D) == 8, ""); // type
          using namespace inner;//static_assert(sizeof(        D) == 0, ""); // ERROR
          static_assert(sizeof(inner::D) == 4, ""); // var
          static_assert(sizeof(outer::D) == 8, ""); // type
          }                           static_assert(sizeof(outer::D) == 8, ""); // type

        In the example above, the inner variable name, D, hides the outer type with the same name,
        starting from the point of D’s declaration in inner until inner is closed, after which the
        unqualified name D reverts back to the type in the outer namespace. Then, right after the
        subsequent using namespace inner; directive, the meaning of the unqualified name D in
        outer becomes ambiguous, shown here with a static_assert that is commented out; any
        attempt to refer to an unqualified D from here to the end of the scope of outer will fail
        to compile. The type entity declared as D in the outer namespace can, however, still be
        accessed — from inside or outside of the outer namespace, as shown in the example — via
        its qualified name, outer::D.
             If an inline namespace were used instead of a nested namespace followed by a using di-
        rective, however, the ability to recover by name the hidden entity in the enclosing namespace
        is lost. Unqualified name lookup considers the inline namespace set and the used namespace
        set simultaneously. Qualified name lookup first considers the inline namespace set, and
        then goes on to look into used namespaces. This means we can still refer to outer::D in the
        example above, but doing so would still be ambiguous if inner were an inline namespace.
                                                                                                  83


i



    i                                                                                                   i
    i                                                                                                     i
                       “emcpps-internal” — 2021/1/16 — 3:34 — page 84 — #86

i



        inline namespace                                                Chapter 1     Safe Features


        This subtle difference in behavior is a byproduct of the highly specific use case that moti-
        vated this feature and for which it was explicitly designed; see Use Cases: Link-safe ABI
        versioning on page 92.

        Argument-dependent–lookup interoperability across
        inline namespace boundaries
        Another important aspect of inline namespaces is that they allow ADL to work seam-
        lessly across inline namespace boundaries. Whenever unqualified function names are being
        resolved, a list of associated namespaces is built for each argument of the function. This list
        of associated namespaces comprises the namespace of the argument, its enclosing namespace
        set, plus the inline namespace set.
            Consider the case of a type, U, defined in an outer namespace, and a function, f(U),
        declared in an inner namespace nested within outer. A second type, V, is defined in the
        inner namespace, and a function, g, is declared, after the close of inner, in the outer
        namespace:
          namespace outer
          {
          struct U { };

          // inline                  // Uncommenting this line fixes the problem.
          namespace inner
          {
          void f(U) { }
          struct V { };
          }

          using namespace inner;     // If we inline inner, we don't need this line.

          void g(V) { };
          }

          void client()
          {
          f(outer::U());            // Error: f is not declared in this scope.
          g(outer::inner::V());     // Error: g is not declared in this scope.
          }

        In the example above, a client invoking f with an object of type outer::U fails to compile
        because f(outer::U) is declared in the nested inner namespace, which is not the same as
        declaring it in outer. Because ADL does not look into namespaces added with the using
        directive, ADL does not find the needed outer::inner::f function. Similarly, the type V,
        defined in namespace outer::inner, is not declared in the same namespace as the function
        g that operates on it. Hence, when g is invoked from within client on an object of type
        outer::inner::V, ADL again does not find the needed function outer::g(outer::V).
            Simply making the inner namespace inline solves both of these ADL-related prob-
        lems. All transitively nested inline namespaces — up to and including the most proximate
                                                      84


i



    i                                                                                                     i
    i                                                                                                    i
                     “emcpps-internal” — 2021/1/16 — 3:34 — page 85 — #87

i



        C++11                                                                     inline namespace


        non-inline enclosing namespace — are treated as one with respect to ADL.

        The ability to specialize templates declared in a nested inline namespace
        The third property that distinguishes inline namespaces from conventional ones, even when
        followed by a using directive, is the ability to specialize a class template defined within an
        inline namespace from within an enclosing one; this ability holds transitively up to and
        including the most proximate non-inline namespace:
          namespace out                           // proximate non­inline outer namespace
          {
          inline namespace in1               // first­level nested inline namespace
          {
          inline namespace in2           // second­level nested inline namespace
          {
          template <typename T>     // primary class template general definition
          struct S { };

          template <>               // class template *full* specialization
          struct S<char> { };
          }

          template <>                    // class template *full* specialization
          struct S<short> { };
          }

          template <>                        // class template *full* specialization
          struct S<int> { };
          }

          using namespace out;                    // conventional using directive

          template <>
          struct S<int> { };                      // error: cannot specialize from this scope

        Note that the conventional nested namespace out followed by a using directive in the
        enclosing namespace does not admit specialization from that outermost namespace, whereas
        all of the inline namespaces do. Function templates behave similarly except that — unlike
        class templates, whose definitions must reside entirely within the namespace in which they
        are declared — a function template can be declared within a nested namespace and then be
        defined from anywhere via a qualified name:
          namespace out                           // proximate non­inline outer namespace
          {
          inline namespace in1               // first­level nested inline namespace
          {
          template <typename T>          // function template declaration
          void f();

          template <>                    // function template (full) specialization
                                                                                                   85


i



    i                                                                                                    i
    i                                                                                                   i
                       “emcpps-internal” — 2021/1/16 — 3:34 — page 86 — #88

i



        inline namespace                                               Chapter 1     Safe Features


          void f<short>() { }
          }

          template <>                        // function template (full) specialization
          void f<int>() { }
          }

          template <typename T>                  // function template general definition
          void out::in1::f() { }

        An important takeaway from the examples above is that every template entity — be it class
        or function — must be declared in exactly one place within the collection of namespaces
        that comprise the inline namespace set. In particular, declaring a class template in a
        nested inline namespace and then subsequently defining it in a containing namespace is
        not possible because, unlike a function definition, a type definition cannot be placed into a
        namespace via name qualification alone:
          namespace outer
          {
          inline namespace inner
          {
          template <typename T> // class template declaration
          struct Z;              // (if defined, must be within same namespace)

          template <>               // class template full specialization
          struct Z<float> { };
          }

          template <typename T>         // inconsistent declaration (and definition)
          struct Z { };                 // Z is now ambiguous in namespace outer.

          const int i = sizeof(Z);      // Error: Reference to Z is ambiguous.

          template <>                   // attempted class template full specialization
          struct Z<double> { };         // Error: outer::Z or outer::inner::Z?
          }


        Reopening namespaces can reopen nested inline ones
        Another subtlety specific to inline namespaces is related to reopening namespaces. Con-
        sider a namespace outer that declares a nested namespace outer::m and an inline name-
        space inner that, in turn, declares a nested namespace outer:inner::m. In this case,
        subsequent attempts to reopen namespace m cause an ambiguity error:
          namespace outer
          {
          namespace m { }         // opens and closes ::outer::m

          inline namespace inner
          {
                                                     86


i



    i                                                                                                   i
    i                                                                                                               i
                       “emcpps-internal” — 2021/1/16 — 3:34 — page 87 — #89

i



        C++11                                                                             inline namespace


          namespace n { }       // opens and closes ::outer::inner::n
          namespace m { }       // opens and closes ::outer::inner::m
          }

          namespace n                // OK, reopens ::outer::inner::n
          {
          struct S { };         // defines ::outer::inner::n::S
          }

          namespace m                // error: namespace m is ambiguous
          {
          struct T { };         // with clang defines ::outer::m::T
          }
          }

          static_assert(std::is_same<outer::n::S, outer::inner::n::S>::value, "");

        In the code snippet above, no issue occurs with reopening outer::inner:n and no issue
        would have occurred with reopening outer::m but for the inner namespaces having been
        declared inline. When a new namespace declaration is encountered, a lookup determines
        if a matching namespace having that name appears anywhere in the inline namespace
        set of the current namespace. If the namespace is ambiguous, as is the case with m in the
        example above, one can get the surprising error shown.76 If a matching namespace is found
        unambiguously inside an inline namespace, n in this case, then it is that nested name-
        space that is reopened — here, ::outer::inner::n. The inner namespace is reopened even
        though the last declaration of n is not lexically scoped within inner. Notice that the defi-
        nition of S is perhaps surprisingly defining ::outer::inner::n::S, not ::outer::n::S.
        For more on what is not supported by this feature, see Annoyances: Inability to redeclare
        across namespaces impedes code factoring on page 103.

        Use Cases
        Facilitating API migration
        Getting a large codebase to promptly upgrade to a new version of a library in any sort of
        timely fashion can be challenging. As a simplistic illustration, imagine that we have just
        developed a new library, parselib, comprising a class template, Parser, and a function
        template, analyze, that takes a Parser object as its only argument:
          namespace parselib
          {
          template <typename T>

           76 Note that reopening already declared namespaces, such as m and n in the inner and outer example,

        is handled incorrectly on several popular platforms. Clang, for example, will perform a name lookup when
        encountering a new namespace declaration and give preference to the outermost namespace found, caus-
        ing the last declaration of m to reopen ::outer::m instead of being ambiguous. GCC, prior to version 8.1,
        will not perform name lookup and will place any nested namespace declarations directly within their en-
        closing namespace. This compiler defect causes the last declaration of m to reopen ::outer::m instead of
        ::outer::inner::m and the last declaration of n to open a new namespace, ::outer::n, instead of reopening
        ::outer::inner::n.
                                                                                                              87


i



    i                                                                                                               i
    i                                                                                                i
                      “emcpps-internal” — 2021/1/16 — 3:34 — page 88 — #90

i



        inline namespace                                             Chapter 1    Safe Features


         class Parser
         {
         // ...

         public:
         Parser();
         int parse(T* result, const char* input);
         // Load result from null­terminated input; return 0 (on
         // success) or nonzero (with no effect on result).
         };

         template <typename T>
         double analyze(const Parser<T>& parser);
         }

        To use our library, clients will need to specialize our Parser class directly within the
        parselib namespace:
         struct MyClass { /*...*/ };     // end­user­defined type

         namespace parselib // necessary to specialize Parser
         {
         template <>           // Create *full* specialization of class
         class Parser<MyClass> // Parser for user­type MyClass.
         {
         // ...

         public:
         Parser();
         int parse(MyClass* result, const char* input);
         // The *contract* for a specialization typically remains the same.
         };

         double analyze(const Parser<MyClass>& parser);
         };

        Typical client code will also look for the Parser class directly within the parselib name-
        space:
         void client()
         {
         MyClass result;
         parselib::Parser<MyClass> parser;

         int status = parser.parse(&result, "...( MyClass value )...");
         if (status != 0)
         {
         return;
         }

         double value = analyze(parser);
                                                    88


i



    i                                                                                                i
    i                                                                                                      i
                     “emcpps-internal” — 2021/1/16 — 3:34 — page 89 — #91

i



        C++11                                                                      inline namespace


          // ...
          }

        Note that invoking analyze on objects of some instantiated type of the Parser class tem-
        plate will rely on ADL to find the corresponding overload.
            We anticipate that our library’s API will evolve over time so we want to enhance the
        design of parselib accordingly. One of our goals is to somehow encourage clients to move
        essentially all at once, yet also to accommodate both the early adopters and the inevitable
        stragglers that make up a typical adoption curve. Our approach will be to create, within our
        outer parselib namespace, a nested inline namespace, v1, which will hold the current
        implementation of our library software:
          namespace parselib
          {
          inline namespace v1                  // Note our use of inline namespace here.
          {
          template <typename T>
          class Parser
          {
          // ...

          public:
          Parser();
          int parse(T* result, const char* input);
          // Load result from null­terminated input; return 0 (on
          // success) or nonzero (with no effect on result).
          };

          template <typename T>
          double analyze(const Parser<T>& parser);
          }
          }

        As suggested by the name v1, this namespace serves primarily as a mechanism to support
        library evolution through API and ABI versioning (see Use Cases: Link-safe ABI versioning
        on page 92 and Use Cases: Build modes and ABI link safety on page 96). The need to
        specialize class Parser and, independently, the reliance on ADL to find the free function
        template analyze require the use of inline namespaces, as opposed to a conventional
        namespace followed by a using directive.
            Note that, whenever a subsystem starts out directly in a first-level namespace and is sub-
        sequently moved to a second-level nested namespace for the purpose of versioning, declaring
        the inner namespace inline is the most reliable way to avoid inadvertently destabilizing ex-
        isting clients; see also Potential Pitfalls: Enabling selective using directives for short-named
        entities on page 99.
            Now suppose we decide to enhance parselib in a non–backwards-compatible manner,
        such that the signature of parse takes a second argument size of type std::size_t
        to allow parsing of non–null-terminated strings and to reduce the risk of buffer overruns.
        Instead of unilaterally removing all support for the previous version in the new release, we
        can instead create a second namespace, v2, containing the new implementation and then,
                                                                                                     89


i



    i                                                                                                      i
    i                                                                                                   i
                       “emcpps-internal” — 2021/1/16 — 3:34 — page 90 — #92

i



        inline namespace                                               Chapter 1     Safe Features


        at some point, make v2 the inline namespace instead of v1:
          #include <cstddef>    // std::size_t

          namespace parselib
          {
          namespace v1 // Notice that v1 is now just a nested namespace.
          {
          template <typename T>
          class Parser
          {
          // ...

          public:
          Parser();
          int parse(T* result, const char* input);
          // Load result from null­terminated input; return 0 (on
          // success) or nonzero (with no effect on result).
          };

          template <typename T>
          double analyze(const Parser<T>& parser);
          }

          inline namespace v2       // Notice that use of inline keyword has moved here.
          {
          template <typename T>
          class Parser
          {
          // ...

          public: // note incompatible change to Parser's essential API
          Parser();
          int parse(T* result, const char* input, std::size_t size);
          // Load result from input of specified size; return 0
          // on success) or nonzero (with no effect on result).
          };

          template <typename T>
          double analyze(const Parser<T>& parser);
          }
          }

        When we release this new version with v2 made inline, all existing clients that rely on the
        version supported directly on parselib will, by design, break when they go to recompile.
        At that point, each client will have two options. The first and easy one is to upgrade the
        code immediately by passing in the size of the input string (e.g., 23) along with the address
        of its first character:
          void client()
                                                     90


i



    i                                                                                                   i
    i                                                                                                        i
                      “emcpps-internal” — 2021/1/16 — 3:34 — page 91 — #93

i



        C++11                                                                        inline namespace


          {
          // ...
          int status = parser.parse(&result, "...( MyClass value )...", 23);
          // ...                                                      ^^^^ Look here!
          }

        The second and more diﬀicult option is to change all references to parselib to refer to the
        original version in v1 explicitly:
          namespace parselib
          {
          namespace v1 // specializations moved to nested namespace
          {
          template <>
          class Parser<MyClass1>
          {
          // ...

          public:
          Parser();
          int parse(MyClass1* result, const char* input);
          };

          double analyze(const Parser<MyClass1>& parser);
          }
          };

          void client1()
          {
          MyClass1 result;
          parselib::v1::Parser<MyClass1> parser;          // reference nested namespace v1

          int status = parser.parse(&result, "...( MyClass value )...");
          if (status != 0)
          {
          return;
          }

          double value = analyze(parser);
          // ...
          }

        Providing the updated version in a new inline namespace v2 provides a more flexible mi-
        gration path — especially for a large population of independent client programs — compared
        to manual targeted changes in client code.
            Although new users would pick up the latest version automatically either way, existing
        users of parselib will have the option of converting immediately by making a few small
        syntactic changes or opting to remain with the original version for a while longer by making
        all references to the library namespace refer explicitly to the desired version. If the library is
        released before the inline keyword is moved, early adopters will have the option of opting
                                                                                                       91


i



    i                                                                                                        i
    i                                                                                                                        i
                          “emcpps-internal” — 2021/1/16 — 3:34 — page 92 — #94

i



        inline namespace                                                             Chapter 1        Safe Features


        in by referring to v2 explicitly until it becomes the default. Those who have no need for
        enhancements can achieve stability by referring to a particular version in perpetuity or until
        it is physically removed from the library source.
             Although this same functionality can sometimes be realized without the use of inline
        namespaces (i.e., by adding a using namespace directive at the end of the parselib name-
        space), the use of ADL and the ability to specialize templates from within the enclosing
        parselib namespace itself would be lost.77
             Providing separate namespaces for each successive version has an additional advantage
        in an entirely separate dimension. Though not demonstrated by this specific example,78
        cases do arise where simply changing which of the version namespaces is declared inline
        might lead to an ill-formed, no-diagnostic required (IFNDR) program. This might
        happen when one or more of its translation units that use the library are not recompiled
        before the program is relinked to the new static or dynamic library containing the updated
        version of the library software; see Use Cases: Link-safe ABI versioning on page 92.

        Link-safe ABI versioning
        inline namespaces are not intended as a mechanism for source-code versioning; instead,
        they prevent programs from being ill-formed due to linking some version of a library with
        client code compiled using some other, typically older version of the same library. Below, we
        present two examples: a simple pedagogical example to illustrate the principle followed by a
        more real-world example. Suppose we have a library component my_thing that implements
        an example type, Thing, that wraps an int and initializes it with some value in its default
        constructor defined out-of-line in the cpp file:
          struct Thing // version 1 of class Thing
          {
          int i;    // integer data member (size is 4)
          Thing(); // original non­inline constructor (defined in .cpp file)
          };

        Salient to this example is that information (e.g., the data member i) in the header file, when
        incorporated into a client’s translation unit, produces a .o file that, if not recompiled, could
        be incompatible yet linkable with another version of the header compiled into a separate .o
        file:
          struct Thing   // version 2 of class Thing
          {
          double d; // double­precision floating­point data member (size is 8)
          Thing();   // updated non­inline constructor (defined in .cpp file)
          };

           77 Note that, because specialization doesn’t kick in until overload resolution is completed, specializing over-

        loaded functions is dubious at best; see Potential Pitfalls: Specializing templates in std can be problematic
        on page 102.
           78 For distinct nested namespaces to effectively guard against accidental link-time errors, the symbols

        involved have to (1) reside in object code (e.g., a header-only library would fail this requirement) and (2)
        have the same name mangling (i.e., linker symbol) in both versions. In this particular instance, however,
        the signature of the parse member function of parser did change, and its mangled name will consequently
        change as well; hence the same undefined symbol link error would result either way.
                                                                92


i



    i                                                                                                                        i
    i                                                                                                               i
                       “emcpps-internal” — 2021/1/16 — 3:34 — page 93 — #95

i



        C++11                                                                             inline namespace


        To make the problem that we are illustrating concrete, let’s represent the client as a main
        program that does nothing but create a Thing and print the value of its only data member,
        i.
          // main.cpp
          #include "my_thing.h"        // my::Thing (version 1)
          #include <iostream>          // std::cout

          int main()
          {
          my::Thing t;
          std::cout << t.i << '\n';
          }

        If we compile this program, a reference to a locally undefined linker symbol, such as
        _ZN2my7impl_v15ThingC1Ev,79 that represents the my::thing::thing constructor will
        be generated in the main.o file:
          $ g++ ­c main.cpp

        Without explicit intervention, the spelling of this linker symbol would be unaffected by any
        subsequent changes made to the implementation of my::Thing, such as its data members
        or implementation of its default constructor, even after recompiling. The same, of course,
        applies to its definition in a separate translation unit.
            We now turn to the translation unit implementing type my::Thing. The my_thing
        component consists of a .h/.cpp pair: my_thing.h and my_thing.cpp. The header file
        my_thing.h provides the physical interface, such as the definition of the principal type,
        Thing, its member and associated free function declarations, plus definitions for inline func-
        tions and function templates, if any:
          // my_thing.h
          #ifndef INCLUDED_MY_THING
          #define INCLUDED_MY_THING

          namespace my                  // outer namespace (used directly by clients)
          {
          inline namespace impl_v1 // inner namespace (for implementer use only)
          {
          struct Thing
          {
          int i;    // original data member, size = 4
          Thing(); // default constructor (defined in my_thing.cpp)
          };
          };
          }

          #endif
           79 On a Unix machine, typing nm main.o reveals the symbols used in the specified object file. A symbol

        prefaced with a capital U represents an undefined symbol that must be resolved by the linker. Note that
        the linker symbol shown here incorporates an intervening inline namespace, impl_v1, as will be explained
        shortly.
                                                                                                              93


i



    i                                                                                                               i
    i                                                                                                         i
                           “emcpps-internal” — 2021/1/16 — 3:34 — page 94 — #96

i



        inline namespace                                                          Chapter 1   Safe Features


        The implementation file my_thing.cpp contains all of the non-inline function bodies that
        will be translated separately into the my_thing.o file:
         // my_thing.cpp
         #include "my_thing.h"

         namespace my                  // outer namespace (used directly by clients)
         {
         inline namespace impl_v1  // inner namespace (for implementer use only)
         {
         Thing::Thing() : i(0) // load a 4­byte value into Thing's data member
         {
         }
         }
         }

        Observing common good practice, we include the filename of the component as the first
        substantive line of code to ensure that — irrespective of anything else — the header always
        compiles in isolation, thereby avoiding insidious include-order dependencies.80 When we
        compile the source file my_thing.cpp, we produce an object file my_thing.o containing
        the definition of the very same linker symbol, such as _ZN2my7impl_v15ThingC1Ev, for the
        default constructor of my::Thing needed by the client:
         $ g++ ­c my_thing.cpp

        We can then link main.o and my_thing.o into an executable and run it:
         $ g++ ­o prog main.o my_thing.o
         $ ./prog

         0

        Now, suppose we were to change the definition of my::thing in place to hold a double
        instead of an int, recompile my_thing.cpp, and then relink with the original main.o with-
        out recompiling main.cpp first. None of the relevant linker symbols would change, and the
        code would recompile and link just fine, but the resulting binary prog would be IFNDR:
        the client would be trying to print a 4-byte, int data member, i, in main.o that was loaded
        by the library component as an 8-byte, double into d in my_thing.o. We can resolve this
        problem by changing — or, if we didn’t think of it in advance, by adding — a new inline
        namespace and making that change there:
         // my_thing.cpp
         #include "my_thing.h"

         namespace my                    // outer namespace (used directly by clients)
         {
         inline namespace impl_v2    // inner namespace (for implementer use only)
         {
         Thing::Thing() : d(0.0) // load 8­byte value into Thing's data member
         {
          80 See   lakos20, section 1.6.1, “Component Property 1,” pp. 210–212.
                                                            94


i



    i                                                                                                         i
    i                                                                                                   i
                     “emcpps-internal” — 2021/1/16 — 3:34 — page 95 — #97

i



        C++11                                                                    inline namespace


          }
          }
          }

        Now clients that attempt to link against the new library will not find the new linker symbol,
        such as _Z...impl_v1...v, and the link stage will fail. Once clients recompile, however,
        the undefined linker symbol will match the one available in the new my_thing.o, such
        as _Z...impl_v2...v, the link stage will succeed, and the program will again work as
        expected. What’s more, we have the option of keeping the original implementation. In that
        case, existing clients that have not as yet recompiled will continue to link against the old
        version until it is eventually removed after some suitable deprecation period.
           As a more realistic second example of using inline namespaces to guard against linking
        incompatible versions, suppose we have two versions of a Key class in a security library in
        the enclosing namespace, auth — the original version in a regular nested namespace v1,
        and the new current version in an inline nested namespace v2:
          #include <cstdint>    // std::uint32, std::unit64

          namespace auth       // outer namespace (used directly by clients)
          {
          namespace v1    // inner namespace (optionally used by clients)
          {
          class Key
          {
          private:
          std::uint32_t d_key;
          // sizeof(Key) is 4 bytes

          public:
          std::uint32_t key() const;     // stable interface function

          // ...
          };
          }

          inline namespace v2    // inner namespace (default current version)
          {
          class Key
          {
          private:
          std::uint64_t d_securityHash;
          std::uint32_t d_key;
          // sizeof(Key) is 16 bytes

          public:
          std::uint32_t key() const;     // stable interface function

          // ...
          };
                                                                                                  95


i



    i                                                                                                   i
    i                                                                                                            i
                        “emcpps-internal” — 2021/1/16 — 3:34 — page 96 — #98

i



        inline namespace                                                     Chapter 1      Safe Features


          }
          }

        Attempting to link together older binary artifacts built against version 1 with binary artifacts
        built against version 2 will result in a link-time error rather than allowing an ill-formed
        program to be created because the two versions of, for example, the key accessor function
        will have different linker-symbol names, assuming it is not declared inline in the header.
            Finally, note that this approach works only if functionality essential to typical use is
        defined out of line in a .cpp file. This approach would add absolutely no value for, say,
        libraries that are shipped entirely as header files, since the versioning offered here occurs
        strictly at the binary level (i.e., between .o files) during the link stage.

        Build modes and ABI link safety
        In certain scenarios, a class might have two different memory layouts depending on com-
        pilation flags. For instance, consider a low-level ManualBuffer class template in which an
        additional data member is added for debugging purposes81 :
          template <typename T>
          struct ManualBuffer
          {
          private:
          alignas(T) char d_data[sizeof(T)];           // aligned and big enough to hold a T

          #ifndef NDEBUG
          bool d_engaged;      // tracks whether buffer is full (debug builds only)
          #endif

          public:
          void construct(const T& obj);
          // Emplace obj. (Engage the buffer.) The behavior is undefined unless
          // the buffer was not previously engaged.

          void destroy();
          // Destroy the current obj. (Disengage the buffer.) The behavior is
          // undefined unless the buffer was previously engaged.

          // ...
          };

        The d_engaged flag in the example above serves as a way to detect misuse of the ManualBuffer
        class but only in debug builds. The extra space and run time required to maintain this
        Boolean flag is undesirable in a release build because ManualBuffer is intended to be an
        eﬀicient, lightweight abstraction over the direct use of placement new and explicit destruc-
        tion.
            The linker symbol names generated for the methods of ManualBuffer are the same
        irrespective of the chosen build mode. If the same program links together two object files
            81 Note that we have employed the C++11 alignas attribute (see “alignas” on page 204) here because

        it is exactly what’s needed for this usage example.
                                                          96


i



    i                                                                                                            i
    i                                                                                                                   i
                       “emcpps-internal” — 2021/1/16 — 3:34 — page 97 — #99

i



        C++11                                                                                 inline namespace


        where ManualBuffer is used — one built in debug mode and one built in release mode —
        the one definition rule will be violated and the program will again be IFNDR.
            One way of avoiding these sorts of incompatibilities at link time is to introduce two
        inline namespaces, the entire purpose of which is to change the ABI-level names of the
        linker symbols associated with ManualBuffer depending on the build mode82 :
          #ifndef NDEBUG                    // perhaps a BAD IDEA
          inline namespace release
          #else
          inline namespace debug
          #endif
          {
          template <typename T>
          struct ManualBuffer
          {
          // ... (same as above)
          };
          }

        The approach demonstrated in this example tries to ensure that a linker error will oc-
        cur if any attempt is made to link objects built with a build mode different from that
        of manualbuffer.o. Tying it to the NDEBUG flag, however, might have unintended conse-
        quences; we might introduce unwanted restrictions in what we call mixed-mode builds.
        Most modern platforms support the notion of linking a collection of .o files irrespective of
        their optimization levels. The same is certainly true for whether or not C-style assert is
        enabled. In other words, we may want to have assertion enabled and/or optimized code in
        a program that is uniformly built either with or without this particular defensive runtime
        checking enabled. Hence, a more general, albeit more complicated and manual, approach
        would be to tie the non-interoperable behavior associated with this “safe” or “defensive”
        build mode to a different switch entirely. Another consideration would be to avoid ever
        inlining a namespace into the global namespace since no method is available to recover a
        symbol when there is a collision:
          namespace buflib // GOOD IDEA: enclosing namespace for nested inline namespace
          {
          #ifndef SAFE_MODE // GOOD IDEA: separate control of non­interoperable versions

           82 Prior to inline namespaces, it was possible to control the ABI-level name of linked symbols by creating

        separate template instantiations on a per-build-mode basis:
          #ifndef NDEBUG
          enum { is_debug_build = 1 };
          #else
          enum { is_debug_build = 0 };
          #endif

          template <typename T, bool Debug = is_debug_build>
          struct ManualBuffer { /* ... */ };

        While the code above changes the interface of ManualBuffer to accept an additional template parameter, it
        also allows debug and release versions of the same class to coexist in the same program, which might prove
        useful, e.g., for testing.
                                                                                                                  97


i



    i                                                                                                                   i
    i                                                                                                  i
                      “emcpps-internal” — 2021/1/16 — 3:34 — page 98 — #100

i



        inline namespace                                              Chapter 1     Safe Features


         inline namespace safe_build_mode
         #else
         inline namespace normal_build_mode
         #endif
         {
         template <typename T>
         struct ManualBuffer
         {
         private:
         alignas(T) char d_data[sizeof(T)];       // aligned/sized to hold a T

         #ifdef SAFE_MODE
         bool d_engaged; // tracks whether buffer is full (safe mode only)
         #endif

         public:
         void construct(const T& obj);      // sets d_engaged (safe mode only)
         void destroy();                    // sets d_engaged (safe mode only)
         // ...
         };
         }
         }

        And, of course, the appropriate conditional compilation within the function bodies would
        need to be in the corresponding .cpp file.
            Finally, if we have two implementations of a particular entity that are suﬀiciently dis-
        tinct, we might choose to represent them in their entirety, controlled by their own bespoke
        conditional-compilation switches, as illustrated here using the my::VersionedThing type
        (see Use Cases: Link-safe ABI versioning on page 92:
         // my_versionedthing.h
         #ifndef INCLUDED_MY_VERSIONEDTHING
         #define INCLUDED_MY_VERSIONEDTHING

         namespace my
         {
         #ifdef MY_THING_VERSION_1      // bespoke switch for this component version
         inline
         #endif
         namespace v1
         {
         struct VersionedThing
         {
         int d_i;
         VersionedThing();
         };
         }

         #ifdef MY_THING_VERSION_2      // bespoke switch for this component version
         inline
                                                     98


i



    i                                                                                                  i
    i                                                                                                     i
                    “emcpps-internal” — 2021/1/16 — 3:34 — page 99 — #101

i



        C++11                                                                      inline namespace


          #endif
          namespace v2
          {
          struct VersionedThing
          {
          double d_i;
          VersionedThing();
          };
          }
          }
          #endif

        However, see Potential Pitfalls: inline-namespace-based versioning doesn’t scale on page 100.

        Enabling selective using directives for short-named entities
        Introducing a large number of small names into client code that doesn’t follow rigorous
        nomenclature can be problematic. Hoisting these names into one or more nested namespaces
        so that they are easier to identify as a unit and can be used more selectively by clients, such
        as through explicit qualification or using directives, can sometimes be an effective way of
        organizing shared codebases. For example, std::literals and its nested namespaces, such
        as chrono_literals, were introduced as inline namespaces in C++14. As it turns out,
        clients of these nested namespaces have no need to specialize any templates defined in these
        namespaces nor do they define types that must be found through ADL, but one can at least
        imagine special circumstances in which such tiny-named entities are either templates that
        require specialization or operator-like functions, such as swap, defined for local types within
        that nested namespace. In those cases, inline namespaces would be required to preserve
        the desired “as if” properties.
            Even without either of these two needs, another property of an inline namespace dif-
        ferentiates it from a non-inline one followed by a using directive. Recall from Description:
        Loss of access to duplicate names in enclosing namespace on page 82 that a name in an outer
        namespace will hide a duplicate name imported via a using directive, whereas any access to
        that duplicate name within the enclosing namespace would be ambiguous when that sym-
        bol is installed by way of an inline namespace. To see why this more forceful clobbering
        behavior might be preferred over hiding, suppose we have a communal namespace abc that
        is shared across multiple disparate headers. The first header, abc_header1.h, represents a
        collection of logically related small functions declared directly in abc:
          // abc_header1.h
          namespace abc
          {
          int i();
          int am();
          int smart();
          }

        A second header, abc_header2.h, creates a suite of many functions having tiny function
        names. In a perhaps misguided effort to avoid clobbering other symbols within the abc
        namespace having the same name, all of these tiny functions are sequestered within a nested
                                                                                                    99


i



    i                                                                                                     i
    i                                                                                                       i
                      “emcpps-internal” — 2021/1/16 — 3:34 — page 100 — #102

i



        inline namespace                                                  Chapter 1     Safe Features


        namespace:
          // abc_header2.h
          namespace abc
          {
          namespace nested // Should this instead have been an inline namespace?
          {
          int a(); // lots of functions with tiny names
          int b();
          int c();
          // ...
          int h();
          int i(); // might collide with another name declared in abc
          // ...
          int z();
          }

          using namespace nested;      // becomes superfluous if nested is made inline
          }

        Now suppose that a client application, for whatever reason, includes both of these headers
        to accomplish some task:
          // client.cpp
          #include "abc_header1.h"
          #include "abc_header2.h"

          int function()
          {
          if (smart() < 0) { return ­1; } // uses smart() from abc_header1.h
          return abc::z() + abc::i() + abc::a() + abc::h() + abc::c(); // Oops!
          // runtime error: silently uses the abc::i() defined in abc_header1.h
          }

        In trying to cede control to the client as to whether the declared or imported abc::i()
        function is to be used, we have, in effect, invited the defect illustrated in the above example
        whereby the client was expecting the abc::i() from abc_header2.h and yet picked up
        the one from abc_header1.h by default. Had the nested namespace in abc_header2.h
        been declared inline, the qualified name abc::i() would have automatically been ren-
        dered ambiguous in namespace abc, the translation would have failed safely, and the defect
        would have been exposed at compile time. The downside, however, is that no method would
        be available to recover nominal access to the abc::i() defined in abc_header1.h once
        abc_header2.h is included, even though the two functions (e.g., including their mangled
        names at the ABI level) remain distinct.

        Potential Pitfalls
        inline-namespace-based versioning doesn’t scale
        The problem with using inline namespaces for ABI link safety is that the protection they
        offer is only partial; in a few major places, critical problems can linger until run time instead
                                                       100


i



    i                                                                                                       i
    i                                                                                                       i
                    “emcpps-internal” — 2021/1/16 — 3:34 — page 101 — #103

i



        C++11                                                                       inline namespace


        of being caught at compile time.
            Controlling which namespace is inline using macros, such as was done in the
        my::VersionedThing example in Use Cases: Link-safe ABI versioning on page 92, will
        result in code that directly uses the unversioned name, my::VersionedThing being bound
        directly to the versioned name my::v1::VersionedThing or my::v2::VersionedThing,
        along with the class layout of that particular entity. Sometimes details of the use of the
        inline namespace member are not resolved by the linker, such as the object layout when
        we use types from that namespace as member variables in other objects:
          // my_thingaggregate.h

          // ...
          #include "my_versionedthing.h"
          // ...

          namespace my
          {
          struct ThingAggregate
          {
          // ...
          VersionedThing d_thing;
          // ...
          };
          }

        This new ThingAggregate type does not have the versioned inline namespace as part
        of its mangled name; it does, however, have a completely different layout if built with
        MY_THING_VERSION_1 defined versus MY_THING_VERSION_2 defined. Linking a program
        with mixed versions of these flags will result in runtime failures that are decidedly diﬀi-
        cult to diagnose.
            This same sort of problem will arise for functions taking arguments of such types; calling
        a function from code that is wrong about the layout of a particular type will result in stack
        corruption and other undefined and unpredictable behavior. This macro-induced problem
        will also arise in cases where an old object file is linked against new code that changes which
        namespace is inlined but still provides the definitions for the old version namespace. The
        old object file for the client can still link, but new object files using the headers for the old
        objects might attempt to manipulate those objects using the new namespace.
            The only viable workaround for this approach is to propagate the inline namespace hier-
        archy through the entire software stack. Every object or function that uses
        my::VersionedThing needs to also be in a namespace that differs based on the same con-
        trol macro. In the case of ThingAggregate, one could just use the same my::v1 and my::v2
        namespaces, but higher-level libraries would need their own my-specific nested namespaces.
        Even worse, for higher-level libraries, every lower-level library having a versioning scheme of
        this nature would need to be considered, resulting in having to provide the full cross-product
        of nested namespaces to get link-time protection against mixed-mode builds.
            This need for layers above a library to be aware of and to integrate into their own
        structure the same namespaces the library has removes all or most of the benefits of using
        inline namespaces for versioning. For an authentic real-world case study of heroic industrial
                                                                                                     101


i



    i                                                                                                       i
    i                                                                                                                  i
                        “emcpps-internal” — 2021/1/16 — 3:34 — page 102 — #104

i



        inline namespace                                                         Chapter 1       Safe Features


        use — and eventual disuse — of inline-namespaces for versioning, see Appendix: Case study
        of using inline namespaces for versioning on page 107.

        Specializing templates in std can be problematic
        Fundamental to the nature of C++ is that the Standard Library can mostly be implemented
        in standard C++. This disposition gives the illusion that the Standard Library is like all
        other libraries and supports any interaction that might work with those libraries. Were
        this assumption true, the Standard Library would quickly become unacceptably limited in
        how it might evolve. To allow for its necessary evolution, the Standard Library — the std
        namespace, in particular — carries certain special restrictions on what one can do with
        it that are enforced by deeming certain constructs ill formed or engendering undefined
        behavior, a feat other libraries simply do not have the authority to pull off.
            Since C++11, several restrictions related to the Standard Library were put in place:
           • Users may not add any new declarations within namespace std. This means that users
             cannot add new functions, overloads, types, or templates to std. This restriction gives
             the Standard Library freedom to add new names in future versions of the Standard.
           • Users may not specialize member functions, member function templates, or member
             class templates. Specializing any of those entities might significantly inhibit a Standard
             Library vendor’s ability to maintain its otherwise encapsulated implementation details.
           • Users may add specializations of top-level Standard Library templates only if the
             declaration depends on the name of a nonstandard user-defined type and only if that
             user-defined type meets all requirements of the original template. Specialization of
             function templates is allowed but generally discouraged because this practice doesn’t
             scale since function templates cannot be partially specialized. Specializing of standard
             class templates when the specialization names a nonstandard user-defined type, such
             as vector<MyType*>, is allowed but also problematic when not explicitly supported.
             While certain specific types, such as std::hash, are designed for user specialization,
             steering clear of the practice for any other types helps to avoid surprises.
            Several other good practices facilitate smooth evolution for the Standard Library83 :
           • Avoid specializing variable templates, even if dependent on user-defined types, except
             for those variable templates where specialization is explicitly allowed.84
           • Other than a few very specific exceptions,85 avoiding the forming of pointers to Stan-
             dard Library functions — either explicitly or implicitly — allows the library to add
           83 These restrictions are normative in C++20, having finally formalized what were long identified as best

        practices. Though these restrictions might not be codified in the Standard for pre-C++20 software, they
        have been recognized best practices for as long as the Standard Library has existed and adherence to them
        will materially improve the ability of software to migrate to future language standards irrespective of what
        version of the language standard is being targeted.
           84 C++20 limits the specialization of variable templates to only those instances where specialization is

        explicitly allowed and does so only for the mathematical constants in <numbers>.
           85 C++20 identifies these functions as addressable and gives that property to only iostream manipulators

        since those are the only functions in the Standard Library for which taking their address is part of normal
        usage.
                                                            102


i



    i                                                                                                                  i
    i                                                                                                               i
                     “emcpps-internal” — 2021/1/16 — 3:34 — page 103 — #105

i



        C++11                                                                             inline namespace


              overloads, either as part of the Standard or as an implementation detail for a particular
              Standard Library, without breaking user code.
           • Overloads of Standard Library functions that depend on user-defined types are per-
             mitted, but, as with specializing Standard Library templates, users must still meet the
             requirements of the Standard Library function. Some functions, such as std::swap,
             are designed to be customization points via overloading, but leaving functions not
             specifically designed for this purpose to vendor implementations only helps to avoid
             surprises.
           Finally, upon reading about this inline namespace feature, one might think that all
        names in namespace std could be made available at a global scope simply by inserting an
        inline namespace std before including any standard headers. This practice is, however,
        explicitly called out as ill-formed within the C++11 Standard.86

        Inconsistent use of inline keyword is ill formed, no diagnostic required
        It is an ODR violation, IFNDR, for a nested namespace to be inline in one translation
        unit and non-inline in another. And yet, the motivating use case of this feature relies on
        the linker to actively complain whenever different, incompatible versions — nested within
        different, possibly inline-inconsistent, namespaces of an ABI — are used within a single
        executable. Because declaring a nested namespace inline does not, by design, affect linker-
        level symbols, developers must take appropriate care, such as effective use of header files,
        to defend against such preventable inconsistencies.

        Annoyances
        Inability to redeclare across namespaces impedes code factoring
        An essential feature of an inline namespace is the ability to declare a template within a
        nested inline namespace and then specialize it within its enclosing namespace. For example,
        we can declare
           • a type template, S0
           • a couple of function templates, f and g
           • and a member function template h, which is similar to f
        in an inline namespace, inner, and specialize each of them, such as for int, in the enclosing
        namespace, outer:
          namespace outer                                                          // enclosing namespace
          {
          inline namespace inner                                              // nested namespace
          {
          template<typename T> struct S0;                                // declarations of
          template<typename T> void f0();                                // various class

          86 Although not uniformly diagnosed as an error by all compilers, attempting this forbidden practice is

        apt to lead to surprising problems even if not diagnosed as an error immediately.
                                                                                                            103


i



    i                                                                                                               i
    i                                                                                                               i
                        “emcpps-internal” — 2021/1/16 — 3:34 — page 104 — #106

i



        inline namespace                                                       Chapter 1       Safe Features


          template<typename T> void g0(T v);                             // and function
          struct A0 { template <typename T> void h0(); };                // templates
          }

          template<> struct S0<int> { };                                      //   specializations
          template<> void f0<int>() { }                                       //   of the various
          void g0(int) { } /* overload not specialization */                  //   class and function
          template<> void A0::h0<int>() { }                                   //   declarations above
          }                                                                         // in outer namespace

        Note that, in the case of g0 in this example, the “specialization” void g0(int) is a non-
        template overload of the function template g0 rather than a specialization of it. We cannot,
        however, portably87 declare these templates within the outer namespace and then specialize
        them within the inner one, even though the inner namespace is inline:
          namespace outer                                                    // enclosing namespace
          {
          template<typename T> struct S1;                              // class template
          template<typename T> void f1();                              // function template
          template<typename T> void g1(T v);                           // function template

          struct A1 { template <typename T> void h1(); }; // member function template

          inline namespace inner                                        // nested namespace
          {                                                             // BAD IDEA
          template<> struct S1<int> { };                          //   error: S1 not a template
          template<> void f1<int>() { }                           //   error: f1 not a template
          void g1(int) { }                                        //   OK, overloaded function
          template<> void A1::h1<int>() { }                       //   error: h1 not a template
          }
          }

        Attempting to declare a template in the outer namespace and then define, effectively re-
        declaring, it in an inline inner one causes the name to be inaccessible within the outer
        namespace:
          namespace outer                                                           // enclosing namespace
          {                                                                         // BAD IDEA
          template<typename T>       struct S2;                               //   declarations of
          template<typename T>       void f2();                               //   various class
          template<typename T>       void g2(T v);                            //   and function
          struct A2 { template       <typename T> void h2(); };               //   templates

          inline namespace inner                                              // nested namespace
          {
          template<typename T> struct S2 { };                            // definitions of
          template<typename T> void f2() { }                             // unrelated class

          87 GCC   provides the ­fpermissive flag, which allows the example containing specializations within the
        inner namespace to compile with warnings. Note again that g1(int), being an overload and not a special-
        ization, wasn’t an error and, therefore, isn’t a warning either.
                                                          104


i



    i                                                                                                               i
    i                                                                                                         i
                    “emcpps-internal” — 2021/1/16 — 3:34 — page 105 — #107

i



        C++11                                                                              inline namespace


         template<typename T> void g2(T v) { }                        // and function
         template<typename T> void A2::h2() { };                      // templates
         }

         template<> struct S2<int> { };            //   Error:   S2   is   ambiguous in outer.
         template<> void f2<int>() { }             //   Error:   f2   is   ambiguous in outer.
         void g2(int) { }                          //   OK, g2   is   an   overload definition.
         template<> void A2::h2<int>() { }         //   Error:   h2   is   ambiguous in outer.
         }

        Finally, declaring a template in the nested inline namespace inner in the example above
        and then subsequently defining it in the enclosing outer namespace has the same effect of
        making declared symbols ambiguous in the outer namespace:
         namespace outer                                                            // enclosing namespace
         {                                                                          // BAD IDEA
         inline namespace inner                                                 // nested namespace
         {
         template<typename T> struct S3;                              //    declarations of
         template<typename T> void f3();                              //    various class
         template<typename T> void g3(T v);                           //    and function
         struct A3 { template <typename T> void h3(); };              //    templates
         }

         template<typename      T>   struct S3 { };                             //   definitions of
         template<typename      T>   void f3() { }                              //   unrelated class
         template<typename      T>   void g3(T v) { }                           //   and function
         template<typename      T>   void A3::h3() { };                         //   templates

         template<> struct S3<int> { };            //   Error:   S3   is   ambiguous in outer.
         template<> void f3<int>() { }             //   Error:   f3   is   ambiguous in outer.
         void g3(int) { }                          //   OK, g3   is   an   *overload* definition.
         template<> void A3::h3<int>() { }         //   Error:   h2   is   ambiguous in outer.
         }

        Note that, although the definition for a member function template must be located directly
        within the namespace in which it is declared, a class or function template, once declared,
        may be defined in a different scope by using an appropriate name qualification:
         template   <typename    T>   struct outer::S3 { };                //    OK, enclosing namespace
         template   <typename    T>   void outer::inner::f3() { }          //    OK, nested namespace
         template   <typename    T>   void outer::g3(T v) { }              //    OK, enclosing namespace
         template   <typename    T>   void outer::A3::h3<T>() { }          //    syntax error: ill­formed

         namespace outer
         {
         inline namespace inner
         {
         template <typename T> void A3::h3<T>() { } // OK, within same namespace
         }
         }
                                                                                                        105


i



    i                                                                                                         i
    i                                                                                                       i
                          “emcpps-internal” — 2021/1/16 — 3:34 — page 106 — #108

i



        inline namespace                                                        Chapter 1   Safe Features


        Also note that, as ever, the corresponding definition of the declared template must have
        been seen before it can be used in a context requiring a complete type. The importance of
        ensuring that all specializations of a template have been seen before it is used substantively
        (i.e., ODR-used) cannot be overstated, giving rise to the only limerick, which is actually
        part of the normative text, in the C++ Language Standard88 :
              When writing a specialization,
              be careful about its location;
              or to make it compile
              will be such a trial
              as to kindle its self-immolation.

        Only one namespace can contain any given inline namespace
        Unlike conventional using directives, which can be used to generate arbitrary many-to-
        many relationships between different namespaces, inline namespaces can be used only to
        contribute names to the sequence of enclosing namespaces up to the first non-inline one.
        In cases in which the names from a namespace are desired in multiple other namespaces, the
        classical using directive must be used, with the subtle differences between the two modes
        properly addressed.
            As an example, the C++14 Standard Library provides a hierarchy of nested inline
        namespaces         for     literals     of     different      sorts     within      namespace
        std:      std::literals::complex_literals,               std::literals::chrono_literals,
        std::literals::string_literals, and std::literals::string_view_literals.
        These namespaces can be imported to a local scope in one shot via a using std::literals
        or instead, more selectively, by using the nested namespaces directly. This separation of
        the types used with user-defined literals, which are all in namespace std, from the user-
        defined literals that can be used to create those types led to some frustration; those who had
        a using namespace std; could reasonably have expected to get the user-defined literals
        associated with their std types. However, the types in the nested namespace std::chrono
        did not meet this expectation.89
            Eventually both solutions for incorporating literal namespace, inline from
        std::literals and non-inline from std::chrono, were pressed into service when, in
        C++17, a using namespace literals::chrono_literals; was added to the
        std::chrono namespace. The Standard does not, however, benefit in any objective way
        from any of these namespaces being inline since the artifacts in the literals namespace
        neither depend on ADL nor are templates in need of user-defined specializations; hence
        having all non-inline namespaces with appropriate using declarations would have been
        functionally indistinguishable from the bifurcated approach taken.

        See Also
          • “alignas” on page 204 — Safe C++11 feature used in the example in Use Cases:
            Build modes and ABI link safety on page 96 to provide properly aligned storage for
            an object of arbitrary type T.
          88 See   iso11, section 14.7.3.7, pp. 375–375, specifically p. 376.
          89 hinnant17

                                                               106


i



    i                                                                                                       i
    i                                                                                                      i
                    “emcpps-internal” — 2021/1/16 — 3:34 — page 107 — #109

i



        C++11                                                                      inline namespace


        Further Reading
        TODO, TBD

        Appendix: Case study of using inline namespaces for versioning
        By Niall Douglas

        Let me tell you what I (don’t) use them for. It is not a conventional opinion.
            At a previous well-regarded company, they were shipping no less than forty-three copies
        of Boost in their application. Boost was not on the approved libraries list, but the great
        thing about header-only libraries is that they don’t obviously appear in final binaries, un-
        less you look for them. So each individual team was including bits of Boost quietly and
        without telling their legal department. Why? Because it saved time. (This was C++98, and
        boost::shared_ptr and boost::function are both extremely attractive facilities).
            Here’s the really interesting part: Most of these copies of Boost were not the same version.
        They were varying over a five-year release period. And, unfortunately, Boost makes no API
        or ABI guarantees. So, theoretically, you could get two different incompatible versions of
        Boost appearing in the same program binary, and BOOM! there goes memory corruption.
            I advocated to Boost that a simple solution would be for Boost to wrap up their imple-
        mentation into an internal inline namespace. That inline namespace ought to mean some-
        thing:
          • lib::v1 is the stable, version-1 ABI, which is guaranteed to be compatible with all
            past and future lib::v1 ABIs, forever, as determined by the ABI-compliance-check
            tool that runs on CI. The same goes for v2, v3, and so on.
          • lib::v2_a7fe42d is the unstable, version-2 ABI, which may be incompatible with any
            other lib::* ABI; hence the seven hex chars after the underscore are the git short
            SHA, permuted by every commit to the git repository but, in practice, per CMake
            configure, because nobody wants to rebuild everything per commit. This ensures that
            no symbols from any revision of lib will ever silently collide or otherwise interfere
            with any other revision of lib, when combined into a single binary by a dumb linker.
            I have been steadily making progress on getting Boost to avoid putting anything in the
        global namespace, so a straightforward find-and-replace can let you “fix” on a particular
        version of Boost.
            That’s all the same as the pitch for inline namespaces. You’ll see the same technique
        used in libstdc++ and many other major modern C++ codebases.
            But I’ll tell you now, I don’t use inline namespaces any more. Now what I do is
        use a macro defined to a uniquely named namespace. My build system uses the git SHA to
        synthesize namespace macros for my namespace name, beginning the namespace and ending
        the namespace. Finally, in the documentation, I teach people to always use a namespace
        alias to a macro to denote the namespace:
          namespace output = OUTCOME_V2_NAMESPACE;

        That macro expands to something like ::outcome_v2_ee9abc2, that is, I don’t use inline
        namespaces any more.
                                                                                                    107


i



    i                                                                                                      i
    i                                                                                                      i
                      “emcpps-internal” — 2021/1/16 — 3:34 — page 108 — #110

i



        inline namespace                                                 Chapter 1     Safe Features


            Why?
            Well, for existing libraries that don’t want to break backward source compatibility, I think
        inline namespaces serve a need. For new libraries, I think a macro-defined namespace is
        clearer.
          • It causes users to publicly commit to “I know what you’re doing here, what it means,
            and what its consequences are.”

          • It declares to other users that something unusual (i.e., go read the documentation) is
            happening here, instead of silent magic behind the scenes.
          • It prevents accidents that interfere with ADL and other customization points, which
            induce surprise, such as accidentally injecting a customization point into lib, not into
            lib::v2.

          • Using macros to denote namespace lets us reuse the preprocessor machinery to generate
            C++ modules using the exact same codebase; C++ modules are used if the compiler
            supports them, else we fall back to inclusion.
            Finally, and here’s the real rub, because we now have namespace aliases, if I were tempted
        to use an inline namespace, nowadays I probably would instead use a uniquely named
        namespace instead, and, in the include file, I’d alias a user-friendly name to that uniquely
        named namespace. I think that approach is less likely to induce surprise in the typical
        developer’s likely use cases than inline namespaces, such as injecting customization points
        into the wrong namespace.
            So now I hope you’ve got a good handle on inline namespaces: I was once keen on
        them, but after some years of experience, I’ve gone off them in favor of better-in-my-opinion
        alternatives. Unfortunately, if your type x::S has members of type a::T and macros decide
        if that is a::v1::T or a::v2::T, then no linker protects the higher-level types from ODR
        bugs, unless you also version x.




                                                      108


i



    i                                                                                                      i
    i                                                                                                  i
                     “emcpps-internal” — 2021/1/16 — 3:34 — page 109 — #111

i



        C++11                                                                        Local Types '11




        Local/Unnamed Types as Template Arguments
        Local (i.e., function-scope) and unnamed (e.g., lambda expression, a.k.a. “closure”) types
        can, as of C++11, be used (like all other types) as arguments to templates.

        Description
        Historically, types without linkage (i.e., local and unnamed types) were forbidden as tem-
        plate arguments due to implementability concerns using the compiler technology available
        at that time.90 Modern C++ lifts this restriction, making use of local or unnamed types
        consistent with nonlocal, named ones, thereby obviating the need to gratuitously name or
        enlarge the scope of a type.
         template <typename T>
         void f(T) { };               // function template

         template <typename T>
         class C { };                 // class template

         struct { } obj;              // object obj of unnamed C++ type

         void g()
         {
         struct S { };            // local type

         f(S());                  // OK in C++11; was error in C++03
         f(obj);                  // OK in C++11; was error in C++03

         C<S>             cs;     // OK in C++11; was error in C++03
         C<decltype(obj)> co;     // OK in C++11; was error in C++03
         }

        Notice that we have used the (C++11) decltype keyword (see Section 1, “decltype”) to
        extract the unnamed type of the object obj.
           These new relaxed rules for template arguments are essential to the ergonomics of lambda
        expressions (see Section 2, “Lambdas”), as such types are both unnamed and local in typical
        usage:
         #include <algorithm>     // std::sort

         struct Person { std::string d_name; };

         void sortByName(std::vector<Person>& people)
         {
         std::sort(people.begin(), people.end(),
         [](const Person& lhs, const Person& rhs)
         {

          90 TODO:   Alisdair
                                                                                                109


i



    i                                                                                                  i
    i                                                                                                                 i
                        “emcpps-internal” — 2021/1/16 — 3:34 — page 110 — #112

i



        Local Types '11                                                          Chapter 1      Safe Features


          return lhs.d_name < rhs.d_name;
          });
          }

        In the example above, the lambda expression passed to the std::sort algorithm is a local
        unnamed type, and the algorithm itself is a function template.

        Use Cases
        Encapsulating a type within a function
        Limiting the scope and visibility of an entity to the body of a function actively prevents
        its direct use, even when the function body is exposed widely — say, as an inline function
        or function template defined within a header file.
            Consider, for instance, an implementation of Dijkstra’s algorithm that uses a local type
        to keep track of metadata for each vertex in the input graph (i.e., the distance of a vertex
        from the source of the search and whether a vertex is included in the shortest path or not):
          // dijkstra.h

          inline int dijkstra(std::vector<Vertex>* path, const Graph& graph)
          {
          struct VertexMetadata         // implementation­specific helper class
          {
          int d_distanceFromSource;
          bool d_inShortestPath;
          };

          std::vector<VertexMetadata> vertexMetadata(graph.numNodes());
          // standard vector of local VertexMetadata objects ­­ one per vertex

          // ... (body of algorithm)
          }

        Defining VertexMetadata outside of the body of dijkstra — e.g., to comply with C++03
        restrictions — would make that implementation-specific helper class directly accessible to
        anyone including the dijkstra.h header file. As Hyrum’s law91 suggests, if the imple-
        mentation-specific VertexMetadata detail is defined outside the function body, it is to be
        expected that some user somewhere will depend on it in its current form, making it problem-
        atic, if not impossible, to change.92 Conversely, encapsulating the type within the function
        body avoids unintended use by clients, while improving human cognition by colocating the
        definition of the type with its sole purpose.93


           91 “With a suﬀicient number of users of an API, it does not matter what you promise in the contract: all

        observable behaviors of your system will be depended on by somebody”: see wight.
           92 The C++20 modules facility enables the encapsulation of helper types (such as metadata in the

        dijkstra.h example on this page) used in the implementation of other locally defined types or functions,
        even when the helper types appear at namespace scope within the module.
           93 For a detailed discussion of malleable versus stable software, see lakos20, section 0.5, pp. 29-43.

                                                           110


i



    i                                                                                                                 i
    i                                                                                                              i
                     “emcpps-internal” — 2021/1/16 — 3:34 — page 111 — #113

i



        C++11                                                                                   Local Types '11


        Instantiating templates with local function objects as type arguments
        Suppose that we have a program that makes wide use of an aggregate data type, City:
          struct City
          {
          int         d_uniqueId;
          std::string d_name;
          };

        Consider now the task of writing a function to print unique elements of an
        std::vector<City>, ordered by name:
          void printUniqueCitiesOrderedByName(const std::vector<City>& cities)
          {
          struct OrderByName
          {
          bool operator()(const City& lhs, const City& rhs) const
          {
          return lhs.d_name < rhs.d_name;
          // increasing order (subject to change)
          }
          };

          const std::set<City, OrderByName> tmp(cities.begin(), cities.end());

          std::copy(tmp.begin(), tmp.end(),
          std::ostream_iterator<City>(std::cout, '\n'));
          }

        Absent any countervailing reasons to make the OrderByName function object more generally
        available, rendering its definition alongside the one place where it is used — i.e., directly
        within function scope — again enforces and readily communicates its tightly encapsulated
        (and therefore malleable) status.

        Configuring algorithms via lambda expressions
        Suppose we are representing a 3D environment using a scene graph94 and managing the
        graph’s nodes via an std::vector of SceneNode objects. Our SceneNode class supports
        a variety of const member functions used to query its status (e.g., isDirty and isNew).
        Our task is to implement a predicate function, mustRecalculateGeometry, that returns
        true if and only if at least one of the nodes is either “dirty” or “new.”
           These days, we might reasonably elect to implement this functionality using the (C++11)
        standard algorithm std::any_of95 :
          template <typename InputIterator, typename UnaryPredicate>
          bool any_of(InputIterator first, InputIterator last, UnaryPredicate pred);
          // Return true if any of the elements in the range satisfies pred.

          94 A  scene graph data structure, commonly used in computer games and 3D-modeling software, represents
        the logical and spatial hierarchy of objects in a scene.
           95 cppreferencea

                                                                                                           111


i



    i                                                                                                              i
    i                                                                                              i
                      “emcpps-internal” — 2021/1/16 — 3:34 — page 112 — #114

i



        Local Types '11                                             Chapter 1    Safe Features


        Prior to C++11, however, use of a function template, such as any_of, would have required
        a separate function or function object (defined outside of the scope of the function):
         namespace {

         struct IsNodeDirtyOrNew
         {
         bool operator()(const SceneNode& node) const
         {
         return node.isDirty() || node.isNew();
         }
         };

         }   // close unnamed namespace

         bool mustRecalculateGeometry(const std::vector<SceneNode>& nodes)
         {
         return std::any_of(nodes.begin(), nodes.end(), IsNodeDirtyOrNew());
         }

        In C++11, not only can we embed the function object within the scope of the function
        but, by using a lambda expression, we can remove much of the boilerplate, including the
        enclosing struct:
         bool mustRecalculateGeometry(const std::vector<SceneNode>& nodes)
         {
         return std::any_of(nodes.begin(),             // start of range
         nodes.end(),               // end of range
         [](const SceneNode& node) // lambda expression
         {
         return node.isDirty() || node.isNew();
         }
         );
         }

        By creating a closure of unnamed type via a lambda expression, unnecessary boilerplate,
        excessive scope, and even local symbol visibility are avoided.

        Potential Pitfalls
        None so far

        Annoyances
        None so far

        See Also
          • Section 2, “Lambdas” — Conditionally safe C++11 feature providing strong practical
            motivation for the relaxations discussed here
                                                  112


i



    i                                                                                              i
    i                                                                                          i
                      “emcpps-internal” — 2021/1/16 — 3:34 — page 113 — #115

i



        C++11                                                                Local Types '11


          • Section 1, “decltype” — Safe C++11 feature that allows developers to query the
            type of any expression or entity, including objects with unnamed types

        Further Reading
        None so far




                                                                                        113


i



    i                                                                                          i
    i                                                                                                              i
                       “emcpps-internal” — 2021/1/16 — 3:34 — page 114 — #116

i



        long long                                                              Chapter 1      Safe Features



        The long long (≥64 bits) Integral Type
        long long is a fundamental integral type guaranteed to have (at least) 64 bits on all
        platforms.

        Description
        The integral type long long and its companion type unsigned long long are the only
        two fundamental integral types in C++ that are guaranteed to have at least 64 bits on
        all conforming platforms96 :
          #include <climits>       // CHAR_BIT (a.k.a.~8, see below)

          long long          a;        // sizeof(a) * CHAR_BIT >= 64
          unsigned long long b;        // sizeof(b) * CHAR_BIT >= 64

          static_assert(sizeof(a) == sizeof(b), "");
          // I.e., a and b necessarily have the same size in every program.

        On all conforming platforms, CHAR_BIT — the number of bits in a byte — is at least 8
        and, on virtually all commonly available commercial platforms today, is exactly 8, as is
        sizeof(long long).
           The corresponding integer-literal suﬀixes indicating type long long are ll and LL; for
        unsigned long long, any of eight alternatives are accepted: ull, ULL, uLL, Ull, llu, LLU,
        LLu, llU97 :
          auto i = 0LL;      // long long, sizeof(i) * CHAR_BIT >= 64
          auto u = 0uLL      // unsigned long long, sizeof(u) * CHAR_BIT >= 64

        For a historical perspective on how integral types have evolved (and continue to evolve) over
        time, see Appendix: Historical Perspective on the Evolution of Use of Fundamental Integral
        Types on page 117.

        Use Cases
        When your pedestrian four-byte int might not cut it
        Deciding when an int (i.e., exactly 32 bits) is big enough is often a nonissue. For most
        common things we deal with day to day — miles on our car, years of age, bottles of wine
        — having more than about a billion of them just isn’t worth thinking about, at least not
        in the interface.98 Sometimes the size of the virtual address space for the underlying ar-
        chitecture itself dictates how large an integer you will need. For example, specifying the
        distance between two pointers into a contiguous array or the size of the array itself could,
          96 long long has been available in C since the C99 standard, and many C++ compilers supported it as

        an extension prior to C++11.
          97 Note that long long and unsigned long long are also candidates for the type of an integer literal

        having a large enough value. As an example, the type of the literal 2147483648 (one more than the upper
        bound of a 32-bit integer) is likely to be long long on a 32-bit platform.
          98 For eﬀicient storage in a class or struct, however, we may well decide to represent such quantities

        more compactly using a short or char; see also the aliases found in C++11’s <cstdint>.
                                                          114


i



    i                                                                                                              i
    i                                                                                                                   i
                      “emcpps-internal” — 2021/1/16 — 3:34 — page 115 — #117

i



        C++11                                                                                           long long


        on a 64-bit platform, well exceed the size of an int or unsigned int, respectively. Using
        either long long or unsigned long long here would, however, not be indicated as the re-
        spective platform-dependent integer types (typedefs) std::ptrdiff_t and std::size_t
        are provided expressly for such use (and avoid wasting space where it cannot be used by
        the underlying hardware).
            Occasionally, however, the decision of whether to use an int is neither platform depen-
        dent nor clear cut, in which case using an int is almost certainly a bad idea. As part of a
        financial library, suppose we were asked to provide a function that, given a date, returns
        the number of shares of some particular stock, identified by its security id (SecId) traded
        on the New York Stock Exchange (NYSE).99 Since the average daily rate for even the most
        heavily traded stocks (roughly 70 million) appears to be well under the maximum value a
        signed int supports (more than 2 billion), we might at first think to write the function
        returning an int:
          int volYMD(SecId equity, int year, int month, int day);                     // (1) BAD IDEA

        One obvious problem with this interface is that the daily fluctuations in turbulent times
        might exceed the maximum value representable by a 32-bit int, which, unless detected
        internally, would result in signed integer overflow, which is both undefined behavior
        and a potential security hole.100 What’s more, the growth rate of some companies, especially
        technology companies, such as AAPL, GOOG, FB, AMZN, and MSFT, has been at times
        seemingly exponential. To gain an extra insurance factor of two, we might opt to replace
        the return type int with an unsigned int:
          unsigned volYND(SecId stock, int year, int month, int day);                      // (2) BAD IDEA!

        Use of an unsigned int, however, simply delays the inevitable as the number of shares
        being traded is almost certainly going to grow over time.
            Furthermore, the algebra for unsigned quantities is entirely different from what one would
        normally expect from an int. For example, if we were to try to express the day-over-day
        increase in volume by subtracting two calls to this function and if the number of shares
        traded were to have decreased, then the unsigned int difference would wrap and the result
        would be a (typically) large unsigned garbage value.101
            If we happen to be on a 64-bit platform, we might choose to return a long:
          long volYMD(SecId stock, int year, int month, int day);                     // (3) NOT A GOOD IDEA

           99 The NYSE consists of 2400 different (Equity) securities. The average daily trading volume (the number

        of shares traded on a given day) on the NYSE is typically between 2? and 6? billion shares per day, with the
        maximum volume reaching ??? on ???. (TODO, TBD – will fill this in much later. NOTE: from Harry: “it
        looks like the numbers you are referencing are for the NYSE Composite – i.e., the volume of all shares traded
        in companies listed at the NYSE. That number is significantly higher than the number of shares traded on
        the NYSE exchange. That is because NYSE shares can trade on other exchanges. With that proviso, over
        the past 5 years, NYSE Composite trading volume has averaged 3.8 billion shares per day. The highest
        volume day was March 20, 2020, when just over 9 billion shares were traded.”)
          100 Signed integer overflow is among the most pervasive kinds of defects enabling avenues of deliberate

        attack from outside sources. For an overview of integer overflow in C++, see ballman. For a more focused
        discussion of secure coding in CPP using CERT standards, see seacord13, section x, pp. yy-zz.
          101 Because integer literals are themselves of type int and not unsigned, comparing an unsigned value

        with a negative signed one does not typically go well; hence, many compilers will warn when the two types
        are mixed, which itself is problematic.
                                                                                                                115


i



    i                                                                                                                   i
    i                                                                                                                i
                        “emcpps-internal” — 2021/1/16 — 3:34 — page 116 — #118

i



        long long                                                               Chapter 1      Safe Features


        The problems using long as the return type are that it (1) is not (yet) generally consid-
        ered a vocabulary type (see Appendix: Historical Perspective on the Evolution of Use of
        Fundamental Integral Types on page 117), and (2) would reduce portability (see Potential
        Pitfalls: Relying on the relative sizes of int, long, and long long on page 116).
            Prior to C++11, we might have considered returning a double:
          double volYMD(SecId stock, int year, int month, int day);                   // (4) OK

        At least with double we know that we will have (at no additional size) suﬀicient precision
        (53 bits) to express integers accurately into the quadrillions, which will certainly cover us
        for any foreseeable future. The main drawback is that double doesn’t properly describe the
        nature of the type that we are returning — i.e., a whole integer number of shares — and so
        its algebra, although not as dubious as unsigned int, isn’t ideal either.
            With the advent of C++11, we might consider using one of the type aliases in <cstdint>:
          std::int64_t volYMD(SecId stock, int year, int month, int day);                     // (4) OK

        This choice addresses most of the issues discussed above except that, instead of being a
        specific C++ type, it is a platform-dependent alias that is likely to be a long on a 64-bit
        platform and almost certainly a long long on a 32-bit one. Such exact size requirements
        are often necessary for packing data in structures and arrays but are not as useful when rea-
        soning about them in the interfaces of functions where having a common set of fundamental
        vocabulary types becomes much more important (e.g., for interoperability).
            All of this leads us to our final alternative, long long:
          long long volYMD(SecId stock, int year, int month, int day);                    // (5) GOOD IDEA

        In addition to being a signed fundamental integral type of suﬀicient capacity on all platforms,
        long long is the same C++ type relative to other C++ types on all platforms.

        Potential Pitfalls
        Relying on the relative sizes of int, long, and long long
        As discussed at some length in Appendix: Historical Perspective on the Evolution of Use
        of Fundamental Integral Types on page 117, the fundamental integral types have histor-
        ically been a moving target. On older, 32-bit platforms, a long was often 32 bits and,
        prior to C++11, a (nonstandard) long long (or its platform-dependent equivalent) was
        needed to ensure that 64 bits were available. When the correctness of code depends on ei-
        ther sizeof(int) < sizeof(long) or sizeof(long) < sizeof(long long), portability is
        needlessly restricted. Relying instead on only the guaranteed102 property that sizeof(int)
        < sizeof(long long) avoids such portability issues since the relative sizes of the (funda-
        mental) long and long long integral types continue to evolve.
            When precise control of size in the implementation (as opposed to in the interface)
        matters, consider using one of the standard signed (int*n*_t) or unsigned (uint*n*_t)
        integer aliases (typedefs) provided (since C++11) in <cstdint> and summarized here in
        Table 3.
          102 Due to the unfathomable amount of software that would stop working if an int were ever anything but

        exactly four bytes, we — along with the late Richard Stevens of Unix fame (see stevens93, section 2.5.1.,
        pp. 31–32, specifically row 6, column 4, Figure 2.2, p. 32) — are prepared to guarantee that it will never
        become as large as a long long for any general-purpose computer.
                                                           116


i



    i                                                                                                                i
    i                                                                                                                    i
                       “emcpps-internal” — 2021/1/16 — 3:34 — page 117 — #119

i



        C++11                                                                                            long long


               Table 3: Useful typedefs found in <cstdint> (since C++11)

                   Exact Size   Fastest (signed) integral type          Smallest (signed) integer type
                                    having at least N bits                 having at least N bits
                     int8_t                int_fast8_t                             int_least8_t
                    int16_ta              int_fast16_t                            int_least16_t
                    int32_t               int_fast32_t                            int_least32_t
                    int64_t               int_fast64_t                            int_least64_t
               aoptional
               Note: Also see intmax_t, the maximum width integer type, which might be none of the above.




        See Also
           • Section 1, “Digit Separators” — Safe C++11 feature that can help with visually
             separating digits of large long long literals
           • Section 1, “Binary Literals” — Safe C++11 feature that allows programmers to specify
             binary constants directly in the source code; large binary values might only fit in a
             long long or even unsigned long long

        Further Reading
        None so far

        Appendix: Historical Perspective on the Evolution of Use of Funda-
        mental Integral Types
        The designers of C got it right back in 1972 when they created a portable int type that
        could act as a bridge from a single-word (16-bit) integer, short, to a double-word (32-bit)
        integer, long. Just by using int, one would get the optimal space versus speed trade-off as
        the 32-bit computer word was on its way to becoming the norm.103
            During the late 1980s and into the 1990s, the word size of the machine and the size of an
        int were synonymous.104 As cost of main memory was decreasing exponentially throughout

          103 The Motorola 68000 series (c. 1979) was a hybrid CISC architecture employing a 32-bit instruction set

        with 32-bit registers and a 32-bit external data bus; internally, however, it used only 16-bit ALUs and a
        16-bit data bus.
          104 Some of the earlier mainframe computers, such as IBM 701 (c. 1954), had a word size of 36 characters

        (1) to allow accurate representation of a signed 10-digit decimal number or (2) to hold up to six 6-bit
        characters. Smaller computers, such as Digital Equipment Corporation’s PDP-1/PDP-9/PDP-15 used 18-
        bit words (so a double word held 36-bits); memory addressing, however, was limited to just 12–18 bits
        (i.e., a maximum 4K–256K 18-bit words of DRAM). With the standardization of 7-bit ASCII (c. 1967),
        its adoption throughout the 1970s, and its most recent update (c. 1986), the common typical notion of
        character size moved from 6 to 7 bytes. Some early conforming implementations (of C) would choose to set
        CHAR_BIT to 9 to allow two characters per half word. (On some early vector-processing computers, CHAR_BIT
        is 32, making every type, including a char, at least a 32-bit quantity.) As double-precision floating (and
        floating-point coprocessors) for type double became typical for scientific calculations, machine architectures
        naturally evolved from 9-, 18-, and 36-bit words to the familiar 8-, 16-, 32-, and now 64-bit addressable
                                                                                                                 117


i



    i                                                                                                                    i
    i                                                                                                                  i
                        “emcpps-internal” — 2021/1/16 — 3:34 — page 118 — #120

i



        long long                                                                Chapter 1       Safe Features


        the final two decades of the 20th century,105 the need for a much larger virtual address space
        quickly followed. Intel began its work on 64-bit architectures in the early 1990s and realized
        one a decade later. As we progressed into the 2000s, the common notion of word size — i.e.,
        the width (in bits) of typical registers within the CPU itself — began to shift from “the size
        of an int” to “the size of a simple (nonmember) pointer type,” e.g., 8 * sizeof(void*),
        on the host platform. By this time, 16-bit int types (like 16-bit architectures) were long
        gone, but long was still expected to be 32 bits on a 32-bit platform.106
            Something new was needed to mean at least 64-bits on all platforms. Enter long long.
        We have now come full circle. On 64-bit platforms, an int is still 4 bytes, but a long is now
        — for practical reasons — typically 8 bytes unless requested explicitly107 to be otherwise. To
        ensure portability until 32-bit machines go the way of 16-bit ones, we have long long to (1)
        provide a common vocabulary type, (2) make our intent clear, and (3) avoid the portability
        issue for at least the next decade or two; still, see Potential Pitfalls: Relying on the relative
        sizes of int, long, and long long on page 116 for some alternative ideas.




        integer words we have today. Apart from embedded systems and DSPs, a char is now almost universally
        considered to be exactly 8 bits. Instead of scrupulously and actively using CHAR_BIT for the number of bits
        in a char, consider statically asserting it instead:
          static_assert(CHAR_BIT == 8, "A char is not 8­bits on this CrAzY platform!");

          105 Moore’s law (c. 1965) — the observation that the number of transistors in densely packed integrated

        circuits (e.g., DRAM) grows exponentially over time, doubling every 1–2 years or so — held for nearly a
        half century, until finally saturating in the 2010s.
          106 Sadly, long was often used (improperly) to hold an address; hence, the size of long is associated with

        a de facto need (due to immeasurable amounts of legacy code) to remain in lockstep with pointer size.
          107 On 64-bit systems, sizeof(long) is typically 8 bytes. Compiling with the ­m32 flag on either GCC or

        Clang emulates compiling on a 32-bit platform: sizeof(long) is likely to be 4, while sizeof(long long)
        remains 8.
                                                            118


i



    i                                                                                                                  i
    i                                                                                                     i
                    “emcpps-internal” — 2021/1/16 — 3:34 — page 119 — #121

i



        C++11                                                                               noreturn




        The [[noreturn]] Attribute
        The [[noreturn]] attribute promises that the function to which it pertains never returns.

        Description
        The presence of the standard [[noreturn]] attribute as part of a function declaration in-
        forms both the compiler and human readers that such a function never returns control flow
        to the caller:
          [[noreturn]] void f()
          {
          throw 1;
          }

        The [[noreturn]] attribute is not part of a function’s type and is also, therefore, not part of
        the type of a function pointer. Applying [[noreturn]] to a function pointer is not an error,
        though doing so has no actual effect in standard C++; see Potential Pitfalls — Misuse of
        [[noreturn]] on function pointers on page 121. Use on a pointer might have benefits for
        external tooling, code expressiveness, and future language evolution:
          void (*fp [[noreturn]])() = f;



        Use Cases
        Better compiler diagnostics
        Consider the task of creating an assertion handler that, when invoked, always aborts ex-
        ecution of the program after printing some useful information about the source of the as-
        sertion. Since this specific handler will never return because it unconditionally invokes a
        [[noreturn]]std::abort function, it is a viable candidate for [[noreturn]]:

          [[noreturn]] void abortingAssertionHandler(const char* filename, int line)
          {
          LOG_ERROR << "Assertion fired at " << filename << ':' << line;
          std::abort();
          }

        The additional information provided by the attribute will allow a compiler to warn if it
        determines that a code path in the function would allow it to return normally:
          [[noreturn]] void abortingAssertionHandler(const char* filename, int line)
          {
          if (filename)
          {
          LOG_ERROR << "Assertion fired at " << filename << ':' << line;
          std::abort();
          }
          } // compile­time warning made possible
                                                                                                   119


i



    i                                                                                                     i
    i                                                                                                       i
                      “emcpps-internal” — 2021/1/16 — 3:34 — page 120 — #122

i



        noreturn                                                          Chapter 1     Safe Features


        This information can also be used to warn in case unreachable code is present after
        abortingAssertionHandler is invoked:

          int main()
          {
          // ...
          abortingAssertionHandler("main.cpp", __LINE__);
          std::cout << "We got here.\n"; // compile­time warning made possible
          // ...
          }

        Note that this warning is made possible by decorating just the declaration of the handler
        function — i.e., even if the definition of the function is not visible in the current translation
        unit.

        Improved runtime performance
        If the compiler knows that it is going to invoke a function that is guaranteed not to return,
        the compiler is within its rights to optimize that function by removing what it can now
        determine to be dead code. As an example, consider a utility component, util, that defines
        a function, throwBadAlloc, that is used to insulate the throwing of an std::bad\_alloc
        exception in what would otherwise be template code fully exposed to clients:
          // util.h:
          [[noreturn]] void throwBadAlloc();

          // util.cpp:
          #include <util.h>     // [[noreturn]] void throwBadAlloc()

          #include <new>       // std::bad_alloc

          void throwBadAlloc() // This redeclaration is also [[noreturn]].
          {
          throw std::bad_alloc();
          }

        The compiler is within its rights to elide code that is rendered unreachable by the call to the
        throwBadAlloc function due to the function being decorated with the [[noreturn]] attribute
        on its declaration:
          #include <util.h>     // [[noreturn]] void throwBadAlloc()

          void client()
          {
          // ...
          throwBadAlloc();
          // ... (Everything below this line can be optimized away.)
          }

        Notice that even though [[noreturn]] appeared only on the first declaration (in the util.h
        header), the [[noreturn]] attribute carries over to the redeclaration used in the
                                                       120


i



    i                                                                                                       i
    i                                                                                                    i
                      “emcpps-internal” — 2021/1/16 — 3:34 — page 121 — #123

i



        C++11                                                                              noreturn


        throwBadAlloc   function’s definition because the header was included in the corresponding
        .cpp file.

        Potential Pitfalls
        [[noreturn]] can inadvertently break an otherwise working program
        Unlike many attributes, use of [[noreturn]] can alter the semantics of a well-formed pro-
        gram, potentially introducing a runtime defect and/or making the program ill-formed. If a
        function that can potentially return is decorated with [[noreturn]] and then, in the course
        of executing a program, it ever does return, that behavior is undefined.
            Consider a printAndExit function whose role is to print a fatal error message before
        aborting the program:
          [[noreturn]] void printAndExit()
          {
          std::cout << "Fatal error. Exiting the program.\n";
          assert(false);
          }
        The programmer chose to (sloppily) implement termination by using an assertion, which
        would not be incorporated into a program compiled with the preprocessor definition NDEBUG
        active, and thus printAndExit would return normally in such a build mode. If the compiler
        of the client is informed that function will not return, the compiler is free to optimize
        accordingly. If the function then does return, any number of hard-to-diagnose defects (e.g.,
        due to incorrectly elided code) might materialize as a consequence of the ensuing undefined
        behavior. Furthermore, if a function is declared [[noreturn]] in some translation units
        within a program but not in others, that program is ill-formed, no diagnostic required.

        Misuse of [[noreturn]] on function pointers
        Although the [[noreturn]] attribute is permitted to syntactically appertain to a function
        pointer for the benefit of external tools, it has no effect in standard C++; fortunately, most
        compilers will issue a warning:
          void (*fp [[noreturn]])();      // no effect in standard C++ (will likely warn)
        What’s more, assigning the address of a function that is not decorated with [[noreturn]]
        to an otherwise suitable function pointer that is so decorated is perfectly fine:
          void f() { return; };     // function that always returns

          void g()
          {
          fp = f; // [[noreturn]] on fp is silently ignored.
          }
        Any reliance on [[noreturn]] to have any effect in standard C++ when applied to other
        than a function’s declaration is misguided.

        Annoyances
        None so far
                                                                                                  121


i



    i                                                                                                    i
    i                                                                                         i
                      “emcpps-internal” — 2021/1/16 — 3:34 — page 122 — #124

i



        noreturn                                                Chapter 1   Safe Features


        See Also
          • “Attribute Syntax” (Section 1.1, p. 12) ♦ To learn more about allowed attribute
            placement in general

        Further Reading
        None so far




                                               122


i



    i                                                                                         i
    i                                                                                                  i
                       “emcpps-internal” — 2021/1/16 — 3:34 — page 123 — #125

i



        C++11                                                                                nullptr




        The Null-Pointer-Literal Keyword
        The keyword nullptr unambiguously denotes the null-pointer-value literal.

        Description
        The nullptr keyword is a prvalue (pure rvalue) of type std::nullptr_t representing the
        implementation-defined bit pattern corresponding to a null address on the host platform;
        nullptr and other values of type std::nullptr_t, along with the integer literal 0 and the
        macro NULL, can be converted implicitly to any pointer or pointer-to-member type:
         #include <cstddef> // NULL
         int data; // nonmember data

         int    *pi0   =   &data;      // Initialize with non­null address.
         int    *pi1   =   nullptr;    // Initialize with null address.
         int    *pi2   =   NULL;       // "           "    "    "
         int    *pi3   =   0;          // "           "    "    "

         double f(int x);         // nonmember function

         double (*pf0)(int) = &f;                   // Initialize with non­null address.
         double (*pf1)(int) = nullptr;              // Initialize with null address.

         struct S
         {
         short d_data;           // member data
         float g(int y);         // member function
         };

         short S::*pmd0 = &S::d_data;           // Initialize with non­null address.
         short S::*pmd1 = nullptr;              // Initialize with null address.

         float (S::*pmf0)(int) = &S::g;               // Initialize with non­null address.
         float (S::*pmf1)(int) = nullptr;             // Initialize with null address.

        Because std::nullptr_t is its own distinct type, overloading on it is possible:
         #include <cstddef>           // std::nullptr_t

         void g(void*);                    // (1)
         void g(int);                      // (2)
         void g(std::nullptr_t);           // (3)

         void f()
         {
         char buf[] = "hello";
         g(buf);      // OK, (1) void g(void*)
         g(0);        // OK, (2) void g(int)
                                                                                                 123


i



    i                                                                                                  i
    i                                                                                                                  i
                        “emcpps-internal” — 2021/1/16 — 3:34 — page 124 — #126

i



        nullptr                                                                  Chapter 1       Safe Features


          g(nullptr);      // OK, (3) void g(std::nullptr_t)
          g(NULL);         // Error, ambiguous ­­­ (1), (2), or (3)
          }


        Use Cases
        Improvement of type safety
        In pre-C++11 codebases, using the NULL macro was a common way of indicating, mostly
        to the human reader, that the literal value the macro conveys is intended specifically to
        represent a null address rather than the literal int value 0. In the C Standard, the macro
        NULL is defined as an implementation-defined integral or void* constant. Unlike C, C++
        forbids conversions from void* to arbitrary pointer types and instead, prior to C++11,
        defined NULL as an “integral constant expression rvalue of integer type that evaluates to zero”;
        any integer literal (e.g., 0, 0L, 0U, 0LLU) satisfies this criterion. From a type-safety perspective,
        its implementation-defined definition, however, makes using NULL only marginally better
        suited than a raw literal 0 to represent a null pointer. It is worth noting that as of C++11,
        the definition of NULL has been expanded to — in theory — permit nullptr as a conforming
        definition; as of this writing, however, no major compiler vendors do so.108
            As just one specific illustration of the added type safety provided by nullptr, imagine
        that the coding standards of a large software company historically required that values
        returned via output parameters (as opposed to a return statement) are always returned via
        pointer to a modifiable object. Functions that return via argument typically do so to reserve
        the function’s return value to communicate status.109 A function in this codebase might
        “zero” the output parameter’s local pointer variable to indicate and ensure that nothing
        more is to be written. The function below illustrates three different ways of doing this:
          int illustrativeFunction(int* x)   // pointer to modifiable integer
          {
          // ...
          if (/*...*/)
          {
          x = 0;       // (1) Set pointer x to null address.
          x = NULL;    // (2) Set pointer x to null address.
          x = nullptr; // (3) Set pointer x to null address.
          }
          // ...
          return 0;    // success
          }

           Now suppose that the function signature is changed (e.g., due to a change in coding
        standards in the organization) to accept a reference instead of a pointer:
          int illustrativeFunction(int& x)             // reference to modifiable integer

         108 Both GCC and Clang default to 0L (long int), while MSVC defaults to 0 (int). Such definitions are

        unlikely to change since existing code could cease to compile or (possibly silently) present altered runtime
        behavior.
         109 See ?, section 9.1.11, pp. 621–628, specifically the Guideline at the bottom of p. 621: “Be consistent

        about returning values through arguments (e.g., avoid declaring nonconst reference parameters).”
                                                            124


i



    i                                                                                                                  i
    i                                                                                                   i
                    “emcpps-internal” — 2021/1/16 — 3:34 — page 125 — #127

i



        C++11                                                                               nullptr


          {
          // ...
          if (/*...*/)
          {
          x = 0;         // (1) always compiles; makes what x refers to 0
          x = NULL;      // (2) implementation­defined (might warn)
          x = nullptr;   // (3) always a compile­time error
          }
          // ...
          return 0;      // SUCCESS
          }

          As the example above demonstrates, how we represent the notion of a null address
        matters:

          1. 0 — Portable across all implementations but minimal type safety

          2. NULL — Implemented as a macro; added type safety (if any) is platform specific

          3. nullptr — Portable across all implementations and fully type-safe

        Using nullptr instead of 0 or NULL to denote a null address maximizes type safety and
        readability, while avoiding both macros and implementation-defined behavior.

        Disambiguation of (int)0 vs. (T*)0 during overload resolution
        The platform-dependent nature of NULL presents additional challenges when used to call a
        function whose overloads differ only in accepting a pointer or an integral type as the same
        positional argument, which might be the case, e.g., in a poorly designed third-party library:
          void uglyLibraryFunction(int* p);        // (1)
          void uglyLibraryFunction(int i);         // (2)

        Calling this function with the literal 0 will always invoke overload (2), but that might not
        always be what casual clients expect:
          void f()
          {
          uglyLibraryFunction(0);             //   unambiguously invokes (2)
          uglyLibraryFunction((int*) 0);      //   unambiguously invokes (1)
          uglyLibraryFunction(nullptr);       //   unambiguously invokes (1)
          uglyLibraryFunction(NULL);          //   anything! (platform­defined)
          uglyLibraryFunction(0L);            //   Error, ambiguous call (on all platforms)
          uglyLibraryFunction(0U);            //   Error, ambiguous call (on all platforms)
          }

        nullptr  is especially useful when such problematic overloads are unavoidable because it
        obviates explicit casts. (Note that explicitly casting 0 to an appropriately typed pointer —
        other than void* — was at one time considered by some to be a best practice, especially in
        C.)
                                                                                                 125


i



    i                                                                                                   i
    i                                                                                                      i
                      “emcpps-internal” — 2021/1/16 — 3:34 — page 126 — #128

i



        nullptr                                                          Chapter 1     Safe Features


        Overloading for a literal null pointer
        Being a distinct type, std::nullptr_t can itself participate in an overload set:
          #include <cstddef> // 'std::nullptr_t'
          void f(int* v);         // (1)
          void f(std::nullptr_t); // (2)

          void g()
          {
          int* ptr = nullptr;
          f(ptr);      // unambiguously invokes (1)
          f(nullptr); // unambiguously invokes (2)
          }

        Given the relative ease with which a nullptr can be converted to a typed pointer having the
        same null-address value, such overloads are dubious when used to control essential behavior.
        Nonetheless, we can envision such use to, say, aid in compile-time diagnostics when passing a
        null address would otherwise result in a runtime error (see Section 1.2.“Deleted Functions”
        on page 70):
          std::size_t strlen(const char* s;)
          // The behavior is undefined unless s is null­terminated.

          std::size_t strlen(std::nullptr_t) = delete;
          // Function is not defined but still participates in overload resolution.

        Another arguably safe use of such an overload for a nullptr is to avoid a null-pointer check.
        However, for cases where the client knows the address is null at compile time, better ways
        typically exist for avoiding the (often insignificant) overhead of testing for a null pointer at
        run time.

        Potential Pitfalls


        Annoyances


        See Also


        Further Reading
          • ?




                                                      126


i



    i                                                                                                      i
    i                                                                                                 i
                   “emcpps-internal” — 2021/1/16 — 3:34 — page 127 — #129

i



        C++11                                                                            override




        The override Member-Function Specifier
        The override keyword ensures that a member function overrides a corresponding virtual
        member function in a base class.

        Description
        The contextual keyword override can be provided at the end of a member-function dec-
        laration to ensure that the decorated function is indeed overriding a corresponding virtual
        member function in a base class, as opposed to hiding it or otherwise inadvertently intro-
        ducing a distinct function declaration:
         struct Base
         {
         virtual void f(int);
         void g(int);
         virtual void h(int) const;
         virtual void i(int) = 0;
         };

         struct DerivedWithoutOverride : Base
         {
         void f();             // hides Base::f(int) (likely mistake)
         void f(int);          // OK, implicitly overrides Base::f(int)

         void g();                // hides Base::g(int) (likely mistake)
         void g(int);             // hides Base::g(int) (likely mistake)

         void h(int);             // hides Base::h(int) const (likely mistake)
         void h(int) const;       // OK, implicitly overrides Base::h(int) const

         void i(int);             // OK, implicitly overrides Base::i(int)
         };

         struct DerivedWithOverride : Base
         {
         void f()          override;    // Error, Base::f() not found
         void f(int)       override;    // OK, explicitly overrides Base::f(int)

         void g()             override;     // Error, Base::g() not found
         void g(int)          override;     // Error, Base::g() is not virtual.

         void h(int)       override;        // Error, Base::h(int) not found
         void h(int) const override;        // OK, explicitly overrides Base::h(int)

         void i(int)          override;     // OK, explicitly overrides Base::i(int)
         };

                                                                                               127


i



    i                                                                                                 i
    i                                                                                                      i
                      “emcpps-internal” — 2021/1/16 — 3:34 — page 128 — #130

i



        override                                                         Chapter 1     Safe Features


        Using this feature expresses design intent so that (1) human readers are aware of it and (2)
        compilers can validate it.
            As noted, override is a contextual keyword. C++11 introduces keywords that have
        special meaning only in certain contexts. In this case, override is a keyword in the context
        of a declaration, but not otherwise using it as the identifier for a variable name, for example,
        is perfectly fine:
          int override = 1;     // OK


        Use Cases
        Ensuring that a member function of a base class is being overridden
        Consider the following polymorphic hierarchy of error-category classes, as we might have
        defined them using C++03:
          struct ErrorCategory
          {
          virtual bool equivalent(const ErrorCode& code, int condition);
          virtual bool equivalent(int code, const ErrorCondition& condition);
          };

          struct AutomotiveErrorCategory : ErrorCategory
          {
          virtual bool equivalent(const ErrorCode& code, int condition);
          virtual bool equivolent(int code, const ErrorCondition& condition);
          };

        Notice that there is a defect in the last line of the example above: equivalent has been
        misspelled. Moreover, the compiler did not catch that error. Clients calling equivalent on
        AutomotiveErrorCategory will incorrectly invoke the base-class function. If the function in
        the base class happens to be defined, the code might compile and behave unexpectedly at
        run time. Now, suppose that over time the interface is changed by marking the equivalence-
        checking function const to bring the interface closer to that of std::error_category:
          struct ErrorCategory
          {
          virtual bool equivalent(const ErrorCode& code, int condition) const;
          virtual bool equivalent(int code, const ErrorCondition& condition) const;
          };

           Without applying the corresponding modification to all classes deriving from
        ErrorCategory,  the semantics of the program change due to the derived classes now hiding
        the base class’s virtual member function instead of overriding it. Both errors discussed
        above would be detected automatically if the virtual functions in all derived classes were
        decorated with override:
          struct AutomotiveErrorCategory : ErrorCategory
          {
          bool equivalent(const ErrorCode& code, int condition) override;
          // compile­time error when base class changed
                                                      128


i



    i                                                                                                      i
    i                                                                                                     i
                    “emcpps-internal” — 2021/1/16 — 3:34 — page 129 — #131

i



        C++11                                                                               override



          bool equivolent(int code, const ErrorCondition& code) override;
          // compile­time error when first written
          };

        What’s more, override serves as a clear indication of the derived-class author’s intent to
        customize the behavior of ErrorCategory. For any given member function, using override
        necessarily renders any use of virtual for that function syntactically and semantically re-
        dundant. The only cosmetic reason for retaining virtual in the presence of override would
        be that virtual appears to the left of the function declaration, as it always has, instead of
        all the way to the right, as override does now.

        Potential Pitfalls
        Lack of consistency across a codebase
        Relying on override as a means of ensuring that changes to base-class interfaces are propa-
        gated across a codebase can prove unreliable if this feature is used inconsistently — i.e., not
        applied in every circumstance where its use would be appropriate. In particular, altering the
        signature of a virtual member function in a base class and then compiling “the world” will
        always flag as an error any nonmatching derived-class function where override was used
        but might fail even to warn where it is not.

        Annoyances


        See Also


        Further Reading
          • ?
          • ?




                                                                                                   129


i



    i                                                                                                     i
    i                                                                                                                        i
                         “emcpps-internal” — 2021/1/16 — 3:34 — page 130 — #132

i



        Raw String Literals '14                                                      Chapter 1        Safe Features



        Syntax for Unprocessed String Contents
        Raw string literals obviate the need to escape each contained special character individually.

        Description
        A raw string literal is a new form of syntax for string literals that allows developers to
        embed arbitrary character sequences in a program’s source code, without having to modify
        them by escaping individual special characters. As an introductory example, suppose that
        we want to write a small program to print out a line of code:
          printf("Hello, %s%c\n", "World", '!');

        In C++03, capturing the C statement above in a string literal would require five escape (\)
        characters distributed throughout the string:
          #include <iostream>          // std::cout, std::endl

          int main()
          {
          std::cout << "printf(\"Hello, %s%c\\n\", \"World\", '!');" << std::endl;
          return 0; //         ^            ^ ^    ^      ^
          //             escaped characters
          }

        If we use C++11’s raw string-literal syntax, no escaping is required:
          #include <iostream>          // std::cout, std::endl

          int main()
          {
          std::cout << R"(printf("Hello, %s%c\n", "World", '!');)" << std::endl;
          return 0; //^ ^                                       ^
          //   additional raw string­literal syntax (C++11)
          }

        To represent the original character data as a raw string literal, we typically need only to add
        a capital R immediately (adjacently) before the starting quote (") and nest the character
        data within parentheses, ( ) (with some exceptions; see Collisions on page 131). Sequences of
        characters that would be escaped in a regular string literal are instead interpreted verbatim:
          const char s0[] = R"({ "key": "value" })";
          // OK, equivalent to "{ \"key\": \"value\" }"

        In contrast to conventional string literals, raw string literals (1) treat unescaped embedded
        double quotes (") as literal data, (2) do not interpret special-character escape sequences (e.g.,
        \n, \t), and (3) interpret all whitespace characters (i.e., vertical110 as well as horizontal)
        present in the source file as part of the string contents111 :
          110 In conventional string literals, a new line in the source before the end of a string is considered an error.

        If new lines are desired, they must be represented with an escape sequence as \n.
          111 In this example, we assume that all trailing whitespace has been stripped since even trailing whitespace

        in a raw literal would be captured.
                                                               130


i



    i                                                                                                                        i
    i                                                                                                                 i
                     “emcpps-internal” — 2021/1/16 — 3:34 — page 131 — #133

i



        C++11                                                                              Raw String Literals '14


          const char s1[] = R"(line one
          line two
          line three)";
          // OK

        Note that any literal tab characters are treated the same as a \t and hence can be prob-
        lematic, especially when developers have inconsistent tab settings; see Potential Pitfalls:
        Unexpected indentation on page 133. Finally, all string literals are concatenated with adja-
        cent ones in the same way the conventional ones are in C++03:
          const char s2[] = R"(line one)"         "\n"
          "line two"           "\n"
          R"(    line three)";
          // OK, equivalent to "line one\nlinetwo\n    line three"


        Collisions
        Although unlikely, the data to be expressed within a string literal might itself have the
        character sequence )" embedded within it:
          printf("printf(\"Hello, World!\")")
          //                             ^^
          // The )" character sequence terminates a typical raw string literal.

        If we use the basic syntax for a raw string literal we will get a syntax error:
          const char s3[] = R"(printf("printf(\"Hello, World!\")"))";                     // collision
          //                                                    ^^
          //                       Syntax error after literal ends

        To circumvent this problem, we could escape every special character in the string separately,
        as in C++03, but the result is diﬀicult to read and error prone:
          const char s4[] = "printf(\"printf(\\\"Hello, World!\\\")\")";                        // error prone

        Instead, we can use the (extended) disambiguation syntax of raw string literals to resolve
        the issue:
          const char s5[] = R"###(printf("printf(\"Hello, World!\")"))###";                        // cleaner
                                                                                          112
        This disambiguation syntax allows us to insert an essentially arbitrary sequence of char-
        acters between the outermost quote/parentheses pairs that avoids the collision with the
        literal data when taken as a combined sequence (e.g., )###"):
          //                        delimiter and parenthesis
          //                  v~~~                             ~~~v
          const char s6[] = R"xyz(<­­ Literal String Data ­­>)xyz";
          //                ^      ^~~~~~~~~~~~~~~~~~~~~~~~~~^
          //                |           string contents
          //                |
          //                | uppercase R
         112 The delimiter of a raw string literal can comprise any member of the basic source character set
        except space, backslash, parentheses, and the control characters representing horizontal tab, vertical tab,
        form feed, and new line.
                                                                                                              131


i



    i                                                                                                                 i
    i                                                                                                  i
                       “emcpps-internal” — 2021/1/16 — 3:34 — page 132 — #134

i



        Raw String Literals '14                                       Chapter 1     Safe Features


        The value of s6 above is equivalent to "<­­ Literal String Data ­­>". Every raw string
        literal comprises these syntactical elements, in order:

          • an uppercase R

          • the opening double quotes, "

          • an optional arbitrary sequence of characters called the delimiter (e.g., xyz)

          • the opening parenthesis, (

          • the contents of the string

          • the closing parenthesis, )

          • the same delimiter (if any) specified previously (i.e., xyz, not reversed)

          • the closing double quotes, "

           The delimiter can be (and, in practice, very often is) an empty character sequence:
         const char s7[] = R"("Hello, World!")";
         // OK, equivalent to \"Hello, World!\"

        A nonempty delimiter (e.g., !) can be used to disambiguate any appearance of the )"
        character sequence within the literal data
         const char s8[] = R"!("­­­ R"(Raw literals are not recursive!)" ­­­")!";
         // OK, equivalent to \"­­­ R\"(Raw literals are not recursive!)\" ­­­\"

        Had an empty delimiter been used to initialize s8 (above), the compiler would have produced
        a (perhaps obscure) compile-time error:
         // error: decrement of read­only location

         const char s8[] = R"("­­­ R"(Raw literals are not recursive!)" ­­­")";
         //                                                              ^~

        In fact, it could turn out that a program with an unexpectedly terminated raw string literal
        could still be valid and compile quietly:
         printf(R"("Live­Free, don't (ever)","Die!");
         // Prints: "Live­Free, don't (ever

         printf((R"("Live­Free, don't (ever)","Die!"));
         // Prints: Die!

        Fortunately, examples like the one above are invariably contrived, not accidental.
                                                    132


i



    i                                                                                                  i
    i                                                                                                                    i
                      “emcpps-internal” — 2021/1/16 — 3:34 — page 133 — #135

i



        C++11                                                                                Raw String Literals '14


        Use Cases
        Embedding code in a C++ program
        When a source code snippet needs to be embedded as part of the source code of a C++
        program, use of a raw string literal can significantly reduce the syntactic noise that would
        otherwise be caused by repeated escape sequences. As an example, consider a regular ex-
        pression (for an online shopping product ID) represented as a conventional string literal:
          const char* productIdRegex = "[0­9]{5}\\(\".*\"\\)";
          // This regular expression matches strings like 12345("Product").

        Not only do the backslashes obscure the meaning to human readers, a mechanical transla-
        tion is often needed113 when transforming between source and data, introducing significant
        opportunities for human error. Using a raw string literal solves these problems:
          const char* productIdRegex = R"([0­9]{5}\(".*"\))";

        Another format that benefits from raw string literals is JSON, due to its frequent use of
        double quotes:
          const char* testProductResponse = R"(
          {
          "productId": "58215(\"Camera\")",
          "availableUnits": 5,
          "relatedProducts": ["59214(\"CameraBag\")", "42931(\"SdStorageCard\")"]
          })";

        With a conventional string literal, the JSON string above would require every occurrence
        of " and \ to be escaped and every new line to be represented as \n, resulting in visual
        noise, less interoperability with other tools accepting or producing JSON, and heightened
        risk during manual maintenance.
            Finally, raw string literals can also be helpful for whitespace-sensitive languages, such as
        Python (but see Potential Pitfalls: Encoding of new lines and whitespace on page 134):
          const char* testPythonInterpreterPrint = R"(def test():
          print("test printing from Python")
          )";


        Potential Pitfalls
        Unexpected indentation
        Consistent indentation and formatting of source code facilitates human comprehension of
        program structure. Space and tabulation (\t) characters114 used for the purpose of source
        code formatting are, however, always interpreted as part of a raw string literal’s contents:
          void emitPythonEvaluator(const std::string& expression)

          113 Such as when you want to copy the contents of the string literal into an online regular-expression

        validation tool.
          114 Always representing indentation as the precise number of spaces (instead of tab characters) — especially

        when committed to source-code control systems — goes a long way to avoiding this issue.
                                                                                                                 133


i



    i                                                                                                                    i
    i                                                                                                   i
                        “emcpps-internal” — 2021/1/16 — 3:34 — page 134 — #136

i



        Raw String Literals '14                                        Chapter 1     Safe Features


          {
          std::cout << R"(
          def evaluate():
          print("Evaluating...")
          return )" << expression;
          }

        Despite the intention of the programmer to aid readability by indenting the above raw string
        literal consistently with the rest of the code, the streamed data will contain a large number
        of spaces (or tabulation characters), resulting in an invalid Python program:
          def evaluate():
          print("Evaluating...")
          return someExpression
          # ^~~~~~
          # Error: excessive indentation

        Correct code would start unindented and then be indented the same number of spaces
        (e.g., exactly four):
          def evaluate():
          print("Evaluating...")
          return someExpression

        Correct — albeit visually jarring — code can be expressed with a single raw string literal,
        but visualizing the final output requires some effort:
          void emitPythonEvaluator(const char *expression)
          {
          std::cout << R"(def evaluate():
          print("Evaluating...")
          return )" << expression;
          }

        When more explicit control is desired, we can use a mixture of raw string literals and
        explicit new lines represented as conventional string literals:
          void emitPythonEvaluator2(const char *expression)
          {
          std::cout <<
          R"(def evaluate():)"                 "\n"
          R"(    print("Evaluating..."))"      "\n"
          R"(    return )" << expression;
          }


        Encoding of new lines and whitespace
        The intent of the feature is that new lines should map to a single \n character regardless of
        how new lines are encoded in the source file. The wording of the C++ Standard, however, is
        not entirely clear.115 While all major compiler implementations act in accordance with the
         115 miller13

                                                     134


i



    i                                                                                                   i
    i                                                                                                                  i
                      “emcpps-internal” — 2021/1/16 — 3:34 — page 135 — #137

i



        C++11                                                                               Raw String Literals '14


        original intent of the feature, relying on a specific new line encoding may lead to nonportable
        code until clarity is achieved.
            In a similar fashion, the type of whitespace characters (e.g., tabs versus spaces) used as
        part of a raw string literal can be significant. As an example, consider a unit test verifying
        that a string representing the status of the system is as expected:
          void verifyDefaultOutput()
          {
          const std::string output = System::outputStatus();
          const std::string expected = R"(Current status:
          ­ No violations detected.)";

          EXPECT(output == expected);
          }

        The unit test might pass for years, until, for instance, the company’s indentation style
        changes from tabulation characters to spaces, leading to a mismatch and thus test failures.116

        Annoyances
        None so far

        See Also
        None so far

        Further Reading
        None so far




          116 A well-designed unit test will typically be imbued with expected values, rather than values that were

        produced by the previous run. The latter is sometimes referred to as a benchmark test, and such tests are
        often implemented as diffs against a file containing output from a previous run. This file has presumably
        been reviewed and is known (believed) to be correct and is sometimes called the golden file. Though ill
        advised, when trying to get a new version of the software to pass the benchmark test and when the precise
        format of the output of a system changes subtly, the golden file may be summarily jettisoned — and the
        new output installed in its stead — with little if any detailed review. Hence, well-designed unit tests will
        often hard code exactly what is to be expected (nothing more or less) directly in the test-driver source
        code.
                                                                                                               135


i



    i                                                                                                                  i
    i                                                                                                             i
                       “emcpps-internal” — 2021/1/16 — 3:34 — page 136 — #138

i



        static_assert                                                         Chapter 1      Safe Features



        Compile-Time Assertions
        The static_assert keyword allows programmers to intentionally terminate compilation
        whenever a given compile-time predicate evaluates to false.

        Description
        Assumptions are inherent in every program, whether we explicitly document them or not. A
        common way of validating certain assumptions at runtime is to use the classic assert macro
        found in <cassert>. Such runtime assertions are not always ideal because (1) the program
        must already be built and running for them to even have a chance of being triggered and (2)
        executing a redundant check at runtime typically117 results in a slower program. Being
        able to validate an assertion at compile time avoids several drawbacks:

           1. Validation occurs at compile time within a single translation unit, and therefore doesn’t
              need to wait until a complete program is linked and executed.
           2. Compile-time assertions can exist in many more places than runtime assertions and
              are unrelated to program control flow.
           3. No runtime code will be generated due to a static_assert, so program performance
              will not be impacted.

        Syntax and semantics
        We can use static assertion declarations to conditionally trigger controlled compilation fail-
        ures depending on the truthfulness of a constant expression. Such declarations are in-
        troduced by the static_assert keyword, followed by a parenthesized list consisting of (1)
        a constant Boolean expression and (2) a mandatory (see Annoyances — Mandatory string
        literal on page 143) string literal, which will be part of the compiler diagnostics if the
        compiler determines that the assertion fails to hold:
          static_assert(true, "Never fires.");
          static_assert(false, "Always fires.");

        Static assertions can be placed anywhere in the scope of a namespace, block, or class:
          static_assert(1 + 1 == 2, "Never fires.");             // (global) namespace scope

          template <typename T>
          struct S
          {
          void f0()
          {
          static_assert(1 + 1 == 3, "Always fires.");             // block scope
          }
         117 It is not unheard of for a program having runtime assertions to run faster with them enabled than
        disabled. For example, asserting that a pointer is not null and enables the optimizer to elide all code
        branches that can be reached only if that pointer were null.
                                                         136


i



    i                                                                                                             i
    i                                                                                                         i
                    “emcpps-internal” — 2021/1/16 — 3:34 — page 137 — #139

i



        C++11                                                                            static_assert



          static_assert(!Predicate<T>::value, "Might fire.");             // class scope
          };

        Providing a non-constant expression to a static_assert is itself a compile-time error:
          extern bool x;
          static_assert(x, "Nice try.");        // Error: x is not a compile­time constant.


        Evaluation of static assertions in templates
        The C++ Standard does not explicitly specify at precisely what point during the compilation
        process static assertion declarations are evaluated.118 In particular, when used within the
        body of a template, a static_assert declaration might not be evaluated until template
        instantiation time. In practice, however, a static_assert that does not depend on any
        template parameters is essentially always119 evaluated immediately — i.e., as soon as it is
        parsed and irrespective of whether any subsequent template instantiations occur:
          void f1()
          {
          static_assert(false, "Impossible!");          // always evaluated immediately...
          }                                                 // even if f1() is never invoked

          template <typename T>
          void f2()
          {
          static_assert(false, "Impossible!");          // always evaluated immediately...
          }                                                 // even if f2() is never instantiated

        The evaluation of a static assertion that is located within the body of a class or function
        template and depends on at least one template parameter is almost always bypassed during
        its initial parse since the assertion predicate might evaluate to true or false depending on
        the template argument:
          template <typename T>
          void f3()
          {
          static_assert(sizeof(T) >= 8, "Size < 8.");           // depends on T
          }

        However, see Potential Pitfalls — Static assertions in templates can trigger unintended
        compilation failures on page 140. In the example above, the compiler has no choice but to
        wait until each time f3 is instantiated because the truth of the predicate will vary depending
        on the type provided:
          void g()
          {
          f3<double>();                     // OK
         118 By  “evaluated” here, we mean that the asserted expression is processed and its semantic truth
        determined.
         119 E.g., GCC 10.1, Clang 10.0, and MSVC 19.24

                                                                                                       137


i



    i                                                                                                         i
    i                                                                                                            i
                       “emcpps-internal” — 2021/1/16 — 3:34 — page 138 — #140

i



        static_assert                                                        Chapter 1      Safe Features


          f3<long double>();                 // OK
          f3<std::complex<float>>();         // OK
          f3<char>();                        // Error: static assertion failed: Size < 8.
          }

        The standard does, however, specify that a program containing any template definition
        for which no valid specialization exists is ill formed (no diagnostic required), which was
        the case for f2 but not f3, above. Contrast each of the h*n* definitions (below) with its
        correspondingly numbered f*n* definition (above)120 :
          void h1()
          {
          int a[!sizeof(int) ­ 1];        // same as int a[­1]; and is ill formed
          }

          template <typename T>
          void h2()
          {
          int a[!sizeof(int) ­ 1];        // always reported as a compile­time error
          }

          template <typename T>
          void h3()
          {
          int a[!sizeof(T) ­ 1];          // typically reported only if instantiated
          }

        Both f1 and h1 are ill-formed, non-template functions, and both will always be reported at
        compile time, albeit typically with decidedly different error messages as demonstrated by
        GCC 10.x’s output:
          f1: error: static assertion failed: Impossible!
          h1: error: size ­1 of array a is negative

        Both f2 and h2 are ill-formed template functions; the cause of their being ill formed has
        nothing to do with the template type and hence will always be reported as a compile-
        time error in practice. Finally, f3 can be only contextually ill formed whereas h3 is always
        necessarily ill formed, and yet neither is reported by typical compilers as such unless and until
        it has been instantiated. Reliance on a compiler not to notice that a program is ill formed
        is dubious; see Potential Pitfalls — Static assertions in templates can trigger unintended
        compilation failures on page 140.

        Use Cases
        Verifying assumptions about the target platform
        Some programs rely on specific properties of the native types provided by their target
        platform. Static assertions can help ensure portability and prevent such programs from

          120 The formula used, int a[­1]; leads to −1, not 0, to avoid a non-conforming extension to gcc that

        allows a[0].
                                                         138


i



    i                                                                                                            i
    i                                                                                                                i
                     “emcpps-internal” — 2021/1/16 — 3:34 — page 139 — #141

i



        C++11                                                                                  static_assert


        being compiled into a malfunctioning binary on an unsupported platform. As an example,
        consider a program that relies on the size of an int to be exactly 32 bits (e.g., due to the use
        of inline asm blocks). Placing a static_assert in namespace scope in any of the program’s
        translation units will (1) ensure that the assumption regarding the size of int is valid and
        (2) serve as documentation for readers:
          #include <ctype>       // CHAR_BIT

          static_assert(sizeof(int) * CHAR_BIT == 32,
          "An int must have exactly 32 bits for this program to work correctly.");

        More typically, statically asserting the size of an int avoids having to write code to handle an
        int type’s having greater or fewer bytes when no such platforms are likely ever to materialize:

          static_assert(sizeof(int) == 4, "An int must have exactly 4 bytes.");


        Preventing misuse of class and function templates
        Static assertions are often used in practice to constrain class or function templates to prevent
        their being instantiated with unsupported types by either substantially improving compile-
        time diagnostics121 or, more critically, actively avoiding erroneous runtime behavior.
           As an example, consider the SmallObjectBuffer<N> class templates, which provide stor-
        age, aligned properly using alignas (see Section 2.1.“alignas” on page 204), for arbitrary
        objects whose size does not exceed N122 :
          #include <cstddef> // for std:;size_t, std::max_align_t
          #include <new>

          template <std::size_t N>
          class SmallObjectBuffer
          {
          private:
          alignas(std::max_align_t) char d_buffer[N];

          public:
          template <typename T>
          void set(const T& object);

          // ...
          };

        To prevent buffer overruns, it is important that set accepts only those objects that will fit
        in d_buffer. The use of a static assertion in the set member function template catches —
        at compile time — any such misuse:
          121 Syntactically incompatible types often lead to absurdly long and notoriously hard-to-read diagnostic

        messages, especially when deeply nested template expressions are involved.
          122 A SmallObjectBuffer is similar to C++17’s std::any (?) in that it can store any object

        of any type. Instead of performing dynamic allocation to support arbitrarily sized objects, however,
        SmallObjectBuffer uses an internal fixed-size buffer, which can lead to better performance and cache
        locality provided (the maximum size of) all of the types involved is known.
                                                                                                             139


i



    i                                                                                                                i
    i                                                                                                     i
                      “emcpps-internal” — 2021/1/16 — 3:34 — page 140 — #142

i



        static_assert                                                   Chapter 1     Safe Features


          template <std::size_t N>
          template <typename T>
          void SmallObjectBuffer<N>::set(const T& object)
          {
          static_assert(sizeof(T) <= N, "object does not fit in the small buffer.");
          // Destroy existing object, if any, store how to destroy this new object of
          // type `T` later, then...
          new (&d_buffer) T(object);
          }

           The principle of constraining inputs can be applied to most class and function templates.
        static_assert is particularly useful in conjunction with standard type traits provided
        in <type_traits>. In the rotateLeft function template (below), we have used two static
        assertions to ensure that only unsigned integral types will be accepted:
          #include <ctype>    // CHAR_BIT

          template <typename T>
          T rotateLeft(T x)
          {
          static_assert(std::is_integral<T>::value, "T must be an integral type.");
          static_assert(std::is_unsigned<T>::value, "T must be an unsigned type.");

          return (x << 1) | (x >> (sizeof(T) * CHAR_BIT ­ 1));
          }


        Potential Pitfalls
        Static assertions in templates can trigger unintended compilation fail-
        ures
        As mentioned in the description, any program containing a template for which no valid spe-
        cialization can be generated is ill formed (no diagnostic required). Attempting to prevent
        the use of, say, a particular function template overload by using a static assertion that never
        holds produces such a program:
          template <bool>
          struct SerializableTag { };

          template <typename T>
          void serialize(char* buffer, const T& object, SerializableTag<true>);             // (1)

          template <typename T>
          void serialize(char* buffer, const T& object, SerializableTag<false>)             // (2a)
          {
          static_assert(false, "T must be serializable."); // independent of T
          // too obviously ill formed: always a compile­time error
          }

        In the example above, the second overload (2a) of serialize is provided with the intent
        of eliciting a meaningful compile-time error message in the event that an attempt is made
                                                      140


i



    i                                                                                                     i
    i                                                                                                     i
                    “emcpps-internal” — 2021/1/16 — 3:34 — page 141 — #143

i



        C++11                                                                         static_assert


        to serialize a nonserializable type. The program, however, is technically ill-formed and, in
        this simple case, will likely result in a compilation failure — irrespective of whether either
        overload of serialize is ever instantiated.
            A commonly attempted workaround is to make the predicate of the assertion somehow
        dependent on a template parameter, ostensibly forcing the compiler to withhold evaluation
        of the static_assert unless and until the template is actually instantiated (a.k.a. instan-
        tiation time):
          template <typename> // N.B., we make no use of the (nameless) type parameter:
          struct AlwaysFalse   // This class exists only to "outwit" the compiler.
          {
          enum { value = false };
          };

          template <typename T>
          void serialize(char* buffer, const T& object, SerializableTag<false>) // (2b)
          {
          static_assert(AlwaysFalse<T>::value, "T must be serializable."); // OK
          // less obviously ill formed: compile­time error when instantiated
          }

        To implement this version of the second overload, we have provided an intermediary class
        template AlwaysFalse that, when instantiated on any type, contains an enumerator named
        value, whose value is false. Although this second implementation is more likely to produce
        the desired result (i.e., a controlled compilation failure only when serialize is invoked with
        unsuitable arguments), suﬀiciently “smart” compilers looking at just the current translation
        unit would still be able to know that no valid instantiation of serialize exists and would
        therefore be well within their rights to refuse to compile this still technically ill-formed
        program.
           Equivalent workarounds achieving the same result without a helper class are possible.
          template <typename T>
          void serialize(char* buffer, const T& object, SerializableTag<false>)             // (2c)
          {
          static_assert(0 == sizeof(T), "T must be serializable."); // OK
          // not too obviously ill formed: compile­time error when instantiated
          }

        Use of this sort of obfuscation is not guaranteed to be either portable or future-proof.

        Misuse of static assertions to restrict overload sets
        Even if we are careful to fool the compiler into thinking that a specialization is wrong only
        if instantiated, we still cannot use this approach to remove a candidate from an overload set
        because translation will terminate if the static assertion is triggered. Consider this (flawed)
        attempt at writing a process function that will behave differently depending on the size of
        the given argument:
          template <typename T>
          void process(const T& x)      // (1) first definition of process function
                                                                                                   141


i



    i                                                                                                     i
    i                                                                                                               i
                        “emcpps-internal” — 2021/1/16 — 3:34 — page 142 — #144

i



        static_assert                                                          Chapter 1       Safe Features


          {
          static_assert(sizeof(T) <= 32, "Overload for small types");                   // BAD IDEA
          // ... (process small types)
          }

          template <typename T>
          void process(const T& x) // (2) compile­time error: redefinition of function
          {
          static_assert(sizeof(T) > 32, "Overload for big types");    // BAD IDEA
          // ... (process big types)
          }

        While the intention of the developer might have been to statically dispatch to one of the two
        mutually exclusive overloads, the ill-fated implementation above will not compile because the
        signatures of the two overloads are identical, leading to a redefinition error. The semantics of
        static_assert are not suitable for the purposes of compile-time dispatch and SFINAE-
        based approaches should be used instead.
            To achieve the goal of removing (up front) a specialization from consideration, we will
        need to employ SFINAE. To do that, we must instead find a way to get the failing compile-
        time expression to be part of the function’s declaration123 :
          template <bool> struct Check { };
          // helper class template having a (non­type) boolean template parameter
          // representing a compile­time predicate

          template <> struct Check<true> { typedef int Ok; };
          // specialization of Check that makes the type Ok manifest *only* if
          // the supplied predicate (boolean template argument) evaluates to true

          template <typename T,
          typename Check<(sizeof(T) <= 32)>::Ok = 0>              // SFINAE
          void process(const T& x) // (1)
          {
          // ... (process small types)
          }

          template <typename T,
          typename Check<(sizeof(T) > 32)>::Ok = 0>              // SFINAE
          void process(const T& x) // (2)
          {
          // ... (process big types)
          }

        The (empty) Check helper class template in conjunction with just one of its two possible
        specializations (above) conditionally exposes the Ok type alias only if the provided boolean
        template parameter evaluates to true. (Otherwise, by default, it does not.)
          123 C++11 provides a library function, std::enable_if, that more directly addresses this use case.

        Concepts — a language feature introduced in C++20 — provides a far less baroque alternative to SFINAE
        that allows for overload sets to be governed by the syntactic properties of their (compile-time) template
        arguments.
                                                          142


i



    i                                                                                                               i
    i                                                                                                    i
                       “emcpps-internal” — 2021/1/16 — 3:34 — page 143 — #145

i



        C++11                                                                         static_assert


            During the substitution phase of template instantiation, exactly one of the two over-
        loads of the process function will attempt to access a nonexisting Ok type alias via the
        Check<false> instantiation, which again, by default, is nonexistent. Although such an error
        would typically result in a compilation failure, in the context of template argument substi-
        tution it will instead result in only the offending overload’s being discarded, giving other
        (valid) overloads a chance to be selected:
          void client()
          {
          process(SmallType());          // discards (2), selects (1)
          process(BigType());            // discards (1), selects (2)
          }

        This general technique of pairing template specializations is used widely in modern C++
        programming. For another, often more convenient way of constraining overloads using ex-
        pression SFINAE, see Section 1.1.“Trailing Return” on page 144.

        Annoyances
        Mandatory string literal
        Many compilation failures caused by static assertions are self-explanatory since the offending
        line (which necessarily contains the predicate code) is displayed as part of the compiler
        diagnostic. In those situations, the message required124 as part of static_assert’s grammar
        is redundant:
          static_assert(std::is_integral<T>::value, "T must be an integral type.");

        Developers commonly provide an empty string literal in these cases:
          static_assert(std::is_integral<T>::value, "");

           There is no universal consensus as to the “parity” of the user-supplied error message.
        Should it re-state the asserted condition, or should it state what went amiss?
          static_assert(0 < x, "x is negative");
          // misleading when 0 == x


        See Also
          • “Trailing Return” (Section 1.1, p. 144) ♦ Safe C++11 feature that allows fine-
            grained control over overload resolution by enabling expression SFINAE as part of
            a function’s declaration

        Further reading
        None so far




         124 As   of C++17, the message argument of a static assertion is optional.
                                                                                                  143


i



    i                                                                                                    i
    i                                                                                                        i
                      “emcpps-internal” — 2021/1/16 — 3:34 — page 144 — #146

i



        Trailing Return                                                    Chapter 1   Safe Features



        Trailing Function Return Types
        Trailing return types provide a new alternate syntax in which the return type of a function
        is specified at the end of a function declaration (as opposed to at the beginning), thereby
        allowing it to reference function parameters by name and to reference class or namespace
        members without explicit qualification.

        Description
        C++11 offers an alternative function-declaration syntax in which the return type of a func-
        tion is located to the right of its signature (name, parameters, and qualifiers), offset by
        the arrow token (­>); the function itself is introduced by the keyword auto, which acts as a
        type placeholder:
          auto f() ­> void;        // equivalent to void f();

           When using the alternative, trailing-return-type syntax, any const, volatile and refer-
        ence qualifiers (see Section 3.1.“??” on page ??) are placed to the left of the ­> *<return­type>*
        and any contextual keywords, such as override and final (see Section 1.1.“override” on
        page 127 and Section 3.1.“??” on page ??), are placed to its right:
          struct Base
          {
          virtual int     e()   const;       //   const qualifier
          virtual int     f()   volatile;    //   volitile qualfier
          virtual int     g()   &;           //   *lvalue*­reference qualifier
          virtual int     h()   &&;          //   *rvalue*­reference qualifier
          };

          struct Derived : Base
          {
          auto e() const    ­> int          override;   //   override contextual keyword
          auto f() volatile ­> int          final;      //   final         "        "
          auto g() &        ­> int          override;   //   override      "        "
          auto h() &&       ­> int          final;      //   final         "        "
          };

        Using a trailing return type allows the parameters of a function to be named as part of the
        specification of the return type, which can be useful in conjunction with decltype:
          auto g(int x) ­> decltype(x);            // equivalent to int g(int x);

        When using the trailing-return-type syntax in a member function definition outside the
        class definition, names appearing in the return type, unlike with the classic notation, will
        be looked up in class scope by default:
          struct S
          {
          typedef int T;
          auto h1() ­> T;        // trailing syntax for member function
                                                         144


i



    i                                                                                                        i
    i                                                                                                              i
                     “emcpps-internal” — 2021/1/16 — 3:34 — page 145 — #147

i



        C++11                                                                                   Trailing Return


          T h2();              // classical syntax for member function
          };

          auto S::h1() ­> T { /*...*/ }          // equivalent to S::T S::h1() { /.../ }
          T    S::h2()      { /*...*/ }          // Error: T is unknown in this context.

        The same advantage would apply to a nonmember function125 defined outside of the name-
        space in which it is declared:
          namespace N
          {
          typedef int T;
          auto h3() ­> T;      // trailing syntax for free function
          T h4();              // classical syntax for free function
          };

          auto N::h3() ­> T { /*...*/ }          // equivalent to N::T N::h3() { /.../ }
          T    N::h4()      { /*...*/ }          // Error: T is unknown in this context.

           Finally, since the syntactic element to be provided after the arrow token is a separate
        type unto itself, return types involving pointers to functions are (somewhat) simplified.
        Suppose, for example, we want to describe a higher-order function, f, that takes as its
        argument a long long and returns a pointer to a function that takes an int and returns a
        double126 :

          // [function(long long) returning]
          //     [pointer to] [function(int x) returning] double   f;
          //     [pointer to] [function(int x) returning] double   f(long long);
          //                  [function(int x) returning] double *f(long long);
          //                                              double (*f(long long))(int x);

        Using the alternate trailing syntax, we can conveniently break the declaration of f into two
        parts: (1) the declaration of the function’s signature, auto f(long long), and (2) that of the
        return type, say, R for now:
          // [pointer to] [function (int) returning] double   R;
          //              [function (int) returning] double *R;
          //                                         double (*R)(int);

        The two equivalent forms of the same declaration are shown below:
          double (*f(long long))(int x);                   // classic return­type syntax
          auto f(long long) ­> double (*)(int);            // trailing return­type syntax

        Note that both syntactic forms of the same declaration may appear together within the
        same scope. Note also that not all functions that can be represented in terms of the trailing
        syntax have a convenient equivalent representation in the classic one:
          125 A static member function of a struct can be a viable alternative implementation to a free func-

        tion declared within a namespace; see ?, section 1.4, pp. 190–201, especially Figure 1-37c (p. 199), and
        section 2.4.9, pp. 312–321, especially Figure 2-23 (p. 316).
          126 Co-author John Lakos first used the shown verbose declaration notation while teaching Advanced

        Design and Programming using C++ at Columbia University (1991-1997).
                                                                                                           145


i



    i                                                                                                              i
    i                                                                                                       i
                      “emcpps-internal” — 2021/1/16 — 3:34 — page 146 — #148

i



        Trailing Return                                                   Chapter 1     Safe Features


          template <typename A, typename B>
          auto foo(A a, B b) ­> decltype(a.foo(b));
          // trailing return­type syntax

          template <typename A, typename B>
          decltype(std::declval<A&>().foo(std::declval<B&>())) foo(A a, B b);
          // classic return­type syntax (using C++11's std::declval)

        In the example above, we were essentially forced to use the (C++11) standard library
        template std::declval (?) to express our intent with the classic return-type syntax.

        Use Cases
        Function template whose return type depends on a parameter type
        Declaring a function template whose return type depends on the types of one or more of its
        parameters is not uncommon in generic programming. For example, consider a mathematical
        function that linearly interpolates between two values of (possibly) different types:
          template <typename A, typename B, typename F>
          auto linearInterpolation(const A& a, const B& b, const F& factor)
          ­> decltype(a + factor * (b ­ a))
          {
          return a + factor * (b ­ a);
          }

        The return type of linearInterpolation is the type of expression inside the decltype spec-
        ifier, which is identical to the expression returned in the body of the function. Hence,
        this interface necessarily supports any set of input types for which a + factor * (b ­ a)
        is valid, including types such as mathematical vectors, matrices, or expression templates.
        As an added benefit, the presence of the expression in the function’s declaration enables
        expression SFINAE, which is typically desirable for generic template functions (see Sec-
        tion 1.1.“decltype” on page 51).

        Avoiding having to qualify names redundantly in return types
        When defining a function outside the class, struct, or namespace in which it is first declared,
        any unqualified names present in the return type might be looked up differently depending on
        the particular choice of function-declaration syntax used. When the return type precedes the
        qualified name of the function definition (as is the case with classic syntax), all references to
        types declared in the same scope where the function itself is declared must also be qualified.
        By contrast, when the return type follows the qualified name of the function, the return type
        is looked up in the same scope in which the function was first declared, just like its parameter
        types would. Avoiding redundant qualification of the return type can be beneficial, especially
        when the qualifying name is long.
             As an illustration, consider a class representing an abstract syntax tree node that exposes
        a type alias:
          struct NumericalASTNode
          {
                                                       146


i



    i                                                                                                       i
    i                                                                                                               i
                      “emcpps-internal” — 2021/1/16 — 3:34 — page 147 — #149

i



        C++11                                                                                    Trailing Return


          using ElementType = double;
          auto getElement() ­> ElementType;
          };

        Defining the getElement member function using traditional function-declaration syntax
        would require repetition of the NumericalASTNode name:
          NumericalASTNode::ElementType NumericalASTNode::getElement() { /*...*/ }

        Using the trailing-return-type syntax handily avoids the repetition:
          auto NumericalASTNode::getElement() ­> ElementType { /*...*/ }

        By ensuring that name lookup within the return type is the same as for the parameter types,
        we avoid needlessly having to qualify names that should be found correctly by default.

        Improving readability of declarations involving function pointers
        Declarations of functions returning a pointer to either a function, a member function, or a
        data member are notoriously hard to parse — even for seasoned programmers. As an exam-
        ple, consider a function called getOperation that takes a kind of (enumerated) Operation as
        its argument and returns a pointer to a member function of Calculator that takes a double
        and returns a double:
          double (Calculator::*getOperation(Operation kind))(double);

        As we saw in the description, such declarations can be constructed systematically but do
        not exactly roll off the fingers. On the other hand, by partitioning the problem into (1)
        the declaration of the function itself and (2) the type it returns, each individual problem
        becomes far simpler than the original:
          auto getOperation(Operation kind) // (1) function taking a kind of Operation
          ­> double (Calculator::*)(double);
          // (2) returning a pointer to a Calculator member function taking a
          //     double and returning a double

        Using this divide-and-conquer approach, writing such functions127 becomes fairly straight-
        forward.

        Potential Pitfalls
        None so far

        Annoyances
        None so far

        See Also
           • “decltype” (Section 1.1, p. 51) ♦ Safe C++11 type inference feature that is often
             used in conjunction with or as an alternative to trailing return types
          127 Declaring a higher-order function that takes a function pointer as an argument might be even easier

        to read if a type alias is used (e.g., via typedef or, as of C++11, using).
                                                                                                            147


i



    i                                                                                                               i
    i                                                                                                    i
                      “emcpps-internal” — 2021/1/16 — 3:34 — page 148 — #150

i



        Trailing Return                                                Chapter 1     Safe Features


          • “Deduced Return Type” (Section 3.2, p. 320) ♦ Unsafe C++14 type inference fea-
            ture that shares syntactical similarities with trailing return types, leading to potential
            pitfalls when migrating from C++11 to C++14

        Further Reading
        None so far




                                                     148


i



    i                                                                                                    i
    i                                                                                                                  i
                      “emcpps-internal” — 2021/1/16 — 3:34 — page 149 — #151

i



        C++11                                                                                     Unicode Literals




        Unicode String Literals
        C++11 introduces a portable mechanism for ensuring that a literal is encoded as UTF-8,
        UTF-16, or UTF-32.

        Description
        According to the C++ Standard, the character encoding of string literals is unspecified and
        can vary with the target platform or the configuration of the compiler. In essence, the C++
        Standard does not guarantee that the string literal "Hello" will be encoded as the ASCII128
        sequence 0x48, 0x65, 0x6C, 0x6C, 0x6F or that the character literal 'X' has the value
        0x58.
           Table 4 illustrates three new kinds of Unicode-compliant string literals, each delineating
        the precise encoding of each character.

                              Table 4: Three new Unicode-compliant literal strings

                                Encoding        Syntax            Underlying Type
                                 UTF-8        u8"Hello"       char (char8_t in C++20)
                                 UTF-16        u"Hello"               char16_t
                                 UTF-32        U"Hello"               char32_t



        A Unicode literal value is guaranteed to be encoded in UTF-8, UTF-16, or UTF-32, for u8,
        u, and U literals, respectively:
          char s0[] = "Hello";
          // unspecified encoding (albeit very likely ASCII)

          char s1[] = u8"Hello";
          // guaranteed to be encoded as {0x48, 0x65, 0x6C, 0x6C, 0x6F, 0x0}

        C++11 also introduces universal character names that provide a reliably portable way of
        embedding Unicode code points in a C++ program. They can be introduced by the \u
        character sequence followed by four hexadecimal digits or by the \U character sequence
        followed by eight hexadecimal digits:
          std::puts(u8"\U0001F378");           // Unicode code point in a UTF­8 encoded literal

        This output statement is guaranteed to emit the cocktail emoji ( ) to stdout, assuming
        that the receiving end is configured to interpret output bytes as UTF-8.




          128 In fact, C++ still fully supports platforms using EBCDIC, a rarely used alternative encoding to ASCII,

        as their primary text encoding.
                                                                                                               149


i



    i                                                                                                                  i
    i                                                                                                                i
                        “emcpps-internal” — 2021/1/16 — 3:34 — page 150 — #152

i



        Unicode Literals                                                        Chapter 1      Safe Features


        Use Cases
        Guaranteed-portable encodings of literals
        The encoding guarantees provided by the Unicode literals can be useful, such as in com-
        munication with other programs or network/IPC protocols that expect character strings
        having a particular encoding.
            As an example, consider an instant-messaging program in which both the client and
        the server expect messages to be encoded in UTF-8. As part of broadcasting a message to
        all clients, the server code uses UTF-8 Unicode literals to guarantee that every client will
        receive a sequence of bytes they are able to interpret and display as human-readable text:
          void Server::broadcastServerMessage(const std::string& message)
          {
          Packet data;
          data << u8"Message from the server: '" << message << u8"'\n";

          broadcastPacket(data);
          }

        Not using u8 literals in the code snippet above could potentially result in nonportable be-
        havior and might require compiler-specific flags to ensure that the source is UTF-8 encoded.

        Potential Pitfalls
        Embedding Unicode graphemes
        The addition of Unicode string literals to the language did not bring along an extension of
        the basic source character set: Even in C++11, the default basic source character set is
        a subset of ASCII.129
            Developers might be fooled into thinking that u8" " is a portable way of embedding a
        string literal representing the cocktail emoji in a C++ program, but they would be mistaken.
        The representation of the string literal depends on what encoding the compiler assumes for
        the source file, which can generally be controlled through compiler flags. The only portable
        way of embedding the cocktail emoji is to use its corresponding Unicode code point escape
        sequence (u8"\U0001F378"), as demonstrated in Description on page 149.

        Lack of library support for Unicode
        Essential vocabulary types, such as std::string, are completely unaware of encoding.
        They treat any stored string as a sequence of bytes. Even when correctly using Unicode string
        literals, programmers unfamiliar with Unicode might be surprised by seemingly innocent
        operations, such as asking for the size of a string representing the cocktail emoji:
          void f()
          {
          std::string cocktail(u8"\U0001F378");             // big character (!)
          assert(cocktail.size() == 1);                     // assertion failure (!)
          }
         129 Implementations are free to map characters outside the basic source character set to sequences of its

        members, resulting in the possibility of embedding other characters, such as emojis, in a C++ source file.
                                                           150


i



    i                                                                                                                i
    i                                                                                                              i
                      “emcpps-internal” — 2021/1/16 — 3:34 — page 151 — #153

i



        C++11                                                                                 Unicode Literals


        Even though the cocktail emoji is a single code point, std::string::size returns the
        number of code units required to encode it. The lack of Unicode-aware vocabulary types
        and utilities in the Standard Library can be a source of defects and misunderstandings,
        especially in the context of international program localization.

        UTF-8 quirks
        UTF-8 string literals use char as their underlying type. Such a choice is inconsistent with
        UTF-16 and UTF-32 literals, which provide their own unique character types (char16_t
        and char32_t), and prevents any overloading or template specialization on UTF-8 strings
        because it would be indistinguishable from default, narrow literal encoding. Furthermore,
        whether the underlying type of char is a signed or unsigned type is itself implementation
        defined.130
            C++20 fundamentally changes how UTF-8 string literals work, by introducing a new
        nonaliasing char8_t character type whose representation is guaranteed to match unsigned char.
        The new character type provides several benefits:

           • Ensures an unsigned and distinct type for UTF-8 character data
           • Enables overloading for regular string literals versus UTF-8 string literals
           • Potentially achieves better performance due to the lack of special aliasing rules

        Unfortunately, the changes brought by C++20 are not backward-compatible and might
        cause code targeting previous versions of the language using u8 literals either to fail to
        compile or to silently change its behavior when targeting C++20:
         template <typename T> void print(const T*);        // (0)
         void print(const char*);                           // (1)

         void f()
         {
         print(u8"text");     // invokes (1) prior to C++20, (0) afterwards
         }



        Annoyances
        None so far

        See Also
        None so far

        Further Reading
        None so far



          130 Note that char is distinct from both signed char and unsigned char, but its behavior is guaranteed

        to be the same as one of those.
                                                                                                           151


i



    i                                                                                                              i
    i                                                                                                      i
                        “emcpps-internal” — 2021/1/16 — 3:34 — page 152 — #154

i



        using Aliases                                                    Chapter 1     Safe Features



        Type/Template Aliases (Extended typedef)
        Alias declarations and alias templates provide an expanded use of the using keyword,
        offering an alternative syntax (to typedef) for creating a type alias that can itself be a
        template.

        Description
        The keyword using has historically supported the introduction of an alias for a named entity
        (e.g., type, function, or data) from some named scope into the current one; see Appendix:
        Brief Review of (C++03) using Declarations on page 156. As of C++11, we can employ the
        using keyword to achieve everything that could previously be accomplished with a typedef
        declaration but in a syntactic form that many people find more natural and intuitive (but
        that offers nothing profoundly new):
          using Type1 = int;         // equivalent to typedef int Type1;
          using Type2 = double;      // equivalent to typedef double Type2;

        In contrast to typedef, the name of the synonym created via the using syntax always
        appears on the left side of the = token and separate from the type declaration itself — the
        advantage of which becomes apparent with more involved types, such as pointer-to-functions,
        pointer-to-member-function, or pointer-to-data-member:
          struct S { int i; void f(); };       // user­defined type S defined at file scope

          using Type3 = void(*)();             // equivalent to typedef void(*Type3)();
          using Type4 = void(S::*)();          // equivalent to typedef void(S::*Type4)();
          using Type5 = int S::*;              // equivalent to typedef int S::*Type5;

        Just as with a typedef, the name representing the type can be qualified, but the symbol
        representing the synonym cannot:
          namespace N { struct S { }; }       // original type S defined with namespace N

          using Type6 = N::S;                 // equivalent to typedef N::S Type6;
          using ::Type7 = int;                // Error: the alias's name must be unqualified.

        Unlike a typedef, however, a type alias employing using can itself be a template, known
        as an alias template:
          template <typename T>
          using Type8 = T; // "identity" alias template

          Type8<int>    i;     // equivalent to int i;
          Type8<double> d;     // equivalent to double d;

        Note, however, that neither partial nor explicit specialization of alias templates is supported:
          template <typename, typename>        // general alias template
          using Type9 = char;                  // OK

                                                      152


i



    i                                                                                                      i
    i                                                                                                                i
                       “emcpps-internal” — 2021/1/16 — 3:34 — page 153 — #155

i



        C++11                                                                                      using Aliases


         template <typename T>                       // attempted partial specialization of above
         using Type9<T, int> = char;                 // error: expected = before < token

         template <>                                 // attempted full specialization of above
         using Type10<int, int> = char;              // error: expected unqualified­id before using

        Used in conjunction with existing class templates, alias templates allow programmers to
        bind one or more template parameters to a fixed type, while leaving others open:
         #include <utility>          // std::pair

         template <typename T>
         using PairOfCharAnd = std::pair<char, T>;
         // alias template that binds char to the first type parameter of std::pair

         PairOfCharAnd<int>    pci;            // equivalent to std::pair<char, int> pci;
         PairOfCharAnd<double> pcd;            // equivalent to std::pair<char, double> pcd;

        Finally, note that the equivalent functionality of alias templates can be achieved in C++03,
        though with additional boilerplate code at both the point of definition and the call site:
         template <typename T>
         struct PairOfCharAnd
         // template class holding an alias, Type, to std::pair<char, T>
         {
         typedef std::pair<char, T> Type;
         // type alias binding char to the first type parameter of std::pair
         };

         PairOfCharAnd<int>::Type    pci;              // equivalent to std::pair<char, int> pci;
         PairOfCharAnd<double>::Type pcd;              // equivalent to std::pair<char, double> pcd;


        Use Cases
        Simplifying convoluted typedef declarations
        Complex typedef declarations involving pointers to functions, member functions, or data
        members require looking in the middle of the declaration to find the alias name. As an
        example, consider a callback type alias intended to be used with asynchronous functions:
         typedef void(*CompletionCallback)(void* userData);

        Developers coming from a background other than C or C++03 might find the above decla-
        ration hard to parse since the name of the alias (CompletionCallback) is embedded in the
        function pointer type. Replacing typedef with using results in a simpler, more consistent
        formulation of the same alias:
         using CompletionCallback = void(*)(void* userData);

        The CompletionCallback alias declaration (above) reads almost completely left-to-right,131
        and the name of the alias is clearly specified after the using keyword.
         131 In   order to make the CompletionCallback alias read left-to-right, a trailing return (see Section 1,
                                                                                                             153


i



    i                                                                                                                i
    i                                                                                                                   i
                        “emcpps-internal” — 2021/1/16 — 3:34 — page 154 — #156

i



        using Aliases                                                             Chapter 1       Safe Features


        Binding template arguments
        An alias template can be used to bind one or more template parameters of, say, a commonly
        used class template, while leaving the other parameters open to variation. Suppose, for
        example, we have a class, UserData, that contains several (e.g., four) distinct instances of
        std::map — each having the same key type, UserId, but with different payloads:
          class UserData // class having excessive code repetition (BAD IDEA)
          {
          private:
          std::map<UserId, Message>          d_messages;
          std::map<UserId, Photos>           d_photos;
          std::map<UserId, Article>          d_articles;
          std::map<UserId, std::set<UserId>> d_friends;
          };

        The example above, though clear and regular, involves significant repetition, making it more
        diﬀicult to maintain should we later opt to change data structures. If we were to instead use
        an alias template to bind the UserId type to the first type parameter of std::map, we
        could both (1) reduce code repetition and (2) enable the programmer to consistently replace
        std::map to another container (e.g., std::unordered_map132 ) by performing the change
        in only one place:
          class UserData // class with well­factored implementation (GOOD IDEA)
          {
          private:
          template <typename V>                 // using a template alias to bind
          using Mapping = std::map<UserId, V>;  // UserId as the key type

          Mapping<Message>                  d_messages;
          Mapping<Photos>                   d_photos;
          Mapping<Article>                  d_articles;
          Mapping<std::set<UserId>>         d_friends;
          };


        Providing a shorthand notation for type traits
        Alias templates can provide a shorthand notation for type traits, avoiding boilerplate
        code in the usage site. As an example, consider a simple type trait that adds a pointer to
        a given type (akin to std::add_pointer):

        “Trailing Return”) can be used:
          using CompletionCallback = auto(*)(void* userData) ­> void;
        The alias declaration above can be read as, “CompletionCallback is an alias for a pointer to a function
        taking a void* parameter named userData and returning void.”
          132 An std::unordered_map is an STL container type that became available on all conforming platforms

        along with C++11. The functionality is similar except that, since it is not required to support ordered
        traversal or (worst case) O[log(n)] lookups and O[n*log(n)] insertions, std::unordered_map can be im-
        plemented as a hash table instead of a balanced tree, yielding significantly faster average access times. See
        cppreferenceb.
                                                            154


i



    i                                                                                                                   i
    i                                                                                                              i
                      “emcpps-internal” — 2021/1/16 — 3:34 — page 155 — #157

i



        C++11                                                                                    using Aliases


          template <typename T>
          struct AddPointer
          {
          typedef T* Type;
          };

        To use the trait above, the AddPointer class template must be instantiated and its nested
        Type alias must be accessed by prepending the typename keyword:
          void f()
          {
          int i;
          typename AddPointer<int>::Type p = &i;
          }

        The syntactical overhead of AddPointer can be removed by creating an alias template for
        its nested type alias, such as AddPointer_t133 :
          template <typename T>
          using AddPointer_t = typename AddPointer<T>::Type;

        Using AddPointer_t instead of AddPointer results in shorter code devoid of boilerplate:
          void g()
          {
          int i;
          AddPointer_t<int> p = &i;
          }


        Potential Pitfalls
        None so far

        Annoyances
        None so far

        See Also
           • Section 1, “Inheriting Ctors” — Safe C++11 feature providing another meaning for
             the using keyword to allow base-class constructors to be invoked as part of the derived
             class
           • Section 1, “Trailing Return” — Safe C++11 feature providing an alternative syntax
             for function declaration, which can help improve readability in type aliases and alias
             templates involving function types
          133 Note that, since C++14, all the standard type traits defined in the <type_traits> header provide a

        corresponding alias template with the goal of reducing boilerplate code. For instance, C++14 introduces
        the std::remove_reference_t alias template for the C++11 std::remove_reference type trait:
         typename std::remove_reference<int&>::type i0 = 5; // OK in both C++11 and C++14
         std::remove_reference_t<int&> i1 = 5;              // OK in C++14


                                                                                                           155


i



    i                                                                                                              i
    i                                                                                               i
                        “emcpps-internal” — 2021/1/16 — 3:34 — page 156 — #158

i



        using Aliases                                               Chapter 1      Safe Features


        Further Reading
        None so far

        Appendix: Brief Review of (C++03) using Declarations
        The using keyword serves another, similar purpose: It introduces an alias for a (named)
        entity from a distinct (named) scope into the current scope. The first usage category for
        employing using to create local aliases is with respect to other namespaces:
         namespace N // namespace containing various named constructs
         {
         void f();       // (0) overloaded function f declared at namespace scope
         void f(int);    // (1)       "       "      "      "    "      "       "
         void f(double); // (2)       "       "      "      "    "      "       "
         void g();       // (3) function g declared at namespace scope
         void h();       // (4)     "    h    "      "     "       "
         int x;          // (5) integer variable x declared at namespace scope
         int y;          // (6)       "     "     y     "     "      "     "
         class C;        // (7) class C declared but not defined at namespace scope
         };

         void h();                // (8) function h declared at file (aka global) scope

         void client1()           // client illustrating usage w.r.t. namespaces
         {
         N::f();            //   OK, invokes (0) above
         N::f(1);           //   OK, invokes (1) above
         N::f(2.0);         //   OK, invokes (2) above
         f(2.0);            //   Error: function f is not found.
         using N::f();      //   Error: using must apply to all overloads at once.
         using N::f;        //   OK, creates local aliases for all three f overloads
         f();               //   OK, invokes (0) above
         f(1);              //   OK, invokes (1) above
         f(2.0);            //   OK, invokes (2) above

         x = 3;             // error: variable x not found
         N::x = 3;          // OK, assigns 3 to (5) above

         using N::x;        //   OK, creates local alias for x
         x = 4;             //   OK, assigns 4 to (5) above
         y = 5;             //   error: variable y not found
         g();               //   error: function g not found
         C *p;              //   error: Class C not found
         N::C *p;           //   OK, creates pointer p to incomplete type C (8) above

         using namespace N;
         // OK, create local aliases for all named entities in namespace N.

         y = 6;            // OK, assigns 6 to (6) above
                                                   156


i



    i                                                                                               i
    i                                                                                                                   i
                      “emcpps-internal” — 2021/1/16 — 3:34 — page 157 — #159

i



        C++11                                                                                        using Aliases


          g();                //   OK, invokes (3) above
          h();                //   Error: alias for h is ambiguous; (4) or (8) above.
          ::h();              //   OK, invokes (4) above
          N::h();             //   OK, invokes (8) above
          C *q;               //   // OK, creates pointer q to incomplete type C (8) above
          }

        The second usage category for employing using to create local aliases is with respect to
        public (or protected) members of privately (or protectedly) inherited base classes into a
        public (or protected) region of the derived class134 :
          struct B   // base       class having various public named entities
          {
          void fb();                //   (10)   overloaded member function
          void fb(int);             //   (11)       "        "       "
          void fb(double);          //   (12)       "        "       "
          void gb();                //   (13)   member function
          static void hb();         //   (14)   static member function
          typedef int Tb;           //   (15)   type alias for an integer
          int xb;                   //   (16)   integer data member
          int yb;                   //   (17)   integer data member
          };

          struct D : private B           // class aliasing private constructs via using
          {
          using B::fb;      //        local     aliases for all three overloads of fb
          using B::hb;      //        local     alias for static member function hb
          using B::xb;      //        local     alias for int data member xb
          using B::Tb;      //        local     alias for int type alias

          protected:
          using B::yb;             // protected local alias for int data member yb
          };

          void client2()       // client illustrating usage w.r.t. inheritance
          {
          D d;        //      Create an instance of derived type D.
          d.fb();     //      OK, alias created by using B::fb invokes (10) above.
          d.fb(1);    //      OK,   "     "     "     "     "     invokes (11) above.
          d.fb(2.0); //       OK,   "     "     "     "     "     invokes (12) above.
          d.gb();     //      Error: gb is privately inherited without using declaration.
          d.hb();     //      OK, alias created by using B::hb invokes (14) above.
          D::hb();    //      OK,   "      "    "     "     "     invokes (14) above.
          D::Tb i;    //      OK,   "      "    "     " B::Tb aliases (15) above.
          D::xb = 1; //       OK,   "      "    "     " B::xb assigns (16) above.
          D::yb = 1; //       Error, using for yb is protected, not public.
          }

          134 The alternatives, shown here in parentheses, are provided for technical accuracy but are unlikely to be

        useful in practice.
                                                                                                                157


i



    i                                                                                                                   i
    i                                                                                                i
                        “emcpps-internal” — 2021/1/16 — 3:34 — page 158 — #160

i



        using Aliases                                                Chapter 1    Safe Features


        Finally, for completeness, we note that the using directive for yb in the protected region
        of D leaves the local alias for yb in D accessible to classes that are derived from D:
         struct DD : D // doubly derived class accessing protected alias
         {
         DD(int v) { yb = v };
         // OK, using yb in D exposes protected alias; assigns (17).
         };




                                                   158


i



    i                                                                                                i
    i                                                                                                      i
                     “emcpps-internal” — 2021/1/16 — 3:34 — page 159 — #161

i



        C++14                                                                         Aggregate Init '14




        Aggregates Having Default Member Initializers
        C++14 enables the use of aggregate initialization with classes employing Default Member
        Initializers (see Section 2, “Default Member Init”).


        Description
        Prior to C++14, classes that made use of Default Member Init — i.e., initializers that
        appear directly within the scope of the class — were not considered aggregate types:

          struct S                   // aggregate type in C++14 but not C++11
          {
          int i;
          bool b = false;        // uses default member initializer
          };

          struct A                   // aggregate type in C++11 and C++14
          {
          int i;
          bool b;                // does not use default member initializer
          };

        Because A (but not S) is considered an aggregate in C++11, instances of A can be created
        via aggregate initialization (whereas instances of S cannot):

          A a{100, true};    // OK in both C++11 and C++14
          S s{100, true};    // error in C++11; OK in C++14

        As of C++14, the requirements for a type to be categorized as an aggregate are relaxed,
        allowing classes employing default member initializers to be considered as such; hence both
        A and S are considered aggregates in C++14 and eligible for aggregate initialization:

          void f()
          {
          S s0{100, true};           // OK in C++14 but not in C++11
          assert(s0.i == 100);       // set via explicit aggregate initialization (above)
          assert(s0.b == true);      // set via explicit aggregate initialization (above)

          S s1{456};                 // OK in C++14 but not in C++11
          assert(s1.i == 456);       // set via explicit aggregate initialization (above)
          assert(s1.b == false);     // set via default member initializer
          }

        In the code snippet above, the C++14 aggregate S is initialized in two ways: s0 is created us-
        ing aggregate initialization for both data members; s is created using aggregate initialization
        for only the first data member (and the second is set via its default member initializer).
                                                                                                    159


i



    i                                                                                                      i
    i                                                                                                                    i
                        “emcpps-internal” — 2021/1/16 — 3:34 — page 160 — #162

i



        Aggregate Init '14                                                         Chapter 1       Safe Features


        Use Cases
        Configuration structs
        Aggregates in conjunction with Default Member Init can be used to provide concise cus-
        tomizable configuration structs, packaged with typical default values. As an example,
        consider a configuration struct for an HTTP request handler:
          struct HTTPRequestHandlerConfig
          {
          int maxQueuedRequests = 1024;
          int timeout           = 60;
          int minThreads        = 4;
          int maxThreads        = 8;
          };

        Aggregate initialization can be used when creating objects of type HTTPRequestHandlerConfig
        (above) to override one or more of the defaults in definition order135 :
          HTTPRequestHandlerConfig getRequestHandlerConfig(bool inLowMemoryEnvironment)
          {
          if (inLowMemoryEnvironment)
          {
          return HTTPRequestHandlerConfig{128};
          // timeout, minThreads, and maxThreads have their default value.
          }
          else
          {
          return HTTPRequestHandlerConfig{2048, 120};
          // minThreads, and maxThreads have their default value.
          }
          }

          // ...


        Potential Pitfalls
        None so far




          135 In C++20, the Designated Initializers feature adds flexibility (e.g., for configuration structs, such as

        HTTPRequestHandlerConfig) by enabling explicit specification of the names of the data members:

          HTTPRequestHandlerConfig lowTimeout{.timeout = 15};
          // maxQueuedRequests, minThreads, and maxThreads have their default value.

          HTTPRequestHandlerConfig highPerformance{.timeout = 120, .maxThreads = 16};
          // maxQueuedRequests and minThreads have their default value.


                                                             160


i



    i                                                                                                                    i
    i                                                                                                   i
                   “emcpps-internal” — 2021/1/16 — 3:34 — page 161 — #163

i



        C++14                                                                      Aggregate Init '14


        Annoyances
        Syntactical ambiguity in the presence of brace elision
        During the initialization of multilevel aggregates, braces around the initialization of a
        nested aggregate can be omitted (brace elision):

         struct S
         {
         int arr[3];
         };

         S s0{{0, 1, 2}};    // OK, nested arr initialized explicitly
         S s1{0, 1, 2};      // OK, brace elision for nested arr

        The possibility of brace elision creates an interesting syntactical ambiguity when used
        alongside aggregates with Default Member Init. Consider a struct X containing three
        data members, one of which has a default value:

         struct X
         {
         int a;
         int b;
         int c = 0;
         };

        Now, consider various ways in which an array of elements of type X can be initialized:

         X xs0[] = {{0, 1}, {2, 3}, {4, 5}};
         // OK, clearly 3 elements having the respective values:
         // {0, 1, 0}, {2, 3, 0}, {4, 5, 0}

         X xs1[] = {{0, 1, 2}, {3, 4, 5}};
         // OK, clearly 2 elements with values:
         // {0, 1, 2}, {3, 4, 5}

         X xs2[] = {0, 1, 2, 3, 4, 5};
         // ...?

        Upon seeing the definition of xs2, a programmer not versed in the details of the C++
        Language Standard might be unsure as to whether the initializer of xs2 is three elements
        (like xs0) or two elements (like xs1). The Standard is, however, clear that the compiler
        will interpret xs2 the same as xs1, and, thus, the default values of X::c for the two array
        elements will be replaced with 2 and 5, respectively.


        See Also
          • Section 2, “Default Member Init” — Conditionally safe C++11 feature that allows
            developers to provide a default initializer for a data member directly in the definition
            of a class
                                                                                                 161


i



    i                                                                                                   i
    i                                                                                     i
                       “emcpps-internal” — 2021/1/16 — 3:34 — page 162 — #164

i



        Aggregate Init '14                                    Chapter 1   Safe Features


        Further Reading
        None so far




                                               162


i



    i                                                                                     i
    i                                                                                                                   i
                      “emcpps-internal” — 2021/1/16 — 3:34 — page 163 — #165

i



        C++14                                                                                        Binary Literals




        Binary Literals: The 0b Prefix
        Binary literals are integer literals representing their values in base 2.

        Description
        A binary literal is an integral value represented in code in a binary numeral system. A binary
        literal consists of a 0b or 0B prefix followed by a nonempty sequence of binary digits, namely,
        0 and 1136 :

          int i = 0b11110000;         // equivalent to 240, 0360, or 0xF0
          int j = 0B11110000;         // same value as above

        The first digit after the 0b prefix is the most significant one:
          static_assert(0b0            ==    0,   "");    //    0*2^0
          static_assert(0b1            ==    1,   "");    //    1*2^0
          static_assert(0b10           ==    2,   "");    //    1*2^1   +   0*2^0
          static_assert(0b11           ==    3,   "");    //    1*2^1   +   1*2^0
          static_assert(0b100          ==    4,   "");    //    1*2^2   +   0*2^1 + 0*2^0
          static_assert(0b101          ==    5,   "");    //    1*2^2   +   0*2^1 + 1*2^0
          // ...
          static_assert(0b11010        == 26, "");        // 1*2^4 + 1*2^3 + 0*2^2 + 1*2^1 + 0*2^0

        Leading zeros — as with octal and hexadecimal (but not decimal) literals — are ignored
        but can be added for readability:
          static_assert(0b00000000          ==   0,      "");
          static_assert(0b00000001          ==   1,      "");
          static_assert(0b00000010          ==   2,      "");
          static_assert(0b00000100          ==   4,      "");
          static_assert(0b00001000          ==   8,      "");
          static_assert(0b10000000          == 128,      "");

        The type of a binary literal is by default an int unless that value cannot fit in an int. In that
        case, its type is the first type in the sequence {unsigned int, long, unsigned long, long long,
        unsigned long long} in which it will fit. This same type list applies for both octal and hex
        literals but not for decimal literals, which, if initially signed, skip over any unsigned types,
        and vice versa; see Description on page 163. If neither of those is applicable, the compiler
        may use implementation-defined extended integer types such as __int128 to represent the
        literal if it fits — otherwise the program is ill-formed:
          // example platform 1:
          // (sizeof(int): 4; sizeof(long): 4; sizeof(long long): 8)
          auto i32 = 0b0111...[ 24 1­bits]...1111; // i32 is int.
          auto u32 = 0b1000...[ 24 0­bits]...0000; // u32 is unsigned int.
          auto i64 = 0b0111...[ 56 1­bits]...1111; // i64 is long long.

         136 Prior to being introduced in C++14, GCC supported binary literals (with the same syntax as the
        standard feature) as a nonconforming extension since version 4.3.0, released in March 2008; for more details,
        see https://gcc.gnu.org/gcc-4.3/.
                                                                                                                163


i



    i                                                                                                                   i
    i                                                                                                       i
                           “emcpps-internal” — 2021/1/16 — 3:34 — page 164 — #166

i



        Binary Literals                                                      Chapter 1     Safe Features


          auto u64 = 0b1000...[ 56 0­bits]...0000;              // u64 is unsigned long long.
          auto i128 = 0b0111...[120 1­bits]...1111;             // error: integer literal too large
          auto u128 = 0b1000...[120 0­bits]...0000;             // error: integer literal too large

          // example platform 2:
          // (sizeof(int): 4; sizeof(long): 8; sizeof(long long): 16)
          auto i32 = 0b0111...[ 24 1­bits]...1111; // i32 is int.
          auto u32 = 0b1000...[ 24 0­bits]...0000; // u32 is unsigned int.
          auto i64 = 0b0111...[ 56 1­bits]...1111; // i64 is long.
          auto u64 = 0b1000...[ 56 0­bits]...0000; // u64 is unsigned long.
          auto i128 = 0b0111...[120 1­bits]...1111; // i128 is long long.
          auto u128 = 0b1000...[120 0­bits]...0000; // u128 is unsigned long long.

        (Purely for convenience of exposition, we have employed the C++11 auto feature to con-
        veniently capture the type implied by the literal itself; see Section 2.1.“auto Variables” on
        page 217.) Separately, the precise initial type of a binary literal, like any other literal, can
        be controlled explicitly using the common integer-literal suﬀixes {u, l, ul, ll, ull} in either
        lower- or uppercase:
          auto   i     =   0b101;         //   type:   int;                  value:   5
          auto   u     =   0b1010U;       //   type:   unsigned int;         value:   10
          auto   l     =   0b1111L;       //   type:   long;                 value:   15
          auto   ul    =   0b10100UL;     //   type:   unsigned long;        value:   20
          auto   ll    =   0b11000LL;     //   type:   long long;            value:   24
          auto   ull   =   0b110101ULL;   //   type:   unsigned long long;   value:   53

        Finally, note that aﬀixing a minus sign to a binary literal (e.g., ­b1010) — just like any
        other integer literal (e.g., ­10, ­012, or ­0xa) — is parsed as a non-negative value first, after
        which a unary minus is applied:
          static_assert(sizeof(int) == 4, ""); // true on virtually all machines today
          static_assert(­0b1010 == ­10, "");    // as if: 0 ­ 0b1010 == 0 ­ 10
          static_assert( 0b0111...[ 24 1­bits]...1111        //  signed
          != ­0b0111...[ 24 1­bits]...1111, ""); //   signed

          static_assert( 0b1000...[ 24 0­bits]...0000        // unsigned
          != ­0b1000...[ 24 0­bits]...0000, ""); // unsigned



        Use Cases
        Bit masking and bitwise operations
        Prior to the introduction of binary literals, hexadecimal and octal literals were commonly
        used to represent bit masks or specific bit constants in source code. As an example, consider
        a function that returns the least significant four bits of a given unsigned int value:
          unsigned int lastFourBits(unsigned int value)
          {
          return value & 0xFu;
          }
                                                          164


i



    i                                                                                                       i
    i                                                                                                        i
                    “emcpps-internal” — 2021/1/16 — 3:34 — page 165 — #167

i



        C++14                                                                              Binary Literals


        The correctness of the bitwise and operation above might not be immediately obvious to a
        developer inexperienced with hexadecimal literals. In contrast, using a binary literal more
        directly states our intent to mask all but the four least-significant bits of the input:
          unsigned int lastFourBits(unsigned int value)
          {
          return value & 0b1111u;
          }

            Similarly, other bitwise operations, such as setting or getting individual bits, might ben-
        efit from the use of binary literals. For instance, consider a set of flags used to represent the
        state of an avatar in a game:
          struct AvatarStateFlags
          {
          enum Enum
          {
          e_ON_GROUND    = 0b0001,
          e_INVULNERABLE = 0b0010,
          e_INVISIBLE    = 0b0100,
          e_SWIMMING     = 0b1000,
          };
          };

          class Avatar
          {
          unsigned char d_state;

          public:
          bool isOnGround() const
          {
          return d_state & AvatarStateFlags::e_ON_GROUND;
          }

          // ...
          };

        Note that the choice of using a                nested   classic   enum   was   deliberate;    see
        Section 2.1.“enum class” on page 222.

        Replicating constant binary data
        Especially in the context of embedded development or emulation, a programmer will
        commonly write code that needs to deal with specific “magic” constants (e.g., provided
        as part of the specification of a CPU or virtual machine) that must be incorporated in
        the program’s source code. Depending on the original format of such constants, a binary
        representation can be the most convenient or most easily understandable one.
           As an example, consider a function decoding instructions of a virtual machine whose
        opcodes are specified in binary format:
          #include <cstdint>     // std::uint8_t
                                                                                                     165


i



    i                                                                                                        i
    i                                                                                                 i
                          “emcpps-internal” — 2021/1/16 — 3:34 — page 166 — #168

i



        Binary Literals                                               Chapter 1    Safe Features



         void VirtualMachine::decodeInstruction(std::uint8_t instruction)
         {
         switch (instruction)
         {
         case 0b00000000u: // no­op
         break;

         case 0b00000001u: // add(register0, register1)
         d_register0 += d_register1;
         break;

         case 0b00000010u: // jmp(register0)
         jumpTo(d_register0);
         break;

         // ...
         }
         }

        Replicating the same binary constant specified as part of the CPU’s or virtual machine’s
        manual or documentation directly in the source avoids the need to mentally convert such
        constant data to and from, say, a hexadecimal number.
           Binary literals are also suitable for capturing bitmaps. For instance, consider a bitmap
        representing the uppercase letter C:

         const unsigned char letterBitmap_C[] =
         {
         0b00011111,
         0b01100000,
         0b10000000,
         0b10000000,
         0b10000000,
         0b01100000,
         0b00011111
         };

        Using binary literals makes the shape of the image that the bitmap represents apparent
        directly in the source code.


        Potential Pitfalls



        Annoyances

                                                    166


i



    i                                                                                                 i
    i                                                                                              i
                   “emcpps-internal” — 2021/1/16 — 3:34 — page 167 — #169

i



        C++14                                                                    Binary Literals


        See Also
          • “Digit Separators” (Section 1.2, p. 172) ♦ Long binary literals are made much more
            readable by grouping digits visually.

        Further Reading
          • ?




                                                                                           167


i



    i                                                                                              i
    i                                                                                                                    i
                        “emcpps-internal” — 2021/1/16 — 3:34 — page 168 — #170

i



        deprecated                                                                 Chapter 1       Safe Features



        The [[deprecated]] Attribute
        The [[deprecated]] attribute discourages the use of a decorated entity, typically via the
        emission of a compiler warning.

        Description
        The standard [[deprecated]] attribute is used to portably indicate that a particular en-
        tity is no longer recommended and to actively discourage its use. Such deprecation typically
        follows the introduction of alternative constructs that, in (ideally) all ways, are superior to
        the original one, providing time for clients to migrate to them (asynchronously137 ) before
        the deprecated one is (in some subsequent release) removed. Although not strictly required,
        the Standard explicitly encourages138 conforming compilers to produce a diagnostic message
        in case a program refers to any entity to which the [[deprecated]] attribute pertains.
        For instance, most popular compilers emit a warning whenever a [[deprecated]] function
        or object139 is used:
          void f();
          [[deprecated]] void g();

          int a;
          [[deprecated]] int b;

          void h()
          {
          f();
          g(); // Warning: g is deprecated.
          a;
          b;    // Warning: b is deprecated.
          }

        A programmer can (optionally) supply a string literal as an argument to the
        [[deprecated]] attribute (e.g., [[deprecated("message")]]) to inform human users
        regarding the reason for the deprecation:
          [[deprecated("too slow, use algo1 instead")]] void algo0();
          137 A process for ongoing improvement of legacy codebases, sometimes known as continuous refactoring,

        often allows time for clients to migrate — on their own respective schedules and time frames — from existing
        deprecated constructs to newer ones, rather than having every client change in lock step. Allowing clients
        time to move asynchronously to newer alternatives is often the only viable approach unless (1) the codebase
        is a closed system, (2) all of the relevant code is governed by a single authority, and (3) there is some sort
        of mechanical way to make the change.
          138 The C++ Standard characterizes what constitutes a well-formed program, but compiler vendors require

        a great deal of leeway to facilitate the needs of their users. In case any feature induces warnings, command-
        line options are typically available to disable those warnings (­Wno­deprecated in GCC) or methods are in
        place to suppress those warnings locally (e.g., #pragma GCC diagnostic ignored "­Wdeprecated").
          139 The [[deprecated]] attribute can be used portably to decorate other entities: class, struct, union,

        type alias, variable, data member, function, enumeration, template specialization. Applying [[deprecated]]
        to a specific enumerator or namespace, however, is guaranteed to be supported only since C++17; see
        smith15a for more information.
                                                             168


i



    i                                                                                                                    i
    i                                                                                                                   i
                      “emcpps-internal” — 2021/1/16 — 3:34 — page 169 — #171

i



        C++14                                                                                         deprecated


          void algo1();

          void f()
          {
          algo0();     // Warning: algo0 is deprecated; too slow, use algo1 instead.
          algo1();
          }

        An entity that is initially declared without [[deprecated]] can later be redeclared with
        the attribute and vice versa:
          void f();
          void g0() { f(); }         // OK, likely no warnings

          [[deprecated]] void f();
          void g1() { f(); } // Warning: f is deprecated.

          void f();
          void g2() { f(); }         // Warning: f is deprecated (still).

        As seen in g2 (above), redeclaring an entity that was previously decorated with
        [[deprecated]] without the attribute does not un-deprecate the entity.

        Use Cases
        Discouraging use of an obsolete or unsafe entity
        Decorating any entity with [[deprecated]] serves both to indicate a particular feature
        should not be used in the future and to actively encourage migration of existing uses to a bet-
        ter alternative. Obsolescence, lack of safety, and poor performance are common motivators
        for deprecation.
            As an example of productive deprecation, consider the RandomGenerator class having
        a static nextRandom member function to generate random numbers:
          struct RandomGenerator
          {
          static int nextRandom();
          // Generate a random value between 0 and 32767 (inclusive).
          };

        Although such a simple random number generator can be very useful, it might become un-
        suitable for heavy use because good pseudorandom number generation requires more state
        (and the overhead of synchronizing such state for a single static function can be a signif-
        icant performance bottleneck) while good random number generation requires potentially
        very high overhead access to external sources of entropy.140 One solution is to provide an al-
        ternative random number generator that maintains more state, allows users to decide where
        to store that state (the random number generator objects), and overall offers more flexibility

         140 The   C Standard Library provides rand, available in C++ through the <cstdlib> header. It has similar
        issues to our RandomGenerator::nextRandom function, and similarly developers are guided to use the facilities
        provided in the <random> header since C++11.
                                                                                                                169


i



    i                                                                                                                   i
    i                                                                                                                  i
                        “emcpps-internal” — 2021/1/16 — 3:34 — page 170 — #172

i



        deprecated                                                               Chapter 1       Safe Features


        for clients. The downside of such a change is that it comes with a functionally distinct API,
        requiring that users update their code to move away from the inferior solution:
          class BetterRandomGenerator
          {
          // ... (internal state of a quality pseudorandom number generator) ...

          public:
          int nextRandom();
          // Generate a quality random value between 0 and 32767 (inclusive).
          };

        Any user of the original random number generator can migrate to the new facility with little
        effort, but that is not a completely trivial operation, and migration will take some time before
        the original feature is no longer in use. The empathic maintainers of RandomGenerator can
        decide, instead of removing it completely, to use the [[deprecated]] attribute to (gently)
        discourage continued use of RandomGenerator::nextRandom():
          struct RandomGenerator
          {
          [[deprecated("Use BetterRandomGenerator::nextRandom() instead.")]]
          static int nextRandom();
          // ...
          };

        By using [[deprecated]] as shown above, existing clients of RandomGenerator are in-
        formed that a superior alternative, BetterRandomGenerator, is available, yet they are
        granted time to migrate their code to the new solution (rather than their code being broken
        by the removal of the old solution). When clients are notified of the deprecation (thanks to
        a compiler diagnostic), they can schedule time to (eventually) rewrite their applications to
        consume the new interface.141

        Potential Pitfalls
        Interaction with ­Werror (e.g., GCC, Clang) or /WX (MSVC)
        To prevent warnings from being overlooked, the ­Werror flag (/WX on MSVC) is sometimes
        used, which promotes warnings to errors. Consider the case where a project has been suc-
        cessfully using ­Werror for years, only to one day face an unexpected compilation failure
        due to one of the project’s dependencies using [[deprecated]] as part of their API.
            Having the compilation process completely stopped due to use of a deprecated entity
        defeats the purpose of the attribute because users of such an entity are given no time to
        adapt their code to use a newer alternative. On GCC and Clang, users can selectively demote
        deprecation errors back to warnings by using the ­Wno­error=deprecated­declarations

          141 All joking aside, continuous refactoring is an essential responsibility of a development organization,

        and deciding when to go back and fix what’s suboptimal instead of writing new code that will please users
        and contribute more immediately to the bottom line will forever be a source of tension. Allowing disparate
        development teams to address such improvements in their own respective time frames (perhaps subject to
        some reasonable overall deadline date) is a proven real-world practical way of ameliorating this tension.
                                                            170


i



    i                                                                                                                  i
    i                                                                                                     i
                      “emcpps-internal” — 2021/1/16 — 3:34 — page 171 — #173

i



        C++14                                                                             deprecated


        compiler flag. On MSVC, however, such demotion of warnings is not possible: The (unsatis-
        factory) workarounds are to disable (entirely) either /WX or deprecation diagnostics (using
        the ­wd4996 flag).
            Furthermore, this interaction between [[deprecated]] and ­Werror makes it impos-
        sible for owners of a low-level library to deprecate a function when releasing their code
        requires that they do not break the ability for any of their higher-level clients to compile; a
        single client using the to-be-deprecated function along with ­Werror prevents the release of
        the code with the [[deprecated]] attribute on it. With the default behaviors of compilers
        and the frequent advice given in practice to use ­Werror aggressively, this can make any
        use of [[deprecated]] completely unfeasible.

        Annoyances
        None so far

        See Also
        None so far

        Further Reading
        None so far




                                                                                                   171


i



    i                                                                                                     i
    i                                                                                                               i
                          “emcpps-internal” — 2021/1/16 — 3:34 — page 172 — #174

i



        Digit Separators                                                         Chapter 1     Safe Features



        The Digit Separator: '
        A digit separator is a single-character token (') that can appear as part of a numeric literal
        without altering its value.

        Description
        A digit separator — i.e., an instance of the single-quote character (') — may be placed
        anywhere within a numeric literal to visually separate its digits without affecting its value:
          int          i      =    ­12'345;                         //   same   as   ­12345
          unsigned int u      =    1'000'000u;                      //   same   as   1000000u
          long         j      =    5'0'0'0'0'0L;                    //   same   as   500000L
          long long    k      =    9'223'372'036'854'775'807;       //   same   as   9223372036854775807
          float        f      =    10'00.42'45f;                    //   same   as   1000.4245f
          double       d      =    3.1415926'53589793;              //   same   as   3.141592653589793
          long double e       =    3.1415926'53589793'23846;        //   same   as   3.14159265358979323846
          int        hex      =    0x8C25'00F9;                     //   same   as   0x8C2500F9
          int        oct      =    044'73'26;                       //   same   as   0447326
          int        bin      =    0b1001'0110'1010'0111;           //   same   as   0b1001011000110001

        Multiple digit separators within a single literal are allowed, but they cannot be contiguous,
        nor can they appear either before or after the numeric part (i.e., digit sequence) of the
        literal142 :
          int   e0   =   10''00;    //   error: consecutive digit separators
          int   e1   =   ­'1000;    //   error: before numeric part
          int   e2   =   1000'u;    //   error: after numeric part
          int   e3   =   0x'abc;    //   error: before numeric part
          int   e4   =   0'xdef;    //   error: way before numeric part
          int   e5   =   0'89;      //   error: non­octal digits
          int   e6   =   0'67;      //   OK, valid octal literal

        As a side note, remember that on some platforms an integer literal that is too large to fit
        in a long long int but that does fit in an unsigned long long int might generate a
        warning143 :
          unsigned long long big1 = 9'223'372'036'854'775'808; // 2^63
          // warning: integer constant is so large that it is an
          // unsigned long long big1 = 9'223'372'036'854'775'808;
          //                           ^~~~~~~~~~~~~~~~~~~~~~~~~~

        Such warnings can typically be suppressed by adding a ull suﬀix to the literal:
          unsigned long long big2 = 9'223'372'036'854'775'808ull;                     // OK

        Warnings like the one above, however, are not typical when the implied precision of a
        floating-point literal exceeds what can be represented:
         142 Although   the leading 0x and 0b prefixes for hexadecimal and binary literals, respectively, are not
        considered part of the numeric part of the lateral, a leading 0 in an octal literal is.
          143 Tested on GCC 7.4.0.

                                                          172


i



    i                                                                                                               i
    i                                                                                                     i
                      “emcpps-internal” — 2021/1/16 — 3:34 — page 173 — #175

i



        C++14                                                                          Digit Separators


          float reallyPrecise = 3.141'592'653'589'793'238'462'643'383'279'502'884;                // OK
          // Everything after 3.141'592'6 is typically ignored silently.

        For more information, see Appendix: Silent Loss of Precision in Floating-Point Literals on
        page 174.


        Use Cases
        Grouping digits together in large constants
        When embedding large constants in source code, consistently placing digit separators (e.g.,
        every thousand) might improve readability, as illustrated in Table 5.


                      Table 5: Use of digit separators to improve readability

                        Without Digit Separator            With Digit Separators
                                   10000                          10'000
                                  100000                         100'000
                                 1000000                        1'000'000
                               1000000000                     1'000'000'000
                        18446744073709551615ull       18'446'744'073'709'551'615ull
                             1000000.123456                 1'000'000.123'456
                       3.141592653589793238462l      3.141'592'653'589'793'238'462l



        Use of digit separators is especially useful with binary literals, as shown in Table 6.


                            Table 6: Use of digit separators in binary data

                             Without Digit Separator      With Digit Separators
                               0b1100110011001100        0b1100'1100'1100'1100
                               0b0110011101011011        0b0110'0111'0101'1011
                               0b1100110010101010         0b11001100'10101010




        Potential Pitfalls
        None so far


        See Also
          • Section 1, “Binary Literals” — Safe C++14 feature representing a binary constant for
            which digit separators are commonly used to group bits in octets (bytes) or quartets
            (nibbles)
                                                                                                    173


i



    i                                                                                                     i
    i                                                                                                             i
                       “emcpps-internal” — 2021/1/16 — 3:34 — page 174 — #176

i



        Digit Separators                                                      Chapter 1      Safe Features


        Further Reading
           • William Kahan. “Lecture Notes on the Status of IEEE Standard 754 for Binary
             Floating-Point Arithmetic,” kahan97

           • IEEE Standard for Floating-PointArithmetic, ieee19

        Appendix: Silent Loss of Precision in Floating-Point Literals
        Just because we can keep track of precision in floating-point literals doesn’t mean that the
        compiler can. As an aside, it is worth pointing out that the binary representation of floating-
        point types is not mandated by the Standard, nor are the precise minimums on the ranges
        and precisions they must support. Although the C++ Standard says little that is normative,
        the macros in <cfloat> are defined by reference to the C Standard.144
           There are, however, normal and customary minimums that one can typically rely upon
        in practice. On conforming compilers that employ the IEEE 754 floating-point standard
        representation145 (as most do), a float can typically represent up to 7 significant deci-
        mal digits accurately, while a double typically nearly 15 decimal digits of precision. For
        any given program, long double is required to hold whatever a double can hold, but is
        typically larger (e.g., 10, 12, or 16 bytes) and typically adds at least 5 decimal digits of
        precision (i.e., supports a total of at last 20 decimal digits). A table summarizing typical
        precisions for various IEEE-conforming floating-point types is presented for convenient ref-
        erence in Table 7. The actual bounds on a given platform can be found using the standard
        std::numeric_limits class template found in <limits>.




          144 PRODUCTION: WAITING FOR THESE REFERENCES TO DOUBLECHECK;

        CONSIDER THESE UNCONFIRMED. iso20, sections [basic.fundamental] Fundamental types
        (6.8.1p12); [numeric.limits.members] numeric_limits members 17.3.5.1; [cfloat.syn] Header <cfloat> syn-
        opsis (17.3.7p1); iso18b, section 5.2.4.2.2 Characteristics of floating types <float.h>
          145 ieee19

                                                         174


i



    i                                                                                                             i
    i                                                                                                                       i
                     “emcpps-internal” — 2021/1/16 — 3:34 — page 175 — #177

i



        C++14                                                                                        Digit Separators


           Table 7: Available precisions for various IEEE-754 floating-point types

                Name            Common                Significant      Decimal       Exponent         Dynamic
                                 Name                     Bitsa          Bits           Bits           Range
               binary16       Half precision               11            3.31            5            ∼ 6.50e5
               binary32      Single precision              24            7.22            8            ∼ 3.4e38
               binary64      Double precision              53           15.95            11           ∼ 1.e308
               binary80     Extended precision             69             20.77           11           ∼ 10308
               binary128   Quadruple precision             113            34.02           15          ∼ 104932
           a Note that the most significant bit of the mantissa is always a 1 and, hence, is not stored explicitly,
           leaving 1 additional bit to represent the sign of the overall floating-point value (the sign of the
           exponent is encoded using excess-n notation).



           Determining the minimum number of decimal digits needed to accurately approximate a
        transcendental value, such as π, for a given type on a given platform can be tricky (requir-
        ing some binary-search-like detective work), which is likely why overshooting the precision
        without warning is the default on most platforms. One way to establish that all of the dec-
        imal digits in a given floating-point literal are relevant for a given floating-point type is to
        compare that literal and a similar one with its least significant decimal digit removed146 :
          static_assert(3.1415926535f != 3.141592653f, "too precise for float");
          // This assert will fire on a typical platform.

          static_assert(3.141592653f != 3.14159265f, "too precise for float");
          // This assert too will fire on a typical platform.

          static_assert(3.14159265f != 3.1415926f, "too precise for float");
          // This assert will NOT fire on a typical platform.

          static_assert(3.1415926f != 3.141592f, "too precise for float");
          // This assert too will NOT fire on a typical platform.

        If the values are not the same, then that floating-point type can make use of the precision
        suggested by the original literal; if they are the same, however, then it is likely that the
        available precision has been exceeded. Iterative use of this technique by developers can
        help them to empirically narrow down the maximal number of decimal digits a particular
        platform will support for a particular floating-point type and value.
            One final useful tidbit pertains to the safe (lossless) conversion between binary and
        decimal floating-point representations; note that “Single” (below) corresponds to a single-
        precision IEEE-754-conforming (32-bit) float147 :

          146 Note that aﬀixing the f (literal suﬀix) to a floating-point literal is equivalent to applying a

        static_cast<float> to the (unsuﬀixed) literal:

         static_assert(3.14'159'265'358f == static_cast<float>(3.14'159'265'358));

         147 kahan97,   section “Representable Numbers,” p. 4
                                                                                                                      175


i



    i                                                                                                                       i
    i                                                                                                  i
                      “emcpps-internal” — 2021/1/16 — 3:34 — page 176 — #178

i



        Digit Separators                                               Chapter 1    Safe Features


             If a decimal string with at most 6 sig. dec. is converted to Single and then
             converted back to the same number of sig. dec., then the final string should
             match the original. Also, ...
             If a Single Precision floating-point number is converted to a decimal string with
             at least 9 sig. dec. and then converted back to Single, then the final number must
             match the original.

        The ranges corresponding to 6–9 for a single-precision (32-bit) float (described above),
        when applied to a double-precision (64-bit) double and a quad-precision (128-bit) long long,
        are 15–17 and 33–36, respectively.




                                                    176


i



    i                                                                                                  i
    i                                                                                                             i
                     “emcpps-internal” — 2021/1/16 — 3:34 — page 177 — #179

i



        C++14                                                                               Lambda Captures




        Lambda-Capture Expressions
        Lambda-capture expressions enable synthetization (spontaneous implicit creation) of ar-
        bitrary data members within closures generated by lambda expressions (see “Lambdas” on
        page 305).

        Description
        In C++11, lambda expressions can capture variables in the surrounding scope either by
        value or by reference148 :
          int i = 0;
          auto f0 = [i]{ };        // Create a copy of i in the generated closure named f0.
          auto f1 = [&i]{ };       // Store a reference to i in the generated closure named f1.

        Although one could specify which and how existing variables were captured, the programmer
        had no control over the creation of new variables within a closure. C++14 extends the
        lambda-introducer syntax to support implicit creation of arbitrary data members inside
        a closure via either copy initialization or list initialization:
          auto f2 = [i = 10]{ /* body of closure */ };
          // Synthesize an int data member, i, initialized with 10 in the closure.

          auto f3 = [c{'a'}]{ /* body of closure */ };
          // Synthesize a char data member, c, initialized with 'a' in the closure.

        Note that the identifiers i and c above do not refer to any existing variable; they are
        specified by the programmer creating the closure. For example, the closure type assigned
        (i.e., bound) to f2 (above) is similar in functionality to an invocable struct containing
        an int data member:
          // pseudocode
          struct f2LikeInvocableStruct
          {
          int i = 10; // The type int is deduced from the initialization expression.
          auto operator()() const { /* closure body */ } // The struct is invocable.
          };

        The type of the data member is deduced from the initialization expression provided as part
        of the capture in the same vein as auto (see “auto Variables” on page 217) type deduction;
        hence, it’s not possible to synthesize an uninitialized closure data member:
          auto f4 = [u]{ };         // Error: u initializer is missing for lambda capture.
          auto f5 = [v{}]{ };       // Error: v's type cannot be deduced.

        It is possible, however, to use variables outside the scope of the lambda as part of a lambda-
        capture expression (even capturing them by reference by prepending the & token to the name
        of the synthesized data member):
          148 We use the familiar (C++11) feature auto (see “auto Variables” on page 217) to deduce a closure’s

        type since there is no way to name such a type explicitly.
                                                                                                           177


i



    i                                                                                                             i
    i                                                                                                                  i
                        “emcpps-internal” — 2021/1/16 — 3:34 — page 178 — #180

i



        Lambda Captures                                                          Chapter 1       Safe Features


          int i = 0;      // zero­initialized int variable defined in the enclosing scope

          auto f6 = [j   = i]{ };          // OK, the local j data member is a copy of i.
          auto f7 = [&ir = i]{ };          // OK, the local ir data member is an alias to i.

        Though capturing by reference is possible, enforcing const on a lambda-capture expression
        is not:
          auto f8 = [const i = 10]{ };                                   // error: invalid syntax
          auto f9 = [const auto i = 10]{ };                              // error: invalid syntax
          auto fA = [i = static_cast<const int>(10)]{ };                 // OK, const is ignored.

        The initialization expression is evaluated during the creation of the closure, not its invoca-
        tion:
          #include <cassert>        // standard C assert macro

          void g()
          {
          int i = 0;

          auto fB = [k = ++i]{ };          // ++i is evaluated at creation only.
          assert(i == 1); // OK

          fB(); // Invoke fB (no change to i).
          assert(i == 1); // OK
          }

        Finally, using the same identifier as an existing variable is possible for a synthesized cap-
        ture, resulting in the original variable being shadowed (essentially hidden) in the lambda
        expression’s body but not in its declared interface. In the example below, we use the
        (C++11) compile-time operator decltype (see “decltype” on page 51) to infer the C++
        type from the initializer in the capture to create a parameter of that same type as that part
        of its declared interface149,150 :
          #include <type_traits>          // std::is_same

          int i = 0;

          auto fC = [i = 'a'](decltype(i) arg)
          {
          static_assert(std::is_same_v<decltype(arg), int>, "");
          // i in the interface (same as arg) refers to the int parameter.

          static_assert(std::is_same_v<decltype(i), char>, "");
          // i in the body refers to the char data member deduced at capture.
          };
          149 Note that, in the shadowing example defining fC, GCC version 10.x incorrectly evaluates decltype(i)

        inside the body of the lambda expression as const char, rather than char; see Potential Pitfalls: Forwarding
        an existing variable into a closure always results in an object (never a reference) on page 182.
          150 Here we are using the (C++14) variable template (see “Variable Templates” on page 185) version of the

        standard is_same metafunction where std::is_same<A, B>::value is replaced with std::is_same_v<A, B>.
                                                            178


i



    i                                                                                                                  i
    i                                                                                                                   i
                      “emcpps-internal” — 2021/1/16 — 3:34 — page 179 — #181

i



        C++14                                                                                    Lambda Captures


        Notice that we have again used decltype, in conjunction with the standard is_same meta-
        function (which is true if and only if its two arguments are the same C++ type). This time,
        we’re using decltype to demonstrate that the type (int), extracted from the local variable
        i within the declared-interface portion of fC, is distinct from the type (char) extracted from
        the i within fC’s body. In other words, the effect of initializing a variable in the capture
        portion of the lambda is to hide the name of an existing variable that would otherwise be
        accessible in the lambda’s body.151

        Use Cases
        Moving (as opposed to copying) objects into a closure
        Lambda-capture expressions can be used to move (see “rvalue References” on page 306) an
        existing variable into a closure152 (as opposed to capturing it by copy or by reference). As
        an example of needing to move from an existing object into a closure, consider the problem
        of accessing the data managed by std::unique_ptr (movable but not copyable) from a
        separate thread — for example, by enqueuing a task in a thread pool:
          ThreadPool::Handle processDatasetAsync(std::unique_ptr<Dataset> dataset)
          {
          return getThreadPool().enqueueTask([data = std::move(dataset)]
         151 Also note that, since the deduced char member variable, i, is not materially used (ODR-used) in the

        body of the lambda expression assigned (bound) to fC, some compilers, e.g., Clang, may warn:
          warning: lambda capture 'i' is not required to be captured for this use


          152 Though possible, it is surprisingly diﬀicult in C++11 to move from an existing variable into a closure.

        Programmers are either forced to pay the price of an unnecessary copy or to employ esoteric and fragile
        techniques, such as writing a wrapper that hijacks the behavior of its copy constructor to do a move instead:
          template <typename T>
          struct MoveOnCopy // wrapper template used to hijack copy ctor to do move
          {
          T d_obj;

          MoveOnCopy(T&& object) : d_obj{std::move(object)} { }
          MoveOnCopy(MoveOnCopy& rhs) : d_obj{std::move(rhs.d_obj)} { }
          };

          void f()
          {
          std::unique_ptr<int> handle{new int(100)}; // move­only
          // Create an example of a handle type with a large body.

          MoveOnCopy<decltype(handle)> wrapper(std::move(handle));
          // Create an instance of a wrapper that moves on copy.

          auto lambda = [wrapper](){ /* use wrapper.d_obj */ };
          // Create a "copy" from a wrapper that is captured by value.
          }

        In the example above, we make use of the bespoke (“hacked”) MoveOnCopy class template to wrap a movable
        object; when the lambda-capture expression tries to copy the wrapper (by value), the wrapper in turn moves
        the wrapped handle into the body of the closure.
                                                                                                                179


i



    i                                                                                                                   i
    i                                                                                                              i
                       “emcpps-internal” — 2021/1/16 — 3:34 — page 180 — #182

i



        Lambda Captures                                                        Chapter 1      Safe Features


          {
          return processDataset(data);
          });
          }

        As illustrated above, the dataset smart pointer is moved into the closure passed to
        enqueueTask by leveraging lambda-capture expressions — the std::unique_ptr is moved
        to a different thread because a copy would have not been possible.

        Providing mutable state for a closure
        Lambda-capture expressions can be useful in conjunction with mutable lambda expressions
        to provide an initial state that will change across invocations of the closure. Consider, for
        instance, the task of logging how many TCP packets have been received on a socket (e.g.,
        for debugging or monitoring purposes)153 :
          TcpSocket tcpSocket(27015); // some well­known port number
          tcpSocket.onPacketReceived([counter = 0]() mutable
          {
          std::cout << "Received " << ++counter << " packet(s)\n";
          // ...
          });

        Use of counter = 0 as part of the lambda introducer tersely produces a function object
        that has an internal counter (initialized with zero), which is incremented on every received
        packet. Compared to, say, capturing a counter variable by reference in the closure, the
        solution above limits the scope of counter to the body of the lambda expression and ties
        its lifetime to the closure itself, thereby preventing any risk of dangling references.

        Capturing a modifiable copy of an existing const variable
        Capturing a variable by value in C++11 does allow the programmer to control its const
        qualification; the generated closure data member will have the same const qualification as
        the captured variable, irrespective of whether the lambda is decorated with mutable:
          void f()
          {
          int i = 0;
          const int ci = 0;

          auto lc = [i, ci]             // This lambda is not decorated with mutable.
          {
          static_assert(std::is_same_v<decltype(i), int>, "");
          static_assert(std::is_same_v<decltype(ci), const int>, "");
          };

          auto lm = [i, ci]() mutable                // Decorating with mutable has no effect.
          {

          153 In this example, we are making use of the (C++11) mutable feature of lambdas to enable the counter

        to be modified on each invocation.
                                                          180


i



    i                                                                                                              i
    i                                                                                               i
                   “emcpps-internal” — 2021/1/16 — 3:34 — page 181 — #183

i



        C++14                                                                   Lambda Captures


         static_assert(std::is_same_v<decltype(i), int>, "");
         static_assert(std::is_same_v<decltype(ci), const int>, "");
         };
         }

        In some cases, however, a lambda capturing a const variable by value might need to modify
        that value when invoked. As an example, consider the task of comparing the output of two
        Sudoku-solving algorithms, executed in parallel:
         template <typename Algorithm> void solve(Puzzle&);
         // This solve function template mutates a Sudoku grid in place to solution.

         void performAlgorithmComparison()
         {
         const Puzzle puzzle = generateRandomSudokuPuzzle();
         // const­correct: puzzle is not going to be mutated after being
         // randomly generated.

         auto task0 = getThreadPool().enqueueTask([puzzle]() mutable
         {
         solve<NaiveAlgorithm>(puzzle); // Error: puzzle is const­qualified.
         return puzzle;
         });

         auto task1 = getThreadPool().enqueueTask([puzzle]() mutable
         {
         solve<FastAlgorithm>(puzzle); // Error: puzzle is const­qualified.
         return puzzle;
         });

         waitForCompletion(task0, task1);
         // ...
         }

        The code above will fail to compile as capturing puzzle will result in a const-qualified
        closure data member, despite the presence of mutable. A convenient workaround is to use
        a (C++14) lambda-capture expression in which a local modifiable copy is deduced:
         // ...

         const Puzzle puzzle = generateRandomSudokuPuzzle();

         auto task0 = getThreadPool().enqueueTask([p = puzzle]() mutable
         {
         solve<NaiveAlgorithm>(p); // OK, p is now modifiable.
         return puzzle;
         });

         // ...

                                                                                             181


i



    i                                                                                               i
    i                                                                                                      i
                         “emcpps-internal” — 2021/1/16 — 3:34 — page 182 — #184

i



        Lambda Captures                                                      Chapter 1     Safe Features


        Note that use of p = puzzle (above) is roughly equivalent to the creation of a new variable
        using auto (i.e., auto p = puzzle;), which guarantees that the type of p will be deduced as
        a non-const Puzzle. Capturing an existing const variable as a mutable copy is possible,
        but doing the opposite is not easy; see Annoyances: There’s no easy way to synthesize a
        const data member on page 183.

        Potential Pitfalls
        Forwarding an existing variable into a closure always results in
        an object (never a reference)
        Lambda-capture expressions allow existing variables to be perfectly forwarded (see “For-
        warding References” on page 284) into a closure:
          template <typename T>
          void f(T&& x) // x is of type forwarding reference to T.
          {
          auto lambda = [y = std::forward<T>(x)]
          // Perfectly forward x into the closure.
          {
          // ... (use y directly in this lambda body)
          };
          }

        Because std::forward<T> can evaluate to a reference (depending on the nature of T),
        programmers might incorrectly assume that a capture such as y = std::forward<T>(x)
        (above) is somehow either a capture by value or a capture by reference, depending on the
        original value category of x.
            Remembering that lambda-capture expressions work similarly to auto type deduction
        for variables, however, reveals that such captures will always result in an object, never a
        reference:
          // pseudocode (auto is not allowed in a lambda introducer.)
          auto lambda = [auto y = std::forward<T>(x)] { };
          // The capture expression above is semantically similar to an auto
          // (deduced­type) variable.

        If x was originally an lvalue, then y will be equivalent to a by-copy capture of x. Otherwise,
        y will be equivalent to a by-move capture of x.154
            If the desired semantics are to capture x by move if it originated from rvalue and by
        reference otherwise, then the use of an extra layer of indirection (using, e.g., std::tuple)
        is required:
          template <typename T>
          void f(T&& x)
          {
          auto lambda = [y = std::tuple<T>(std::forward<T>(x))]
          {
          // ... (Use std::get<0>(y) instead of y in this lambda body.)

         154 Note   that both by-copy and by-move capture communicate value for value-semantic types.
                                                         182


i



    i                                                                                                      i
    i                                                                                               i
                   “emcpps-internal” — 2021/1/16 — 3:34 — page 183 — #185

i



        C++14                                                                   Lambda Captures


         };
         }

        In the revised code example above, T will be an lvalue reference if x was originally an
        lvalue, resulting in the synthetization of a std::tuple containing an lvalue reference,
        which — in turn — has semantics equivalent to x’s being captured by reference. Otherwise,
        T will not be a reference type, and x will be moved into the closure.

        Annoyances
        There’s no easy way to synthesize a const data member
        Consider the (hypothetical) case where the programmer desires to capture a copy of a non-
        const integer k as a const closure data member:
         [k = static_cast<const int>(k)]() mutable // const is ignored
         {
         ++k; // "OK" ­­ i.e., compiles anyway even though we don't want it to
         };

         [const k = k]() mutable // error: invalid syntax
         {
         ++k; // no easy way to force this variable to be const
         };

        The language simply does not provide a convenient mechanism for synthesizing, from a
        modifiable variable, a const data member. If such a const data member somehow proves
        to be necessary, we can either create a ConstWrapper struct (that adds const to the
        captured object) or write a full-fledged function object in lieu of the leaner lambda
        expression. Alternatively, a const copy of the object can be captured with traditional
        (C++11) lambda-capture expressions:
         int k;
         const int kc = k;

         auto l = [kc]() mutable
         {
         ++kc; // error: increment of read­only variable kc
         };


        std::function supports only copyable callable objects
        Any lambda expression capturing a move-only object produces a closure type that is itself
        movable but not copyable:
         void f()
         {
         std::unique_ptr<int> moo(new char);        // some move­only object
         auto la = [moo = std::move(moo)]{ };       // lambda that does move capture

         static_assert(false == std::is_copy_constructible_v<decltype(la)>, "");
                                                                                             183


i



    i                                                                                               i
    i                                                                                                               i
                        “emcpps-internal” — 2021/1/16 — 3:34 — page 184 — #186

i



        Lambda Captures                                                        Chapter 1       Safe Features


          static_assert( true == std::is_move_constructible_v<decltype(la)>, "");
          }

        Lambdas are sometimes used to initialize instances of std::function, which requires the
        stored callable object to be copyable:
          std::function<void()> f = la;           // Error: la must be copyable.

        Such a limitation — which is more likely to be encountered when using lambda-capture
        expressions — can make std::function unsuitable for use cases where move-only clo-
        sures might conceivably be reasonable. Possible workarounds include (1) using a different
        type-erased, callable object wrapper type that supports move-only callable objects,155 (2)
        taking a performance hit by wrapping the desired callable object into a copyable wrapper
        (such as std::shared_ptr), or (3) designing software such that noncopyable objects, once
        constructed, never need to move.156

        See Also
           • “Lambdas” on page 305 — provides the needed background for understanding the
             feature in general
           • “Braced Init” on page 218 — illustrates one possible way of initializing the captures
           • “auto Variables” on page 217 — offers a model with the same type deduction rules

           • “rvalue References” on page 306 — gives a full description of an important feature
             used in conjunction with movable types.
           • “Forwarding References” on page 284 — describes a feature that contributes to a
             source of misunderstanding of this feature

        Further Reading
        None so far




          155 The any_invocable library type, proposed for C++23, is an example of a type-erased wrapper for

        move-only callable objects; see calabrese20.
          156 For an in-depth discussion of how large systems can benefit from a design that embraces local arena

        memory allocators and, thus, minimizes the use of moves across natural memory boundaries identified
        throughout the system, see lakos22.
                                                          184


i



    i                                                                                                               i
    i                                                                                                             i
                     “emcpps-internal” — 2021/1/16 — 3:34 — page 185 — #187

i



        C++14                                                                                Variable Templates




        Templated Variable Declarations/Definitions
        Variable templates extend traditional template syntax to define, in namespace or class (but
        not function) scope, a family of like-named variables that can subsequently be instantiated
        explicitly.

        Description
        By beginning a variable declaration with the familiar template-head syntax — e.g., tem­
        plate <typename T> — we can create a variable template, which defines a family of variables
        having the same name (e.g., typeid):
          template <typename> int typeId;           // template variable defined at file scope

        Like any other kind of template, a variable template can be instantiated (explicitly) by
        providing an appropriate number (one or more) of type or non-type arguments:
          void f1()
          {
          typeId<bool> = ­1;         // typeId<bool> is an int
          typeId<char> = 1000;       // typeId<char> is an int
          typeId<void> = ­666;       // typeId<void> is an int

          assert(typeId<bool> ==   ­1);
          assert(typeId<char> == 1000);
          assert(typeId<void> == ­666);
          }

        In the example above, the type of each instantiated variable — i.e., typeId<bool> and
        typeId<char> — is int. Such need not be the case157 :
          template <typename T> const T pi(3.1415926535897932385);                   // distinct types

        In the example above, the type of the instantiated non-const variable is that of its (type)
        argument, and its (mutable) value is initialized to the best approximation of π offered by
        that type:
          void f2()
          {
          bool           pi_as_bool            =   1;                           //    ( 1   bit)
          int            pi_as_int             =   3;                           //    (32   bits)
          float          pi_as_float           =   3.1415927;                   //    (32   bits)
          double         pi_as_double          =   3.141592653589793;           //    (64   bits)
          long double    pi_as_long_double     =   3.1415926535897932385;       //    (80   bits)

          assert(pi<bool>              == pi_as_bool);
          assert(pi<int>               == pi_as_int);
          assert(pi<float>             == pi_as_float);

          157 Use of constexpr variables would allow the instantiated variables to be usable as a constant in a

        compile-time context (see Use Cases: Parameterized constants on page 187).
                                                                                                           185


i



    i                                                                                                             i
    i                                                                                                 i
                     “emcpps-internal” — 2021/1/16 — 3:34 — page 186 — #188

i



        Variable Templates                                            Chapter 1    Safe Features


         assert(pi<double>      == pi_as_double);
         assert(pi<long double> == pi_as_long_double);
         }

        For examples involving immutable variable templates, see Use Cases: Parameterized constants
        on page 187.
           Variable templates, like C-style functions, may be declared at namespace-scope or
        as static members of a class, struct, or union but are not permitted as nonstatic
        members nor at all in function scope:
         template <typename T> T vt1;                  // OK (external linkage)
         template <typename T> static T vt2;           // OK (internal linkage)

         namespace N
         {
         template <typename T> T vt3;                // OK (external linkage)
         template <typename T> T vt4;                // OK (internal linkage)
         }

         struct S
         {
         template <typename T> T vt5;              // error: not static
         template <typename T> static T vt6;       // OK (external linkage)
         };

         void f3() // Variable templates cannot be defined in functions.
         {
         template <typename T> T vt7;        // compile­time error
         template <typename T> static T vt8; // compile­time error

         vt1<bool> = true;                         // OK (to use them)
         }

        Like other templates, variable templates may be defined with multiple parameters consisting
        of arbitrary combinations of type and non-type parameters (including a parameter pack):
         namespace N
         {
         template <typename V, int I, int J> V factor;        // namespace scope
         }

        Variable templates can even be defined recursively (but see Potential Pitfalls: Recursive
        variable template initializations require const or constexpr on page 189):
         template <int N>
         const int sum = N + sum<N ­ 1>;        // recursive general template

         template <> const int sum<0> = 0;      // base­case specialization

         void f()
         {
                                                    186


i



    i                                                                                                 i
    i                                                                                                       i
                    “emcpps-internal” — 2021/1/16 — 3:34 — page 187 — #189

i



        C++14                                                                         Variable Templates


          std::cout << sum<4> << '\n';       // prints 10
          std::cout << sum<5> << '\n';       // prints 15
          std::cout << sum<6> << '\n';       // prints 21
          }

        Note that variable templates do not enable any novel patterns; anything that can be achieved
        using them could also have been achieved in C++11 along with some additional boilerplate.
        The initial typeId example could have instead been implemented using a struct:
          template <typename> struct TypeId { static int value; };

        And used with just a bit more syntax:
          void f1b()
          {
          TypeId<bool>::value = ­1;         // TypeId<bool>::value is an int.
          TypeId<char>::value = 1000;       // TypeId<char>::value is an int.
          TypeId<void>::value = ­666;       // TypeId<void>::value is an int.

          assert(TypeId<bool>.value ==   ­1);
          assert(TypeId<char>.value == 1000);
          assert(TypeId<void>.value == ­666);
          }


        Use Cases
        Parameterized constants
        A common effective use of variable templates is in the definition of type-parameterized
        constants. As discussed in Description on page 185, the mathematical constant π serves as
        our example. Here we want to initialize the constant as part of the variable template (the
        literal chosen is the shortest decimal string to do so accurately for an 80-bit long double)158 :
          template <typename T>
          constexpr T pi(3.1415926535897932385);
          // smallest digit sequence to accurately represent pi as a long double

        Notice that we have elected to use constexpr variables (from C++11) in place of a classic
        const as a stronger guarantee that the provided initializer is a compile-time constant and
        that pi itself will be usable as part of a constant expression.
            With the definition above, we can provide a toRadians function template that performs
        at maximum runtime eﬀiciency by avoiding needless type conversions during the computa-
        tion:
          template <typename T>
          constexpr T toRadians(T degrees)
          {
          return degrees * (pi<T> / T(180));
          }

         158 For  portability, a floating-point literal value of π that provides suﬀicient precision for
        the  longest long double on any relevant platform (e.g., 128 bits or 34 decimal digits:
        3.141'592'653'589'793'238'462'643'383'279'503) should be used; see Section 1, “Digit Separators.”
                                                                                                     187


i



    i                                                                                                       i
    i                                                                                                              i
                       “emcpps-internal” — 2021/1/16 — 3:34 — page 188 — #190

i



        Variable Templates                                                     Chapter 1      Safe Features


        Reducing verbosity of type traits
        A type trait is an empty type carrying compile-time information about one or more aspects
        of another type. The way in which type traits have been specified historically has been to
        define a class template having the trait name and a public static (or enum) data member,
        that is conventionally called value, which is initialized in the primary template to false.
        Then, for each type that wants to advertise that it has this trait, the header defining the
        trait is included and the trait is specialized for that type, initializing value to true. We can
        achieve precisely this same usage pattern replacing a trait struct with a variable template
        whose name represents the type trait and whose type of variable itself is always bool.
        Preferring variable templates in this use case decreases the amount of boilerplate code —
        both at the point of definition and at the call site.159
            Consider, for example, a boolean trait designating whether a particular type T can be
        serialized to JSON:
          // isSerializableToJson.h

          template <typename T>
          constexpr bool isSerializableToJson = false;

        The header above contains the general variable template trait that, by default, concludes
        that a given type is not serializable to JSON. Next we consider the streaming utility itself:
          // serializeToJson.h
          #include <isSerializableToJson.h>           // general trait variable template

          template <typename T>
          JsonObject serializeToJson(const T& object)              // serialization function template
          {
          static_assert(isSerializableToJson<T>,
          "T must support serialization to JSON.");

          // ...
          }

        Notice that we have used the C++11 static_assert feature to ensure that any type used
        to instantiate this function will have specialized (see the next code snippet) the general
        variable template associated with the specific type to be true.
            Now imagine that we have a type, CompanyData, that we would like to advertise at
        compile time as being serializable to JSON. Like other templates, variable templates can be
        specialized explicitly:
          159 As of C++17, the Standard Library provides a more convenient way of inspecting the result of a

        type trait, by introducing variable templates named the same way as the corresponding traits but with an
        additional _v suﬀix:
         // C++11/14
         std::is_default_constructible<T>::value

         // C++17
         std::is_default_constructible_v<T>


                                                          188


i



    i                                                                                                              i
    i                                                                                                                 i
                     “emcpps-internal” — 2021/1/16 — 3:34 — page 189 — #191

i



        C++14                                                                                 Variable Templates


          // companyData.h
          #include <isSerializableToJson.h>             // general trait variable template

          struct CompanyData { /* ... */ };             // type to be JSON serialized

          template <>
          constexpr bool isSerializableToJson<CompanyData> = true;
          // Let anyone who needs to know that this type is JSON serializable.

        Finally, our client function incorporates all of the above and attempts to serialize both a
        CompanyData object and an std::map<int, char>>:
          // client.h
          #include <isSerializableToJson.h>             //   general trait template
          #include <companyData.h>                      //   JSON serializable type
          #include <serializeToJson.h>                  //   serialization function
          #include <map>                                //   std::map (not JSON serializable)

          void client()
          {
          auto jsonObj0 = serializeToJson<CompanyData>();         // OK
          auto jsonObj1 = serializeToJson<std::map<int, char>>(); // compile­time error
          }

        In the client() function above, CompanyData works fine, but, because the variable template
        isSerializableToJson was never specialized to be true for type std::map<int, char>>,
        the client header will — as desired — fail to compile.

        Potential Pitfalls
        Recursive variable template initializations require const or constexpr
        When discussing the intricacies of the C++ language with your peers, consider quizzing
        them on why the example below, having no undefined behavior, might produce different
        results with popular compilers160 :
          #include <iostream>

          template <int N>
          int fib = fib<N ­ 1> + fib<N ­ 2>;

          template <> int fib<2> = 1;
          template <> int fib<1> = 1;

          int main()
          {
          std::cout << fib<4> << '\n';           // 3 expected
          std::cout << fib<5> << '\n';           // 5 expected
          std::cout << fib<6> << '\n';           // 8 expected
          160 For example, GCC version 4.7.0 (2017) produces the expected results whereas Clang version 10.x (2020)

        produces 1, 3, and 4, respectively.
                                                                                                              189


i



    i                                                                                                                 i
    i                                                                                                      i
                      “emcpps-internal” — 2021/1/16 — 3:34 — page 190 — #192

i



        Variable Templates                                               Chapter 1     Safe Features



          return 0;
          }

        The didactic value in answering this question dwarfs any potential practical value that
        recursive template variable instantiation can offer. First, consider that this same issue could,
        in theory, have occurred in C++03 using nested static members of a struct:
          #include <iostream>

          template <int N> struct Fib
          {
          static int value;                                     // BAD IDEA: not const
          };

          template <> struct Fib<2> { static int value; };           // BAD IDEA: not const
          template <> struct Fib<1> { static int value; };           // BAD IDEA: not const

          template <int N> int Fib<N>::value = Fib<N ­ 1>::value + Fib<N ­ 2>::value;
          int Fib<2>::value = 1;
          int Fib<1>::value = 1;

          int main()
          {
          std::cout << Fib<4>::value << '\n';        // 3 expected
          std::cout << Fib<5>::value << '\n';        // 5 expected
          std::cout << Fib<6>::value << '\n';        // 8 expected

          return 0;
          };

        The problem did not manifest, however, because the simpler solution of using enums (below)
        obviated separate initialization of the local static and didn’t admit the possibility of failing
        to make the initializer a compile-time constant:
          #include <iostream>

          template <int N> struct Fib
          {
          enum { value = Fib<N ­ 1>::value + Fib<N ­ 2>::value };           // OK ­ const
          };

          template <> struct Fib<2> { enum { value = 1 }; };                     // OK ­ const
          template <> struct Fib<1> { enum { value = 1 }; };                     // OK ­ const

          int main()
          {
          std::cout << Fib<4>::value << '\n';        // 3 guaranteed
          std::cout << Fib<5>::value << '\n';        // 5 guaranteed
          std::cout << Fib<6>::value << '\n';        // 8 guaranteed

                                                      190


i



    i                                                                                                      i
    i                                                                                                          i
                     “emcpps-internal” — 2021/1/16 — 3:34 — page 191 — #193

i



        C++14                                                                           Variable Templates


          return 0;
          };

        It was not until C++14 that the variable templates feature readily exposed this latent pitfall
        involving recursive initialization of non-const variables. The root cause of the instability is
        that the relative order of the initialization of the (recursively generated) variable instantia-
        tions is not guaranteed because they are not defined explicitly within the same translation
        unit. The magic sauce that makes everything work is the C++ language requirement that
        any variable that is declared const and initialized with a compile-time constant is itself
        to be treated as a compile-time constant within the translation unit. This compile-time-
        constant propagation requirement imposes the needed ordering to ensure that the expected
        results are portable to all conforming compilers:
          #include <iostream>

          template <int N>
          const int fib = fib<N ­ 1> + fib<N ­ 2>;           // OK ­ compile­time const.

          template <> const int fib<2> = 1;                  // OK ­ compile­time const.
          template <> const int fib<1> = 1;                  // OK ­ compile­time const.

          int main()
          {
          std::cout << fib<4> << '\n';        // guaranteed to print out 3
          std::cout << fib<5> << '\n';        // guaranteed to print out 5
          std::cout << fib<6> << '\n';        // guaranteed to print out 8

          return 0;
          }

        Note that replacing each of the three const keywords with constexpr in the example above
        also achieves the desired goal and does not consume memory in the static data space.

        Annoyances
        Variable templates do not support template template parameters
        While a class or function template can accept a template template class parameter, no
        equivalent construct is available for variable templates161 :
          template <typename T> T vt(5);

          template <template <typename> class>
          struct S { };

          S<vt> s1;    // compile­time error




          161 Pusz has proposed for C++23 a way to increase consistency between variable templates and class

        templates when used as template template parameters; see pusz20.
                                                                                                        191


i



    i                                                                                                          i
    i                                                                                                i
                      “emcpps-internal” — 2021/1/16 — 3:34 — page 192 — #194

i



        Variable Templates                                           Chapter 1    Safe Features


        Providing a wrapper struct around a variable template might therefore be necessary in case
        the variable template needs to be passed to an interface accepting a template template
        parameter:
         template <typename T>
         struct Vt { static constexpr T value = vt<T>; }

         S<Vt> s2;    // OK


        See Also
          • Section 2, “constexpr Variables” — Conditionally safe C++11 feature providing an
            alternative to const template variables that can reduce unnecessary consumption of
            the static data space

        Further Reading
        None so far




                                                   192


i



    i                                                                                                i
    i                                                                                                   i
                    “emcpps-internal” — 2021/1/16 — 3:34 — page 193 — #195

i



        C++14                                                               constexpr Functions '14




        Relaxed Restrictions on constexpr Functions
        C++14 lifts restrictions regarding use of many language features in the body of a constexpr
        function (see “constexpr Functions” on page 219).

        Description
        The cautious introduction (in C++11) of constexpr functions — i.e., functions eligible for
        compile-time evaluation — was accompanied by a set of strict rules that, despite making life
        easier for compiler implementers, severely narrowed the breadth of valid use cases for the
        feature. In C++11, constexpr function bodies were restricted to essentially a single return
        statement and were not permitted to have any modifiable local state (variables) or imper-
        ative language constructs (e.g., assignment), thereby greatly reducing their usefulness:
          constexpr int fact11(int x)
          {
          static_assert(x >= 0, "");
          // Error in C++11/14: x is not a constant expression.

          static_assert(sizeof(x) >= 4, "");      // OK in C++11/14

          return x < 2 ? 1 : x * fact11(x ­ 1);       // OK in C++11/14
          }

        Notice that recursive calls were supported, often leading to convoluted implementations of
        algorithms (compared to an imperative counterpart); see Use Cases: Nonrecursive cons­
        texpr algorithms on page 194.
           The C++11 static_assert feature (see “static_assert” on page 136) was always
        permitted in a C++11 constexpr function body. However, because the input variable x in
        fact11 (in the code snippet above) is inherently not a compile-time constant expression, it
        can never appear as part of a static_assert predicate. Note that a constexpr function
        returning void was also permitted:
          constexpr void no_op() { };     // OK in C++11/14

        Experience gained from the release and subsequent real-world use of C++11 emboldened the
        standard committee to lift most of these (now seemingly arbitrary) restrictions for C++14,
        allowing use of (nearly) all language constructs in the body of a constexpr function. In
        C++14, familiar non-expression-based control-flow constructs, such as if statements and
        while loops, are also available, as are modifiable local variables and assignment operations:
          constexpr int fact14(int x)
          {
          if (x <= 2)        // error in C++11; OK in C++14
          {
          return 1;
          }

          int temp = x ­ 1;    // error in C++11; OK in C++14
                                                                                                 193


i



    i                                                                                                   i
    i                                                                                                                   i
                        “emcpps-internal” — 2021/1/16 — 3:34 — page 194 — #196

i



        constexpr Functions '14                                                   Chapter 1       Safe Features


          return x * fact14(temp);
          }

        Some useful features remain disallowed in C++14; most notably, any form of dynamic
        allocation is not permitted, thereby preventing the use of common standard container types,
        such as std::string and std::vector162 :

           1. asm declarations
           2. goto statements
           3. Statements with labels other than case and default

           4. try blocks
           5. Definitions of variables
             (a) of other than a literal type (i.e., fully processable at compile time)
            (b) decorated with either static or thread_local
             (c) left uninitialized
        The restrictions on what can appear in the body of a constexpr that remain in C++14
        are reiterated here in codified form163 :
          template <typename       T>
          constexpr void f()
          try {                        // Error: try outside body isn't allowed (until C++20).
          std::ifstream is;        // Error: objects of *non­literal* types aren't allowed.
          int x;                   // error: uninitialized vars. disallowed (until C++20)
          static int y = 0;        // Error: static variables are disallowed.
          thread_local T t;        // Error: thread_local variables are disallowed.
          try{}catch(...){}        // error: try/catch disallowed (until C++20)
          if (x) goto here;        // Error: goto statements are disallowed.
          []{};                    // Error: lambda expressions are disallowed (until C++17).
          here: ;                      // Error: labels (except case/default) aren't allowed.
          asm("mov %r0");          // Error: asm directives are disallowed.
          } catch(...) { }             // error: try outside body disallowed (until C++20)


        Use Cases
        Nonrecursive constexpr algorithms
        The C++11 restrictions on the use of constexpr functions often forced programmers to im-
        plement algorithms (that would otherwise be implemented iteratively) in a recursive manner.



          162 In C++20, even more restrictions were lifted, allowing, for example, some limited forms of dynamic

        allocation, try blocks, and uninitialized variables.
          163 Note that the degree to which these remaining forbidden features are reported varies substantially from

        one popular compiler to the next.
                                                            194


i



    i                                                                                                                   i
    i                                                                                                                  i
                      “emcpps-internal” — 2021/1/16 — 3:34 — page 195 — #197

i



        C++14                                                                          constexpr Functions '14


        Consider, as a familiar example, a naive164 C++11-compliant constexpr implementation
        of a function, fib11, returning the nth Fibonacci number165 :
          constexpr long long fib11(long long x)
          {
          return
          x == 0 ? 0
          : (x == 1 || x == 2) ? 1
          : fib11(x ­ 1) + fib11(x ­ 2);
          }

        The implementation of the fib11 function (above) has various undesirable properties.

           1. Reading diﬀiculty — Because it must be implemented using a single return statement,
              branching requires a chain of ternary operators, leading to a single long expression that
              might impede human comprehension.
           2. Ineﬀiciency and lack of scaling — The explosion of recursive calls is taxing on compil-
              ers: (1) the time to compile is markedly slower for the recursive (C++11) algorithm
              than it would be for its iterative (C++14) counterpart, even for modest inputs,166
              and (2) the compiler might simply refuse to complete the compile-time calculation if
              it exceeds some internal (platform-dependent) threshold number of operations.167
           3. Redundancy — Even if the recursive implementation were suitable for small input
              values during compile-time evaluation, it would be unlikely to be suitable for any run-
              time evaluation, thereby requiring programmers to provide and maintain two separate

          164 For a more eﬀicient (yet less intuitive) C++11 algorithm, see Appendix: Optimized C++11 Example

        Algorithms, Recursive Fibonacci on page 200.
          165 We used long long (instead of long) here to ensure a unique C++ type having at least 8 bytes on

        all conforming platforms for simplicity of exposition (avoiding an internal copy). We deliberately chose not
        to make the value returned unsigned because the extra bit does not justify changing the algebra (from
        signed to unsigned). For more discussion on these specific topics, see “long long” on page 114.
          166 As an example, Clang 10.0.0, running on an x86-64 machine, required more than 80 times longer to eval-

        uate fib(27) implemented using the recursive (C++11) algorithm than to evaluate the same functionality
        implemented using the iterative (C++14) algorithm.
          167 The same Clang 10.0.0 compiler discussed in the previous footnote failed to compile fib11(28):


          error: static_assert expression is not an integral constant expression
          static_assert(fib11(28) == 317811, "");
          ^~~~~~~~~~~~~~~~~~~

          note: constexpr evaluation hit maximum step limit; possible infinite loop?

        GCC 10.x fails at fib(36), with a similar diagnostic:
          error: 'constexpr' evaluation operation count exceeds limit of 33554432
          (use '­fconstexpr­ops­limit=' to increase the limit)

        Clang 10.x fails to compile any attempt at constant evaluating fib(28), with the following diagnostic
        message:
          note: constexpr evaluation hit maximum step limit; possible infinite loop?


                                                                                                               195


i



    i                                                                                                                  i
    i                                                                                                               i
                        “emcpps-internal” — 2021/1/16 — 3:34 — page 196 — #198

i



        constexpr Functions '14                                                Chapter 1       Safe Features


              versions of the same algorithm: a compile-time recursive one and a runtime iterative
              one.
            In contrast, an imperative implementation of a constexpr function implementing a
        function returning the nth Fibonacci number in C++14, fib14, does not suffer from any
        of the three issues discussed above:
          constexpr long long fib14(long long x)
          {
          if (x == 0) { return 0; }

          long long a = 0;
          long long b = 1;

          for (long long i = 2; i <= x; ++i)
          {
          long long temp = a + b;
          a = b;
          b = temp;
          }

          return b;
          }

        As one would expect, the compile time required to evaluate the iterative implementation
        (above) is manageable168 ; of course, far more computationally eﬀicient (e.g., closed form169 )
        solutions to this classic exercise are available.

        Optimized metaprogramming algorithms
        C++14’s relaxed constexpr restrictions enable the use of modifiable local variables and
        imperative language constructs for metaprogramming tasks that were historically often
        implemented by using (Byzantine) recursive template instantiation (notorious for their vo-
        racious consumption of compilation time).
            Consider, as the simplest of examples, the task of counting the number of occurrences
        of a given type inside a type list represented here as an empty variadic template (see
        “Variadic Templates” on page 314) that can be instantiated using a variable-length sequence
        of arbitrary C++ types170 :
          168 Both GCC 10.x and Clang 10.x evaluated fib14(46) 1836311903 correctly in under 20ms on a machine

        running Windows 10 x64 and equipped with a Intel Core i7-9700k CPU.
          169 E.g., see http://mathonline.wikidot.com/a-closed-form-of-the-fibonacci-sequence.
          170 Variadic templates are a C++11 feature having many valuable and practical uses. In this case, the

        variadic feature enables us to easily describe a template that takes an arbitrary number of C++ type
        arguments by specifying an ellipsis (...) immediately following typename. Emulating such functionality in
        C++98/03 would have required significantly more effort: A typical workaround for this use case would have
        been to create a template having some fixed maximum number of arguments (e.g., 20), each defaulted to
        some unused (incomplete) type (e.g., Nil):
          struct Nil;   // arbitrary unused (incomplete) type

          template <typename = Nil, typename = Nil, typename = Nil, typename = Nil>
                                                          196


i



    i                                                                                                               i
    i                                                                                                                       i
                      “emcpps-internal” — 2021/1/16 — 3:34 — page 197 — #199

i



        C++14                                                                              constexpr Functions '14


          template <typename...> struct TypeList { };
          // empty variadic template instantiable with arbitrary C++ type sequence

        Explicit instantiations of this variadic template could be used to create objects:
          TypeList<>                 emptyList;
          TypeList<int>              listOfOneInt;
          TypeList<int, double, Nil> listOfThreeIntDoubleNil;

        A naive C++11-compliant implementation of a metafunction Count, used to ascertain
        the (order-agnostic) number of times a given C++ type was used when creating an instance
        of the TypeList template (above), would usually make recursive use of (baroque) partial
        class template specialization171 to satisfy the single-return-statement requirements172 :

          struct TypeList { };
          // emulates the variadic TypeList template struct for up to four
          // type arguments
        Another theoretically appealing approach is to implement a Lisp-like recursive data structure; the compile-
        time overhead for such implementations, however, often makes them impractical.
          171 The use of class-template specialization (let alone partial specialization) might be unfamiliar to those

        not accustomed to writing low-level template metaprograms, but the point of this use case is to obviate
        such unfamiliar use. As a brief refresher, a general class template is what the client typically sees at the user
        interface. A specialization is typically an implementation detail consistent with the contract specified in the
        general template but somehow more restrictive. A partial specialization (possible for class but not function
        templates) is itself a template but with one or more of the general template parameters resolved. An explicit
        or full specialization of a template is one in which all of the template parameters have been resolved and,
        hence, is not itself a template. Note that a full specialization is a stronger candidate for a match than a
        partial specialization, which is a stronger match candidate than a simple template specialization, which, in
        turn, is a better match than the general template (which, in this example, happens to be an incomplete
        type).
          172 Notice that this Count metafunction also makes use (in its implementation) of variadic class templates

        to parse a type list of unbounded depth. Had this been a C++03 implementation, we would have been
        forced to create an approximation (to the simple class-template specialization containing the parameter
        pack Tail...) consisting of a bounded number (e.g., 20) of simple (class) template specializations, each
        one taking an increasing number of template arguments:
          template <typename X, typename Y>
          struct Count<X, TypeList<Y>>
          : std::integral_constant<int, std::is_same<X, Y>::value> { };
          // (class) template specialization for one argument

          template <typename X, typename Y, typename Z>
          struct Count<X, TypeList<Y, Z>>
          : std::integral_constant<int,
          std::is_same<X, Y>::value + std::is_same<X, Z>::value> { };
          // (class) template specialization for two arguments

          template <typename X, typename Y, typename Z, typename A>
          struct Count<X, TypeList<Y, Z, A>>
          : std::integral_constant<int,
          std::is_same<X, Y>::value + Count<X, TypeList<Z, A>>::value> { };
          // recursive (class) template specialization for three arguments

          // ...


                                                                                                                    197


i



    i                                                                                                                       i
    i                                                                                                         i
                       “emcpps-internal” — 2021/1/16 — 3:34 — page 198 — #200

i



        constexpr Functions '14                                            Chapter 1      Safe Features


          #include <type_traits>       // std::integral_constant, std::is_same

          template <typename X, typename List> struct Count;
          // general template used to characterize the interface for the Count
          // metafunction
          // Note that this general template is an incomplete type.

          template <typename X>
          struct Count<X, TypeList<>> : std::integral_constant<int, 0> { };
          // partial (class) template specialization of the general Count template
          // (derived from the integral­constant type representing a compile­time
          // 0), used to represent the base case for the recursion ­­­ i.e., when
          // the supplied TypeList is empty
          // The payload (i.e., the enumerated value member of the base class)
          // representing the number of elements in the list is 0.

          template <typename X, typename Head, typename... Tail>
          struct Count<X, TypeList<Head, Tail...>>
          : std::integral_constant<int,
          std::is_same<X, Head>::value + Count<X, TypeList<Tail...>>::value> { };
          // simple (class) template specialization of the general count template
          // for when the supplied list is not empty
          // In this case, the second parameter will be partitioned as the first
          // type in the sequence and the (possibly empty) remainder of the
          // TypeList. The compile­time value of the base class will be either the
          // same as or one greater than the value accumulated in the TypeList so
          // far, depending on whether the first element is the same as the one
          // supplied as the first type to Count.

          static_assert(Count<int, TypeList<int, char, int, bool>>::value == 2, "");

        Notice that we made use of a C++11 parameter pack, Tail... (see “Variadic Templates”
        on page 314), in the implementation of the simple template specialization to package up
        and pass along any remaining types.
           As should be obvious by now, the C++11 restriction encourages both somewhat rarified
        metaprogramming-related knowledge and a recursive implementation that can be compile-
        time intensive in practice.173 By exploiting C++14’s relaxed constexpr rules, a simpler
        and typically more compile-time friendly imperative solution can be realized:
          template <typename X, typename... Ts>
          constexpr int count()
          {
          bool matches[sizeof...(Ts)] = { std::is_same<X, Ts>::value... };
          // Create a corresponding array of bits where 1 indicates sameness.

          int result = 0;
          for (bool m : matches)       // (C++11) range­based for loop

          173 For a more eﬀicient C++11 version of Count, see Appendix: Optimized C++11 Example Algorithms,

        constexpr type list Count algorithm on page 200.
                                                       198


i



    i                                                                                                         i
    i                                                                                                                   i
                      “emcpps-internal” — 2021/1/16 — 3:34 — page 199 — #201

i



        C++14                                                                           constexpr Functions '14


          {
          result += m;               // Add up 1 bits in the array.
          }

          return result;       // Return the accumulated number of matches.
          }

        The implementation above — though more eﬀicient and comprehensible — will require some
        initial learning for those unfamiliar with modern C++ variadics. The general idea here is
        to use pack expansion in a nonrecursive manner174 to initialize the matches array with
        a sequence of zeros and ones (representing, respectively, mismatch and matches between X
        and a type in the Ts... pack) and then iterate over the array to accumulate the number of
        ones as the final result. This constexpr-based solution is both easier to understand and
        typically faster to compile.175

        Potential Pitfalls
        None so far

        Annoyances
        None so far

        See Also
           • “constexpr Functions” — Conditionally safe C++11 feature that first introduced
             compile-time evaluations of functions.
           • “constexpr Variables” — Conditionally safe C++11 feature that first introduced
             variables usable as constant expressions.
           • “Variadic Templates” — Conditionally safe C++11 feature allowing templates to ac-
             cept an arbitrary number of parameters.
          174 Pack expansion is a language construct that expands a variadic pack during compilation, generating

        code for each element of the pack. This construct, along with a parameter pack itself, is a fundamental
        building block of variadic templates, introduced in C++11. As a minimal example, consider the variadic
        function template, e:
          template <int... Is> void e() { f(Is...); }

        e is a function template that can be instantiated with an arbitrary number of compile-time-constant integers.
        The int... Is syntax declares a variadic pack of compile-time-constant integers. The Is... syntax (used
        to invoke f) is a basic form of pack expansion that will resolve to all the integers contained in the Is
        pack, separated by commas. For instance, invoking e<0, 1, 2, 3>() results in the subsequent invocation
        of f(0, 1, 2, 3). Note that — as seen in the count example (which starts on page 198) — any arbitrary
        expression containing a variadic pack can be expanded:
          template <int... Is> void g() { h((Is > 0)...); }

        The (Is > 0)... expansion (above) will resolve to N comma-separated Boolean values, where N is the number
        of elements contained in the Is variadic pack. As an example of this expansion, invoking g<5, ­3, 9>()
        results in the subsequent invocation of h(true, false, true).
          175 For a type list containing 1024 types, the imperative (C++14) solution compiles about twice as fast on

        GCC 10.x and roughly 2.6 times faster on Clang 10.x.
                                                                                                                199


i



    i                                                                                                                   i
    i                                                                                             i
                      “emcpps-internal” — 2021/1/16 — 3:34 — page 200 — #202

i



        constexpr Functions '14                                    Chapter 1    Safe Features


        Further Reading
        None so far

        Appendix: Optimized C++11 Example Algorithms
        Recursive Fibonacci
        Even with the restrictions imposed by C++11, we can write a more eﬀicient recursive
        algorithm to calculate the nth Fibonacci number:
         #include <utility>    // std::pair

         constexpr std::pair<long long, long long> fib11NextFibs(
         const std::pair<long long, long long> prev, // last two calculations
         int count)                                   // remaining steps
         {
         return (count == 0) ? prev : fib11NextFibs(
         std::pair<long long, long long>(prev.second,
         prev.first + prev.second),
         count ­ 1);
         }

         constexpr long long fib11Optimized(long long n)
         {
         return fib11NextFibs(
         std::pair<long long, long long>(0, 1), // first two numbers
         n                                      // number of steps
         ).second;
         }


        constexpr type list Count algorithm
        As with the fib11Optimized example, providing a more eﬀicient version of the Count
        algorithm in C++11 is also possible, by accumulating the final result through recursive
        constexpr function invocations:
         #include <type_traits>    // std::is_same

         template <typename>
         constexpr int count11Optimized() { return 0; }
         // Base case: always return 0.

         template <typename X, typename Head, typename... Tail>
         constexpr int count11Optimized()
         // Recursive case: compare the desired type (X) and the first type in
         // the list (Head) for equality, turn the result of the comparison
         // into either 1 (equal) or 0 (not equal), and recurse with the rest
         // of the type list (Tail...).
         {
         return (std::is_same<X, Head>::value ? 1 : 0)
                                                  200


i



    i                                                                                             i
    i                                                                                                i
                   “emcpps-internal” — 2021/1/16 — 3:34 — page 201 — #203

i



        C++14                                                             constexpr Functions '14


         + count11Optimized<X, Tail...>();
         }

        This algorithm can be optimized even further in C++11 by using a technique similar to
        the one shown for the iterative C++14 implementation. By leveraging a std::array as
        compile-time storage for bits where 1 indicates equality between types, we can compute the
        final result with a fixed number of template instantiations:
         #include <array>           // std::array
         #include <type_traits>     // std::is_same

         template <int N>
         constexpr int count11VeryOptimizedImpl(
         const std::array<bool, N>& bits, // storage for "type sameness" bits
         int i)                            // current array index
         {
         return i < N
         ? bits[i] + count11VeryOptimizedImpl<N>(bits, i + 1)
         // Recursively read every element from the bits array and
         // accumulate into a final result.
         : 0;
         }

         template <typename X, typename... Ts>
         constexpr int count11VeryOptimized()
         {
         return count11VeryOptimizedImpl<sizeof...(Ts)>(
         std::array<bool, sizeof...(Ts)>{ std::is_same<X, Ts>::value... },
         // Leverage pack expansion to avoid recursive instantiations.
         0);
         }

        Note that, despite being recursive, count11VeryOptimizedImpl will be instantiated only
        once with N equal to the number of elements in the Ts... pack.




                                                                                              201


i



    i                                                                                                i
    i                                                            i
        “emcpps-internal” — 2021/1/16 — 3:34 — page 202 — #204

i




i



    i                                                            i
    i                                                                             i
                   “emcpps-internal” — 2021/1/16 — 3:34 — page 203 — #205

i




        Chapter 2
        Conditionally Safe Features
        Intro text should be here.




                                                                            203


i



    i                                                                             i
    i                                                                                                                  i
                        “emcpps-internal” — 2021/1/16 — 3:34 — page 204 — #206

i



        alignas                                               Chapter 2       Conditionally Safe Features



        The alignas Decorator
        alignas, a keyword that acts like an attribute, is used to widen (make more strict) the
        alignment of a variable, user-defined type, or data member.

        Description
        The alignas specifier provides a means of further restricting the granularity at which (1) a
        particular object of arbitrary type, (2) a user-defined type (class, struct, union, or enum),
        or (3) an individual data member is permitted to reside within the virtual-memory-address
        space.

        Restricting the alignment of a particular object
        In its most basic form, alignas acts like an attribute that accepts (as an argument) an
        integral constant expression representing an explicitly supplied minimum alignment
        value:
          alignas(64) int i;           // OK, i is aligned on a 64­byte address boundary.
          int j alignas(8), k;         // OK, j is 8­byte aligned; k remains naturally aligned.

        If more than one alignment pertains to a given object, the most restrictive alignment value
        is applied:
          alignas(4) alignas(8) alignas(2) char m;                // OK, m is 8­byte aligned.
          alignas(8) int n alignas(16);                           // OK, n is 16­byte aligned.

        For a program to be well formed, a specified alignment value must satisfy several
        requirements:
           1. Be either zero or a non-negative integral power of two of type std::size_t (0, 1, 2,
              4, 8, 16…).
           2. Be at least the minimum alignment1 required by the decorated entity.
           3. Be no more than the largest alignment2 supported on the platform in the context in
              which the entity appears.
            1 The minimum alignment of an entity is the least restrictive memory-address boundary at which the

        entity can be placed and have the program continue to work properly. This value is platform dependent and
        often subject to compiler controls but, by default, is often well approximated by natural alignment; see
        Appendix: Natural Alignment on page 212.
            2 The notion of the largest supported alignment is characterized by both maximal alignment and the

        maximum extended alignment. Maximal alignment is defined as that most restrictive alignment that is
        valid in all contexts on the current platform. All fundamental and pointer types necessarily have a minimal
        alignment that is less than or equal to alignof(std::max_align_t) — typically 8 or 16. Any alignment value
        greater than maximal alignment is an extended alignment value. Whether any extended alignment is
        supported (and in which contexts) is implementation defined. On typical platforms, extended alignment will
        often be as large as 218 or 219 , however implementations may warn when the alignment of a global object
        exceeds some maximal hardware threshold (such as the size of a physical memory page, e.g., 4096 or 8192).
        For automatic variables (defined on the program stack), making alignment more restrictive than what
        would naturally be employed is seldom desired because at most one thread is able to access proximately
        located variables there unless explicitly passed in via address to separate threads; see Use Cases: Avoiding
                                                            204


i



    i                                                                                                                  i
    i                                                                                                                 i
                     “emcpps-internal” — 2021/1/16 — 3:34 — page 205 — #207

i



        C++11                                                                                           alignas


        Additionally, if the specified alignment value is zero, the alignas specifier is ignored:
          // Static variables declared at namespace scope
          alignas(32) int i0; // OK, aligned on a 32­byte boundary (extended alignment)
          alignas(16) int i1; // OK, aligned on a 16­byte boundary (maximum alignment)
          alignas(8) int i2; // OK, aligned on an 8­byte boundary
          alignas(7) int i3; // error: not a power of two
          alignas(4) int i4; // OK, no change to alignment boundary
          alignas(2) int i5; // error: less than minimum alignment on this platform
          alignas(0) int i6; // OK, alignas specifier ignored

          alignas(1024 * 16) int i7;
          // OK, might warn: e.g., exceeds (physical) page size on current platform

          alignas(1024 * 1024 * 512) int i8;
          // (likely) compile­time error: e.g., exceeds maximum size of object file

          alignas(8) char buf[128];           // create 8­byte­aligned, 128­byte character buffer

          void f()
          {
          // automatic variables declared at function scope
          alignas(4) double e0; // error: less than minimum alignment on this platform
          alignas(8) double e1; // OK, no­change to (8­byte) alignment boundary
          alignas(16) double e2; // OK, aligned to maximum (fundamental) alignment value
          alignas(32) double e3; // OK, maximum alignment value exceeded; might warn
          }


        Restricting the alignment of a user-defined type
        The alignas specifier can also be used to specify alignment for user-defined types (UDTs),
        such as a class, struct, union, or enum. When specifying the alignment of a UDT, the
        alignas keyword is placed after the type specifier (e.g., class) and just before the name
        of the type (e.g., C):
          class alignas(2)       C   {   };   //   OK,   aligned   on   a 2­byte boundary; size = 2
          struct alignas(4)      S   {   };   //   OK,   aligned   on   a 4­byte boundary; size = 4
          union alignas(8)       U   {   };   //   OK,   aligned   on   an 8­byte boundary; size = 8
          enum alignas(16)       E   {   };   //   OK,   aligned   on   a 16­byte boundary; size = 4

        Notice that, for each of class, struct, and union above, the sizeof objects of that type
        increased to match the alignment; in the case of the enum, however, the size remains that
        of the default underlying type (e.g., 4 bytes) on the current platform.3

        false sharing among distinct objects in a multi-threaded program on page 209. Note that, in the case of i
        in the first code snippet on page 204, a conforming platform that did not support an extended alignment of
        64 would be required to report an error at compile time.
            3 When alignas is applied to an enumeration E, the Standard does not indicate whether padding bits are

        added to E’s object representation or not, affecting the result of sizeof(E). The implementation variance
        resulting from this lack of clarity in the Standard was captured in miller17. The outcome of the core issue
        was to completely remove permission for alignas to be applied to enumerations (see iso18a). Therefore,
                                                                                                              205


i



    i                                                                                                                 i
    i                                                                                                            i
                       “emcpps-internal” — 2021/1/16 — 3:34 — page 206 — #208

i



        alignas                                            Chapter 2      Conditionally Safe Features


            Again, specifying an alignment that is less than what would occur naturally or else is
        restricted explicitly is ill formed:
          struct alignas(2) T0 {      int i; };
          // Error: Alignment of      T0 (2) is less than that of int (4).
          struct alignas(1) T1 {      C c; };
          // Error: Alignment of      T1 (1) is less than that of C (2).


        Restricting the alignment of individual data members
        Within a user-defined type (class, struct, or union), using the attribute-like syntax of
        the alignas keyword to specify the alignments of individual data members is possible:
          struct T2
          {
          alignas(8)     char   x; // size         1; alignment 8
          alignas(16)    int    y; // size         4; alignment 16
          alignas(64)    double y; // size         8; alignment 64
          }; // size     128; alignment 64

        The effect here is the same as if we had added the padding explicitly and then set the
        alignment of the structure overall:
          struct   alignas(64) T3
          {
          char     x;      // size   1; alignment 8
          char     a[15]; // padding
          int      y;      // size   4; alignment 16
          char     b[44]; // padding
          double   z;      // size   8; alignment 64
          char     c[56]; // padding (optional)
          }; //    size 128; alignment 64

        Again, if more than one attribute pertains to a given data member, the maximum applicable
        alignment value is applied:
          struct T4
          {
          alignas(2) char
          c1 alignas(1), // size 1; alignment 2
          c2 alignas(2), // size 1; alignment 2
          c4 alignas(4); // size 1; alignment 4
          };                     // size 8; alignment 4


        Matching the alignment of another type
        The alignas specifier also accepts (as an argument) a type identifier. In its alternate form,
        alignas(T) is strictly equivalent to alignas(alignof(T)):
          alignas(int) char c;       // equivalent to alignas(alignof(int)) char c;

        conforming implementations will eventually stop accepting the alignas specifier on enumerations in the
        future.
                                                         206


i



    i                                                                                                            i
    i                                                                                                    i
                     “emcpps-internal” — 2021/1/16 — 3:34 — page 207 — #209

i



        C++11                                                                                alignas


        Use Cases
        Creating a sufficiently aligned object buffer
        When writing low-level, system-infrastructure code, constructing an object within a raw
        buffer is sometimes useful. As a minimal example, consider a function that uses a local
        character buffer to create an object of type std::complex<long double> on the program
        stack using placement new:
          void f()
          {
          // ...
          char objectBuffer[sizeof(std::complex<long double>)]; // BAD IDEA
          // ...
          new(objectBuffer) std::complex<long double>(1.0, 0.0); // Might dump core!
          // ...
          }

        The essential problem with the code above is that objectBuffer, being an array of char-
        acters (each having an alignment of 1), is itself byte aligned. The compiler is therefore free
        to place it on any address boundary. On the other hand, std::complex<long double> is
        an aggregate consisting of two long double objects and therefore necessarily requires (at
        least) the same strict alignment (typically 16) as the two long double objects it comprises.
        Previous solutions to this problem involved creating a union of the object buffer and some
        maximally aligned type (e.g., std::max_align_t):
          #include <cstddef>     // std::max_align_t

          void f()
          {
          // ...

          union {                                               // awkward workaround
          std::max_align_t dummy; // typedef to maximally aligned type
          char objectBuffer[sizeof(std::complex<long double>)];
          } objectBuffer;

          // ...

          new(&objectBuffer) std::complex<long double>(1.0, 0.0);          // OK

          // ...
          }

        Using the alternate syntax for alignas, we can avoid gratuitous complexity and just state
        our intentions explicitly:
          void f()
          {
          // ...

          alignas(std::complex<long double>) char objectBuffer[
                                                                                                  207


i



    i                                                                                                    i
    i                                                                                                         i
                         “emcpps-internal” — 2021/1/16 — 3:34 — page 208 — #210

i



        alignas                                           Chapter 2     Conditionally Safe Features


          sizeof(std::complex<long double>)];         // GOOD IDEA

          // ...

          new(objectBuffer) std::complex<long double>(1.0, 0.0);             // OK

          // ...
          }


        Ensuring proper alignment for architecture-specific instructions
        Architecture-specific instructions or compiler intrinsics might require the data they act on to
        have a specific alignment. One example of such intrinsics is the Streaming SIMD Extensions
        (SSE)4 instruction set available on the x86 architecture. SSE instructions operate on groups
        of four 32-bit single-precision floating-point numbers at a time, which are required to be 16-
        byte aligned.5 The alignas specifier can be used to create a type satisfying this requirement:
          struct SSEVector
          {
          alignas(16) float d_data[4];
          };

        Each object of the SSEVector type above is guaranteed always to be aligned to a 16-byte
        boundary and can therefore be safely (and conveniently) used with SSE intrinsics:
          #include <xmmintrin.h>       // __m128 and _mm_XXX functions

          void f()
          {
          const SSEVector v0 = {0.0f, 1.0f, 2.0f, 3.0f};
          const SSEVector v1 = {10.0f, 10.0f, 10.0f, 10.0f};

          __m128 sseV0 =    _mm_load_ps(v0.d_data);
          __m128 sseV1 =    _mm_load_ps(v1.d_data);
          // _mm_load_ps    requires the given float array to be 16­byte aligned.
          // The data is    loaded into a dedicated 128­bit CPU register.

          __m128 sseResult = _mm_add_ps(sseV0, sseV1);
          // sum two 128­bit registers; typically generates an addps instruction

          SSEVector vResult;
          _mm_store_ps(vResult.d_data, sseResult);
          // Store the result of the sum back into a float array.

          assert(vResult.d_data[0] == 10.0f);
          assert(vResult.d_data[1] == 11.0f);
          assert(vResult.d_data[2] == 12.0f);
           4 inteliig,
                   “Technologies: SSE”
           5 “Data
                 must be 16-byte aligned when loading to and storing from the 128-bit XMM registers used by
        SSE/SSE2/SSE3/SSSE3”: see intel16, section 4.4.4, “Data Alignment for 128-Bit Data,” pp. 4-19–4-20.
                                                       208


i



    i                                                                                                         i
    i                                                                                                    i
                     “emcpps-internal” — 2021/1/16 — 3:34 — page 209 — #211

i



        C++11                                                                                alignas


          assert(vResult.d_data[3] == 13.0f);
          }


        Avoiding false sharing among distinct objects in a multi-threaded pro-
        gram
        In the context of an application where multithreading has been employed to improve per-
        formance, seeing a previously single-threaded workflow become even less performant after a
        parallelization attempt can be surprising (and disheartening). One possible insidious cause
        of such disappointing results comes from false sharing — a situation in which multiple
        threads unwittingly harm each other’s performance while writing to logically independent
        variables that happen to reside on the same cache line; see Appendix: Cache lines; L1, L2,
        and L3 cache; pages; and virtual memory on page 214.
            As a simple (purely pedagogical) illustration of the potential performance degradation
        resulting from false sharing, consider a function that spawns separate threads to repeatedly
        increment (concurrently) logically distinct variables that happen to reside in close proximity
        on the program stack:
          #include <thread>    // std::thread

          volatile int target = 0;     // updated asynchronously from multiple threads

          void incrementJob(int* p);
          // Repeatedly increment *p a large, fixed number of times;
          // periodically write its current value to target.

          void f()
          {
          int i0 = 0;   // Here, i0 and i1 likely share the same cache line,
          int i1 = 0;   // i.e., byte­aligned memory block on the program stack.

          std::thread t0(&incrementJob, &i0);
          std::thread t1(&incrementJob, &i1);
          // Spawn two parallel jobs incrementing the respective variables.

          t0.join();
          t1.join();
          // Wait for both jobs to be completed.
          }

        In the simplistic example above, the proximity in memory between i0 and i1 can result
        in their belonging to the same cache line, thus leading to false sharing. By prepending
        alignas(64) to the declaration of both integers, we ensure that the two variables reside on
        distinct cache lines:
          // ...

          void f()
          {
                                                                                                  209


i



    i                                                                                                    i
    i                                                                                                                  i
                        “emcpps-internal” — 2021/1/16 — 3:34 — page 210 — #212

i



        alignas                                               Chapter 2       Conditionally Safe Features


          alignas(64) int i0 = 0;           // Assuming a cache line on this platform is 64
          alignas(64) int i1 = 0;           // bytes, i0 and i1 will be on separate ones.

          // ...

        As an empirical demonstration of the effects of false sharing, a benchmark program re-
        peatedly calling f completed its execution seven times faster on average when compared to
        the same program without use of alignas.6

        Avoiding false sharing within a single thread-aware object
        A real-world scenario where the need for preventing false sharing is fundamental occurs
        in the implementation of high-performance concurrent data structures. As an example, a
        thread-safe ring buffer might make use of alignas to ensure that the indices of the head
        and tail of the buffer are aligned at the start of a cache line (typically 64, 128, or 256 bytes),
        thereby preventing them from occupying the same one.
          class ThreadSafeRingBuffer
          {
          alignas(cpuCacheSize) std::atomic<std::size_t> d_head;
          alignas(cpuCacheSize) std::atomic<std::size_t> d_tail;

          // ...
          };

        Not aligning d_head and d_tail (above) to the CPU cache size might result in poor per-
        formance of the ThreadSafeRingBuffer because CPU cores that need to access only one
        of the variables will inadvertently load the other one as well, triggering expensive hardware-
        level coherency mechanisms between the cores’ caches. On the other hand, specifying such
        substantially stricter alignment on consecutive data members necessarily increases the size
        of the object; see Potential Pitfalls: Stricter alignment might reduce cache utilization on
        page 212.

        Potential Pitfalls
        Underspecifying alignment is not universally reported
        The Standard is clear when it comes to underspecifying alignment7 :
              The combined effect of all alignment-specifiers in a declaration shall not specify
              an alignment that is less strict than the alignment that would be required for the
              entity being declared if all alignment-specifiers were omitted (including those in
              other declarations).

           6 The benchmark program was compiled using Clang 11.0.0 using ­Ofast, ­march=native, and

        ­std=c++11. The program was then executed on a machine running Windows 10 x64, equipped with an
        Intel Core i7-9700k CPU (8 cores, 64-byte cache line size). Over the course of multiple runs, the version of
        the benchmark without alignas took 18.5967ms to complete (on average), while the version with alignas
        took 2.45333ms to complete (on average). See [PRODUCTION: CODE PROVIDED WITH BOOK]
        alignasbenchmark for the source code of the program.
            7 cpp11, section 7.6.2, “Alignment Specifier,” paragraph 5, pp. 179

                                                            210


i



    i                                                                                                                  i
    i                                                                                                                 i
                     “emcpps-internal” — 2021/1/16 — 3:34 — page 211 — #213

i



        C++11                                                                                           alignas


        The compiler is required to honor the specified value if it is a fundamental alignment,8
        so imagining how this would lead to anything other than an ill-formed program is diﬀicult:
          alignas(4) void* p;                         // (1) Error: alignas(4) is below minimum, 8.

          struct alignas(2) S { int x; };             // (2) Error: alignas(2) is below minimum, 4.

          struct alignas(2) T { };
          struct alignas(1) U { T e; };               // (3) Error: alignas(1) is below minimum, 2.

        Each of the three errors above are reported by Clang, but GCC doesn’t issue so much as a
        warning (let alone the required error) — even in the most pedantic warning mode. Thus,
        one could write a program, involving statements like those above, that happens to work on
        one platform (e.g., GCC) but fails to compile on another (e.g., Clang).9

        Incompatibly specifying alignment is IFNDR
        It is permissible to forward declare a user-defined type (UDT) without an alignas specifier
        so long as all defining declarations of the type have either no alignas specifier or have
        the same one. Similarly, if any forward declaration of a user-defined type has an alignas
        specifier, then all defining declarations of the type must have the same specifier and that
        specifier must be equivalent to (not necessarily the same as) that in the forward declaration:
          struct   Foo;                         //   OK,   does not specify an alignment
          struct   alignas(double) Foo;         //   OK,   must be equivalent to every definition
          struct   alignas(8) Foo;              //   OK,   all definitions must be identical.
          struct   alignas(8) Foo { };          //   OK,   equivalent to each decl. specifying alignas
          struct   Foo;                         //   OK,   has no effect
          struct   alignas(8) Foo;              //   OK,   has no effect; might warn after definition

        Specifying an alignment in a forward declaration without specifying an equivalent one in
        the defining declaration is ill formed; no diagnostic is required (IFNDR) if the two
        declarations appear in distinct translation units:
          struct alignas(4) Bar;              // OK, forward declaration
          struct Bar { };                     // error: missing alignas specifier

          struct alignas(4) Baz;              // OK, forward declaration
          struct alignas(8) Baz { };          // error: non­equivalent alignas specifier

        Both of the errors above are flagged by Clang, but neither of them is reported by GCC.
        Note that when the inconsistency occurs across translation units, no mainstream compiler
        is likely to diagnose the problem:
          // file1.cpp
          struct Bam { char ch; } bam, *p = &bam;
            8 “If the constant expression evaluates to a fundamental alignment, the alignment requirement of the

        declared entity shall be the specified fundamental alignment”: cpp11, section 7.6.2, “Alignment Specifier,”
        paragraph 2, item 2, p. 178.
            9 Underspecifying alignment is not reported at all by GCC 10.1, using the ­std=c++11 ­Wall ­Wextra

        ­Wpedantic flags. With the same set of options, Clang 10.0 produces a compilation failure. MSVC v19.24
        will produce a warning and ignore any alignment less than the minimum one.
                                                                                                              211


i



    i                                                                                                                 i
    i                                                                                                                 i
                        “emcpps-internal” — 2021/1/16 — 3:34 — page 212 — #214

i



        alignas                                               Chapter 2       Conditionally Safe Features



          // file2.cpp
          struct alignas(int) Bam;           // Error: definition of Bam lacks alignment specifier.
          extern Bam* p;                     //        (no diagnostic required)

        Any program incorporating both translation units above is ill formed, no diagnostic
        required.

        Stricter alignment might reduce cache utilization
        User-defined types having artificially stricter alignments than would naturally occur on the
        host platform means that fewer of them can fit within any given level of physical cache within
        the hardware. Types having data members whose alignment is artificially widened tend to be
        larger and thus suffer the same lost cache utilization. As an alternative to enforcing stricter
        alignment to avoid false sharing, consider organizing a multithreaded program such that
        tight clusters of repeatedly accessed objects are always acted upon by only a single thread
        at a time, e.g., using local (arena) memory allocators; see Appendix: Cache lines; L1, L2,
        and L3 cache; pages; and virtual memory on page 214.

        See Also
           • Section 1, “alignof” — Safe C++11 feature that inspects the alignment of a given
             type
           • Section 1, “Attribute Syntax” — Safe C++11 feature that shows how other attributes
             (following the conventional attribute notation) are used to annotate source code, im-
             prove error diagnostics, and implicitly code generation

        Further Reading
        None so far

        Appendix
        Natural Alignment
        By default, fundamental, pointer, and enumerated types typically reside on an address
        boundary that divides the size of the object; we refer to such alignment as natural align-
        ment10 :
          char     c;   //   size   1;   alignment   1;   boundaries:   0x00,   0x01,   0x02,   0x03,   ...
          short    s;   //   size   2;   alignment   2:   boundaries:   0x00,   0x02,   0x04,   0x06,   ...
          int      i;   //   size   4;   alignment   4;   boundaries:   0x00,   0x04,   0x08,   0x0c,   ...
          float    f;   //   size   4;   alignment   4;   boundaries:   0x00,   0x04,   0x08,   0x0c,   ...
          double   d;   //   size   8;   alignment   8;   boundaries:   0x00,   0x08,   0x10,   0x18,   ...



           10 Sizes and alignment shown here are typical but not specifically required by the standard. On some

        platforms, one can request that all types be byte aligned. While such a representation is more compact,
        entities that span memory boundaries can require multiple fetch operations leading to run times that are
        typically significantly (sometimes as much as an order of magnitude) slower when run in this “packed” mode.
                                                            212


i



    i                                                                                                                 i
    i                                                                                                 i
                   “emcpps-internal” — 2021/1/16 — 3:34 — page 213 — #215

i



        C++11                                                                             alignas


        For aggregates (including arrays) or user-defined types, the alignment is typically that of
        the most strictly aligned subelement:
         struct S0
         {
         char a; // size 1; alignment 1
         char b; // size 1; alignment 1
         int c; // size 4; alignment 4
         };          // size 8; alignment 4

         struct S1
         {
         char a; // size 1;      alignment 1
         int b; // size 4;       alignment 4
         char c; // size 1;      alignment 1
         };          // size     12; alignment 4

         struct S2
         {
         int a; // size 4; alignment 4
         char b; // size 1; alignment 1
         char c; // size 1; alignment 1
         };          // size 8; alignment 4

         struct S3
         {
         char a; // size 1; alignment 1
         char b; // size 1; alignment 1
         };          // size 2; alignment 1

         struct S4
         {
         char a[2];    // size 2; alignment 1
         };                // size 2; alignment 1

        Size and alignment behave similarly with respect to structural inheritance:
         struct D0 : S0
         {
         double d; // size 8; alignment 8
         };             // size 16; alignment 8

         struct D1 : S1
         {
         double d; // size 8; alignment 8
         };             // size 24; alignment 8

         struct D2 : S2
         {
         int d; // size 4; alignment 4
         };          // size 12; alignment 4
                                                                                               213


i



    i                                                                                                 i
    i                                                                                                     i
                      “emcpps-internal” — 2021/1/16 — 3:34 — page 214 — #216

i



        alignas                                         Chapter 2     Conditionally Safe Features



          struct D3 : S3
          {
          int d; // size 4; alignment 4
          };          // size 8; alignment 4

          struct D4 : S4
          {
          char d; // size 1; alignment 1
          };           // size 3; alignment 1

        Finally, virtual functions invariably introduce an implicit virtual-table-pointer member hav-
        ing a size and alignment corresponding to that of a memory address (e.g., 4 or 8) on the
        host platform:
          struct S5
          {
          virtual ~S5();
          };                      // size 8; alignment 8

          struct D5 : S5
          {
          char d; // size 1; alignment 1
          };           // size 16; alignment 8


        Cache lines; L1, L2, and L3 cache; pages; and virtual memory
        Modern computers are highly complex systems, and a detailed understanding of their in-
        tricacies is unnecessary to achieve most of the performance benefits. Still, certain general
        themes and rough thresholds aid in understanding how to squeeze just a bit more out of
        the underlying hardware. In this section, we sketch fundamental concepts that are common
        to all modern computer hardware; although the precise details will vary, the general ideas
        remain essentially the same.
            In its most basic form, a computer consists of central processing unit (CPU) having
        internal registers that access main memory (MM). Registers in the CPU (on the order of
        hundreds of bytes) are among the fastest forms of memory, while main memory (typically
        many gigabytes) is orders of magnitude slower. An almost universally observed phenomenon
        is that of locality of reference, which suggests that data that resides in close proximity
        (in the virtual address space) is more likely to be accessed together in rapid succession than
        more distant data.
            To exploit the phenomenon of locality of reference, computers introduce the notion
        of a cache that, while much faster than main memory, is also much smaller. Programs that
        attempt to amplify locality of reference will, in turn, often be rewarded with faster run
        times. The organization of a cache and, in fact, the number of levels of cache (e.g., L1, L2,
        L3,. . .) will vary, but the basic design parameters are, again, more or less the same. A given
        level of cache will have a certain total size in bytes (invariably an integral power of two).
        The cache will be segmented into what are called cache lines whose size (a smaller power
        of two) divides that of the cache itself. When the CPU accesses main memory, it first looks
                                                      214


i



    i                                                                                                     i
    i                                                                                                                    i
                      “emcpps-internal” — 2021/1/16 — 3:34 — page 215 — #217

i



        C++11                                                                                              alignas


        to see if that memory is in the cache; if it is, the value is returned quickly (known as a cache
        hit). Otherwise, the cache line(s) containing that data is (are) fetched (from the next higher
        level of cache or from main memory) and placed into the cache (known as a cache miss),
        possibly ejecting other less recently used ones.11
            Data residing in distinct cache lines is physically independent and can be written concur-
        rently by multiple threads. Logically unrelated data residing in the same cache line, however,
        is nonetheless physically coupled; two threads that write to such logically unrelated data will
        find themselves synchronized by the hardware. Such unexpected and typically undesirable
        sharing of a cache line by unrelated data acted upon by two concurrent threads is known
        as false sharing. One way of avoiding false sharing is to align such data on a cache-line
        boundary, thus rendering accidental collocation of such data on the same cache line impos-
        sible. Another (more broad-based) design approach that avoids lowering cache utilization is
        to ensure that data acted upon by a given thread is kept physically separate — e.g., through
        the use of local (arena) memory allocators.12
            Finally, even data that is not currently in cache but resides nearby in MM can benefit
        from locality. The virtual address space, synonymous with the size of a void* (typically
        64-bits on modern general-purpose hardware), has historically well exceeded the physical
        memory available to the CPU. The operating system must therefore maintain a mapping
        (in main memory) from what is resident in physical memory and what resides in secondary
        storage (e.g., on disc). In addition, essentially all modern hardware provides a TLB13 that
        caches the addresses of the most recently accessed physical pages, providing yet another
        advantage to having the working set (i.e., the current set of frequently accessed pages)
        remain small and densely packed with relevant data.14 What’s more, dense working sets,
           11 Conceptually, the cache is often thought of as being able to hold any arbitrary subset of the most

        recently accessed cache lines. This kind of cache is known as fully associative. Although it provides the
        best hit rate, a fully associative cache requires the most power along with significant additional chip
        area to perform the fully parallel lookup. Direct-mapped cache associativity is at the other extreme.
        In direct mapped, each memory location has exactly one location available to it in the cache. If another
        memory location mapping to that location is needed, the current cache line must be flushed from the cache.
        Although this approach has the lowest hit rate, lookup times, chip area, and power consumption are all
        minimized (optimally). Between these two extremes is a continuum that is referred to as set associative. A
        set associate cache has more than one (typically 2, 4, or 8; see solihin15, section 5.2.1, “Placement Policy,”
        pp. 136–141, and hruska20) location in which each memory location in main memory can reside. Note that,
        even with a relatively small N , as N increases, an N -way set associative cache quickly approaches the hit
        rate of a fully associative cache at greatly reduced collateral cost; for most software-design purposes, any
        loss in hit rate due to set associativity of a cache can be safely ignored.
           12 lakos17, lakos19, lakos22
           13 A translation-lookaside buffer (TLB) is a kind of address-translation cache that is typically part of a

        chip’s memory management unit (MMU). A TLB holds a recently accessed subset of the complete mapping
        (itself maintained in MM) from virtual memory address to physical ones. A TLB is used to reduce access
        time when the requisite pages are already resident in memory; its size (e.g., 4K) is capped at the number
        of bytes of physical memory (e.g., 32Gb) divided by the number of bytes in each physical page (e.g., 8Kb),
        but could be smaller. Because it resides on chip, is typically an order of magnitude faster (SRAM versus
        DRAM), and requires only a single lookup (as opposed to two or more when going out to MM), there is an
        enormous premium on minimizing TLB misses.
           14 Note that memory for handle-body types (e.g., std::vector or std::deque) and especially node-

        based containers (e.g., std::map and std::unordered_map), originally allocated within a single page, can
        — through deallocation and reallocation (or even move operations) — become scattered across multiple
        (perhaps many) pages, thus causing what was originally a relatively small working set to no longer fit within
        physical memory. This phenomenon, known as diffusion (which is a distinct concept from fragmentation),
                                                                                                                 215


i



    i                                                                                                                    i
    i                                                                                                                      i
                         “emcpps-internal” — 2021/1/16 — 3:34 — page 216 — #218

i



        alignas                                                 Chapter 2        Conditionally Safe Features


        in addition to facilitating hits for repeat access, increase the likelihood that data that is
        coresident on a page (or cache line) will be needed soon (i.e., in effect acting as a prefetch).15
        Table 1 provides a summary of typical physical parameters found in modern computers
        today.

               Table 1: Various sizes and access speeds of typical memory for modern
               computers

                   Memory Type                Typical Memory Size (Bytes)            Typical Access Times
                   CPU Registers                       512 … 2048                           ∼250ps
                     Cache Line                         64 … 256                              NA
                      L1 Cache                        16Kb … 64Kb                            ∼1ns
                      L2 Cache                         1Mb … 2Mb                             ∼10ns
                      L3 Cache                        8Mb … 32Mb                          ∼80ns–120ns
                      L4 Cache                       32Mb … 128Mb                        ∼100ns–200ns
                  Set Associativity                      2 … 64                               NA
                         TL                         4 words … 65536                       10ns … 50ns
                Physical Memory Page                   512 … 8192                        100ns … 500ns
                   Virtual Memory                  232 bytes … 264 bytes                  ∼10µs–50µs
                Solid-State Disc (SSD)                256Gb … 16Tb                        ∼25µs–100µs
                   Mechanical Disc                         Huge                           ∼5ms–10ms
                     Clock Speed                            NA                              ∼4GHz




        is what typically leads to a substantial runtime performance degradation (due to thrashing) in large, long-
        running programs. Such diffusion can be mitigated by judicious use of local arena memory allocators (and
        deliberate avoidance of move operations across disparate localities of frequent memory usage).
           15 We sometimes lightheartedly refer to the beneficial prefetch of unrelated data that is accidentally needed

        subsequently (e.g., within a single thread) due to high locality within a cache line (or a physical page) as
        true sharing.
                                                              216


i



    i                                                                                                                      i
    i                                                                                          i
                     “emcpps-internal” — 2021/1/16 — 3:34 — page 217 — #219

i



        C++11                                                                 auto Variables




        Variables of Automatically Deduced Type
        placeholder text.........




                                                                                        217


i



    i                                                                                          i
    i                                                                                      i
                       “emcpps-internal” — 2021/1/16 — 3:34 — page 218 — #220

i



        Braced Init                              Chapter 2   Conditionally Safe Features



        Brace-Initialization Syntax: {}
        placeholder text.........




                                               218


i



    i                                                                                      i
    i                                                                                      i
                     “emcpps-internal” — 2021/1/16 — 3:34 — page 219 — #221

i



        C++11                                                        constexpr Functions




        Compile-Time Evaluatable Functions
        placeholder text.........




                                                                                    219


i



    i                                                                                      i
    i                                                                                       i
                        “emcpps-internal” — 2021/1/16 — 3:34 — page 220 — #222

i



        constexpr Variables                       Chapter 2   Conditionally Safe Features



        Compile-Time Accessible Variables
        placeholder text...........




                                                220


i



    i                                                                                       i
    i                                                                                        i
                     “emcpps-internal” — 2021/1/16 — 3:34 — page 221 — #223

i



        C++11                                                          Default Member Init




        Default class/union Member Initializers
        placeholder text.........




                                                                                      221


i



    i                                                                                        i
    i                                                                                                                  i
                        “emcpps-internal” — 2021/1/16 — 3:34 — page 222 — #224

i



        enum class                                            Chapter 2       Conditionally Safe Features



        Strongly Typed Scoped Enumerations
        enum class is an alternative to the classic enum construct that simultaneously provides
        both stronger typing and an enclosing scope for its enumerated values.

        Description
        Classic, C-style enumerations are useful and continue to fulfill important engineering needs:
          enum EnumName { e_Enumerator0 /*= value0 */, e_EnumeratorN /* = valueN */ };
          // classic, C­style enum: enumerators are neither type­safe nor scoped

        For more examples where the classic enum shines, see Potential Pitfalls: Strong typing of an
        enum class can be counterproductive on page 233 and Annoyances: Scoped enumerations do
        not necessarily add value on page 238. Still, innumerable practical situations occur in which
        enumerators that are both scoped and more type-safe would be preferred; see Introducing
        the C++11 enum class on page 224.

        Drawbacks and workarounds relating to unscoped C++03 enumerations
        Since the enumerators of a classic enum leak out into the enclosing scope, if two unrelated
        enumerations that happen to use the same enumerator name appear in the same scope, an
        ambiguity could ensue:
          enum Color { e_RED, e_ORANGE, e_YELLOW };                  // OK
          enum Fruit { e_APPLE, e_ORANGE, e_BANANA };                // Error: e_ORANGE is redefined.

        The problems associated with the use of unscoped enumerations is exacerbated when those
        enumerations are placed in their own respective header files in the global or some other large
        namespace scope, such as std, for general reuse. In such cases, latent defects will typically
        not manifest unless and until the two enumerations are included in the same translation
        unit.16
           If the only issue were the leakage of the enumerators into the enclosing scope, then the
        long-established workaround of enclosing the enumeration within a struct would suﬀice:
          struct Color { enum Enum { e_RED, e_ORANGE, e_YELLOW }; };                        // OK
          struct Fruit { enum Enum { e_APPLE, e_ORANGE, e_BANANA }; };                      // OK (scoped)

        Employing the C++03 workaround in the above code snippet implies that, when passing
        such an explicitly scoped, classical enum into a function, the distinguishing name of the
        enum is subsumed by its enclosing struct and the enum name itself, such as Enum, becomes
        boilerplate code:
          int enumeratorValue1 = Color::e_ORANGE;               // OK
          int enumeratorValue2 = Fruit::e_ORANGE;               // OK

          void colorFunc(Color::Enum color);             // enumerated (scoped) Color parameter
          void fruitFunc(Fruit::Enum fruit);             // enumerated (scoped) Fruit parameter
          16 Note that we use a lowercase, single-letter prefix, such as e_, to ensure that the uppercase enumerator

        name is less likely to collide with a legacy macro, which is especially useful in header files.
                                                            222


i



    i                                                                                                                  i
    i                                                                                                           i
                      “emcpps-internal” — 2021/1/16 — 3:34 — page 223 — #225

i



        C++11                                                                                   enum class


        Hence, adding just scope to a classic, C++03 enum is easily doable and might be exactly what
        is indicated; see Potential Pitfalls: Strong typing of an enum class can be counterproductive
        on page 233.

        Drawbacks relating to weakly typed, C++03 enumerators
        Historically, C++03 enumerations have been employed to represent at least two distinct
        concepts:

           1. A collection of related, but not necessarily unique, named integral values
           2. A pure, perhaps ordered, set of named entities in which cardinal value has no relevance

        It will turn out that the modern enum class feature, which we will discuss in Description:
        Introducing the C++11 enum class, is more closely aligned with this second concept.
            A classic enumeration, by default, has an implementation-defined underlying type (see
        “Underlying Type ’11” on page 257), which it uses to represent variables of that enumerated
        type as well as the values of its enumerators. While implicit conversion to an enumerated
        type is never permitted, when implicitly converting from a classical enum type to some
        arithmetic type, the enum promotes to integral types in a way similar to how its underlying
        type would promote using the rules of integral promotion and standard conversion:
          void f()
          {
          enum A { e_A0, e_A1, e_A2 };                // classic, C­style C++03 enum
          enum B { e_B0, e_B1, e_B2 };                //    "       "       "     "

          A a;      // Declare object a to be of type A.
          B b;      //   "       "    b " " "         B.

          a   =   e_B2;       //   error: cannot convert e_B2 to enum type A
          b   =   e_B2;       //   OK, assign the value e_B2 (numerically 2) to b.
          a   =   b;          //   error: cannot convert enumerator b to enum type A
          b   =   b;          //   OK, self­assignment
          a   =   1;          //   error: invalid conversion from int 1 to enum type A
          a   =   0;          //   error: invalid conversion from int 0 to enum type A

          bool            v   =   a;       //   OK
          char            w   =   e_A0;    //   OK
          unsigned        y   =   e_B1;    //   OK
          float           x   =   b;       //   OK
          double          z   =   e_A2;    //   OK
          char*           p   =   e_B0;    //   error: unable to convert e_B0 to char*
          char*           q   =   +e_B0;   //   error: invalid conversion of int to char*
          }

        Notice that, in this example, the final two diagnostics for the attempted initializations of p
        and q, respectively, differ slightly. In the first, we are trying to initialize a pointer, p, with an
        enumerated type, B. In the second, we have creatively used the built-in unary-plus operator
        to explicitly promote the enumerator to an integral type before attempting to assign it to
                                                                                                         223


i



    i                                                                                                           i
    i                                                                                                                    i
                        “emcpps-internal” — 2021/1/16 — 3:34 — page 224 — #226

i



        enum class                                                    Chapter 2    Conditionally Safe Features


        a pointer, q. Even though the numerical value of the enumerator is 0 and such is known at
        at compile time, implicit conversion to a pointer type from anything but the literal integer
        constant 017 is not permitted.
            C++ fully supports comparing values of classic enum types with values of arbitrary
        arithmetic type as well as those of the same enumerated type; the operands of a com-
        parator will be promoted to a suﬀiciently large integer type and the comparison will be
        done with those values. Comparing values having distinct enumerated types, however, is
        deprecated and will typically elicit a warning.18

        Introducing the C++11 enum class
        With the advent of modern C++, we now have a new, alternative enumeration construct,
        enum class, that simultaneously addresses strong type safety and lexical scoping, two dis-
        tinct and often desirable properties:
          enum class Name { e_Enumerator0 /* = value0 */, e_EnumeratorN /* = valueN */ };
          // enum class enumerators are both type­safe and scoped

        Another major distinction is that the default underlying type for a C-style enum is im-
        plementation defined, whereas, for an enum class, it is always an int. See Description:
        enum class and underlying type on page 226 and Potential Pitfalls: External use of opaque
        enumerators on page 259.
           The enumerators within an enum class are all scoped by its name, while classic enu-
        merations leak the enumerators into the enclosing scope:
          enum Vehicle { e_CAR,    e_TRAIN, e_PLANE };
          enum Geometry { e_POINT, e_LINE, e_PLANE };                       // Error: e_PLANE is redefined.

        Unlike unscoped enumerations, enum class does not leak its enumerators into the enclosing
        scope and can therefore help avoid collisions with other enumerations having like-named
        enumerators defined in the same scope:
          enum       VehicleUnscoped { e_CAR, e_TRAIN, e_PLANE };
          struct     VehicleScopedExplicitly { enum { e_CAR, e_TRAIN, e_PLANE }; };
          enum class VehicleScopedImplicitly { e_CAR, e_BOAT, e_PLANE };




            17 Excluding esoteric user-defined types, only a literal 0 or, as of C++11, a value of type std::nullptr_t

        is implicitly convertible to an arbitrary pointer type; see “nullptr” on page 123.
            18 As of C++20, attempting to compare two values of distinct classically enumerated types is a compile-

        time error. Note that explicitly converting at least one of them to an integral type — for example, using
        built-in unary plus — both makes our intentions clear and avoids warnings.
          if   (e_A0 < 0)         {   /*   ...   */   }   //   OK, comparison with integral type
          if   (1.0 != e_B1)      {   /*   ...   */   }   //   OK, comparison with arithmetic type
          if   (A() <= e_A2)      {   /*   ...   */   }   //   OK, comparison with same enumerated type
          if   (e_A0 == e_B0)     {   /*   ...   */   }   //   warning, deprecated (error as of C++20)
          if   ( e_A0 == +e_B0)   {   /*   ...   */   }   //   OK, unary + converts to integral type
          if   (+e_A0 == e_B0)    {   /*   ...   */   }   //   OK,   "        "     "     "      "
          if   (+e_A0 == +e_B0)   {   /*   ...   */   }   //   OK,   "        "     "     "      "


                                                                   224


i



    i                                                                                                                    i
    i                                                                                                              i
                     “emcpps-internal” — 2021/1/16 — 3:34 — page 225 — #227

i



        C++11                                                                                     enum class


        Just like an unscoped enum type, an object of type enum class is passed as a parameter to
        a function using the enumerator name itself19 :
          void f1(VehicleUnscoped value);                     // classic enumeration passed by value
          void f2(VehicleScopedImplicitly value);             // modern enumeration passed by value

        Qualifying the enumerators of a scoped enumeration is the same, irrespective of whether
        the scoping is explicit or implicit:
          void g()
          {
          f1(VehicleUnscoped::e_PLANE);
          // call f1 with an explicitly scoped enumerator

          f2(VehicleScopedImplicitly::e_PLANE);
          // call f2 with an implicitly scoped enumerator
          }

        Apart from implicit scoping, the modern, C++11 enum class deliberately does not support
        implicit conversion, in any context, to its underlying type:
          int i1 = VehicleScopedExplicitly::e_PLANE;
          // OK, scoped C++03 enum (implicit conversion)

          int i2 = VehicleScopedImplicitly::e_PLANE;
          // error: no implicit conversion to underlying type

          if (VehicleScopedExplicitly::e_PLANE > 3) { /* OK */ }
          if (VehicleScopedImplicitly::e_PLANE > 3) { /* error: implicit conversion */ }

        Enumerators of an enum class do, however, admit equality and ordinal comparisons within
        their own type:
          enum class E { e_A, e_B, e_C };           // By default, enumerators increase from 0.

          static_assert(E::e_A < E::e_C, ""); // OK, comparison between same­type values
          static_assert(0 == E::e_A, "");      // error: no implicit conversion from E
          static_assert(0 == static_cast<int>(E::e_A), ""); // OK, explicit conversion

          void f(E v)
          {
          if (v > E::e_A) { /* ... */ }          // OK, comparing values of same type, E
          }



           19 If we use the approach for adding scope to enumerators that is described in Description: Drawbacks

        relating to weakly typed, C++03 enumerators on page 223, the name of the enclosing struct together with
        a consistent tag, such as Enum, has to be used to indicate an enumerated type:
         void f1(VehicleScopedExplicitly::Enum value);
         // classically scoped enum passed by value


                                                                                                           225


i



    i                                                                                                              i
    i                                                                                                     i
                         “emcpps-internal” — 2021/1/16 — 3:34 — page 226 — #228

i



        enum class                                      Chapter 2     Conditionally Safe Features


        Note that incrementing an enumerator variable from one strongly typed enumerator’s value
        to the next requires an explicit cast; see Potential Pitfalls: Strong typing of an enum class
        can be counterproductive on page 233.

        enum class and underlying type
        Since C++11, both scoped and unscoped enumerations permit explicit specification of their
        integral underlying type:
          enum Ec : char { e_X, e_Y, e_Z };
          // underlying type is char

          static_assert(1 == sizeof(Ec),     "");
          static_assert(1 == sizeof Ec::E_X, "");

          enum class Es : short { e_X, e_Y, e_Z };
          // underlying type is short int

          static_assert(sizeof(short) == sizeof(Es),     "");
          static_assert(sizeof(short) == sizeof Es::E_X, "");

        Unlike a classic enum, which has an implementation-defined default underlying type,
        the default underlying type for an enum class is always int:
          enum class Ei { e_X, e_Y, e_Z };
          // When not specified the underlying type of an enum class is int.

          static_assert(sizeof(int) == sizeof(Ei),     "");
          static_assert(sizeof(int) == sizeof Ei::E_X, "");

        Note that, because the default underlying type of an enum class is specified by the
        Standard, eliding the enumerators20 of an enum class in a local redeclaration is always
        possible; see Potential Pitfalls: External use of opaque enumerators on page 259.

        Use Cases
        Avoiding unintended implicit conversions to arithmetic types
        Suppose that we want to represent the result of selecting one of a fixed number of alternatives
        from a drop-down menu as a simple unordered set of uniquely valued named integers. For
        example, this might be the case when configuring a product, such as a vehicle, for purchase:
          struct Trans
          {
          enum Enum { e_MANUAL, e_AUTOMATIC };        // classic, C++03 scoped enum
          };

        Although automatic promotion of a classic enumerator to int works well when typical use
        of the enumerator involves knowing its cardinal value, such promotions are less than ideal
        when cardinal values have no role in intended usage:
          20 See   “Opaque enums” on page 240.
                                                      226


i



    i                                                                                                     i
    i                                                                                                        i
                    “emcpps-internal” — 2021/1/16 — 3:34 — page 227 — #229

i



        C++11                                                                                enum class


          class Car { /* ... */ };

          struct Trans
          {                                                // explicitly scoped
          enum Enum { e_MANUAL, e_AUTOMATIC };         // classic enum
          };                                               // (BAD IDEA)

          int buildCar(Car* result, int numDoors, Trans::Enum trans)
          {
          int status = Trans::e_MANUAL;    // Oops, accidental misuse!

          for (int i = 0; i < trans; ++i)        // Oops, accidental misuse!
          {
          attachDoor(i);
          }

          return status;
          }

        As shown in the example above, it is never correct for a value of type Trans::Enum to be
        assigned to, compared with, or otherwise modified like an integer; hence, any such use would
        necessarily be considered a mistake and, ideally, flagged by the compiler as an error. The
        stronger typing provided by enum class achieves this goal:
          class Car { /* ... */ };

          enum class Trans { e_MANUAL, e_AUTOMATIC };           // modern enum class (GOOD IDEA)

          int buildCar(Car* result, int numDoors, Trans trans)
          {
          int status = Trans::e_MANUAL;    // error: incompatible types

          for (int i = 0; i < trans; ++i)        // error: incompatible types
          {
          attachDoor(i);
          }

          return status;
          }

        By deliberately choosing the enum class over the classic enum above, we automate the
        detection of many common kinds of accidental misuse. Secondarily, we slightly simplify the
        interface of the function signature by removing the extra ::Enum boilerplate qualifications
        required of an explicitly scoped, less-type-safe, classic enum, but see Potential Pitfalls: Strong
        typing of an enum class can be counterproductive on page 233.
            In an unlikely event that the numeric value of a strongly typed enumerator is needed
        (e.g., for serialization), it can be extracted explicitly via a static_cast:
          const int manualIntegralValue    = static_cast<int>(Trans::e_MANUAL);
          const int automaticIntegralValue = static_cast<int>(Trans::e_AUTOMATIC);
                                                                                                      227


i



    i                                                                                                        i
    i                                                                                                   i
                      “emcpps-internal” — 2021/1/16 — 3:34 — page 228 — #230

i



        enum class                                     Chapter 2    Conditionally Safe Features


          static_assert(0 == manualIntegralValue,    "");
          static_assert(1 == automaticIntegralValue, "");


        Avoiding namespace pollution
        Classic, C-style enumerations do not provide scope for their enumerators, leading to unin-
        tended latent name collisions:
          // vehicle.h
          // ...
          enum Vehicle   { e_CAR, e_TRAIN, e_PLANE };        // classic, C­style enum
          // ...

          // geometry.h
          // ...
          enum Geometry { e_POINT, e_LINE,      e_PLANE };     // classic, C­style enum
          // ...

          // client
          #include <vehicle.h> // OK
          #include <geometry.h> // error: e_PLANE redefined
          // ...

        The common workaround is to wrap the enum in a struct or namespace:
          // vehicle.h
          // ...
          struct Vehicle {                                 // explicitly scoped
          enum Enum { e_CAR, e_TRAIN, e_PLANE };       // classic, C­style enum
          };
          // ...

          // geometry.h
          // ...
          struct Geometry {                                 // explicitly scoped
          enum Enum { e_POINT, e_LINE, e_PLANE };       // classic, C­style enum
          };
          // ...

          // client
          #include <vehicle.h>       // OK
          #include <geometry.h>      // OK, enumerators are scoped explicitly.
          // ...

        If implicit conversions of enumerators to integral types are not required, we can achieve the
        same scoping effect with much more type safety and slightly less boilerplate — i.e., without
        the ::Enum when declaring a variable — by employing enum class instead:
          // vehicle.h
          // ...
          enum class Vehicle { e_CAR, e_TRAIN, e_PLANE };
                                                     228


i



    i                                                                                                   i
    i                                                                                                               i
                     “emcpps-internal” — 2021/1/16 — 3:34 — page 229 — #231

i



        C++11                                                                                      enum class


          // ...

          // geometry.h
          // ...
          enum class Geometry { e_POINT, e_LINE, e_PLANE };
          // ...

          // client
          #include <vehicle.h> // OK
          #include <geometry.h>  // OK, enumerators are scoped implicitly.
          // ...


        Improving overloading disambiguation
        Overloaded functions are notorious for providing opportunities for misuse. Maintenance
        diﬀiculties are exacerbated when arguments for these overloads are convertible to more
        than a single parameter in the function. As an illustration of the compounding of such
        maintenance diﬀiculties, suppose that we have a widely used, named type, Color, and the
        numeric values of its enumerators are small, unique, and irrelevant. Imagine we have chosen
        to represent Color as a classic enum:
          struct Color
          {                                                         // explicitly scoped
          enum Enum { e_RED, e_BLUE /*, ...*/ };                // classic, C­style enum
          };                                                        // (BAD IDEA)

        Suppose further that we have provided two overloaded functions, each having two parame-
        ters, with one signature’s parameters including the enumeration Color:
          void clearScreen(int pattern, int orientation);                          // (0)
          void clearScreen(Color::Enum background, double alpha);                  // (1)

        Depending on the types of the arguments supplied, one or the other functions will be selected
        or else the call will be ambiguous and the program will fail to compile21 :
          void f0()
          {
          clearScreen(1                  , 1               );    // calls (0) above

          21 GCC version 7.4.0 incorrectly diagnoses both ambiguity errors as warnings, although it states in the

        warning that it is an error:
          warning: ISO C++ says that these are ambiguous, even though the worst conversion for the
          first is better than the worst conversion for the second:

          note: candidate 1: void clearScreen(int, int)
          void clearScreen(int pattern, int orientation);
          ^~~~~~~~~~~
          note: candidate 2: void clearScreen(Color::Enum, double)
          void clearScreen(Color::Enum background, double alpha;
          ^~~~~~~~~~~


                                                                                                            229


i



    i                                                                                                               i
    i                                                                                                 i
                     “emcpps-internal” — 2021/1/16 — 3:34 — page 230 — #232

i



        enum class                                    Chapter 2    Conditionally Safe Features


         clearScreen(1              , 1.0         );      // calls (0) above
         clearScreen(1              , Color::e_RED);      // calls (0) above

         clearScreen(1.0            , 1           );      // calls (0) above
         clearScreen(1.0            , 1.0         );      // calls (0) above
         clearScreen(1.0            , Color::e_RED);      // calls (0) above

         clearScreen(Color::e_RED, 1           );         // error: ambiguous call
         clearScreen(Color::e_RED, 1.0         );         // calls (1) above
         clearScreen(Color::e_RED, Color::e_RED);         // error: ambiguous call
         }

        Now suppose that we had instead defined our Color enumeration as a modern enum class:
         enum class Color { e_RED, e_BLUE /*, ...*/ };

         void clearScreen(int pattern, int orientation);           // (2)
         void clearScreen(Color background, double alpha);         // (3)

        The function that will be called from a given set of arguments becomes clear:
         void f1()
         {
         clearScreen(1              , 1           );      // calls (2) above
         clearScreen(1              , 1.0         );      // calls (2) above
         clearScreen(1              , Color::e_RED);      // error: no matching function

         clearScreen(1.0            , 1           );      // calls (2) above
         clearScreen(1.0            , 1.0         );      // calls (2) above
         clearScreen(1.0            , Color::e_RED);      // error: no matching function

         clearScreen(Color::e_RED, 1           );         // calls (3) above
         clearScreen(Color::e_RED, 1.0         );         // calls (3) above
         clearScreen(Color::e_RED, Color::e_RED);         // error: no matching function
         }

        Returning to our original, classic-enum design, suppose that we find we need to add a third
        parameter, bool z, to the second overload:
         void clearScreen(int pattern, int orientation);                          // (0)
         void clearScreen(Color::Enum background, double alpha, bool z);          // (4) classic

        If our plan is that any existing client calls involving Color::Enum will now be flagged as
        errors, we are going to be very disappointed:
         void f2()
         {
         clearScreen(Color::e_RED, 1.0);      // calls (0) above
         }

        In fact, every combination of arguments above — all nine of them — will call function (0)
        above with no warnings at all:
                                                    230


i



    i                                                                                                 i
    i                                                                                                 i
                   “emcpps-internal” — 2021/1/16 — 3:34 — page 231 — #233

i



        C++11                                                                          enum class


         void f3()
         {
         clearScreen(1              , 1           );    // calls (0) above
         clearScreen(1              , 1.0         );    // calls (0) above
         clearScreen(1              , Color::e_RED);    // calls (0) above

         clearScreen(1.0            , 1           );    // calls (0) above
         clearScreen(1.0            , 1.0         );    // calls (0) above
         clearScreen(1.0            , Color::e_RED);    // calls (0) above

         clearScreen(Color::e_RED, 1           );       // calls (0) above
         clearScreen(Color::e_RED, 1.0         );       // calls (0) above
         clearScreen(Color::e_RED, Color::e_RED);       // calls (0) above
         }

        Finally, let’s suppose again that we have used enum class to implement our Color
        enumeration:
         void clearScreen(int pattern, int orientation);                   // (2)
         void clearScreen(Color background, double alpha, bool z);         // (5) modern

         void f4()
         {
         clearScreen(Color::e_RED, 1.0);      // error: no matching function
         }

        And in fact, the only calls that succeed unmodified are precisely those that do not involve
        the enumeration Color, as desired:
         void f5()
         {
         clearScreen(1              , 1           );    // calls (2) above
         clearScreen(1              , 1.0         );    // calls (2) above
         clearScreen(1              , Color::e_RED);    // error: no matching function

         clearScreen(1.0            , 1           );    // calls (2) above
         clearScreen(1.0            , 1.0         );    // calls (2) above
         clearScreen(1.0            , Color::e_RED);    // error: no matching function

         clearScreen(Color::e_RED, 1           );       // error: no matching function
         clearScreen(Color::e_RED, 1.0         );       // error: no matching function
         clearScreen(Color::e_RED, Color::e_RED);       // error: no matching function
         }

        Bottom line: Having a pure enumeration — such as Color, used widely in function signatures
        — be strongly typed can only help to expose accidental misuse but, again, see Potential
        Pitfalls: Strong typing of an enum class can be counterproductive on page 233.
            Note that strongly typed enumerations help to avoid accidental misuse by requiring an
        explicit cast should conversion to an arithmetic type be desired:
         void f6()
                                                                                               231


i



    i                                                                                                 i
    i                                                                                                                    i
                        “emcpps-internal” — 2021/1/16 — 3:34 — page 232 — #234

i



        enum class                                             Chapter 2        Conditionally Safe Features


          {
          clearScreen(Color::e_RED, 1.0);                   // error: no match
          clearScreen(static_cast<int>(Color::e_RED), 1.0); // OK, calls (2) above
          clearScreen(Color::e_RED, 1.0, false);            // OK, calls (5) above
          }


        Encapsulating implementation details within the enumerators themselves
        In rare cases, providing a pure, ordered enumeration having unique, but not necessarily
        contiguous, numerical values that exploit lower-order bits22 to categorize (and make readily
        available) important individual properties might offer an advantage, such as in performance.
           For example, suppose that we have a MonthOfYear enumeration that encodes the months
        that have 31 days in their least-significant bit and an accompanying inline function to
        quickly determine whether a given enumerator represents such a month23 :
          enum class MonthOfYear : unsigned char                // optimized to flag long months
          {
          e_JAN = ( 1 << 4) + 0x1,
          e_FEB = ( 2 << 4) + 0x0,
          e_MAR = ( 3 << 4) + 0x1,
          e_APR = ( 4 << 4) + 0x0,
          e_MAY = ( 5 << 4) + 0x1,
          e_JUN = ( 6 << 4) + 0x0,
          e_JUL = ( 7 << 4) + 0x1,
          e_AUG = ( 8 << 4) + 0x1,
          e_SEP = ( 9 << 4) + 0x0,
          e_OCT = (10 << 4) + 0x1,
          e_NOV = (11 << 4) + 0x0,
          e_DEC = (12 << 4) + 0x1
          };

          bool hasThirtyOneDays(MonthOfYear month)
          {
          return static_cast<std::underlying_type<MonthOfYear>::type>(month) & 0x1;
          }

        In such cases, the public clients are not intended to make use of the cardinal values; hence
        clients are well advised to treat them as implementation details, potentially subject to change
        without notice. Representing this enumeration using the modern enum class, instead of an
        explicitly scoped classic enum, deters clients from making any use (apart from same-type
        comparisons) of the cardinal values assigned to the enumerators. Notice that implementors
        of the hasThirtyOneDays function will require a verbose but runtime eﬀicient static_cast
           22 To preserve the ordinality of the enumerators overall, the higher-level bits must encode their relative

        order. The lower-level bits are then available for arbitrary use in the implementation.
           23 In this example, we are using a new cross-cutting feature of all enumerated types that allows the client

        defining the type to specify its underlying type precisely. In this case, we have chosen an unsigned char
        to maximize the number of flag bits while keeping the overall size to a single byte. Three bits remain
        available. Had we needed more flag bits, we could have just as easily used a larger underlying type, such as
        unsigned short; see “Underlying Type ’11” on page 257.
                                                             232


i



    i                                                                                                                    i
    i                                                                                                  i
                   “emcpps-internal” — 2021/1/16 — 3:34 — page 233 — #235

i



        C++11                                                                           enum class


        to resolve the cardinal value of the enumerator and thus make the requested determination
        as eﬀiciently as possible.

        Potential Pitfalls
        Strong typing of an enum class can be counterproductive
        The additive value in using a modern enum class is governed solely by whether its stronger
        typing, not its implicit scoping, of its enumerators would be beneficial in its anticipated
        typical usage. If the expectation is that the client will never to need to know the specific
        values of the enumerators, then use of the modern enum class is often just what’s needed.
        But if the cardinal values themselves are ever needed during typical use, extracting them
        will require the client to perform an explicit cast. Beyond mere inconvenience, encouraging
        clients to use casts invites defects.
            Suppose, for example, we have a function, setPort, from an external library that takes
        an integer port number:
         int setPort(int portNumber);
         // Set the current port; return 0 on success and a nonzero value otherwise.

        Suppose further that we have used the modern enum class feature to implement an enu-
        meration, SysPort, that identifies well-known ports on our system:
         enum class SysPort { e_INPUT = 27, e_OUTPUT = 29, e_ERROR = 32, e_CTRL = 6 };
         // enumerated port values used to configure our systems

        Now suppose we want to call the function f using one of these enumerated values:
         void setCurrentPortToCtrl()
         {
         setPort(SysPort::e_CTRL); // error: cannot convert SetPort to int
         }

        Unlike the situation for a classic enum, no implicit conversion occurs from an enum class
        to its underlying integral type, so anyone using this enumeration will be forced to somehow
        explicitly cast the enumerator to some arithmetic type. There are, however, multiple choices
        for performing this cast:
         #include <type_traits>     // std::underlying_type

         setPort(int(SysPort::e_CTRL));                                                     //   (1)
         setPort((int)SysPort::e_CTRL);                                                     //   (2)
         setPort(static_cast<int>(SysPort::e_CTRL));                                        //   (3)
         setPort(static_cast<std::underlying_type<SysPort>::type>(                          //   (4)
         SysPort::e_CTRL));
         setPort(static_cast<int>(                                                          // (5)
         static_cast<std::underlying_type<SysPort>::type>(SysPort::e_CTRL)));

        Any of the above casts would work in this case, but consider a future where a platform
        changed setPort to take a long and the control port was changed to a value that cannot
        be represented as an int:
                                                                                                 233


i



    i                                                                                                  i
    i                                                                                                              i
                       “emcpps-internal” — 2021/1/16 — 3:34 — page 234 — #236

i



        enum class                                          Chapter 2       Conditionally Safe Features


          int setPort(long portNumber);
          enum class SysPort : unsigned { e_INPUT = 27, e_OUTPUT = 29, e_ERROR = 32,
          e_CTRL = 0x80000000 };
          // enumerated port values used to configure our systems

        Only casting method (4) above will pass the correct value for e_CTRL to this new setPort
        implementation. The other variations will all pass a negative number for the port, which
        would certainly not be the intention of the user writing this code. A classic C-style enum
        would have avoided any manually written cast entirely and the proper value would propagate
        into setPort even as the range of values used for ports changes:
          struct SysPort // explicit scoping for a classic, C­style enum
          {
          enum Enum { e_INPUT = 27, e_OUTPUT = 29, e_ERROR = 32,
          e_CTRL = 0x80000000 };

          // Note that the underlying type of Enum is implicit and will be
          // large enough to represent all of these values.
          static_assert(
          std::is_same<std::underlying_type<Enum>::type,unsigned>::value, "");
          };

          void setCurrentPortToCtrl()
          {
          setPort(SysPort::e_CTRL); // OK, SysPort::Enum promotes to long.
          }

        When the intended client will depend on the cardinal values of the enumerators during
        routine use, we can avoid tedious, error-prone, and repetitive casting by instead employing
        a classic, C-style enum, possibly nested within a struct to achieve explicit scoping of its
        enumerators. The subsections that follow highlight specific cases in which classic, C-style,
        C++03 enums are appropriate.

        Misuse of enum class for collections of named constants
        When constants are truly independent, we are often encouraged to avoid enumerations al-
        together, preferring instead individual constants; see “Default Member Init” on page 221.
        On the other hand, when the constants all participate within a coherent theme, the expres-
        siveness achieved using a classic enum to aggregate those values is compelling.24
            For example, suppose we want to collect the coeﬀicients for various numerical suﬀixes
        representing thousands, millions, and billions using an enumeration:
          enum class S0 { e_K = 1000, e_M = e_K * e_K, e_G = e_M * e_K };                   // (BAD IDEA)

        A client trying to access one of these enumerated values would need to cast it explicitly:
          void client0()
          {
          24 Another advantage of an enumerator over an individual constant is that the enumerator is guaranteed
        to be a compile-time constant (see “constexpr Variables” on page 220) and a prvalue (see “rvalue
        References” on page 306), which never needs static storage and cannot have its address taken.
                                                          234


i



    i                                                                                                              i
    i                                                                                                                i
                     “emcpps-internal” — 2021/1/16 — 3:34 — page 235 — #237

i



        C++11                                                                                       enum class


          int distance = 5 * static_cast<int>(S0::e_K);                // casting is error­prone
          // ...
          }

        By instead making the enumeration an explicitly scoped, classic enum nested within a
        struct, no casting is needed during typical use:
          struct S1 // scoped
          {
          enum Enum { e_K = 1000, e_M = e_K * e_K, e_G = e_M * e_K };
          // *classic* enum (GOOD IDEA)
          };

          void client1()
          {
          int distance = 5 * S1::e_K;          // no casting required during typical use
          // ...
          }

        If the intent is that these constants will be specified and used in a purely local context, we
        might choose to drop the enclosing scope, along with the name of the enumeration itself25,26 :
          void client2()
          {
          enum { e_K = 1000, e_M = e_K * e_K, e_G = e_M * e_K };                  // function scoped

          double salary = 95 * e_K;
          double netWorth = 0.62 * e_M;
          double companyRevenue = 47.2 * e_G;
          // ...
          }


        Misuse of enum class in association with bit flags
        Using enum class to implement enumerators that are intended to interact closely with arith-
        metic types will typically require the definition of arithmetic and bitwise operator overloads
        between values of the same enumeration and between the enumeration and arithmetic types,
        leading to yet more code that needs to be written, tested, and maintained. This is often the
        case for bit flags. Consider, for example, an enumeration used to control a file system:
          enum class Ctrl { e_READ = 0x1, e_WRITE = 0x2, e_EXEC = 0x4 };                     // (BAD IDEA)
          // low­level bit flags used to control file system


          25 See “Local Types ’11” on page 109.
          26 We  sometimes use the lowercase prefix k_ instead of e_ to indicate salient compile-time constants
        that are not considered part of an enumerated set, irrespective of whether they are implemented as enumer-
        ators:
          enum { k_NUM_PORTS = 500, k_PAGE_SIZE = 512 };     // compile­time constants
          static const double k_PRICING_THRESHOLD = 0.03125; // compile­time constant


                                                                                                             235


i



    i                                                                                                                i
    i                                                                                                     i
                      “emcpps-internal” — 2021/1/16 — 3:34 — page 236 — #238

i



        enum class                                      Chapter 2     Conditionally Safe Features


          void chmodFile(int fd, int access);
          // low­level function used to change privileges on a file

        We could conceivably write a series of functions to combine the individual flags in a type-safe
        manner:
          #include <type_traits>     // std::underlying_type

          int   flags() { return 0; }
          int   flags(Ctrl a) { return static_cast<std::underlying_type<a>::type>(a); }
          int   flags(Ctrl a, Ctrl b) { return flags(a) | flags(b); }
          int   flags(Ctrl a, Ctrl b, Ctrl c) { return flags(a, b) | flags(c); }

          void setRW(int fd)
          {
          chmodFile(fd, flags(Ctrl::e_READ, Ctrl::e_WRITE));          // (BAD IDEA)
          }

        Alternatively, a classic, C-style enum nested within a struct achieves what’s needed:
          struct Ctrl // scoped
          {
          enum Enum { e_READ = 0x1, e_WRITE = 0x2, e_EXEC = 0x4 }; // classic enum
          // low­level bit flags used to control file system (GOOD IDEA)
          };

          void chmodFile(int fd, int access);
          // low­level function used to change privileges on a file

          void setRW(int fd)
          {
          chmodFile(fd, Ctrl::e_READ | Ctrl::e_WRITE);         // (GOOD IDEA)
          }


        Misuse of enum class in association with iteration
        Sometimes the relative values of enumerators are considered important as well. For example,
        let’s again consider enumerating the months of the year:
          enum class MonthOfYear // modern, strongly typed enumeration
          {
          e_JAN, e_FEB, e_MAR, // winter
          e_APR, e_MAY, e_JUN, // spring
          e_JUL, e_AUG, e_SEP, // summer
          e_OCT, e_NOV, e_DEC, // autumn
          };

        If all we need to do is compare the ordinal values of the enumerators, there’s no problem:
          bool isSummer(MonthOfYear month)
          {
          return MonthOfYear::e_JUL <= month && month <= MonthOfYear::e_AUG;
          }
                                                      236


i



    i                                                                                                     i
    i                                                                                                   i
                    “emcpps-internal” — 2021/1/16 — 3:34 — page 237 — #239

i



        C++11                                                                            enum class


        Although the enum class features allow for relational and equality operations between
        like-typed enumerators, no arithmetic operations are supported directly, which becomes
        problematic when we need to iterate over the enumerated values:
          void doSomethingWithEachMonth()
          {
          for (MonthOfYear i = MonthOfYear::e_JAN;
          i <= MonthOfYear::e_DEC;
          ++i) // error: no match for ++
          {
          // ...
          }
          }

        To make this code compile, an explicit cast from and to the enumerated type will be required:
          void doSomethingWithEachMonth()
          {
          for (MonthOfYear i = MonthOfYear::e_JAN;
          i <= MonthOfYear::e_DEC;
          i = static_cast<MonthOfYear>(static_cast<int>(i) + 1)
          {
          // ...
          }
          }

        Alternatively, an auxiliary, helper function could be supplied to allow clients to bump the
        enumerator:
          MonthOfYear nextMonth(MonthOfYear value)
          {
          return static_cast<MonthOfYear>(static_cast<int>(value) + 1);
          }

          void doSomethingWithEachMonth()
          {
          for (MonthOfYear i = MonthOfYear::e_JAN;
          i <= MonthOfYear::e_DEC;
          i = nextMonth(i)
          {
          // ...
          }
          }

        If, however, the cardinal value of the MonthOfYear enumerators is likely to be relevant to
        clients, an explicitly scoped classic enum should be considered as a viable alternative:
          struct MonthOfYear // explicit scoping for enum
          {
          enum Enum
          {
          e_JAN, e_FEB, e_MAR, // winter
                                                                                                 237


i



    i                                                                                                   i
    i                                                                                                     i
                      “emcpps-internal” — 2021/1/16 — 3:34 — page 238 — #240

i



        enum class                                      Chapter 2     Conditionally Safe Features


          e_APR, e_MAY, e_JUN,     // spring
          e_JUL, e_AUG, e_SEP,     // summer
          e_OCT, e_NOV, e_DEC,     // autumn
          };
          };

          bool isSummer(MonthOfYear::Enum month) // must now pass nested Enum type
          {
          return MonthOfYear::e_JUL <= month && month <= MonthOfYear::e_AUG;
          }

          void doSomethingWithEachMonth()
          {
          for (int i = MonthOfYear::e_JAN; // iteration variable is now an int
          i <= MonthOfYear::e_DEC;
          ++i) // OK, convert to underlying type
          {
          // ... (might require cast back to enumerated type)
          }
          }

        Note that such code presumes that the enumerated values will (1) remain in the same order
        and (2) have contiguous numerical values irrespective of the implementation choice.

        External use of opaque enumerators
        Since enum class types have an underlying type of int by default, clients are always able
        to (re)declare it, as a complete type, without its enumerators. Unless the opaque form of
        an enum class’s definition is exported in a header file separate from the one implementing
        the publicly accessible full definition, external clients wishing to exploit the opaque version
        will experience an attractive nuisance in that they can provide it locally, along with its
        underlying type, if any.
            If the underlying type of the full definition were to subsequently change, any program
        incorporating the original elided definition locally and also the new, full one from the header
        would become silently ill formed, no diagnostic required (IFNDR); see “Opaque
        enums” on page 240.

        Annoyances
        Scoped enumerations do not necessarily add value
        When the enumeration is local, say, within the scope of a given function, forcing an additional
        scope on the enumerators is superfluous. For example, consider a function that returns an
        integer status 0 on success and a nonzero value otherwise:
          int f()
          {
          enum { e_ERROR = ­1, e_OK = 0 } result = e_OK;
          // ...
          if (/* error 1 */) { result = e_ERROR; }
                                                      238


i



    i                                                                                                     i
    i                                                                                              i
                   “emcpps-internal” — 2021/1/16 — 3:34 — page 239 — #241

i



        C++11                                                                       enum class


         // ...
         if (/* error 2 */) { result = e_ERROR; }
         // ...
         return result;
         }

        Use of enum class in this context would require potentially needless qualification — and
        perhaps even casting — where it might not be warranted:
         int f()
         {
         enum class RC { e_ERROR = ­1, e_OK = 0 } result = RC::e_OK;
         // ...
         if (/* error 1 */) { result = RC::e_ERROR; } // undesirable qualification
         // ...
         if (/* error 2 */) { result = RC::e_ERROR; } // undesirable qualification
         // ...
         return static_cast<int>(result); // undesirable explicit cast
         }


        See Also
          • “Underlying Type ’11” on page 257 — The underlying integral representation enu-
            merator variables and values

          • “Opaque enums” on page 240 — A means of insulating individual enumerators from
            clients

        Further Reading
        TODO




                                                                                            239


i



    i                                                                                              i
    i                                                                                                   i
                          “emcpps-internal” — 2021/1/16 — 3:34 — page 240 — #242

i



        Opaque enums                                        Chapter 2   Conditionally Safe Features



        Opaque Enumeration Declarations
        Enumerated types, such as an enum or enum class (see Section 2.1.“enum class” on page 222),
        whose Underlying Type (see Section 2.1.“Underlying Type ’11” on page 257) is well-specified,
        can be declared without being defined, i.e., declared without its enumerators.

        Description
        We identify two distinct forms of opaque declarations, i.e., declarations that are not also
        definitions:

          1. A forward declaration has some translation unit in which the full definition and
             that declaration both appear. This can be a declaration in a header file where the
             definition is in the same header or in the corresponding implementation file. It can
             also be a declaration that appears in the same implementation file as the corresponding
             definition.

          2. A local declaration has no translation unit that includes both that declaration and
             the corresponding full definition.

            A classic (C++03) “C-style” enum cannot have opaque declarations nor can its defi-
        nition be repeated within the same translation unit (TU):
          enum   E0;                      //   Error, opaque declaration
          enum      {     e_A0, e_B0 };   //   OK, anonymous classic (only) enum
          enum   E1 {     e_A1, e_B1 };   //   OK, definition
          enum   E1;                      //   OK, redeclaration in same TU
          enum   E2 {     e_A2, e_B2 };   //   OK, definition
          enum   E2 {     e_A2, e_B2 };   //   Error, redefinition in same TU

        The underlying integral types used to represent objects of each of the (classic) enumerations
        above is implementation defined, making all of them ineligible for opaque declaration.
        This restriction on opaque declarations exists because the specific values of the enumer-
        ators might affect the underlying type (see Section 2.1.“Underlying Type ’11” on page 257)
        (e.g., size, alignment, signedness), and therefore the declaration alone cannot be used to
        create objects of that type. A declaration that specifies the underlying type or a full defi-
        nition can, however, be used to create objects of that type. Specifying an underlying type
        (see Section 2.1.“Underlying Type ’11” on page 257) explicitly makes opaque declaration
        possible:
          enum        :   char { e_A, e_B );        //   OK, (anonymous) complete definition
          enum   E3   :   char;                     //   OK, forward declaration w/underlying type
          enum   E3   :   char { e_A3, e_B3 };      //   OK, compatible complete definition
          enum   E4   :   short { e_A4, e_B4 };     //   OK, complete definition
          enum   E4   :   short;                    //   OK, compatible opaque redeclaration
          enum   E4   :   int;                      //   Error, incompatible opaque redeclaration
          enum   E5   :   int { e_A5, e_B5 };       //   OK, complete definition
          enum   E5   :   int { e_A5, e_B5 };       //   Error, complete redefinition in same TU
                                                          240


i



    i                                                                                                   i
    i                                                                                                   i
                    “emcpps-internal” — 2021/1/16 — 3:34 — page 241 — #243

i



        C++11                                                                         Opaque enums


        The modern (C++11) enum class (see Section 2.1.“enum class” on page 222), which pro-
        vides its enumerators with (1) stronger typing and (2) an enclosing scope, also comes with
        a default underlying type of int, thereby making it eligible to be declared without a
        definition (even without explicit qualification):
          enum   class   E6;                   //   OK, implicit underlying type (int)
          enum   class   E6 :   int;           //   OK, explicit matching underlying type
          enum   class   E6 {   e_A3, e_B3 };  //   OK, compatible complete definition
          enum   class   E7 {   e_A4, e_B4 };  //   OK, complete definition, int underlying type
          enum   class   E7;                   //   OK, compatible opaque redeclaration
          enum   class   E7 :   short;         //   Error, incompatible opaque redeclaration
          enum   class   E8 :   long;          //   OK, opaque declaration, long underlying type
          enum   class   E8 :   long { e_A5 }; //   OK, compatible complete definition
          enum   class   E9 {   e_A6, e_B7 }; //    OK, complete definition
          enum   class   E9 {   e_A6, e_B7 }; //    Error, complete redefinition in same TU
          enum   class      {   e_A, e_B };    //   Error, anonymous enum classes are not allowed

        To summarize, each classical enum type having an explicitly specified underlying type
        and every (modern) enum class type can be declared (e.g., for the first time in a TU) as a
        complete type:
          enum E10 : char;        static_assert(sizeof(E9) == 1);
          enum class E11;         static_assert(sizeof(E10) == sizeof(int));

          E10 a;                  static_assert(sizeof a == 1);
          E11 b;                  static_assert(sizeof b == sizeof(int));

        Typical usage of opaque enumerations often involves placing the forward declaration
        within a header and sequestering the complete definition within a corresponding .cpp (or else
        a second header), thereby insulating (at least some) clients from changes to the enumerator
        list (see Use Cases — Using opaque enumerations within a header file on page 242):
          // mycomponent.h
          // ...
          enum E9 : char;         // forward declaration of enum E9
          enum class E10;         // forward declaration of enum class E10



          // mycomponent.cpp
          #include <mycomponent.h>
          // ...
          enum E9 : char { e_A9, e_B9, e_C9 };
          // complete definition compatible with forward declaration of E9

          enum class E10 { e_A10, e_B10, e_C10 };
          // complete definition compatible with forward declaration of E10

        Note, however, that clients embedding local declarations directly in their code can be prob-
        lematic; see Potential Pitfalls — Redeclaring an externally defined enumeration locally on
        page 253.
                                                                                                 241


i



    i                                                                                                   i
    i                                                                                                   i
                       “emcpps-internal” — 2021/1/16 — 3:34 — page 242 — #244

i



        Opaque enums                                   Chapter 2    Conditionally Safe Features


        Use Cases
        Using opaque enumerations within a header file
        Physical design involves two related but distinct notions of information “hiding”: en-
        capsulation and insulation. An implementation detail is encapsulated if changing it (in a
        semantically compatible way) does not require clients to rework their code but might require
        them to recompile it.
            An insulated implementation detail, on the other hand, can be altered (compatibly)
        without forcing clients even to recompile. The advantages of avoiding such compile-time
        coupling transcend merely reducing compile time. For larger codebases in which various
        layers are managed under different release cycles, making a change to an insulated detail can
        be done with a .o patch and a relink the same day, whereas an uninsulated change might
        precipitate a waterfall of releases spanning days, weeks, or even longer.
            As a first example of opaque-enumeration usage, consider a (non-value-semantic)
        mechanism class, Proctor, implemented as a finite-state machine:
          // proctor.h
          // ...
          class Proctor
          {
          int d_current;    // "opaque" but unconstrained int type (BAD IDEA)
          // ...

          public:
          Proctor();
          // ...
          };

        Among other private members, Proctor has a data member, d_current, representing the
        current (pure) enumerated state of the object. We anticipate that the implementation of
        the underlying state machine will change regularly over time but that the public interface
        is relatively stable. We will, therefore, want to ensure that all parts of the implementation
        that are likely to change reside outside of the header. Hence, the complete definition of the
        enumeration of the states (including the enumerator list itself) is sequestered within the
        corresponding .cpp file:
          // proctor.cpp
          #include <proctor.h>

          enum State { e_STARTING, e_READY, e_RUNNING, e_DONE };
          Proctor::Proctor() : d_current(e_STARTING) { /* ... */ }
          // ...

        Prior to C++11, enumerations could not be forward declared. To avoid exposing (in
        a header file) enumerators that were used only privately (in the .cpp file), a completely
        unconstrained int would be used as a data member to represent the state. With the advent
        of modern C++, we now have better options. First, we might consider adding an explicit
        underlying type to the enumeration in the .cpp file:
          // proctor.cpp
                                                     242


i



    i                                                                                                   i
    i                                                                                                  i
                   “emcpps-internal” — 2021/1/16 — 3:34 — page 243 — #245

i



        C++11                                                                        Opaque enums


         #include <proctor.h>

         enum State : int { e_STARTING, e_READY, e_RUNNING, e_DONE };
         Proctor::Proctor() : d_current(e_STARTING) { /* ... */ }
         // ...

        Now that the component-local enum has an explicit underlying type, we can forward
        declare it in the header file. The existence of proctor.cpp, which includes proctor.h, makes
        this declaration a forward declaration and not just an opaque declaration. Compilation of
        proctor.cpp guarantees that the declaration and definition are compatible. Having this
        forward declaration improves (somewhat) our type safety:
         // proctor.h
         // ...
         enum State : int;     // opaque declaration of enumeration (new in C++11)

         class Proctor
         {
         State d_current;     // opaque classical enumerated type (BETTER IDEA)
         // ...

         public:
         Proctor();
         // ...
         };

        But we can do even better. First we will want to nest the enumerated State type within the
        private section of the proctor to avoid needless namespace pollution. What’s more, because
        the numerical values of the enumerators are not relevant, we can more closely model our
        intent by nesting a more strongly typed enum class instead:
         // proctor.h
         // ...
         class Proctor
         {
         enum class State;     // forward (nested) declaration of type­safe enumeration
         State d_current;      // opaque (modern) enumerated data type (BEST IDEA)
         // ...

         public:
         Proctor();
         // ...
         };

        We would then declare the nested enum class (see Section 2.1.“enum class” on page 222)
        accordingly in the .cpp file:
         // proctor.cpp
         #include <proctor.h>

         enum class Proctor::State { e_STARTING, e_READY, e_RUNNING, e_DONE };
                                                                                                243


i



    i                                                                                                  i
    i                                                                                                      i
                          “emcpps-internal” — 2021/1/16 — 3:34 — page 244 — #246

i



        Opaque enums                                          Chapter 2      Conditionally Safe Features


          Proctor::Proctor() : d_current(State::e_STARTING) { /* ... */ }
          // ...

        Finally, notice that in this example we first forward declared the (nested) enum class type
        within class scope and then in a separate statement defined a data member of the opaque
        enumerated type. We needed to do this in two statements because simultaneously opaquely
        declaring either a classic enum having an explicit underlying type (see Section 2.1.“Underlying
        Type ’11” on page 257) or an enum class (see Section 2.1.“enum class” on page 222) and
        also defining an object of that type in a single statement is not possible:
          enum E1 : int e1;         // Error, syntax not supported
          enum class E2 e2;         // Error,    "    "     "

        Fully defining an enumeration and simultaneously defining an object of the type in one
        stroke is, however, possible:
          enum E3 : int { e_A, e_B } e3;            // OK, full type definition + object definition
          enum class E4 { e_A, e_B } e4;            // OK, "     "       "      "   "        "

        Providing such a full definition, however, would have run counter to our intention to insulate
        the enumerator list of Proctor::State from clients #include-ing the header file defining
        Proctor.

        Cookie: Insulating all external clients from the enumerator list
        A commonly recurring design pattern, commonly known as the Memento Pattern27 , man-
        ifests when a facility providing a service, often in a multi-client environment, hands off a
        packet of opaque information — a.k.a. a cookie — to a client to hold and then present back
        to the facility to enable resuming operations where processing left off. Since the information
        within the cookie will not be used substantively by the client, any unnecessary compile-time
        coupling of clients with the implementation of that cookie serves only to impede fluid main-
        tainability of the facility issuing the cookie. It is with respect to not just encapsulating but
        insulating pure implementation details that are held but not used substantively by clients
        that we offer this Memento pattern as a possible use case for opaque enumerations.
            Event-driven programming28 , historically implemented using callback functions, intro-
        duces a style of programming that is decidedly different from what we might have become
        accustomed to. In this programming paradigm, a higher-level agent (e.g., main) would begin
        by instantiating an Engine that will be responsible for monitoring for events and invoking
        provided callbacks when appropriate. Classically, clients might have registered a function
        pointer and a corresponding pointer to a client-defined piece of identifying data, but here
        we will make use of a C++11 standard library type, std::function, which can encapsulate
        arbitrary callable function objects and their associated state. This callback will be provided
        one object to represent the event that just happened and another object that can be used
        opaquely to reregister interest in the same event again.
            This opaque cookie and passing around of the client state might seem like an unnecessary
        step, but often the event management involved in software of this sort is wrapping the
        most often executed code in very busy systems, and performance of each basic operation
          27 ?   Chapter behavioral patterns? 5?, section “Memento,”, pp. 283–??? TBD
          28 See  also ? Chapter behavioral patterns? 5?, section “Observer,”, pp. ???–??? TBD
                                                            244


i



    i                                                                                                      i
    i                                                                                                    i
                    “emcpps-internal” — 2021/1/16 — 3:34 — page 245 — #247

i



        C++11                                                                          Opaque enums


        is therefore very important. To maximize performance, every potential branch or lookup
        in an internal data structure must be minimized, and allowing clients to pass back the
        internal state of the engine when reregistering can greatly reduce the engine’s work to
        continue a client’s processing of events without tearing down and rebuilding all client state
        each time an event happens. More importantly, event managers such as this often become
        highly concurrent to take advantage of modern hardware, so performant manipulation of
        their own data structures and well-defined lifetime of the objects they interact with become
        paramount. This makes the simple guarantee of, “If you don’t reregister, then the engine
        will clean everything up; if you do, then the callback function will continue its lifetime”, a
        very tractable paradigm to follow.
          // callbackengine.h
          #include <deque>
          #include <functional>     // for std::function

          class EventData;          // information that clients will need to process an event
          class CallbackEngine;     // the driver for processing and delivering events

          class CallbackData
          {
          // This class represents a handle to the shared state associating a
          // callback function object with a CallbackEngine.

          public:
          typedef std::function<void(const EventData&, CallbackEngine*,
          CallbackData)> Callback;
          // alias for a function object returning void and taking, as arguments,
          // the event data to be consumed by the client, the address of the
          // CallbackEngine object that supplied the event data, and the
          // callback data that can be used to reregister the client, should the
          // client choose to show continued interest in future instances of the
          // same event

          enum class State;                                              // GOOD IDEA
          // nested forward declaration of insulated enumeration, enabling
          // changes to the enumerator list without forcing clients to recompile

          private:
          std::deque<CallbackData>     d_pendingCallbacks; // waiting for next event

          // ... (other state that might need to be stored for an active or inactive
          //      registration of interest in events)

          public:
          // ... (constructors, other manipulators and accessors, etc.)

          State getState() const;
          // Return the current state of this callback.

                                                                                                  245


i



    i                                                                                                    i
    i                                                                                                 i
                     “emcpps-internal” — 2021/1/16 — 3:34 — page 246 — #248

i



        Opaque enums                                  Chapter 2    Conditionally Safe Features


         void setState(State state);
         // Set the current state to the specified state.

         Callback& getCallback() const;
         // Return the callback function object specified at construction.
         };

         class CallbackEngine
         {
         private:
         // ... (other, stable private data members implementing this object)

         std::unordered_map<int, CallbackData> d_clientStateMap;
         // mapping from an internally generated id to the full state for a
         // client, including the opaque enumerated state that tracks which
         // other data structures within this CallbackEngine have references
         // to this callback
         //
         // Reregistering or skipping reregistering when
         // called back will lead to updating internal data structures based on
         // the current value of this State.

         public:
         // ...     (other public member functions, e.g., creators, manipulators)

         void registerInterest(CallbackData::Callback cb);
         // Register (e.g., from main) a new client with this manager object.

         void reregisterInterest(const CallbackData& callback);
         // Reregister (e.g., from a client) the specified callback with this
         // manager object, providing the state contained in the CallbackData
         // to enable resumption from the same state as processing left off.

         void run();
         // Start this object's event loop.

         // ...    (other public member functions, e.g., manipulators, accessors)
         };

        A client would, in main, create an instance of this CallbackEngine, define the appropriate
        functions to be invoked when events happen, register interest, and then let the engine run:
         // myapplication.cpp
         // ...
         static void myCallback(const EventData&    event,
         CallbackEngine*     engine,
         const CallbackData& cookie);
         // Process the specified event, and then potentially reregister the
         // specified cookie for interest in the same data.

                                                    246


i



    i                                                                                                 i
    i                                                                                                      i
                     “emcpps-internal” — 2021/1/16 — 3:34 — page 247 — #249

i



        C++11                                                                            Opaque enums


          int main()
          {
          CallbackEngine e;     // Create a configurable callback engine object.

          //...       (Configure the callback engine , e, as appropriate.)

          e.registerInterest(&myCallback);       // Even a stateless function pointer can
          // be used with std::function.

          // ...create and register other clients for interest...

          m.run();      // Cede control to e's event loop until complete.

          return 0;
          }

        The implementation of myCallback, in the example below, is then free to reregister interest
        in the same event, save the cookie elsewhere to reregister at a later time, or complete its task
        and let the CallbackEngine take care of properly cleaning up all now unnecessary resources:
          void myCallback(const EventData&     event,
          CallbackEngine      *engine,
          const CallbackData& cookie)
          {
          int status = EventProcessor::processEvent(event);

          if (status > 0) // status is non­zero; continue interest in event
          {
          engine­>reregisterInterest(cookie);
          }
          else if (status < 0) // Negative status indicates EventProcessor wants
          // to reregister later.
          {
          EventProcessor::storeCallback(engine,cookie);
          // call reregisterInterest later
          }

          // Return flow of control to the CallbackEngine that invoked this
          // callback. If status was zero, then this callback should be cleaned
          // up properly with minimal fuss and no leaks.
          }

        What makes use of the opaque enumeration here especially apt is that the internal data
        structures maintained by the CallbackEngine might be very subtly interrelated, and any
        knowledge of a client’s relationship to those data structures that can be maintained through
        callbacks is going to reduce the amount of lookups and synchronization that would be needed
        to correctly reregister a client without that information. The otherwise wide contract on
        reregisterInterest means that clients have no need themselves to directly know anything
        about the actual values of the State they might be in. More notably, a component like this
        is likely to be very heavily reused across a large codebase, and being able to maintain it
                                                                                                    247


i



    i                                                                                                      i
    i                                                                                                i
                     “emcpps-internal” — 2021/1/16 — 3:34 — page 248 — #250

i



        Opaque enums                                 Chapter 2     Conditionally Safe Features


        while minimizing the need for clients to recompile can be a huge boon to deployment times.
           To see what is involved, we can consider the business end of the CallbackEngine imple-
        mentation and an outline of what a single-threaded implementation might involve:

         // callbackengine.cpp

         enum class CallbackData::State
         {
         // Full (local) definition of the enumerated states for the callback engine.
         e_INITIAL,
         e_LISTENING,
         e_READY,
         e_PROCESSING,
         e_REREGISTERED,
         e_FREED
         };

         void CallbackEngine::registerInterest(Callback cb)
         {
         // Create a CallbackData instance with a state of e_INITIAL and
         // insert it into the set of active clients.
         callbacks.push_back(CallbackData(cb, CallbackData::State::e_INITIAL));
         }

         void CallbackEngine::run()
         {
         // Update all client states to e_LISTENING based on the events in which
         // they have interest.

         d_running = true;
         while (d_running)
         {
         // Poll the operating system API waiting for an event to be ready.
         EventData event = getNextEvent();

         // Go through the elements of d_pendingCallbacks to deliver this
         // event to each of them.
         std::deque<CallbackData> callbacks = std::move(d_pendingCallbacks);

         // Loop once over the callbacks we are about to notify to update their
         // state so that we know they are now in a different container.
         for (CallbackData& callback : callbacks)
         {
         callback.setState(CallbackData::State::e_READY);
         }

         while (!callbacks.empty())
         {
         CallbackData callback = callbacks.pop_front();
                                                   248


i



    i                                                                                                i
    i                                                                                      i
                 “emcpps-internal” — 2021/1/16 — 3:34 — page 249 — #251

i



        C++11                                                               Opaque enums



         // Mark the callback as processing and invoke it.
         callback.setState(CallbackData::State::e_PROCESSING);

         callback.getCallback()(event, this, callback);

         // Clean up based on the new State.
         if (callback.getState() == CallbackData::State::e_REREGISTERED)
         {
         // Put the callback on the queue to get events again.
         d_pendingCallbacks.push_back(callback);
         }
         else
         {
         // The callback can be released, freeing resources.
         callback.setState(CallbackData::State::e_FREED);
         }
         }
         }
         }

         void CallbackEngine::reregisterInterest(const CallbackData& callback)
         {
         if (callback.getState() == CallbackData::State::e_PROCESSING)
         {
         // This is being called reentrantly from run(); simply update state.
         callback.setState(CallbackData::State::e_REREGISTERED);
         }
         else if (callback.getState() == CallbackData::State::e_READY)
         {
         // This callback is in the deque of callbacks currently having events
         // delivered to it; do nothing and leave it there.
         }
         else
         {
         // This callback was saved; set it to the proper state and put it in
         // the queue of callbacks.
         if (d_running)
         {
         callback.setState(CallbackData::State::e_LISTENING);
         }
         else
         {
         callback.setState(CallbackData::State::e_INITIAL);
         }

         d_pendingCallbacks.push_back(callback);
         }
         }

                                                                                    249


i



    i                                                                                      i
    i                                                                                                     i
                      “emcpps-internal” — 2021/1/16 — 3:34 — page 250 — #252

i



        Opaque enums                                    Chapter 2     Conditionally Safe Features


        Note how the definition of CallbackData::State is visible and needed only in this implemen-
        tation file. Also, consider that the set of states might grow or shrink as this CallbackEngine
        is optimized and extended, and clients can still pass around the object containing that state
        in a type-safe manner while remaining insulated from this definition.
            Prior to C++11, we could not have forward declared this enumeration, and so would have
        had to represent it in a type-unsafe way — e.g., as an int. Thanks to the modern enum class
        (see Section 2.1.“enum class” on page 222), however, we can conveniently forward declare
        it as a nested type and then, separately, fully define it inside the .cpp implementing other
        (non-inline) member functions of the CallbackEngine class. In this way, we are able to
        insulate changes to the enumerator list along with any other aspects of the implementation
        defined outside of the .h file without forcing any client applications to recompile.
            Finally, the basic design of the hypothetical CallbackEngine (in the code snippet above)
        could have been used for any number of useful components: a parser or tokenizer, a workflow
        engine, or even a more generalized event loop.

        Dual-Access: Insulating some external clients from the enumerator list
        In previous use cases, the goal has been to insulate all external clients from the enumerators
        of an enumeration that is visible (but not necessarily programmatically reachable) in the
        defining component’s header. Consider the situation in which a component (.h/.cpp pair)
        itself defines an enumeration that will be used by various clients within a single program,
        some of which will need access to the enumerators.
            When an enum class (or a classic enum having an explicitly specified underlying type; see
        Section 2.1.“Underlying Type ’11” on page 257) is specified in a header for direct program-
        matic use, external clients are at liberty to unilaterally redeclare it opaquely, i.e., without
        its enumerator list. A compelling motivation for doing so would be for a client who doesn’t
        make direct use of the enumerators to insulate itself and/or its clients from having to
        recompile whenever the enumerator list changes.
            Embedding any such local declaration in client code, however, would be highly prob-
        lematic: If the underlying type of the declaration (in one translation unit) were somehow to
        become inconsistent with that of the definition (in some other translation unit), any pro-
        gram incorporating both translation units would immediately become silently ill-formed,
        no-diagnostic required (IFNDR); see Potential Pitfalls — ?? on page ??
        Pitfalls: Creating local declarations of an externally defined enumeration, below.
        Unless a separate “forwarding” header file is provided along with (and ideally included by)
        the header defining the full enumeration, any client opting to exploit (when available) this
        opacity feature of an enumerated type will have no alternative but to redeclare the enumer-
        ation locally; see Potential Pitfalls — ?? on page ??
        Pitfalls: Suborning local enumeration declarations, below.
            For example, consider an enum class, Event, intended for public use by external clients:
          // event.h
          // ...
          enum class Event : char { /*... changes frequently ...*/ };
          // ...             ^^^^

        Now imagine some client header file, badclient.h, that makes use of the Event enumeration
                                                      250


i



    i                                                                                                     i
    i                                                                                                                 i
                     “emcpps-internal” — 2021/1/16 — 3:34 — page 251 — #253

i



        C++11                                                                                     Opaque enums


        and chooses to avoid compile-time coupling itself to the enumerator list by (for whatever
        reason) embedding a local declaration of Event instead:
          // badclient.h
          // ...
          enum class Event : char; // BAD IDEA: local external declaration
          // ...
          {
          Event d_currentEvent; // object of locally declare enumeration
          // ...
          };
          // ...

        Imagine now that the number of events that can fit in a char is exceeded and we decide to
        change the definition to have an underlying type of short:
          // event.h
          // ...
          enum class Event : short { /*... changes frequently ...*/ };
          // ...             ^^^^^

        Client code, such as in badclient.h, that fails to include the event.h header will have no
        automatic way of knowing that it needs to change, and recompiling the code (for all cases
        where event.h isn’t also included in the translation unit) will not fix the problem. Unless
        every such client is somehow updated manually, a newly linked program comprising them will
        be IFNDR with the likely consequence of either a crash or (worse) when the program runs
        and misbehaves. When providing a programmatically accessible definition of an enumerated
        type in a header where the underlying type is specified (either explicitly or implicitly), we
        can give external clients a safe alternative to local declaration by also providing an auxiliary
        header containing just the corresponding opaque declaration29 :
          // event.fwd.h
          // ...
          enum class Event : char;
          // ...

        In general, having a forwarding header always included in its corresponding full header
        facilitates situations such as default template arguments where the declaration can appear
        at most once in any given translation unit; the only drawback being that the (typically)
        comparatively small forwarding header file must now also be opened and parsed (once) if
        the full header file is included in a given translation unit. To ensure consistency, we thus
        #include this forwarding header in the original header defining the full enumeration:

          // event.h
          // ...                         // Ensure opaque declaration (included here) is
          #include <event.fwd.h>         // consistent with complete definition (below).

           29 Here we have chosen to treat the forwarding header file as part of the same event component as

        the principal header but with an injected descriptive suﬀix field, .fwd; this approach, as opposed to, say,
        file\_fwd.h, filefwd.h, or file.hh, was chosen so as not to (1) encroach on a disciplined component-
        naming scheme involving reserved use of underscores (see ?, section 2.4., pp. 297–333) or (2) confuse tools
        and scripts that expect header-file names to end with a .h suﬀix.
                                                                                                              251


i



    i                                                                                                                 i
    i                                                                                                              i
                       “emcpps-internal” — 2021/1/16 — 3:34 — page 252 — #254

i



        Opaque enums                                        Chapter 2       Conditionally Safe Features


          // ...
          enum class Event : char { /*... changes frequently ...*/ };
          // ...

        In this way, every translation unit that includes the definition will serve to ensure that
        the forward declaration and definition match; hence, clients can incorporate safely only the
        (presumably more stable) forwarding header30 :
          // goodclient.h
          // ...
          #include <event.fwd.h>        // GOOD IDEA: consistent opaque declaration
          // ...
          class Client
          {
          Event d_currentEvent;
          // ...
          };

        To illustrate real-world practical use of the opaque-enumerations feature, consider the vari-
        ous components31 that might depend on32 an Event enumeration such as that above:
           • message — Provides a value-semantic Message class consisting of just raw data,33
             including an Event field representing the type of event. This component never makes
             direct use of any enumeration values and thus needs to include only event.fwd.h and
             the corresponding opaque forward declaration of the Event enumeration.
           • sender and receiver — These are a pair of components that, respectively, create and
             consume Message objects. To populate a Message object, a Sender will need to provide
             a valid value for the Event member. Similarly, to process a Message, a Receiver will
             need to understand the potential individual enumerated values for the Event field.
             Both of these components will include the primary event.h header and thus have the
             complete definition of Event available to them.
           • messenger — The final component, a general engine capable of being handed Message
             objects by a Sender and then delivering those objects in an appropriate fashion to
             a Receiver, needs a complete and usable definition of Message objects — possibly
             copying them or storing them in containers before delivery — but has no need for
             understanding the possible values of the Event member within those Message objects.
             This component can participate fully and correctly in the larger system while being
             completely insulated from the enumeration values of the Event enumeration.
        tl;dr: By factoring out the Event enumeration into its own separate component and pro-
        viding two distinct but compatible headers, one containing the opaque declaration and the
           30 Note that we have consistently employed angle brackets exclusively for all include directives used

        throughout this book to maximize flexibility of deployment presuming a regimen for unique naming; see ?,
        section 1.5.1, pp. 201–203.
           31 See ?, sections 1.6 and 1.11, pp. 209–216 and pp. 256–259, respectively.
           32 ?, section 1.9?, pp. 237–243, TODO
           33 We sometimes refer to data that is meaningful only in the context of a higher-level entity as dumb

        data; see ?, section 3.5.5, pp. 629–633.
                                                          252


i



    i                                                                                                              i
    i                                                                                                     i
                    “emcpps-internal” — 2021/1/16 — 3:34 — page 253 — #255

i



        C++11                                                                           Opaque enums


        other (which includes the first) providing the complete definition, we enable having different
        components choose not to compile-time couple themselves with the enumerator list without
        forcing them to (unsafely) redeclare the enumeration locally.

        Potential Pitfalls
        Redeclaring an externally defined enumeration locally
        An opaque enumeration declaration enables the use of that enumeration without grant-
        ing visibility to its enumerators, reducing physical coupling between components. Unlike
        a forward class declaration, an opaque enumeration declaration produces a complete type,
        suﬀicient for substantive use (e.g., via the linker):
          // client.cpp
          enum Event : std::uint8_t;
          Event e; // OK, Event is a complete type.

        The underlying type specified in an opaque enum declaration must exactly match the full
        definition; otherwise a program incorporating both is automatically IFNDR. Updating an
        enum’s underlying type to accommodate additional values can lead to latent defects when
        these changes are not propagated to all local declarations:
          // library.h
          enum Event : std::uint16_t { /* now more than 256 events */ };

        Consistency of a local opaque enum declaration’s underlying type with that of its complete
        definition in a separate translation unit cannot be enforced by the compiler, potentially
        leading to a program that is IFNDR. In the example shown above, if the opaque declaration
        in client.h is not somehow updated to reflect the changes in event.h, the program will
        compile, link, and run, but its behavior has silently become undefined. The only robust
        solution to this problem is for library.h to provide two separate header files; see
        Suborning local enumeration declarations (“an attractive nuisance”), below.
            The problem with local declarations is by no means limited to opaque enumerations. Em-
        bedding a local declaration for any object whose use might be associated with its definition
        in a separate translation unit via just the linker invites instability:

          // main.cpp                                                   // library.cpp
          extern int x;    // BAD IDEA!                                 int x;
          // ...                                                        // ...

        The definition of object x (in the code snippets above) resides in the .cpp file of the library
        component while a supposed declaration of x is embedded in the file defining main. Should
        the type of just the definition of x change, both translation units will continue to compile
        but, when linked, the resulting program will be IFNDR:
          // main.cpp                                                   // library.cpp
          extern int x;    // ILL­FORMED PROGRAM                        double x;
          // ...                                                        // ...

        To ensure consistency across translation units, the time-honored tradition is to place, in a
        header file managed by the supplier, a declaration of each external-linkage entity intended
                                                                                                   253


i



    i                                                                                                     i
    i                                                                                                                 i
                        “emcpps-internal” — 2021/1/16 — 3:34 — page 254 — #256

i



        Opaque enums                                          Chapter 2       Conditionally Safe Features


        for use outside of the translation unit in which it is defined; that header is then included by
        both the supplier and each consumer:
          // main.cpp                         // library.h                     // library.cpp
          #include <library.h>                // ...                           #include <library.h>
          // ...                              extern int x;                    int x;
          // ...                         // ...

        In this way, any change to the definition of x in library.cpp (the supplier) will trigger a
        compilation error when library.cpp is recompiled, thereby forcing a corresponding change
        to the declaration in library.h. When that happens, typical build tools will take note of
        the change in the header file’s timestamp relative to that of the .o file corresponding to
        main.cpp (the consumer), indicating that it too needs to be recompiled. Problem solved.
            The maintainability pitfall associated with opaque enumerations, however, is qualita-
        tively more severe than for other external-linkage types, such as a global int: (1) the full
        definition for the enumeration type itself needs to reside in a header for any external client to
        make use of its individual enumerators and (2) typical components consist of just a .h/.cpp
        pair, i.e., exactly one .h file and usually just one .cpp file.34
            Exposing, within a library header file, an opaquely declarable enumeration that is pro-
        grammatically accessible by external clients without providing some maintainable way for
        those clients to keep their elided declarations in sync with the full definition introduces what
        we are calling an attractive nuisance: the client is forced to choose between (a) introducing
        the added risk and maintenance burden of having to manually maintain consistency between
        the underlying types for all its separate opaque uses and the one true (full) definition or
        (b) forgo use of this opaque-enumeration feature entirely, forcing gratuitous compile-time
        coupling35 with the unused (and perhaps unstable) enumerators.

        Inciting local enumeration declarations — an attractive nuisance
        Whenever we, as library component authors, provide the complete definition of an enum class
        or a classic enumeration with an explicitly specified underlying type and fail to provide a
        corresponding header having just the opaque declaration, we confront our clients with the
        unenviable conundrum of whether to needlessly compile-time couple themselves and/or their
        clients with the details of the enumerator list or to make the dubious choice to unilaterally
        redeclare that enumeration locally.
            The problems associated with local declarations of data whose types are maintained in
        separate translation units is not limited to enumerations; see Redeclaring an externally de-
        fined enumeration locally on page 253. The maintainability pitfall associated with opaque
        enumerations, however, is qualitatively more severe than for other external-linkage types,
        such as a global int, in that the ability to elide the enumerators amounts to an attractive
        nuisance wherein a client — wanting to do so and having access to only a single header con-
        taining the unelided definition (i.e., comprising the enumeration name, underlying integral
          34 ?,sections 2.2.11–13, pp. 280–281.
          35 At even moderate scale, excessive compile-time coupling can adversely affect projects in ways that are
        far more insidious than just increased compile times during development — e.g., any “emergency” changes
        that might need to occur and be deployed quickly to production without forcing all clients to recompile and
        then be retested and then, eventually, be rereleased. For a complete real-world example of how compile-time
        coupling can delay a “hot fix” by weeks, not just hours, see ?, section 3.10.5, pp. 783–789.
                                                           254


i



    i                                                                                                                 i
    i                                                                                                             i
                       “emcpps-internal” — 2021/1/16 — 3:34 — page 255 — #257

i



        C++11                                                                          Opaque enums


        type, and enumerator list) — might be seduced into providing an elided copy of the enum’s
        definition (i.e., one omitting just the enumerators) locally!
            Ensuring that (e.g., reusable) library components that define enumerations (e.g., enum class Event)
        whose enumerators can be elided also consistently provide a second (forwarding) header file
        containing the opaque declaration of each such enumeration (i.e., enumeration name and
        underlying integral type only) would be one (generally applicable) way to sidestep this often
        surprisingly insidious maintenance burden; see Dual-Access: Insulating some external clients
        from the enumerator list on page 250. Note that the attractive nuisance potentially exists
        even when the intent of the component is not primarily to make the enumeration generally
        available.36

        Annoyances
        Opaque enumerations are not completely type-safe
        Making an enumeration opaque does not stop it from being used to create an object that is
        initialized opaquely to a zero value and then subsequently used (e.g., in a function call):
          enum Bozo : int;       // *forward declaration* of enumeration Bozo
          void f(Bozo);          // *forward declaration* of function f

          void g()
          {
          Bozo clown{0};
          f(clown);      // OK, who knows if zero is a valid value?!
          }

        Though creating a zero-valued enumeration variable by default is not new, allowing one to
        be created without even knowing what enumerated values are valid is arguably dubious.

        See Also
          • “Underlying Type ’11” (Section 2.1, p. 257) ♦ The underlying integral representation
            for enumeration variables and their values.
          • “enum class” (Section 2.1, p. 222) ♦ An implicitly scoped, more strongly typed
            enumeration.

        Further Reading
          • For more on internal versus external linkage, see ?, section 1.3.1, pp. 154–159.
          • For more on the use of header files to ensure consistency across translation units, see
            ?, section 1.4, pp. 190–201, especially Figure 1-35, p. 197.
          • For more on the use of #include directives and #include guards, see ?, section 1.5,
            pp. 201–209.
          • For a complete delineation of inherent properties that belong to every well-conceived
            .h/.cpp pair, see ?, sections 1.6 and 1.11, pp. 219–216 and 256–259, respectively.
          36 See   https://www.hyrumslaw.com/.
                                                                                                  255


i



    i                                                                                                             i
    i                                                                                                  i
                    “emcpps-internal” — 2021/1/16 — 3:34 — page 256 — #258

i



        Opaque enums                                 Chapter 2     Conditionally Safe Features


         • For an introduction to physical dependency, see ?, section 1.8, pp. 237–243.

         • For a suggestion on how to achieve unique naming of files, see ?, section 2.4, pp. 297–
           333.
         • For a thorough treatment of architectural insulation, see ?, sections 3.10–3.11, pp. 773–
           835.




                                                   256


i



    i                                                                                                  i
    i                                                                                                                    i
                      “emcpps-internal” — 2021/1/16 — 3:34 — page 257 — #259

i



        C++11                                                                                  Underlying Type '11




        Explicit Enumeration Underlying Type
        The underlying type of an enumeration is the fundamental integral type used to represent
        its enumerated values, which can be specified explicitly in C++11.

        Description
        Every enumeration employs an integral type, known as its underlying type, to represent its
        compile-time-enumerated values.37 By default, the underlying type of an enum38 is chosen
        by the implementation to be large enough to represent all of the values in an enumeration
        and is allowed to exceed the size of an int only if there are enumerators having values that
        cannot be represented as an int or unsigned int:
          enum RGB { e_RED, e_GREEN, e_BLUE };                                       // fits any char

          enum Port { e_LEFT = ­81, e_RIGHT = ­82 };                                 // fits signed char

          enum Mask { e_LOW = 32767, e_HIGH = 65535 };                               // fits unsigned short

          enum Big { e_32 = 1<<32 };                                                 // too big for int

          enum Err { K = 1024, M = K*K, G = M*K, T = G*K };                          // G*K overflows int...

          enum OK { K = 1<<10, M = 1<<20, G = 1<<30, T = 1<<40 }; // ...but 1<<40 is OK

        The default underlying type chosen for an enum is always suﬀiciently large to represent
        all enumerator values defined for that enum. If the value doesn’t fit in an int, it will be
        selected deterministically as the first type able to represent all values from the sequence:
        unsigned int, long, unsigned long, long long, unsigned long long.39

        Specifying underlying type explicitly
        As of C++11, we have the ability to specify the integral type that is used to represent an
        enum. This is achieved by providing the type explicitly in the enum’s declaration following
        the enumeration’s (optional) name and preceded by a colon:
          enum Port : unsigned char
          {
          // Each enumerator of Port is represented as an unsigned char type.
          37 Note  that char and wchar_t, like enumerations, are their own distinct types (as opposed to typedef-like
        aliases such as std::uint8_t) and have their own implemenation-defined underlying integral types. With
        char, for example, the underlying type will always be either signed char or unsigned char (both of which
        are also distinct C++ types). The same is true in C++11 for char16_t and char32_t and in C++20 for
        char8_t.
           38 Note that the default underlying type of an enum class is ubiquitously int, and it is not implementation

        defined; see “enum class” on page 222.
           39 While specifying an enumeration’s underlying type was impossible before C++11, the compiler could be

        forced to choose at least a 32-bit or 64-bit signed integral type by adding an enumerator having a suﬀiciently
        large negative value — e.g., ­1 << 31 for a 32-bit and ­1 << 63 for a 64-bit signed integer (assuming such is
        available on the target platform).
                                                                                                                 257


i



    i                                                                                                                    i
    i                                                                                                    i
                      “emcpps-internal” — 2021/1/16 — 3:34 — page 258 — #260

i



        Underlying Type '11                            Chapter 2     Conditionally Safe Features



          e_INPUT          = 37,    //   OK, would have fit   in a signed char too
          e_OUTPUT         = 142,   //   OK, would not have   fit in a signed char
          e_CONTROL        = 255,   //   OK, barely fits in   an 8­bit unsigned integer
          e_BACK_CHANNEL   = 256,   //   error, doesn't fit   in an 8­bit unsigned integer
          };

        If any of the values specified in the definition of the enum is outside the boundaries of what
        the provided underlying type is able to represent, the compiler will emit an error, but see
        Potential Pitfalls: Subtleties of integral promotion on page 260.

        Use Cases
        Ensuring a compact representation where enumerator values are salient
        When the enumeration needs to have an eﬀicient representation, e.g., when it is used as a
        data member of a widely replicated type, restricting the width of the underlying type to
        something smaller than would occur by default on the target platform might be justified.
           As a concrete example, suppose that we want to enumerate the months of the year, for
        example, in anticipation of placing that enumeration inside a date class having an inter-
        nal representation that maintains the year as a two-byte signed integer, the month as an
        enumeration, and the day as an 8-bit signed integer:
          #include <cstdint>     // std::int8_t, std::int16_t

          class Date
          {
          std::int16_t d_year;
          Month d_month;
          std::int8_t day;

          public:
          Date(int year, Month month, int day);

          // ...

          int year() const    { return d_year; }
          Month month() const { return d_month; }
          int day() const     { return d_day; }
          }

        Within the software, the Date is typically constructed using the values obtained through
        the GUI, where the month is always selected from a drop-down menu. Management has
        requested that the month be supplied to the constructor as an enum to avoid recurring
        defects where the individual fields of the date are supplied in month/day/year format. New
        functionality will be written to expect the month to be enumerated. Still, the date class
        will be used in contexts where the numerical value of the month is significant, such as in
        calls to legacy functions that accept the month as an integer. Moreover, iterating over a
        range of months is common and requires that the enumerators convert automatically to
                                                     258


i



    i                                                                                                    i
    i                                                                                                      i
                    “emcpps-internal” — 2021/1/16 — 3:34 — page 259 — #261

i



        C++11                                                                       Underlying Type '11


        their (integral) underlying type, thus contraindicating use of the more strongly typed
        enum class:
          enum Month    // defaulted underlying type (BAD IDEA)
          {
          e_JAN = 1,   e_FEB,   e_MAR,    //   winter
          e_APR    ,   e_MAY,   e_JUN,    //   spring
          e_JUL    ,   e_AUG,   e_SEP,    //   summer
          e_OCT    ,   e_NOV,   e_DEC     //   autumn
          };

          static_assert(sizeof(Month) == 4 && alignof(Month) == 4, "");

        As it turns out, date values are used widely throughout this code base, and the proposed
        Date type is expected to be used in large aggregates. The underlying type of the enum in the
        code snippet above is implementation-defined and could be as small as a char or as large
        as an int despite all the values fitting in a char. Hence, if this enumeration were used as
        a data member in the Date class, sizeof(Date) would likely balloon to 12 bytes on some
        relevant platforms due to natural alignment! (See “alignas” on page 204.)
            While reordering the data members of Date such that d_year and d_day were adjacent
        would ensure that sizeof(Date) would not exceed 8 bytes, a better approach is to explicitly
        specify the enumeration’s underlying type to ensure sizeof(Date) is exactly the 4 bytes
        needed to accurately represent the value of the Date object. Given that the values in this
        enumeration fit in an 8-bit signed integer, we can specify its underlying type to be, e.g.,
        std::int8_t or signed char, on every platform:
          enum Month   : std::int8_t     // user­provided underlying type (GOOD IDEA)
          {
          e_JAN = 1,   e_FEB,   e_MAR,    //   winter
          e_APR    ,   e_MAY,   e_JUN,    //   spring
          e_JUL    ,   e_AUG,   e_SEP,    //   summer
          e_OCT    ,   e_NOV,   e_DEC     //   autumn
          };

          static_assert(sizeof(Month) == 1 && alignof(Month) == 1, "");

        With this revised definition of Month, the size of a Date class is 4 bytes, which is especially
        valuable for large aggregates:
          Date timeSeries[1000 * 1000];        // sizeof(timeSeries) is now 4Mb (not 12Mb)


        Potential Pitfalls
        External use of opaque enumerators
        Providing an explicit underlying type to an enum enables clients to declare or redeclare it as
        a complete type with or without its enumerators. Unless the opaque form of its definition is
        exported in a header file separate from its full definition, external clients wishing to exploit
        the opaque version will be forced to locally declare it with its underlying type but without
        its enumerator list. If the underlying type of the full definition were to change, any program
                                                                                                    259


i



    i                                                                                                      i
    i                                                                                                   i
                          “emcpps-internal” — 2021/1/16 — 3:34 — page 260 — #262

i



        Underlying Type '11                            Chapter 2    Conditionally Safe Features


        incorporating its own original and now inconsistent elided definition and the new full one
        would become silently ill formed, no diagnostic required (IFNDR). (See “Opaque enums”
        on page 240.)

        Subtleties of integral promotion
        When used in an arithmetic context, one might naturally assume that the type of a classic
        enum will first convert to its underlying type, which is not always the case. When used in
        a context that does not explicitly operate on the enum type itself, such as a parameter to
        a function that takes that enum type, integral promotion comes into play. For unscoped
        enumerations without an explicitly specified underlying type and for character types such
        as wchar_t, char16_t, and char32_t, integral promotion will directly convert the value
        to the first type in the list int, unsigned int, long, unsigned long, long long, and
        unsigned long long that is suﬀiciently large to represent all of the values of the underlying
        type. Enumerations having a fixed underlying type will, as a first step, behave as if they
        had decayed to their underlying type.
            In most arithmetic expressions, this difference is irrelevant. Subtleties arise, however,
        when one relies on overload resolution for identifying the underlying type:
          void     f(signed char x);
          void     f(short x);
          void     f(int x);
          void     f(long x);
          void     f(long long x);

          enum E1         { a, b, c, d, e };
          enum E2 : short { f, g, h, i ,j };

          void g()
          {
          f(E1::a);       // always calls f(int) on all platforms
          f(E2::f);       // always calls f(short) on all platforms
          }

        The overload resolution for f considers the type to which each individual enumerator can
        be directly integrally promoted. This conversion for E1 can be only to int. For E2, the
        conversion will consider int and short, and short, being an exact match, will be selected.
        Note that even though both enumerations are small enough to fit into a signed char, that
        overload of f will never be selected.
           One might want to get to the implementation-defined underlying type though, and the
        standard does provide a trait to do that: std::underlying_type in C++11 and the cor-
        responding std::underlying_type_t alias in C++14. This trait can safely be used in a
        cast without risking loss of value40 :
          template <typename E>
          std::underlying_type<E>::type toUnderlying(E value)
          {

          40 See   “auto Variables” on page 217.
                                                     260


i



    i                                                                                                   i
    i                                                                                                i
                       “emcpps-internal” — 2021/1/16 — 3:34 — page 261 — #263

i



        C++11                                                                  Underlying Type '11


         return static_cast<std::underlying_type<E>::type>(value);
         }

         void h()
         {
         auto e1 = toUnderlying(E1::a); // might be anywhere from signed char to int
         auto e2 = toUnderlying(E2::f); // always deduced as short
         }

        As of C++20, however, the use of a classic enumerator in a context in which it is compared
        to or otherwise used in a binary operation with either an enumerator of another type or
        a nonintegral type (i.e., a floating-point type, such as float, double, or long double) is
        deprecated, with the the possibility of being removed in C++23. Platforms might decide to
        warn against such uses retroactively:
         enum { k_GRAMS_PER_OZ = 28 };             // not the best idea

         double gramsFromOunces(double ounces)
         {
         return ounces * k_GRAMS_PER_OZ; // deprecated in C++20; might warn
         }

        Casting to the underlying type is not necessarily the same as direct integral promotion.
        In this context, we might want to change our enum to a constexpr int41 in the long term:
         constexpr int k_GRAMS_PER_OZ = 28;             // future proof


        See Also
          • “enum class” on page 222 — a scoped, more strongly typed enumeration

          • “Opaque enums” on page 240 — a means of insulating individual enumerators from
            clients
          • “constexpr Variables” on page 220 — an alternative way of declaring compile-time
            constants

        Further Reading
        TODO




          41 See   “constexpr Variables” on page 220.
                                                                                              261


i



    i                                                                                                i
    i                                                                                                  i
                       “emcpps-internal” — 2021/1/16 — 3:34 — page 262 — #264

i



        friend '11                                    Chapter 2     Conditionally Safe Features



        Extended friend Declarations
        Extended friend declarations enable a class’s author to designate a type alias, a template
        parameter, or any other previously declared type as a friend of that class.

        Description
        A friend declaration located within a given user-defined type (UDT) grants a designated
        type (or free function) access to private and protected members of that class. Because the
        extended friend syntax does not affect function friendships, this feature section addresses
        extended friendship only between types.
            Prior to C++11, the Standard required an elaborated type specifier to be provided after
        the friend keyword to designate some other type as being a friend of a given type. An elab-
        orated     type     specified   is    a    syntactical    element    having     the    form
        <typename|struct|union|enum> <identifier>. Elaborated type specifiers can be used
        to refer to a previously declared entity or to declare a brand new one, with the restriction
        that such an entity is one of class, struct, union, or enum:
         // C++03

         struct S;
         class C;
         enum E { };

         struct   X0
         {
         friend   S;          //   error: not legal C++98/03
         friend   struct S;   //   OK, refers to S above
         friend   class S;    //   OK, refers to S above (might warn)
         friend   class C;    //   OK, refers to C above
         friend   class C0;   //   OK, declares C0 in X0's namespace
         friend   union U0;   //   OK, declares U0 in X0's namespace
         friend   enum E;     //   OK, refers to E above
         friend   enum E2;    //   Error: enum cannot be forward­declared.
         };

        This restriction prevents other potentially useful entities, e.g., type aliases and template
        parameters, from being designated as friends:
         // C++03

         struct S;
         typedef S SAlias;

         struct X1
         {
         friend struct SAlias;
         // error: using typedef­name after struct
         };
                                                    262


i



    i                                                                                                  i
    i                                                                                                     i
                     “emcpps-internal” — 2021/1/16 — 3:34 — page 263 — #265

i



        C++11                                                                              friend '11



          template <typename T>
          struct X2
          {
          friend class T;
          // error: using template type parameter after class
          };

        Furthermore, even though an entity belonging to a namespace other than the class con-
        taining a friend declaration might be visible, explicit qualification is required to avoid
        unintentionally declaring a brand-new type:
          // C++03

          struct S;   // This S resides in the global namespace.

          namespace ns
          {
          class X3
          {
          friend struct S;
          // OK but declares a new ns::S instead of referring to ::S
          };
          }

        C++11 relaxes the aforementioned elaborated type specifier requirement and extends the
        classic friend syntax by instead allowing either a simple type specifier, which is any un-
        qualified type or type alias, or a typename specifier, e.g., the name of a template type
        parameter or dependent type thereof:
          struct S;
          typedef S SAlias;

          namespace ns
          {
          template <typename T>
          struct X4
          {
          friend T;           //    OK
          friend S;           //    OK, refers to ::S
          friend SAlias;      //    OK, refers to ::S
          friend decltype(0); //    OK, equivalent to friend int;
          friend C;           //    Error: C does not name a type.
          };
          }

        Notice that now it is again possible to declare as a friend a type that is expected to have
        already been declared, e.g., S, without having worry that a typo in the spelling of the type
        would silently introduce a new type declaration, e.g., C, in the enclosing scope.
            Finally, consider the hypothetical case in which a class template, C, befriends a dependent
        (e.g., nested) type, N, of its type parameter, T:
                                                                                                   263


i



    i                                                                                                     i
    i                                                                                                        i
                       “emcpps-internal” — 2021/1/16 — 3:34 — page 264 — #266

i



        friend '11                                       Chapter 2      Conditionally Safe Features


          template <typename T>
          class C
          {
          friend typename T::N;            // N is a *dependent* *type* of parameter T.
          enum { e_SECRET = 10022 };       // This information is private to class C.
          };

          struct   S
          {
          struct   N
          {
          static   constexpr int f()     // f is eligible for compile­time computation.
          {
          return   C<S>::e_SECRET;     // Type S::N is a friend of C<S>.
          }
          };
          };

          static_assert(S::N::f() == 10022, "");          // N has private access to C<S>.

        In the example above, the nested type S::N — but not S itself — has private access to
        C<S>::e_SECRET. Note that the need for typename in the friend declaration in the example
        above to introduce the dependent type N is relaxed in C++20.42

        Use Cases
        Safely declaring a previously declared type to be a friend
        In C++98/03, to befriend a type that was already declared required redeclaring it. If the
        type were misspelled in the friend declaration, a new type would be created:
          class Container { /* ... */ };

          class ContainerIterator
          {
          friend class Contianer;       // Compiles but wrong: ia should have been ai.
          // ...
          };

        The code above will compile and appear to be correct until ContainerIterator attempts
        to access a private or protected member of Container. At that point, the compiler will
        surprisingly produce an error. As of C++11, we have the option of preventing this mistake
        by using extended friend declarations:
          class Container { /* ... */ };

          class ContainerIterator
          {
          friend Contianer; // error: Contianer not found
         42 For information on other contexts in which typename will eventually no longer be required, see

        meredith20.
                                                       264


i



    i                                                                                                        i
    i                                                                                                                   i
                      “emcpps-internal” — 2021/1/16 — 3:34 — page 265 — #267

i



        C++11                                                                                           friend '11


          // ...
          };


        Befriending a type alias used as a customization point
        In C++03, the only option for friendship was to specify a particular class or struct
        when granting private access. Let’s begin by considering a scenario in which we have an
        in-process43 value-semantic type (VST) that serves as a handle to a platform-specific
        object, such as a Window in a graphical application. Large parts of a codebase may seek to
        interact with Window objects without needing or obtaining access to the internal represen-
        tation.
            A very small part of the codebase that handles platform-specific window management,
        however, needs privileged access to the internal representation of Window. One way to achieve
        this goal is to make the platform-specific WindowManager a friend of the Window class, but
        see Potential Pitfalls: Long-distance friendship on page 271.
          class WindowManager;         // forward declaration enabling extended friend syntax

          class Window
          {
          private:
          friend class WindowManager;           // could instead use friend WindowManager;
          int d_nativeHandle;                   // in­process (only) value of this object

          public:
          // ... all the typical (e.g., special) functions we expect of a value type
          };

        In the example above, class Window befriends class WindowManager, granting it private
        access. Provided that the implementation of WindowManager resides in the same (physi-
        cal) component as that of class Window, no long-distance friendship results. The con-
        sequence of such a monolithic design would be that every client that makes use of the
        otherwise lightweight Window class would necessarily depend physically on the presumably
        heavier-weight WindowManger class.
            Now consider that the WindowManager implementations on different platforms might
        begin to diverge significantly. To keep the respective implementations maintainable, one
        might choose to factor them into distinct C++ types, perhaps even defined in separate files,
        and to use a type alias determined using platform-detection preprocessor macros to configure
        that alias:
          // windowmanager_win32.h

          #ifdef WIN32
          class Win32WindowManager { /* ... */ };
          #endif

          43 When  used to qualify a VST, the term in-process, also called in-core, refers to a type that has typical
        value-type–like operations but does not refer to a value that is meaningful outside of the current process;
        see lakos2a, section 4.2.
                                                                                                                265


i



    i                                                                                                                   i
    i                                                                                                   i
                      “emcpps-internal” — 2021/1/16 — 3:34 — page 266 — #268

i



        friend '11                                     Chapter 2    Conditionally Safe Features




          // windowmanager_unix.h

          #ifdef UNIX
          class UnixWindowManager { /* ... */ };
          #endif


          // windowmanager.h

          #ifdef WIN32
          #include <windowmanager_win32.h>
          typedef Win32WindowManager WindowManager;
          #else
          #include <windowmanager_unix.h>
          typedef UnixWindowManager WindowManager;
          #endif


          // window.h
          #include <windowmanager.h>

          class Window
          {
          private:
          friend WindowManager;     // C++11 extended friend declaration
          int d_nativeHandle;

          public:
          // ...
          };

            In this example, class Window no longer befriends a specific class named WindowManager;
        instead, it befriends the WindowManager type alias, which in turn has been set to the correct
        platform-specific window manager implementation. Such extended use of friend syntax was
        not available in C++03.
            Note that this use case involves long-distance friendship inducing an implicit cyclic
        dependency between the component implementing Window and those implementing Win­
        dowManager; see Potential Pitfalls: Long-distance friendship on page 271. Such designs,
        though undesirable, can result from an emergent need to add new platforms while keeping
        tightly related code sequestered within smaller, more manageable physical units. An alter-
        native design would be to obviate the long-distance friendship by widening the API for
        the Window class, the natural consequence of which would be to invite public client abuse
        vis-a-vis Hyrum’s law.

        Using the PassKey idiom to enforce initialization
        Avoiding long-distance friendship is one of two design imperatives that drove the design
        of C++20 modules. Prior to C++11, efforts to grant private access to a class defined in a
                                                     266


i



    i                                                                                                   i
    i                                                                                                      i
                        “emcpps-internal” — 2021/1/16 — 3:34 — page 267 — #269

i



        C++11                                                                                friend '11


        separate physical unit required declaring the higher-level type itself to be a friend, resulting
        in this highly undesirable form of friendship; see Potential Pitfalls: Long-distance friendship
        on page 271. The ability in C++11 to declare a template type parameter or any other type
        specifier to itself be a friend affords new opportunities to enforce selective private access
        (e.g., to one or more individual functions) without explicitly declaring another type to be a
        friend; see also Description: Granting a specific type access to a single private function
        on page 268. In this use case, however, our use of extended friend syntax to befriend a
        template parameter is unlikely to run afoul of sound physical design.
            Let’s say we have a commercial library, and we want it to verify a software-license key,
        in the form of a C-style string, prior to using other parts of the API:
          // overly simplified pseudocode
          LibPassKey initializeLibrary(const char* licenseKey);
          int utilityFunction1(LibPassKey object /*, ... (other parameters) */)
          int utilityFunction2(LibPassKey object /*, ... (other parameters) */)

        Knowing full well that this is not a secure approach and that innumerable deliberate, ma-
        licious ways exist to get around the C++ type system, we nonetheless want to create a
        plausible regime where no well-formed way is available to accidentally gain access to library
        functionality other than by legitimately initializing the system using a valid license key.
        Although we could easily cause a function to throw, abort, and so on at run time when
        the function is called prior to the client’s license key being authenticated, part of our goal,
        as a friendly library vendor, is to ensure that clients do not inadvertently call other library
        functions prior to initialization. To that end, we propose the following protocol:
          1. use an instantiation of the PassKey class template44 that only our API utility
             struct45 can create

          2. return a constructed object of this type only upon successful validation of the license
             key
          3. require that clients present this (constructed) passkey object every time they invoke
             any other function in the API

        Here’s an example that encompasses all three aforementioned points:
          template <typename T>
          class PassKey // reusable standard utility type
          {
          PassKey() { } // private default constructor (no aggregate initialization)
          friend T;      // Only T is allowed to create this object.
          };

          struct BestExpensiveLibraryUtil
          {
          class LicenseError { /*...*/ };               // thrown if license string is invalid


          44 mayrand15
          45 lakos20,   section 2.4.9, pp. 312–321, specifically Figure 2-23, p. 316
                                                                                                    267


i



    i                                                                                                      i
    i                                                                                                    i
                      “emcpps-internal” — 2021/1/16 — 3:34 — page 268 — #270

i



        friend '11                                     Chapter 2     Conditionally Safe Features


          using LibPassKey = PassKey<BestExpensiveLibraryUtil>;
          // This is the type of the PassKey that will be returned when this
          // utility is initialized successfully, but only this utility is able
          // to construct an object of this type. Without a valid license string,
          // the client will have no way to create such an object and thus no way
          // to call functions within this library.

          static LibPassKey initializeLibrary(const char* licenseKey)
          // This function must be called with a valid licenseKey string prior
          // to using this library; if the supplied license is valid, a
          // LibPassKey *object* will be returned for mandatory use in *all*
          // subsequent calls to useful functions of this library. This function
          // throws LicenseError if the supplied licenseKey string is invalid.
          {
          if (isValid(licenseKey))
          {
          // Initialize library properly.

          return LibPassKey();
          // Return a default­constructed LibPassKey. Note that only
          // this utility is able to construct such a key.
          }

          throw LicenseError();     // supplied license string was invalid
          }

          static int doUsefulStuff(LibPassKey key /*,...*/);
          // The function requires a LibPassKey object, which can be constructed
          // only by invoking the static initializeLibrary function, to be
          // supplied as its first argument. ...

          private:
          static bool isValid(const char* key);
          // externally defined function that returns true if key is valid
          };

        Other than going outside the language with invalid constructs or circumventing the type
        system with esoteric tricks, this approach, among other things, prevents invoking doUse­
        fulStuff functions without a proper license. What’s more, the C++ type system at compile
        time forces a prospective client to have initialized the library before any attempt is made to
        use any of its other functionality.


        Granting a specific type access to a single private function
        When designing in purely logical terms, wanting to grant some other logical entity special
        access to a type that no other entity enjoys is a common situation. Doing so does not
        necessarily become problematic until that friendship spans physical boundaries; see Potential
        Pitfalls: Long-distance friendship on page 271.
                                                     268


i



    i                                                                                                    i
    i                                                                                                                i
                     “emcpps-internal” — 2021/1/16 — 3:34 — page 269 — #271

i



        C++11                                                                                        friend '11


            As a simple approximation to a real-world use case,46 suppose we have a lightweight
        object-database class, Odb, that is designed to operate collaboratively with objects, such as
        MyWidget, that are themselves designed to work collaboratively with Odb. Every compliant
        UDT suitable for management by Odb will need to maintain an integer object ID that is
        read/write accessible by an Odb object. Under no circumstances is any other object permitted
        to access, let alone modify, that ID independently of the Odb API.
            Prior to C++11, the design of such a feature might require every participating class to
        define a data member named d_objectId and to declare the Odb class a friend (using
        old-style friend syntax):
          class MyWidget // grants just Odb access to *all* of its private data
          {
          int d_objectId;   // required by our collaborative­design strategy
          friend class Odb; //    "     "   "        "        "       "
          // ...

          public:
          // ...
          };

          class Odb
          {
          // ...

          public:
          template <typename T>
          void processObject(T& object)
          // This function template is generally callable by clients.
          {
          int& objId = object.d_objectId;
          // ... (process as needed)
          }

          // ...
          };

        In this example, the Odb class implements the public member function template,
        processObject, which then extracts the objectId field for access. The collateral dam-
        age is that we have exposed all of our private details to Odb, which is at best a gratuitous
        widening of our sphere of encapsulation.
           Using the PassKey pattern allows us to be more selective with what we share:
          template <typename T>
          class Passkey
          // Implement this imminently reusable Passkey class template again here.
          {
          Passkey() { } // prevent aggregate initialization

          46 For an example of a real-world database implementation that requires managed objects to befriend that

        database manager, see cst15, section 2.1.
                                                                                                             269


i



    i                                                                                                                i
    i                                                                                                 i
                      “emcpps-internal” — 2021/1/16 — 3:34 — page 270 — #272

i



        friend '11                                    Chapter 2    Conditionally Safe Features


         friend T;      // Only the T in PassKey<T> can create a PassKey object.
         Passkey(const Passkey&) = delete;             // no copy/move construction
         Passkey& operator=(const Passkey&) = delete; // no copy/move assignment
         };

        We are now able to adjust the design of our systems such that only the minimum private
        functionality is exposed to Odb:
         class Odb;        // Objects of this class have special access to other objects.

         class MyWidget // grants just Odb access to only its objectId member function
         {
         int d_objectId; // must have an int data member of any name we choose
         // ...

         public:
         int& objectId(Passkey<Odb>) { return d_objectId; }
         // Return a non­const reference to the mandated int data member.
         // objectId is callable only within the scope of Odb.

         // ...
         };

         class Odb
         {
         // ...

         public:
         template <typename T>
         void processObject(T& object)
         // This function template is generally callable by clients.
         {
         int& objId = object.objectId(Passkey<Odb>());
         // ...
         }

         // ...
         };

        Instead of granting Odb private access to all encapsulated implementation details of
        MyWidget, this example uses the PassKey idiom to enable just Odb to call the (syntactically
        public) objectId member function of MyWidget with no private access whatsoever. As a
        further demonstration of the eﬀicacy of this approach, consider that we are able to create
        and invoke the processObject method of an Odb object from a function, f, but we are
        blocked from calling the objectId method of a MyWidget object directly:
         void f()
         {
         Odb mgr;          // object receiving fine­grained privileged access
         MyWidget widget; // object granting selective private access to just Odb
         mgr.processObject(widget);
                                                    270


i



    i                                                                                                 i
    i                                                                                                     i
                        “emcpps-internal” — 2021/1/16 — 3:34 — page 271 — #273

i



        C++11                                                                              friend '11



          int& objId = widget.objectId(PassKey<Odb>()); // cannot call out of Odb
          // Error: Passkey<T>::Passkey() [withT = Odb] is private within
          // this context.
          }

        Notice that use of the extended friend syntax to befriend a template parameter and thereby
        enable the PassKey idiom here improved the granularity with which we effectively grant
        privileged access to an individually named type but didn’t fundamentally alter the testability
        issues that result when private access to specific C++ types is allowed to extend across
        physical boundaries; again, see Potential Pitfalls: Long-distance friendship on page 271.

        Curiously recurring template pattern
        Befriending a template parameter via extended friend declarations can be helpful when
        implementing the curiously recurring template pattern (CRTP). For use-case exam-
        ples and more information on the pattern itself, see Appendix: Curiously Recurring Template
        Pattern Use Cases on page 272.

        Potential Pitfalls
        Long-distance friendship
        Since before C++ was standardized, granting private access via a friend declaration across
        physical boundaries, known as long-distance friendship, was observed47,48 to potentially
        lead to designs that are qualitatively more diﬀicult to understand, test, and maintain. When
        a user-defined type, X, befriends some other specific type, Y, in a separate, higher-level
        translation unit, testing X thoroughly without also testing Y is no longer possible. The effect
        is a test-induced cyclic dependency between X and Y. Now imagine that Y depends on a
        sequence of other types, C1, C2, …, CN­2, each defined in its own physical component, CI,
        where CN­2 depends on X. The result is a physical design cycle of size N. As N increases,
        the ability to manage complexity quickly becomes intractable. Accordingly, the two design
        imperatives that were most instrumental in shaping the C++20 modules feature were (1)
        to have no cyclic module dependencies and (2) to avoid intermodule friendships.

        See Also
        TODO

        Further Reading
          • For yet more potential uses of the extended friend pattern in metaprogramming con-
            texts, such as using CRTP, see alexandrescu01.

          • lakos96, section 3.6, pp. 136–146, is dedicated to the classic use (and misuse) of
            friendship.


          47 lakos96,   section 3.6.1 pp. 141–144
          48 lakos20,   section 2.6, pp. 342–370, specifically p. 367 and p. 362
                                                                                                   271


i



    i                                                                                                     i
    i                                                                                                      i
                      “emcpps-internal” — 2021/1/16 — 3:34 — page 272 — #274

i



        friend '11                                      Chapter 2     Conditionally Safe Features


          • lakos20 provides extensive advice on sound physical design, which generally pre-
            cludes long-distance friendship.

        Appendix: Curiously Recurring Template Pattern Use Cases
        Refactoring using the curiously recurring template pattern
        Avoiding code duplication across disparate classes can sometimes be achieved using a strange
        template pattern first recognized in the mid-90s, which has since become known as the
        curiously recurring template pattern (CRTP). The pattern is curious because it
        involves the surprising step of declaring as a base class, such as B, a template that expects
        the derived class, such as C, as a template argument, such as T:
          template <typename T>
          class B
          {
          // ...
          };

          class C : public B<C>
          {
          // ...
          };

        As a trivial illustration of how the CRTP can be used as a refactoring tool, suppose that we
        have several classes for which we would like to track, say, just the number of active instances:
          class A
          {
          static int s_count;      // declaration
          // ...

          public:
          static int count() { return s_count; }

          A()            {   ++s_count;   }
          A(const A&)    {   ++s_count;   }
          A(const A&&)   {   ++s_count;   }
          ~A()           {   ­­s_count;   }

          A& operator=(A&) = default;         // see special members
          A& operator=(A&&) = default;        // "      "       "
          // ...
          };

          int A::s_count;      // definition (in .cpp file)

          class B { /* similar to A (above) */ }
          // ...

          void test()
                                                      272


i



    i                                                                                                      i
    i                                                                                                  i
                   “emcpps-internal” — 2021/1/16 — 3:34 — page 273 — #275

i



        C++11                                                                            friend '11


         {           // A::d_count = 0, B::d_count = 0
         A a1;   // A::d_count = 1, B::d_count = 0
         B b1;   // A::d_count = 1, B::d_count = 1
         A a2;   // A::d_count = 2, B::d_count = 1
         }           // A::d_count = 0, B::d_count = 0

        In this example, we have multiple classes, each repeating the same common machinery. Let’s
        now explore how we might refactor this example using the CRTP:
         template <typename T>
         class InstanceCounter
         {
         protected:
         static int s_count; // declaration

         public:
         static int count() { return s_count; }
         };

         template <typename T>
         int InstanceCounter<T>::s_count;       // definition (in same file as declaration)

         struct A : InstanceCounter<A>
         {
         A()          { ++s_count; }
         A(const A&) { ++s_count; }
         A(const A&&) { ++s_count; }
         ~A()         { ­­s_count; }

         A& operator=(const A&)     = default;
         A& operator=(A&&)          = default;
         // ...
         };

        Notice that we have factored out a common counting mechanism into an InstanceCounter
        class template and then derived our representative class A from InstanceCounter<A>, and
        we would do similarly for classes B, C, and so on. This approach works because the compiler
        does not need to see the derived type until the point at which the template is instantiated,
        which will be after it has seen the derived type.
            Prior to C++11, however, there was plenty of room for user error. Consider, for example,
        forgetting to change the base-type parameter when copying and pasting a new type:
         struct B : InstanceCounter<A> // Oops! We forgot to change A to B in
         // InstanceCounter: The wrong count will be
         // updated!
         {
         B() { ++s_count; }
         };

        Another problem is that a client deriving from our class can mess with our protected
        s_count:
                                                                                                273


i



    i                                                                                                  i
    i                                                                                                        i
                       “emcpps-internal” — 2021/1/16 — 3:34 — page 274 — #276

i



        friend '11                                       Chapter 2      Conditionally Safe Features


          struct AA : A
          {
          AA() { s_count = ­1; }      // Oops! *Hyrum's Law* is at work again!
          };

        We could inherit from the InstanceCounter class privately, but then InstanceCounter
        would have no way to add to the derived class’s public interface, for example, the public
        count static member function.
            As it turns out, however, both of these missteps can be erased simply by making the inter-
        nal mechanism of the InstanceCounter template private and then having InstanceCounter
        befriend its template parameter, T:
          template <typename T>
          class InstanceCounter
          {
          static int s_count; // Make this static data member private.
          friend T;             // Allow access only from the derived T.

          public:
          static int count() { return s_count; }
          };

          template <typename T>
          int InstanceCounter<T>::s_count;

        Now if some other class does try to derive from this type, it cannot access this type’s counting
        mechanism. If we want to suppress even that possibility, we can declare and default (see
        “Defaulted Functions” on page 58) the InstanceCounter class constructors be private as
        well.

        Synthesizing equality using the curiously recurring template pattern
        As a second example of code factoring using the CRTP, suppose that we want to create a
        factored way of synthesizing operator== for types that implement just an operator<.49
        In this example, the CRTP base-class template, E, will synthesize the homogeneous oper­
        ator== for its parameter type, D, by returning false if either argument is less than the
        other:
          template <typename D>
          class E { }; // CRTP base class used to synthesize operator== for D

          template <typename D>
          bool operator==(E<D> const& lhs, E<D> const& rhs)
          {
          const D& d1 = static_cast<const D&>(lhs); // derived type better be D
          const D& d2 = static_cast<const D&>(rhs); //      "    "     "    " "
          return !(d1 < d2) && !(d2 < d1);           // assuming D has an operator<
          }
          49 This example is based on a similar one found on stackoverflow.com: https://stackoverflow.com/

        questions/4173254/what-is-the-curiously-recurring-template-pattern-crtp
                                                       274


i



    i                                                                                                        i
    i                                                                                                   i
                    “emcpps-internal” — 2021/1/16 — 3:34 — page 275 — #277

i



        C++11                                                                             friend '11


        A client that implements an operator< can now reuse this CRTP base case to synthesize
        an operator==:
          struct S : E<S>
          {
          int d_size;
          };

          bool operator<(const S& lhs, const S& rhs)
          {
          return lhs.d_size < rhs.d_size;
          }

          #include <cassert>

          void test1()
          {
          S s1; s1.d_size = 10;
          S s2; s2.d_size = 10;

          assert(s1 == s2);     // compiles and passes
          }

        As this code snippet suggests, the base-class template, E, is able to use the template param-
        eter, D (representing the derived class, S), to synthesize the homogeneous free operator==
        function for S.
            Prior to C++11, no method existed to guard against accidents, such as inheriting from
        the wrong base and then perhaps even forgetting to define the operator<:
          struct P : E<S>     // Oops! should have been E(P) ­­ a serious latent defect
          {
          int d_x;
          int d_y;
          };

          void test2()
          {
          P p1; p1.d_x = 10; p1.d_y = 15;
          P p2; p2.d_x = 10; p2.d_y = 20;

          assert( !(p1 == p2) );     // Oops! This fails because of E(S) above.
          }

        Again, thanks to C++11’s extended friend syntax, we can defend against these defects
        at compile time simply by making the CRTP base class’s default constructor private and
        befriending its template parameter:
          template <typename D>
          class E
          {
          E() = default;
                                                                                                 275


i



    i                                                                                                   i
    i                                                                                                 i
                     “emcpps-internal” — 2021/1/16 — 3:34 — page 276 — #278

i



        friend '11                                    Chapter 2    Conditionally Safe Features


         friend D;
         };

        Note that the goal here is not security but simply guarding against accidental typos, copy-
        paste errors, and occasional human error. By making this change, we will soon realize that
        there is no operator< defined for this type.

        Compile-time polymorphism using the curiously recurring template pat-
        tern
        Object-oriented programming provides certain flexibility that at times might be supereroga-
        tory. Here we will exploit the familiar domain of abstract/concrete shapes to demonstrate
        a mapping between runtime polymorphism using virtual functions and compile-time poly-
        morphism using the CRTP. We begin with a simple abstract Shape class that implements
        a single, pure, virtual draw function:
         class Shape
         {
         public:
         virtual void draw() const = 0;      // abstract draw function (interface)
         };

        From this abstract Shape class, we now derive two concrete shape types, Circle and
        Rectangle, each implementing the abstract draw function:
         #include <iostream>     // std::cout

         class Circle : public Shape
         {
         int d_radius;

         public:
         Circle(int radius) : d_radius(radius) { }

         void draw() const // concrete implementation of abstract draw function
         {
         std::cout << "Circle(radius = " << d_radius << ")\n";
         }
         };

         class Rectangle : public Shape
         {
         int d_length;
         int d_width;

         public:
         Rectangle(int length, int width) : d_length(length), d_width(width) { }

         void draw() const // concrete implementation of abstract draw function
         {
         std::cout << "Rectangle(length = " << d_length << ", "
                                                    276


i



    i                                                                                                 i
    i                                                                                                   i
                    “emcpps-internal” — 2021/1/16 — 3:34 — page 277 — #279

i



        C++11                                                                             friend '11


          "width = " << d_width     << ")\n";
          }
          };

        Notice that a Circle is constructed with a single integer argument, i.e., radius, and a
        Rectangle is constructed with two integers, i.e., length and width.
            We now implement a function that takes an arbitrary shape, via a const lvalue reference
        to its abstract base class, and prints it:
          void print(const Shape& shape)
          {
          shape.draw();
          }

          void testShape()
          {
          print(Circle(1));           // prints: Circle(radius = 1)
          print(Rectangle(2, 3));     // prints: Rectangle(length = 2, width = 3)
          print(Shape());             // Compile­time error: Shape is an abstract class.
          }

        Now suppose that we didn’t need all the runtime flexibility offered by this system and wanted
        to map just what we have in the previous code snippet onto templates that avoid the spatial
        and runtime overhead of virtual-function tables and dynamic dispatch. Such transformation
        again involves creating a CRTP base class, this time in lieu of our abstract interface:
          template <typename T>
          struct Shape
          {
          void draw() const
          {
          static_cast<const T*>(this)­>draw();       // assumes T derives from Shape
          }
          };

        Notice that we are using a static_cast to the address of an object of the const template
        parameter type, T, assuming that the template argument is of the same type as some derived
        class of this object’s type. We now define our types as before, the only difference being the
        form of the base type:
          class Circle : public Shape<Circle>
          {
          // same as above
          };

          class Rectangle : public Shape<Rectangle>
          {
          // same as above
          };

        We now define our print function, this time as a function template taking a Shape of
        arbitrary type T:
                                                                                                 277


i



    i                                                                                                   i
    i                                                                                                   i
                      “emcpps-internal” — 2021/1/16 — 3:34 — page 278 — #280

i



        friend '11                                     Chapter 2      Conditionally Safe Features


          template <typename T>
          void print(const Shape<T>& shape)
          {
          shape.draw();
          }

        The result of compiling and running testShape above is the same, including that Shape()
        doesn’t compile.
           However, opportunities for undetected failure remain. Suppose we decide to add a third
        shape, Triangle, constructed with three sides:
          class Triangle : public Shape<Rectangle>         // Oops!
          {
          int d_side1;
          int d_side2;
          int d_side3;

          public:
          Triangle(int side1, int side2, int side3)
          : d_side1(side1), d_side2(side2), d_side3(side3) { }

          void draw() const
          {
          std::cout << "Triangle(side1 = " << d_side1 << ", "
          "side2 = " << d_side2 << ", "
          "side3 = " << d_side3 << ")\n";
          }
          };

        Unfortunately we forgot to change the base-class type parameter when we copy-pasted from
        Rectangle.
           Let’s now create a new test that exercises all three and see what happens on our platform:
          void test2()
          {
          print(Circle(1));             //   prints: Circle(radius = 1)
          print(Rectangle(2, 3));       //   prints: Rectangle(length = 2, width = 3)
          print(Triangle(4, 5, 6));     //   prints: Rectangle(length = 4, width = 5) ?!
          Shape<int> bug;               //   Compiles?!
          }

        As should by now be clear, a defect in our Triangle implementation results in hard un-
        defined behavior that could have been prevented at compile time by using the extended
        friend syntax. Had we defined the CRTP base-class template’s default constructor to be
        private and made its type parameter a friend, we could have prevented the copy-paste
        error with Triangle and suppressed the ability to create a Shape object without deriving
        from it (e.g., see bug in the previous code snippet):
          template <typename T>
          class Shape
          {
                                                     278


i



    i                                                                                                   i
    i                                                                                                   i
                    “emcpps-internal” — 2021/1/16 — 3:34 — page 279 — #281

i



        C++11                                                                             friend '11


          Shape() = default;    // Default the default constructor to be private.
          friend T;             // Ensure only a type derived from T has access.
          }

        Generally, whenever we are using the CRTP, making just the default constructor of the
        base-class template private and having it befriend its type parameter is typically a trivial
        local change, is helpful in avoiding various forms of accidental misuse, and is unlikely to
        induce long-distance friendships where none previously existed: Applying extended friend
        syntax to an existing CRTP is typically safe.

        Compile-time visitor using the curiously recurring template pattern
        As more real-world applications of compile-time polymorphism using the CRTP, consider
        implementing traversal and visitation of complex data structures. In particular, we want to
        facilitate employing default-action functions, which allow for simpler code from the point of
        view of the programmer who needs the results of the traversal. We illustrate our compile-time
        visitation approach using binary trees as our data structure.
            We begin with the traditional node structure of a binary tree, where each node has a
        left and right subtree plus a label:
          struct Node
          {
          Node* left;
          Node* right;
          char label; // label will be used in the pre­order example.

          Node() : left(0), right(0), label(0) { }
          };

        Now we wish to have code that traverses the tree in one of the three traditional ways:
        pre-order, in-order, post-order. Such traversal code is often intertwined with the actions to
        be taken. In our implementation, however, we will write a CRTP-like base-class template,
        Traverser, that implements empty stub functions for each of the three traversal types,
        relying on the CRTP-derived type to supply the desired functionality:
          template <typename T>
          class Traverser
          {
          private:
          Traverser() = default;     // Make the default constructor private.
          friend T;                  // Grant access only to the derived class.

          public:
          void visitPreOrder(Node*) { }       // stub­functions & placeholders
          void visitInOrder(Node*)   { }      // (Each of these three functions
          void visitPostOrder(Node*) { }      // defaults to an inline "no­op.")

          void traverse(Node* n) // factored subfunctionality
          {
          T *t = static_cast<T*>(this); // Cast this to the derived type.
                                                                                                 279


i



    i                                                                                                   i
    i                                                                                                   i
                          “emcpps-internal” — 2021/1/16 — 3:34 — page 280 — #282

i



        friend '11                                          Chapter 2     Conditionally Safe Features



          if   (n)   {   t­>visitPreOrder(n);     }   //   optionally   defined   in   derived
          if   (n)   {   t­>traverse(n­>left);    }   //   optionally   defined   in   derived
          if   (n)   {   t­>visitInOrder(n);      }   //   optionally   defined   in   derived
          if   (n)   {   t­>traverse(n­>right);   }   //   optionally   defined   in   derived
          if   (n)   {   t­>visitPostOrder(n);    }   //   optionally   defined   in   derived
          }
          };

        The factored traversal mechanism is implemented in the Traverser base-class template.
        A proper subset of the four customization points, that is, the four member functions in-
        voked from the public traverse function of the Traverser base class, are implemented
        as appropriate in the derived class, identified by T. Each of these customization functions
        is invoked in order. Notice that the traverse function is safe to call on a nullptr as each
        individual customization-function invocation will be independently bypassed if its supplied
        Node pointer is null. If a customization function is defined in the derived class, that ver-
        sion of it is invoked; otherwise, the corresponding empty inline base-class version of that
        function is invoked instead. This approach allows for any of the three traversal orders to be
        implemented simply by supplying an appropriately configured derived type where clients are
        obliged to implement only the portions they need. Even the traversal itself can be modified,
        as we will soon see, where we create the very data structure we’re traversing.
            Let’s now look at how derived-class authors might use this pattern. First, we’ll write a
        traversal class that fully populates a tree to a specified depth:
          struct FillToDepth : Traverser<FillToDepth>
          {
          using Base = Traverser<FillToDepth>; // similar to a local typedef

          int d_depth;                  //   final "height" of the tree
          int d_currentDepth;           //   current distance from the root

          FillToDepth(int depth) : d_depth(depth), d_currentDepth(0) { }

          void traverse(Node*& n)
          {
          if (d_currentDepth++ < d_depth && !n) // descend; if not balanced...
          {
          n = new Node;     // Add node since it's not already there.
          }

          Base::traverse(n);          // Recurse by invoking the *base* version.

          ­­d_currentDepth;           // Ascend.
          }
          };

        The derived class’s version of the traverse member function acts as if it overrides the
        traverse function in the base-class template and then, as part of its re-implementation,
        defers to the base-class version to perform the actual traversal.
                                                           280


i



    i                                                                                                   i
    i                                                                                                       i
                    “emcpps-internal” — 2021/1/16 — 3:34 — page 281 — #283

i



        C++11                                                                                friend '11


            Importantly, note that we have re-implemented traverse in the derived class with a
        function by the same name but having a different signature that has more capability
        (i.e., it’s able to modify its immediate argument) than the one in the base-class template.
        In practice, this signature modification is something we would do rarely, but part of the
        flexibility of this design pattern, as with templates in general, is that we can take advantage
        of duck typing to achieve useful functionality in somewhat unusual ways. For this pattern,
        the designers of the base-class template and the designers of the derived classes are, at
        least initially, likely to be the same people, and they will arrange for these sorts of signature
        variants to work correctly if they need such functionality. Or they may decide that overridden
        methods should follow a proper contract and signature that they determine is appropriate,
        and they may declare improper overrides to be undefined behavior. In this example, we aim
        for illustrative flexibility over rigor.
          void traverse(Node* n);       // as declared in the Traverser base­class template
          void traverse(Node*& n);      // as declared in the FillToDepth derived class

        Unlike virtual functions, the signatures of corresponding functions in the base and derived
        classes need not match exactly provided the derived-class function can be called in the
        same way as the corresponding one in the base class. In this case, the compiler has all the
        information it needs to make the call properly:
          static_cast<FillToDepth *>(this)­>traverse(n)          // what the compiler sees

        Suppose that we now want to create a type that labels a small tree, balanced or not,
        according to its pre-order traversal:
          struct PreOrderLabel : Traverser<PreOrderLabel>
          {
          char d_label;

          PreOrderLabel() : d_label('a') { }

          void visitPreOrder(Node* n) // This choice controls traversal order.
          {
          n­>label = label++;
          // Each successive label is sequential alphabetically.
          }
          };

        The simple pre-order traversal class, PreOrderLabel, labels the nodes such that it visits
        each parent before it visits either of its two children.
           Alternatively, we might want to create a read-only derived class, InOrderPrint, that
        simply prints out the sequence of labels resulting from an in-order traversal of the, e.g.,
        previously pre-ordered, labels:
          #include <cstdio>     // std::putchar

          struct InOrderPrint : Traverser<InOrderPrint>
          {
          ~InOrderPrint()
          {
                                                                                                     281


i



    i                                                                                                       i
    i                                                                                                     i
                       “emcpps-internal” — 2021/1/16 — 3:34 — page 282 — #284

i



        friend '11                                         Chapter 2       Conditionally Safe Features


          std::putchar('\n');       // print single newline at end of string
          }

          void visitInOrder(const Node* n) const
          {
          std::putchar(n­>label); // Print the label character exactly as is.
          }
          };

        The simple InOrderPrint-derived class, shown in the example above, prints out the labels
        of a tree in order: left subtree, then node, then right subtree. Notice that since we are only
        examining the tree here — not modifying it — we can declare the overriding method to
        take a const Node* rather than a Node* and make the method itself const. Once again,
        compatibility of signatures, not identity, is the key.
            Finally, we might want to clean up the tree. We do so in post-order since we do not want
        to delete a node before we have cleaned up its children!
          struct CleanUp : Traverser<CleanUp>
          {
          void visitPostOrder(Node*& n)
          {
          delete n; // always necessary
          n = 0;     // might be omitted in a "raw" version of the type
          }
          };

        Putting it all together, we can create a main program that creates a balanced tree to a
        depth of four and then labels it in pre-order, prints those labels in in-order, and destroys it
        in post-order:
          int main()
          {
          Node* n = 0;                        // tree handle

          FillToDepth(4).traverse(n);         //   (1)   Create balanced tree.
          PreOrderLabel().traverse(n);        //   (2)   Label tree in pre­order.
          InOrderPrint().traverse(n);         //   (3)   Print above labels in order.
          CleanUp().traverse(n);              //   (4)   Destroy tree in post­order.
          return 0
          }

        Running this program results in a binary tree of height 4, as illustrated in the code snippet
        below, and has reliably consistent output:
          dcebgfhakjlinmo

          Level 0:                                             a
          .    '            '       .
          Level 1:                      b '                                  ' i
          . '      '   .                       .    '      '       .
          Level 2:              c                  f                   j             m
                                                         282


i



    i                                                                                                     i
    i                                                                                                    i
                     “emcpps-internal” — 2021/1/16 — 3:34 — page 283 — #285

i



        C++11                                                                              friend '11


          /   \               /    \             /    \             /   \
          Level 3:      d         e          g            h     k           l     n    o

        This use of the CRTP for traversal truly shines when the data structure to be traversed
        is especially complex, such as an abstract-syntax-tree (AST) representation of a computer
        program, where tree nodes have many different types, with each type having custom ways
        of representing the subtrees it contains. For example, a translation unit is a sequence of
        declarations; a declaration can be a type, a variable, or a function; functions have return
        types, parameters, and a compound statement; the statement has substatements, expressions
        and so on. We would not want to rewrite the traversal code for each new application. Given
        a reusable CRTP-based traverser for our AST, we don’t have to.
            For example, consider writing a type that visits each integer literal node in a given AST:
          struct IntegerLiteralHandler : AstTraverser<IntegerLiteralHandler>
          {
          void visit(IntegerLiteral* iLit)
          {
          // ... (do something with this integer literal)
          }
          }

        The AST traverser, which would implement a separate empty visit overload for each
        syntactic node type in the grammar, would invoke our derived visit member function with
        every integer literal in the program, regardless of where it appeared. This CRTP-based
        traverser would also call many other visit methods, but each of them performs no action
        at all by default and would likely be elided at even modest compiler-optimization levels.
        Be aware, however, that, although we ourselves are not rewriting the traversal code each
        time, the compiler is still doing it because every CRTP instantiation produces a new copy
        of the traversal code. If the traversal code is large and complex, the consequence might be
        increased program size, that is, code bloat.
            Finally, the CRTP can be used in a variety of situations for many purposes,50 hence
        its curiously recurring nature. Those uses invariably benefit from (1) declaring the base-
        class template’s default constructor private and (2) having that template befriend its type
        parameter, which is possible only by means of the extended friend syntax. Thus, the CRTP
        base-class template can ensure, at compile time, that its type argument is actually derived
        from the base class as required by the pattern.




          50 https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern

                                                                                                  283


i



    i                                                                                                    i
    i                                                                                                                   i
                        “emcpps-internal” — 2021/1/16 — 3:34 — page 284 — #286

i



        Forwarding References                                  Chapter 2       Conditionally Safe Features



        Forwarding && References
        A forwarding reference (T&&) — distinguishable from an rvalue reference (&&) (see “rvalue
        References” on page 306) only based on context — is a distinct, special kind of reference
        that (1) binds (universally) to the result of an expression of any value category and (2)
        preserves aspects of that value category so that the bound object can be moved from, if
        appropriate.

        Description
        Sometimes we’ll want the same reference to be able to bind to either an lvalue or an rvalue
        and then later be able to discern, from the reference itself, whether the result of the original
        expression was eligible to be moved from. A forwarding reference (e.g., forRef) used in the
        interface of a function template (e.g., myFunc) affords precisely this capability and will prove
        invaluable for the purpose of conditionally moving (or else copying) an object from within
        the function template’s body:
          template <typename T>
          void myFunc(T&& forRef)
          {
          // It is possible to check if forRef is eligible to be moved from or not
          // from within the body of myFunc.
          }

        In the definition of the myFunc function template in the example above, the parameter
        forRef syntactically appears to be a non-const reference to an rvalue of type T; in this
        very precise context,51 however, the same T&& syntax designates a forwarding reference,
        with the effect of retaining the original value category of the object bound to the argument
        forRef; see Description: Identifying forwarding references on page 288.
            Consider, for example, a function f that takes a single argument by reference and then
        attempts to use it to invoke one of two overloads of a function g, depending on whether the
        original argument was an lvalue or rvalue52 :
          struct S { /* some UDT that might benefit from being able to be moved */ };

          void g(const S&);        // target function ­ overload for const int lvalues
          void g(S&&);             // target function ­ overload for int rvalues only

          template <typename T>
          void f(T&& forRef); // forwards to target overload g based on value category

        In this specific case — where f is a function template, T is a template type parameter, and
        the type of the parameter itself is exactly T&& — the forRef function parameter (in the
           51 The T&& syntax represents a forwarding reference (as opposed to an rvalue reference) whenever an

        individual (possibly member) function template has a type parameter (e.g., T) and an unqualified function
        parameter of type that is exactly T&& (e.g., const T&& would be an rvalue reference).
           52 In theory, we could have chosen a non-const lvalue reference along with a (modifiable) rvalue reference

        here for pedagogical symmetry; such an inherently unharmonious overload set would, however, not typically
        occur in practice; see “rvalue References” on page 306.
                                                            284


i



    i                                                                                                                   i
    i                                                                                                 i
                   “emcpps-internal” — 2021/1/16 — 3:34 — page 285 — #287

i



        C++11                                                                 Forwarding References


        code snippet above) denotes a forwarding reference. If f is invoked with an lvalue, forRef
        is an lvalue reference; otherwise forRef is an rvalue reference. Given the dual nature of
        forRef, one (overly verbose) way of determining the original value category of the passed
        argument would be to use the std::is_lvalue_reference type trait on forRef itself:
         #include <type_traits>     // std::is_lvalue_reference

         template <typename T>
         void f(T&& forRef)      // forRef is a forwarding       reference.
         {
         if (std::is_lvalue_reference<T>::value) // using        a C++11 type trait
         {
         g(forRef);             // propagates forRef as an       *lvalue*
         }                          // invokes g(const S&)
         else
         {
         g(std::move(forRef)); // propagates forRef as an        *rvalue*
         }                          // invokes g(S&&)
         }

        The std::is_lvalue_reference<T>::value predicate above asks the question, “Did the
        object bound to fRef originate from an lvalue expression?” allowing the developer to branch
        on the answer. A more concise but otherwise equivalent implementation is generally pre-
        ferred; see Description: The std::forward utility on page 291:
         #include <utility>     // std::forward

         template <typename T>
         void f(T&& forRef)
         {
         g(std::forward<T>(forRef));
         // same as g(std::move(forRef)) if and only if forRef is an *rvalue*
         // reference; otherwise, equivalent to g(forRef)
         }

        A client function invoking f will enjoy the same behavior with either of the two imple-
        mentation alternatives offered above:
         void client()
         {
         S s;
         f(s);    // Instantiates f<S&> ­­ fRef is an lvalue reference (S&).
         // The function f<S&> will end up invoking g(S&).

         f(S()); // Instantiates f<S&&> ­­ fRef is an rvalue reference (S&&).
         // The function f<S&&> will end up invoking g(S&&).
         }

        Use of std::forward in combination with forwarding references is typical in the implemen-
        tation of industrial-strength generic libraries; see Use Cases on page 291.
                                                                                               285


i



    i                                                                                                 i
    i                                                                                                    i
                      “emcpps-internal” — 2021/1/16 — 3:34 — page 286 — #288

i



        Forwarding References                          Chapter 2     Conditionally Safe Features


        A brief review of function template argument deduction
        Invoking a function template without explicitly providing template arguments at the call site
        will compel the compiler to attempt, if possible, to deduce those template type arguments
        from the function arguments:
          template <typename T> void f();
          template <typename T> void g(T x);
          template <typename T> void h(T y, T z);

          void example0()
          {
          f();        // error: couldn't infer template argument T
          g(0);       // OK, T deduced as int from literal 0 ­­ x is an int.
          h(0, 'a'); // error: deduced conflicting types for T (int vs. char)
          }

        Any cv-qualifiers (const, volatile, or both) on a deduced function parameter will be
        applied after type deduction is performed:
          template <typename T> void cf(const T x);
          template <typename T> void vf(volatile T y);
          template <typename T> void wf(const volatile T z);

          void example1()
          {
          cf(0); // OK, T deduced as int ­­ x is a const int.
          vf(0); // OK, T deduced as int ­­ y is a volatile int.
          wf(0); // OK, T deduced as int ­­ z is a const volatile int.
          }

        Similarly, ref-qualifiers other than && (& or && along with any cv-qualifier) do not alter
        the deduction process, and they too are applied after deduction:
          template <typename T> void rf(T& x);
          template <typename T> void crf(const T& x);

          void example2()
          {
          int i;
          rf(i);   // OK, T is deduced as int ­­ x is an int&.
          crf(i); // OK, T is deduced as int ­­ x is a const int&.

          rf(0);    // error: expects an lvalue for 1st argument
          crf(0);   // OK, T is deduced as int ­­ x is a const int&.
          }

        Type deduction works differently for forwarding references where the only qualifier on the
        template argument is &&. For the sake of exposition, consider a function template declaration,
        f, accepting a forwarding reference, forRef:
          template <typename T> void f(T&& forRef);
                                                     286


i



    i                                                                                                    i
    i                                                                                                     i
                    “emcpps-internal” — 2021/1/16 — 3:34 — page 287 — #289

i



        C++11                                                                     Forwarding References


        We have seen in the example on page 285 that, when f is invoked with an lvalue of type S,
        then T is deduced as S& and forRef becomes an lvalue reference. When f is instead invoked
        with an xvalue of type S, then T is deduced as S and forRef becomes an rvalue reference.
        The underlying process that results in this “duality” relies on a special rule (known as
        reference collapsing; see the next section) introduced as part of type deduction. When
        the type T of a forwarding reference is being deduced from an expression E, T itself will be
        deduced as an lvalue reference if E is an lvalue; otherwise normal type-deduction rules will
        apply and T will be deduced an rvalue reference:
          void g()
          {
          int i;
          f(i); // i is an *lvalue* expression.
          // T is therefore deduced as int& ­­ special rule!
          // T&& becomes int& &&, which collapses to int&.

          f(0) // 0 is an *rvalue* expression.
          // T is therefore deduced as int.
          // T&& becomes int&&, which is an *rvalue* reference.
          }

        For more on on general type deduction, see “auto Variables” on page 217.

        Reference collapsing
        As we saw in the previous section, when a function having a forwarding reference parameter,
        forRef, is invoked with a corresponding lvalue argument, an interesting phenomenon occurs:
        After type deduction, we temporarily get what appears syntactically to be an rvalue reference
        to an lvalue reference. As references to references are not allowed in C++, the compiler
        employs reference collapsing to resolve the forwarding-reference parameter, forRef, into
        a single reference, thus providing a way to infer, from T itself, the original value category
        of the argument passed to f.
            The process of reference collapsing takes place automatically in any situation where
        a reference to a reference is formed. Table 2 illustrates the simple rules for collapsing “un-
        stable” references into “stable” ones. Notice, in particular, that an lvalue reference always
        overpowers an rvalue reference. The only situation in which two references collapse into an
        rvalue reference is when they are both rvalue references.

              Table 2: Collapsing “unstable” reference pairs into a single “stable” one

                1st Reference Type    2nd Reference Type      Result of Reference Collapsing
                         &                      &                             &
                         &                     &&                             &
                        &&                      &                             &
                        &&                     &&                            &&



           Finally, note that it is not possible to write a reference-to-reference type in C++
                                                                                                   287


i



    i                                                                                                     i
    i                                                                                                      i
                       “emcpps-internal” — 2021/1/16 — 3:34 — page 288 — #290

i



        Forwarding References                           Chapter 2     Conditionally Safe Features


        explicitly:
          int    i   = 0;       // OK
          int&   ir = i;        // OK
          int& & irr = ir;      // error: irr declared as a reference to a reference

        It is, however, easy to do so with type aliases and template parameters, and that is where
        reference collapsing will come into play:
          using i = int&; // OK
          using j = i&;    // OK, int& & becomes int&.
          static_assert(std::is_same_v<j,int&>);

        During computations involving metafunctions, or as part of language rules (such as type
        deduction), however, references to references can occur spontaneously:
          template <typename T>
          struct AddLvalueRef { typedef T& type; };
          // metafunction that transforms to an *lvalue* reference to T

          template    <typename T>
          void f(T    input)
          {
          typename    AddLvalueRef<T>::type ir1 = input;         // OK, adds & to make T&
          typename    AddLvalueRef<T&>::type ir2 = input;        // OK, collapses to T&
          typename    AddLvalueRef<T&&>::type ir3 = input;       // OK, collapses to T&
          }

        Notice that we are using the typename keyword in the example above as a generalized way
        of indicating, during template instantiation, that a dependent name is a type (as opposed
        to a value).

        Identifying forwarding references
        The syntax for a forwarding reference (&&) is the same as that for rvalue references; the only
        way to discern one from the other is by observing the surrounding context. When used in a
        manner where type deduction can take place, the T&& syntax does not designate an rvalue
        reference; instead, it represents a forwarding reference; for type deduction to be in effect, an
        individual (possibly member) function template must have a type parameter (e.g., T) and a
        function parameter of type that exactly matches that parameter followed by && (e.g., T&&):
          struct S0
          {
          template <typename T>
          void f(T&& forRef);
          // OK, fully eligible for template­argument type deduction: forRef
          // is a forwarding reference.
          }

        Note that if the function parameter is qualified, the syntax reverts to the usual meaning of
        rvalue reference:
                                                      288


i



    i                                                                                                      i
    i                                                                                                      i
                     “emcpps-internal” — 2021/1/16 — 3:34 — page 289 — #291

i



        C++11                                                                    Forwarding References


          struct S1
          {
          template <typename T>
          void f(const T&& crRef);
          // Eligible for type deduction but is not a forwarding reference: due
          // to the const qualifier, crRef is an *rvalue* reference.
          }

        If a member function of a class template is not itself also a template, then its template type
        parameter will not be deduced:
          template <typename T>
          struct S2
          {
          void f(T&& rRef);
          // Not eligible for type deduction because T is fixed and known as part
          // of the instantiation of S2: rRef is an *rvalue* reference.
          };

        More generally, note that the && syntax can never imply a forwarding reference for a function
        that is not itself a template; see Annoyances: Forwarding references look just like rvalue
        references on page 302.

        auto&& — a forwarding reference in a non-parameter context
        Outside of template function parameters, forwarding references can also appear in the con-
        text of variable definitions using the auto variable (see “auto Variables” on page 217)
        because they too are subject to type deduction:
          void f()
          {
          auto&& i = 0; // i is a forwarding reference because the type of i must
          // be deduced from the initialization expression 0.
          }

        Just like function parameters, auto&& resolves to either an lvalue reference or rvalue reference
        depending on the value category of the initialization expression:
          void g()
          {
          int i;
          auto&& lv = i;    // lv is an int&.

          auto&& rv = 0;    // rv is an int&&.
          }

        Similarly to const auto&, the auto&& syntax binds to anything. In auto&&, however, the
        const-ness of the bound object is preserved rather than always enforced:
          void h()
          {
          int         i = 0;
                                                                                                    289


i



    i                                                                                                      i
    i                                                                                                   i
                      “emcpps-internal” — 2021/1/16 — 3:34 — page 290 — #292

i



        Forwarding References                          Chapter 2    Conditionally Safe Features


          const int ci = 0;

          auto&& lv = i;        // lv is an int&.
          auto&& clv = ci;      // clv is a const int&.
          }

        Just as with function parameters, the original value category of the expression used to
        initialize a forwarding reference variable can be propagated during subsequent function invo-
        cation – e.g., using std::forward (see Description: The std::forward utility on page 291):
          template <typename T>
          void use(T&& t); // Here use also takes a forwarding reference parameter
          // to do with as it pleases.

          template <typename T>
          void l()
          {
          auto&& fr = get<T>();
          // get<T>() might be either an *lvalue* or *rvalue* depending on T.

          use(std::forward<decltype(fr)>(fr)); // decltype is a C++11 feature.
          // Propagate the original value category of get<T>() into use.
          }

        Notice that, because (1) std::forward (see the next section) requires the type of the object
        that’s going to be forwarded as a user-provided template argument and (2) it is not possible
        to name the type of fr, decltype (see “decltype” on page 51) was used in the example
        above to retrieve the type of fr.

        Forwarding references without forwarding
        Sometimes deliberately not forwarding (see Description: The std::forward utility on page 291)
        an auto&& variable or a forwarding reference function parameter at all can be useful, instead
        employing forwarding references solely for their const-preserving and universal binding se-
        mantics. As an example, consider the task of obtaining iterators over a range of an unknown
        value category:
          template <typename T>
          void m()
          {
          auto&& r = getRange<T>();
          // getRange<T>() might be either an lvalue or rvalue depending on T.

          auto b = std::begin(r);
          auto e = std::end(r);

          traverseRange(b, e);
          }

        Using std::forward in the initialization of both b and e might result in moving from r
        twice, which is potentially unsafe (see “rvalue References” on page 306). Forwarding r only
                                                     290


i



    i                                                                                                   i
    i                                                                                                     i
                    “emcpps-internal” — 2021/1/16 — 3:34 — page 291 — #293

i



        C++11                                                                   Forwarding References


        in the initialization of e might avoid issues caused by moving an object twice but might
        result in inconsistent behavior with b, especially if the implementation of r makes use of
        reference qualifiers (see “??” on page ??).

        The std::forward utility
        The final piece of the forwarding reference puzzle is the std::forward utility function. Since
        the expression naming a forwarding reference x is always an lvalue (due to its reachability
        either by name or address in virtual memory) and since our intention is to move x in case
        it was an rvalue to begin with, we need a conditional move operation that will move x only
        in that case and otherwise let x pass through as an lvalue.
            The declaration for std::forward<T> is as follows (in <utility>):
          template <class T> T&& forward(typename remove_reference<T>::type& t) noexcept;
          template <class T> T&& forward(typename remove_reference<T>::type&& t) noexcept;

        The second overload is ill-formed if invoked when T is an lvalue reference type.
           Remember that the type T associated with a forwarding reference is deduced as a ref-
        erence type if given an lvalue reference and as a non-reference type otherwise. So for a
        forwarding reference forRef of type T&&, we have two cases:

          • An lvalue of type U was used for initializing forRef, so T is U&, thus the first overload
            of forward will be selected and will be of the form U& forward(U& u) noexcept, thus
            just returning the original lvalue reference.

          • An rvalue of type U was used for initializing forRef, so T is U, so the second overload
            of forward will be selected and will be of the form U&& forward(U& u) noexcept,
            essentially equivalent to std::move.

        Note that, in the body of a function template accepting a forwarding reference T&& named x,
        std::forward<T>(x) could be replaced with static_cast<T&&>(x) to achieve the same
        effect. Due to reference collapsing rules, T&& will resolve to T& whenever the original value
        category of x was an lvalue and to T&& otherwise, thus achieving the conditional move
        behavior elucidated in Description on page 284. Using std::forward over static_cast
        will, however, ensure that the types of T and x match, preventing accidental unwanted
        conversions and, separately, perhaps also more clearly expressing the programmer’s intent.

        Use Cases
        Perfectly forwarding an expression to a downstream consumer
        A frequent use of forwarding references and std::forward is to propagate an object, whose
        value category is invocation-dependent, down to one or more service providers that will
        behave differently depending on the value category of the original argument.
            As an example, consider an overload set for a function, sink, that accepts a std::string
        either by const lvalue reference (e.g., with the intention of copying from it) or rvalue refer-
        ence (e.g., with the intention of moving from it):
          void sink(const std::string& s) { target = s; }
          void sink(std::string&& s)      { target = std::move(s); }
                                                                                                   291


i



    i                                                                                                     i
    i                                                                                                                   i
                        “emcpps-internal” — 2021/1/16 — 3:34 — page 292 — #294

i



        Forwarding References                                  Chapter 2       Conditionally Safe Features


        Now, let’s assume that we want to create an intermediary function template, pipe, that
        will accept an std::string of any value category and will dispatch its argument to the
        corresponding overload of sink. By accepting a forwarding reference as a function parameter
        and invoking std::forward as part of pipe’s body, we can achieve our original goal without
        any code duplication:
          template <typename T>
          void pipe(T&& x)
          {
          sink(std::forward<T>(x));
          }

        Invoking pipe with an lvalue will result in x being an lvalue reference and thus
        sink(const std::string&)’s being called. Otherwise, x will be an rvalue reference and
        sink(std::string&&) will be called. This idea of enabling move operations without code
        duplication (as pipe does) is commonly referred to as Use Cases: Perfect forwarding for
        generic factory functions on page 293.

        Handling multiple parameters concisely
        Suppose you have a value-Semantic type (VST) that holds a collection of attributes
        where some (not necessarily proper) subset of them need to be changed together53 :
          struct Person { /* UDT that benefits from move semantics */ };

          class StudyGroup
          {
          Person d_a;
          Person d_b;
          Person d_c;
          Person d_d;
          // ...

          public:
          bool isValid(const Person& a, const Person& b, const Person& c, const Person& d);
          // Return true if these specific people form a valid study group under
          // the guidelines of the study­group commission, and false otherwise.
          // ...

          template <typename PA, typename PB, typename PC, typename PD,
          typename = typename std::enable_if<
          std::is_same<typename std::decay<PA>::type, Person>::value &&
          std::is_same<typename std::decay<PB>::type, Person>::value &&
          std::is_same<typename std::decay<PC>::type, Person>::value &&
          std::is_same<typename std::decay<PD>::type, Person>::value>::type>
          int setPersonsIfValid(PA&& a, PB&& b, PC&& c, PD&& d)
          {
          enum { e_SUCCESS = 0, e_FAIL };
           53 This type of value-semantic type can be classified more specifically as a complex-constrained attribute

        class; see lakos2a, section 4.2.
                                                            292


i



    i                                                                                                                   i
    i                                                                                                     i
                    “emcpps-internal” — 2021/1/16 — 3:34 — page 293 — #295

i



        C++11                                                                   Forwarding References



          if (!isValid(a, b, c, d))
          {
          return e_FAIL; // bad choice; no change
          }

          // Move or copy each person into this object's Person data members:
          d_a = std::forward<PA>(a);
          d_b = std::forward<PB>(b);
          d_c = std::forward<PC>(c);
          d_d = std::forward<PD>(d);

          return e_SUCCESS;     // Study group was updated successfully.
          }
          };

        The setPersonsIfValid function is producing the full crossproduct of instantiations for
        every variation of qualifiers that can be on a Person object. Any combination of lvalue and
        rvalue Persons can be passed, and a template will be instantiated that will copy the lvalues
        and move from the rvalues. To make sure the Person objects are created externally, the
        function is restricted, using std::enable_if, to instantiate only for types that decay to
        Person (i.e., types that are cv-qualified or ref-qualified Person). Because each parameter is a
        forwarding reference, they can all implicitly convert to const Person& to pass to isValid,
        creating no additional temporaries. Finally, std::forward is then used to do the actual
        moving or copying as appropriate to data members.

        Perfect forwarding for generic factory functions
        Consider the prototypical standard-library generic factory function, std::make_shared<T>.
        On the surface, the requirements for this function are fairly simple — allocate a place for a
        T and then construct it with the same arguments that were passed to make_shared. This,
        however, gets reasonably complex to implement eﬀiciently when T can have a wide variety
        of ways in which it might be initialized.
            For simplicity, we will show how a two-argument my::make_shared might be defined,
        knowing that a full implementation would employ variadic template arguments for this
        purpose — see “Variable Templates” on page 185. We will also implement a simpler version
        of make_shared that simply creates the element on the heap with new and constructs a
        std::shared_ptr to manage the lifetime of that element. The declaration of this form of
        make shared would be structured like this:
          template <typename ELEMENT_TYPE, typename ARG1, typename ARG2>
          std::shared_ptr<ELEMENT_TYPE> my::make_shared(ARG1&& arg1, ARG2&& arg2)

        As you can see, we have two forwarding reference arguments — arg1 and arg2 — with
        deduced types ARG1 and ARG2. Now, the body of our function needs to carefully construct
        our ELEMENT_TYPE object on the heap and then create our output shared_ptr:
          template <typename ELEMENT_TYPE, typename ARG1, typename ARG2>
          std::shared_ptr<ELEMENT_TYPE> my::make_shared(ARG1&& arg1, ARG2&& arg2)
          {
                                                                                                   293


i



    i                                                                                                     i
    i                                                                                                   i
                      “emcpps-internal” — 2021/1/16 — 3:34 — page 294 — #296

i



        Forwarding References                          Chapter 2    Conditionally Safe Features


          ELEMENT_TYPE *element_p = new ELEMENT_TYPE(std::forward<ARG1>(arg1),
          std::forward<ARG2>(arg2));
          try
          {
          return std::shared_ptr<ELEMENT_TYPE>(element_p);
          }
          catch (...)
          {
          delete element_p;
          throw;
          }
          }

        Note that this simplified implementation needs to take care that the constructor for the
        return value does not throw, cleaning up the allocated element if that should happen; nor-
        mally a RAII proctor to manage this ownership would be a more robust solution to this
        problem.
            Importantly, the use of std::forward to construct the element means that the argu-
        ments passed to make_shared will be used to find the appropriate matching two-argument
        constructor of ELEMENT_TYPE. When those arguments were rvalues, the constructor found
        will again search for one that takes an rvalue and the arguments will be moved from. Even
        more, because this function wants to forward exactly the const-ness and reference type of
        the input arguments, we would have to write 12 distinct overloads for each argument if we
        were not using perfect forwarding – the full cross product of const (or not), volatile (or
        not), and &, &&, (or not). This would mean a full implementation of just this two-argument
        variation would require 144 distinct overloads, all almost identical and most never actu-
        ally instantiated. The use of forwarding references reduces that to just 1 overload for each
        number of arguments.

        Wrapping initialization in a generic factory function
        Occasionally we might want to initialize an object with an intervening function call wrapping
        the actual construction of that object. Suppose we have a tracking system that we want to
        use to monitor how many times certain initializers have been invoked:
          struct TrackingSystem
          {
          template <typename T>
          static void trackInitialization(int numArgs);
          // Track the creation of a T with a constructor taking numArgs
          // arguments.
          };

        Now we want to write a general utility function that can be used to construct an arbitrary
        object and notify the tracking system of the construction for us. Here we will use a variadic
        pack (see “Variable Templates” on page 185) of forwarding references to handle calling the
        constructor for us:
          template <class ELEMENT_TYPE, typename... ARGS>
          ELEMENT_TYPE trackConstruction(ARGS&&... args)
                                                     294


i



    i                                                                                                   i
    i                                                                                                     i
                    “emcpps-internal” — 2021/1/16 — 3:34 — page 295 — #297

i



        C++11                                                                   Forwarding References


          {
          TrackingSystem::trackInitialization<ELEMENT_TYPE>(sizeof...(args));
          return ELEMENT_TYPE(std::forward<ARGS>(args)...);
          }

        This let’s us add tracking easily to convert any initialization to a tracked one by inserting
        a call to this function around the constructor arguments.
          void myFunction()
          {
          BigObject untracked("Hello", "World");
          BigObject tracked = trackConstruction("Hello","World");
          }

        On the surface there does seem to be a difference between how untracked and tracked are
        initialized. The first variable is having its constructor directly invoked, while the second is
        being constructed from an object being returned by-value from trackConstruction. This
        construction, however, has long been something that has been optimized away to avoid any
        additional objects and construct the object in question just once. In this case, because the
        element being returned is initialized by the return statement of trackConstruction, the
        optimization is called return value optimization (RVO). C++ has always allowed this
        optimization by enabling copy elision. In C++17, this elision can even be guaranteed and is
        allowed to be done for objects that have no copy or move constructors. Prior to C++17, this
        elision can still be guaranteed (on all compilers that the authors are aware of) by declaring
        but not defining the copy constructor for BigObject. You’ll find that this code will still
        compile and link with such an object, providing observable proof that the copy constructor
        is never actually invoked with this pattern.

        Emplacement
        Prior to C++11, inserting an object into a standard library container always required the
        programmer to first create such object and then copy it inside the container’s storage. As an
        example, consider a inserting a temporary std::string object in a
        std::vector<std::string>:
          void f(std::vector<std::string>& v)
          {
          v.push_back(std::string("hello world"));
          // invokes std::string::string(const char*) and the copy­constructor
          }

        In the function above, a temporary std::string object is created in the stack frame of
        f and is then copied to the dynamically allocated buffer managed by v. Additionally, the
        buffer might have insuﬀicient capacity and hence might require reallocation, which would in
        turn require every element of v to be somehow copied from the old buffer to the new, larger
        one.
            In C++11, the situation is significantly better thanks to rvalue references. The temporary
        will be moved into v, and any buffer reallocation will move the elements between buffers
        rather copying them, assuming that the element’s move-constructor is a noexcept specifier
        (see “??” on page ??). The amount of work can, however, be further minimized: What if,
                                                                                                   295


i



    i                                                                                                     i
    i                                                                                                                i
                        “emcpps-internal” — 2021/1/16 — 3:34 — page 296 — #298

i



        Forwarding References                                Chapter 2       Conditionally Safe Features


        instead of first creating an object externally, we constructed the new std::string object
        directly in v’s buffer?
            This is where emplacement comes into play. All standard library containers (includ-
        ing std::vector) now provide an emplacement API powered by variadic templates (see
        “Variadic Templates” on page 314) and perfect forwarding (see Use Cases: Perfect forward-
        ing for generic factory functions o page 293). Rather than accepting a fully-constructed
        element, emplacement operations accept an arbitrary number of arguments, which will in
        turn be used to construct a new element directly in the container’s storage, thereby avoiding
        unnecessary copies or even moves:
          void g(std::vector<std::string>& v)
          {
          v.emplace_back("hello world");
          // invokes only the std::string::string(const char*) constructor
          }

        Calling std::vector<std::string>::emplace_back with a const char* argument re-
        sults in a new std::string object being created in-place in the next suitable spot of
        the vector’s storage. Internally, std::allocator_traits::construct is invoked, which
        typically employs placement new to construct the object in raw dynamically allocated
        memory. As previously mentioned, emplace_back makes use of both variadic templates
        and forwarding references; it accepts any number of forwarding references and internally
        perfectly forwards them to the constructor of T via std::forward:
          template <typename T>
          template <typename... Args>
          void std::vector<T>::emplace_back(Args&&... args)
          {
          // ...
          new (&freeLocationInBuffer) T(std::forward<Args>(args)...);                    // pseudocode
          // ...
          }

        Emplacement operations remove the need for copy or move operations when inserting
        elements into containers, potentially increasing the performance of a program and sometimes
        (depending on the container) even allowing even noncopyable or nonmovable objects to be
        stored in a container.54

        Decomposing complex expressions
        Many modern C++ libraries have adopted a more “functional” style of programming, chain-
        ing the output of one function as the arguments of another function to produce very complex
        expressions that accomplish a great deal in relatively concise fashion. Consider the way in
        which the C++20 ranges library encapsulates containers and arbitrary pairs of iterators into
           54 As previously mentioned, declaring (but not defining) the copy or move ctor of a noncopyable or non-

        movable type to be private is often a way to guarantee that a C++11/14 compiler constructed an object
        in place. Containers that might need to move elements around for other operations (such as std::vector
        or std::deque) will still need movable elements, while node-based containers that never move the elements
        themselves after initial construction (such as std::list or std::map) can use emplace along with noncopy-
        able or nonmovable objects.
                                                           296


i



    i                                                                                                                i
    i                                                                                                   i
                    “emcpps-internal” — 2021/1/16 — 3:34 — page 297 — #299

i



        C++11                                                                  Forwarding References


        objects that can be adapted and manipulated through long chains of functions. Let’s say you
        have a function that reads a file, does some spellchecking for every unique word in the file,
        and gives you a list of incorrect words and corresponding suggested proper spellings, and
        you have a range-like library with common utilities similar to standard UNIX processing
        utilities:
          SpellingSuggestion checkSpelling(const std::string& word);

          std::map<std::string, SpellingSuggestion> checkFileSpelling(
          const std::string& filename)
          {
          return makeMap(
          filter(transform(
          uniq(sort(filterRegex(splitRegex(openFile(filename),"\S+"),"\w+")))
          [](const std::string& x)
          {
          return std::tuple<std::string, SpellingSuggestion>(x,
          checkSpelling(x));
          }
          ), [](auto&& x) { return !std::get<1>(x).isCorrect(); }));
          }

        Upon doing code review for this amazing use of a modern library produced by the smart,
        new programmer on your team, you discover that you actually have a very hard time un-
        derstanding what is going on. On top of that, the usual tools you have to poke and prod at
        the code by adding printf statements or even breakpoints in your debugger are very hard
        to apply to the complex set of nested templates involved.
            Each of the functions in this range library – makeMap, transform, uniq, sort, filter­
        Regex, splitRegex, and openFile – is a set of complex templated overloads and deeply
        subtle metaprogramming that becomes hard to unravel for a nonexpert C++ programmer.
        On the other hand, you have also looked at the code generated for this function and the
        abstractions amazingly get compiled away to a very robust implementation.
            To better understand, document, and debug what is happening here, you want to de-
        compose this expression into many, capturing the implicit temporaries returned by all of
        these functions and ideally not changing the actual semantics of what is being done. To
        do that properly, you need to capture the type and value category of each subexpression
        appropriately, without necessarily being able to easily decode it manually from the expres-
        sion. Here is where auto&& forwarding references can be used effectively to decompose and
        document this expression while achieving the same:
          std::map<std::string, SpellingSuggestion> checkFileSpelling(
          const std::string& filename)
          {
          // Create a range over the contents of filename.
          auto&& openedFile = openFile(filename);

          // Split the file by whitespace.
          auto&& potentialWords = splitRegex(
          std::forward<decltype(openedFile)>(openedFile), "\S+");
                                                                                                 297


i



    i                                                                                                   i
    i                                                                                                  i
                      “emcpps-internal” — 2021/1/16 — 3:34 — page 298 — #300

i



        Forwarding References                         Chapter 2     Conditionally Safe Features



         // Filter out only words made from word­characters.
         auto&& words = filterRegex(
         std::forward<decltype(potentialWords)>(potentialWords), "\w+");

         // Sort all words.
         auto&& sortedWords = sort(std::forward<decltype(words)>(words));

         // Skip adjacent identical words. (This is now a sequence of unique words.)
         auto&& uniqueWords = uniq(std::forward<decltype(sortedWords)>(sortedWords));

         // Get a SpellingSuggestion for every word.
         auto&& suggestions = transform(
         std::forward<decltype(uniqueWords)>(uniqueWords),
         [](const std::string&x) {
         return std::tuple<std::string,SpellingSuggestion>(
         x,checkSpelling(x));
         });

         // Filter out correctly spelled words, keeping only elements where the
         // second element of the tuple, which is a SpellingSuggestion, is not
         // correct.
         auto&& corrections = filter(
         std::forward<decltype(corrections)>(corrections),
         [](auto&& suggestion){ return !std::get<1>(suggestion).isCorrect(); });

         // Return a map made from these 2­element tuples:
         return makeMap(std::forward<decltype(corrections)>(corrections));
         }

        Now each step of this complex expression is documented, each temporary has a name, but
        the net result of the lifetimes of each object is functionally the same. No new conversions
        have been introduced, and every object that was used as an rvalue in the original expression
        will still be used as an rvalue in this much longer (and more descriptive) implementation of
        the same functionality.

        Potential Pitfalls
        Surprising number of template instantiations with string literals
        When forwarding references are used as a means to avoid code repetition between exactly
        two overloads of the same function (one accepting a const T& and the other a T&&), it
        can be surprising to see more than two template instantiations for that particular template
        function, in particular when the function is invoked using string literals.
           Consider, as an example, a Dictionary class containing two overloads of an addWord
        member function:
         class Dictionary
         {
         // ...
                                                    298


i



    i                                                                                                  i
    i                                                                                                i
                   “emcpps-internal” — 2021/1/16 — 3:34 — page 299 — #301

i



        C++11                                                                Forwarding References



         public:
         void addWord(const std::string& word);       // (0) copy word in the dictionary
         void addWord(std::string&& word);            // (1) move word in the dictionary
         };

         void f()
         {
         Dictionary d;

         std::string s = "car";
         d.addWord(s);                        // invokes (0)

         const std::string cs = "toy";
         d.addWord(cs);                       // invokes (0)

         d.addWord("house");                  // invokes (1)
         d.addWord("garage");                 // invokes (1)
         d.addWord(std::string{"ball"});      // invokes (1)
         }

        Now, imagine replacing the two overloads of addWord with a single perfectly forwarding
        template member function, with the intention of avoiding code repetition between the two
        overloads:
         class Dictionary
         {
         // ...

         public:
         template <typename T>
         void addWord(T&& word);
         };

        Perhaps surprisingly, the number of template instantiations skyrockets:
         void f()
         {
         Dictionary d;

         std::string s = "car";
         d.addWord(s); // instantiates addWord<std::string&>

         const std::string cs = "toy";
         d.addWord(cs); // instantiates addWord<const std::string&>

         d.addWord("house");                  // instantiates addWord<char const(&)[6]>
         d.addWord("garage");                 // instantiates addWord<char const(&)[7]>
         d.addWord(std::string{"ball"});      // instantiates addWord<std::string&&>
         }

                                                                                              299


i



    i                                                                                                i
    i                                                                                                  i
                      “emcpps-internal” — 2021/1/16 — 3:34 — page 300 — #302

i



        Forwarding References                         Chapter 2     Conditionally Safe Features


        Depending on the variety of argument types supplied to addWord, having many call sites
        could result in an undesirably large number of distinct template instantiations, perhaps
        significantly increasing object code size, compilation time, or both.

        std::forward<T> can enable move operations
        Invoking std::forward<T>(x) is equivalent to conditionally invoking std::move (if T is
        an lvalue reference). Hence, any subsequent use of x is subject to the same caveats that
        would apply to an lvalue cast to an (unnamed) rvalue reference; see “rvalue References” on
        page 306:
         template <typename T>
         void f(T&& x)
         {
         g(std::forward<T>(x));     // OK
         g(x);                      // Oops! x could have already been moved from.
         }

        Once an object has been passed as an argument using std::forward, it should typically
        not be accessed again (without first assigning it a new value) because it could now be in a
        moved-from state.

        A perfect-forwarding constructor can hijack the copy constructor
        A single-parameter constructor of a class S accepting a forwarding reference can unexpect-
        edly be a better match during overload resolution compared to S’s copy constructor:
         struct S
         {
         template <typename T> S(T&&);      // forwarding constructor
         S(const S&);                       // copy constructor
         };

         void f()
         {
         S a;
         const S b;

         S x(a);    // invokes forwarding constructor
         S y(b);    // invokes copy constructor
         }

        Despite the programmer’s intention to copy from a into x, the forwarding constructor of
        S was invoked instead, because a is a non-const lvalue expression, and instantiating the
        forwarding constructor with T = S& results in a better match than even the copy constructor.
           This potential pitfall can arise in practice, for example, when writing a value-semantic
        wrapper template (e.g., Wrapper) that can be initialized by perfectly forwarding the object
        to be wrapped into it:
         template <typename T>
         class Wrapper // wrapper for an object of arbitrary type 'T'
                                                    300


i



    i                                                                                                  i
    i                                                                                               i
                   “emcpps-internal” — 2021/1/16 — 3:34 — page 301 — #303

i



        C++11                                                               Forwarding References


         {
         private:
         T d_datum;

         public:
         template <typename U>
         Wrapper(U&& datum) : d_datum(std::forward<U>(datum)) { }
         // perfect­forwarding constructor (to optimize runtime performance)

         // ...
         };

         void f()
         {
         std::string s("hello world");
         Wrapper<std::string> w0(s); // OK, s is copied into d_datum.

         Wrapper<std::string> w1(std::string("hello world"));
         // OK, the temporary string is moved into d_datum.
         }

        Similarly to the example involving class S (above), attempting to copy-construct a non-
        const instance of Wrapper (e.g., wr, above) results in an error:
         void g(Wrapper<int>& wr) // The same would happen if wr were passed by value.
         {
         Wrapper<int> w2(10); // OK, invokes perfect­forwarding constructor
         Wrapper<int> w3(wr); // error: no conversion from Wrapper<int> to int
         }

        The compilation failure above occurs because the perfect-forwarding constructor template,
        instantiated with Wrapper<int>&, is a better match than the implicitly generated copy
        constructor, which accepts a const Wrapper<int>&. Constraining the perfect forwarding
        constructor via SFINAE (e.g., with std::enable_if) to explicitly not accept objects
        whose type is Wrapper fixes this problem:
         template <typename T>
         class Wrapper
         {
         private:
         T d_datum;

         public:
         template <typename U,
         typename = typename std::enable_if<
         !std::is_same<typename std::decay<U>::type, Wrapper>::value
         >::type
         >
         Wrapper(U&& datum) : d_datum(std::forward<U>(datum)) { }
         // This constructor participates in overload resolution only if U,
         // after being decayed, is not the same as Wrapper.
                                                                                             301


i



    i                                                                                               i
    i                                                                                                                 i
                        “emcpps-internal” — 2021/1/16 — 3:34 — page 302 — #304

i



        Forwarding References                                 Chapter 2       Conditionally Safe Features


          };

          void h(Wrapper<int>& wr) // The same would happen if wr were passed by value.
          {
          Wrapper<int> w4(10); // OK, invokes the perfect­forwarding constructor
          Wrapper<int> w5(wr); // OK, invokes the copy constructor
          }

        Notice that the std::decay metafunction was used as part of the constraint; for more in-
        formation on the using std::decay, see Annoyances: Metafunctions are required in constraints
        on page 303.

        Annoyances
        Forwarding references look just like rvalue references
        Despite forwarding references and rvalue references having significantly different semantics,
        as discussed in Description: Identifying forwarding references on page 288, they share the
        same syntax. For any given type T, whether the T&& syntax designates an rvalue reference
        or a forwarding reference depends entirely on the surrounding context.55
          template <typename T> struct S0 { void f(T&&); };                  // rvalue reference
          struct S1 { template <typename T> void f(T&&); };                  // forwarding reference

        Furthermore, even if T is subject to template argument deduction, the presence of any
        qualifier will suppress the special forwarding-reference deduction rules:
          template <typename T> void f(T&&);                         // forwarding reference
          template <typename T> void g(const T&&);                   // const rvalue reference
          template <typename T> void h(volatile T&&);                // volatile rvalue reference

        It is truly remarkable that we (still) do not have some unique syntax (e.g., &&&) that we could
        use, at least optionally, to imply unequivocally a forwarding reference that is independent
        of its context.
           55 In C++20, developers might be subject to additional confusion due to the new terse concept notation

        syntax, which allows function templates to be defined without any explicit appearance of the template
        keyword. As an example, a constrained function parameter, like Addable auto&& a in the example below,
        is a forwarding reference; looking for the presence of the mandatory auto keyword is helpful in identifying
        whether a type is a forwarding reference or rvalue reference:
          template<typename T>
          concept Addable = requires(T a, T b) { a + b; };

          void f(Addable auto&& a);      // C++20 terse concept notation

          void example()
          {
          int i;

          f(i);   // OK, decltype(a) is int& in f.
          f(0);   // OK, decltype(a) is int&& in f.
          }


                                                           302


i



    i                                                                                                                 i
    i                                                                                                    i
                   “emcpps-internal” — 2021/1/16 — 3:34 — page 303 — #305

i



        C++11                                                                  Forwarding References


        Metafunctions are required in constraints
        As we showed in Use Cases on page 291, being able to perfectly forward arguments of the
        same general type and effectively leave only the value category of the argument up to type
        deduction is a frequent need. This is necessary if you do not want to delay construction
        of the arguments until they are forwarded, possibly because doing so would produce many
        unnecessary temporaries.
            The challenge to make this work correctly is significant. The template must be con-
        strained using SFINAE and the appropriate type traits to disallow types that aren’t
        some form of cv-qualified or ref-qualified version of the type that you want to accept. As
        an example, let’s consider a function intended to copy or move a Person object into a data
        structure:
         template <typename T, typename = typename std::enable_if<
         std::is_same<std::decay<T>::type, Person>::value>::type>
         void PersonManager::addPerson(T&& person);
         // This function participates in overload resolution only if T is
         // (possibly cv­ or ref­qualified) Person.

        This incantation to constrain T has a number of layers to it, so let’s unpack them one at a
        time.
          • T is the template argument we are trying to deduce. We’d like to limit it to being
            Person that is const, volatile, &, &&, or some (possibly empty) valid combination
            those.
          • std::decay<T>::type is then the application of the standard metafunction (defined
            in <type_traits>) std::decay to T. This metafunction removes all cv-qualifiers and
            ref-qualifiers from T, and so, for the types to which we want to limit T, this will always
            be Person. Note that decay will also allow some other implicitly convertible trans-
            formations, such as converting an array type to the corresponding pointer type. For
            types we are concerned with — those that decay to a Person — this metafunction is
            equivalent to std::remove_cv<std::remove_reference<T>::type>::type, or the
            equivalent and shorter std::remove_cvref<T>::type> available in C++20. Due to
            historical availability and readability, we will continue with our use of decay for this
            purpose.
          • std::is_same<std::decay<T>::type, Person>::value is then the application of
            another metafunction, std::is_same, to two arguments — our decay expression and
            Person, which results in a value that is either std::true_type or std::false_type
            — special types that can convert, in compile time, expressions to true or false. For
            the types T that we care about, this expression will be true, and for all other types
            this expression will be false.
          • std::enable_if<X>::type is yet another metafunction that evaluates to a valid type
            if and only if X is true. Unlike the value in std::is_same, this expression is simply
            not valid if X is false.
          • Finally, by using this enable_if expression as a default-initialized template argument,
            the expression is going to be instantiated for any deduced T considered during overload
                                                                                                  303


i



    i                                                                                                    i
    i                                                                                                   i
                      “emcpps-internal” — 2021/1/16 — 3:34 — page 304 — #306

i



        Forwarding References                         Chapter 2     Conditionally Safe Features


             resolution for addPerson. This instantiation (or substitution), will fail for any of the
             types we don’t want to allow (something that is not a cv). Because of this, for any
             T that isn’t one of the types for which we want to allow addPerson to be invoked,
             this substitution will fail. Rather than being an error, this just removes addPerson
             from the overload set being considered, hence the term SFINAE. In this case, that
             would give us a different error indicating that we attempted to pass a non-Person to
             addPerson, which is exactly the result we want.

        Putting this all together means we get to call addPerson with lvalues and rvalues of type
        Person, and the value category will be appropriately usable within addPerson (generally
        with use of std::forward within that function’s definition).

        See Also
          • “rvalue References” on page 306 — Conditionally safe C++11 feature which can syn-
            tactically look identical to forwarding references

          • “auto Variables” on page 217 — Conditionally safe C++11 feature that can introduce
            a forwarding reference with the auto&& syntax
          • “Variadic Templates” on page 314 — Conditionally safe C++11 feature commonly
            used in conjunction with forwarding references to provide highly generic interfaces

        Further Reading
        None so far




                                                    304


i



    i                                                                                                   i
    i                                                                                   i
                     “emcpps-internal” — 2021/1/16 — 3:34 — page 305 — #307

i



        C++11                                                                 Lambdas




        Unnamed Local Function Objects (Closures)
        placeholder text.........




                                                                                  305


i



    i                                                                                   i
    i                                                                                       i
                        “emcpps-internal” — 2021/1/16 — 3:34 — page 306 — #308

i



        rvalue References                         Chapter 2   Conditionally Safe Features



        Rvalue References: &&
        placeholder text..........




                                                306


i



    i                                                                                       i
    i                                                                                                      i
                    “emcpps-internal” — 2021/1/16 — 3:34 — page 307 — #309

i



        C++11                                                                               union '11



        Unions Having Non-Trivial Members
        Any nonreference type is permitted to be a member of a union.

        Description
        Prior to C++11, only trivial types — e.g., fundamental types, such as int and double,
        enumerated or pointer types, or a C-style array or struct (a.k.a. a POD) — were allowed
        to be members of a union. This limitation prevented any (user-defined) type having a non-
        trivial special member function from being a member of a union:
          union U0
          {
          int         d_i;     // OK
          std::string d_s;     // compile­time error in C++03 (OK as of C++11)
          };

        C++11 relaxes such restrictions on union members, such as d_s above, allowing any type
        other than a reference type to be a member of a union.
            A union type is permitted to have user-defined special member functions but — by design
        — does not initialize any of its members automatically. Any member of a union having a
        non-trivial constructor, such as struct Nt (below), must be constructed manually (e.g.,
        via placement new before it can be used:
          struct Nt // used as part of a union (below)
          {
          Nt();   // non­trivial default constructor
          ~Nt(); // non­trivial destructor

          // Copy construction and assignment are implicitly defaulted.
          // Move construction and assignment are implicitly deleted.
          };

        As an added safety measure, any non-trivial special member function defined — either
        implicitly or explicitly — for any member of a union results in the compiler implicitly deleting
        (see “Deleted Functions” on page 70) the corresponding special member function of the
        union itself:

          union U1
          {
          int d_i;    // fundamental type having all trivial special member functions
          Nt d_nt;    // user­defined type having non­trivial special member functions

          // Implicitly deleted special member functions of U1:
          /*
          U1()                     = delete; // due to explicit Nt::Nt()
          U1(const U1&)            = delete; // due to implicit Nt::Nt(const Nt&)
          ~U1()                    = delete; // due to explicit Nt::~Nt()
          U1& operator=(const U1&) = delete; // due to implicit
          // Nt::operator=(const Nt&)
                                                                                                    307


i



    i                                                                                                      i
    i                                                                                                 i
                      “emcpps-internal” — 2021/1/16 — 3:34 — page 308 — #310

i



        union '11                                     Chapter 2    Conditionally Safe Features


         */
         };

            A special member function of a union that is implicitly deleted can be restored via ex-
        plicit declaration, thereby forcing a programmer to consider how non-trivial members should
        be managed. For example, we can start providing a value constructor and corresponding
        destructor:
         #include <new>

         struct U2
         {
         union
         {
         int d_i;      // fundamental type (trivial)
         Nt   d_nt;    // non­trivial user­defined type
         };

         bool d_useInt;    // discriminator

         U2(bool useInt) : d_useInt(useInt)
         {
         if (d_useInt) { new (&d_i) int(); }       // value initialized (to 0)
         else          { new (&d_nt) Nt(); }       // default constructed in place
         }

         ~U2() // destructor
         {
         if (!d_useInt) { d_nt.~Nt(); }
         }
         };

        Notice that we have employed placement new syntax to control the lifetime of both member
        objects. Although assignment would be permitted for the trivial int type, it would be
        undefined behavior for the non-trivial Nt type:
         U2(bool useInt) : d_useInt(useInt)
         {
         if (d_useInt) { d_i = int(); } // value initialized (to 0)
         else          { d_nt = Nt(); } // BAD IDEA: undefined behavior (no
         // lhs object)
         }

        Now if we were to try to copy-construct or assign one object of type U2 to another, the
        operation would fail because we have not (yet) specifically addressed those special member
        functions:
         void f()
         {
         U2 a(false), b(true);     // OK (construct both instances of U2)
         U2 c(a);                  // compile­time error: no U2(const U2&)
                                                    308


i



    i                                                                                                 i
    i                                                                                               i
                   “emcpps-internal” — 2021/1/16 — 3:34 — page 309 — #311

i



        C++11                                                                        union '11

         a = b;                   // compile­time error: no U2& operator=(const U2&)
         }

        We can restore these implicitly deleted special member functions too, simply by adding
        appropriate copy-constructor and assignment-operator definitions for U2 explicitly:
         union U2
         {
         // ... (everything in U2 above)

         U2(const U2& original) : d_useInt(original.d_useInt)
         {
         if (d_useInt) { new (&d_i) int(original.d_i); }
         else          { new (&d_nt) Nt(original.d_nt); }
         }

         U2& operator=(const U2& rhs)
         {
         if (this == &rhs) // Prevent self­assignment.
         {
         return *this;
         }

         // Resolve all possible combinations of active types between the
         // left­hand side and right­hand side of the assignment:

         if (d_useInt)
         {
         if (rhs.d_useInt) { d_i = rhs.d_i; }
         else              { new (&d_nt) Nt(rhs.d_nt); } // int DTOR trivial
         }
         else
         {
         if (rhs.d_useInt) { d_nt.~Nt(); new (&d_i) int(rhs.d_i); }
         else              { d_nt = rhs.d_nt; }
         } d_useInt = rhs.d_useInt;

         //   Resolve all possible combinations of active types between the
         //   left­hand side and right­hand side of the assignment. Use the
         //   corresponding assignment operator when they match, otherwise
         //   if the old member is d_nt run its non­trivial destructor, then
         //   copy­construct the new member in place:

         return *this;
         }
         };

        Note that in the code example above, we ignore exceptions for exposition simplicity. Note
        also that attempting to restore a union’s implicitly deleted special member functions by
        using the = default syntax (see Section 1.1.“Defaulted Functions” on page 58) will still
                                                                                             309


i



    i                                                                                               i
    i                                                                                                           i
                         “emcpps-internal” — 2021/1/16 — 3:34 — page 310 — #312

i



        union '11                                           Chapter 2      Conditionally Safe Features


        result in their being deleted because the compiler cannot know which member of the union
        is active.

        Use Cases
        Implementing a sum type as a discriminated (or tagged) union
        A sum type is an algebraic data type that provides a choice among a fixed set of specific
        types. A C++11 unrestricted union can serve as a convenient and eﬀicient way to define
        storage for a sum type (also called a tagged or discriminated union) because the alignment
        and size calculations are performed automatically by the compiler.
            As an example, consider writing a parsing function parseInteger that, given a
        std::string input, will return, as a sum type ParseResult (see below), containing either
        an int result (on success) or an informative error message (on failure):
         ParseResult parseInteger(const std::string& input)                // Return a sum type.
         {
         int result;     // accumulate result as we go
         std::size_t i; // current character index

         // ...

         if (/* Failure case (1). */)
         {
         std::ostringstream oss;
         oss << "Found non­numerical character '" << input[i]
         << "' at index '" << i << "'.";

         return ParseResult(oss.str());
         }

         if (/* Failure case (2). */)
         {
         std::ostringstream oss;
         oss << "Accumulating '" << input[i]
         << "' at index '" << i
         << "' into the current running total '" << result
         << "' would result in integer overflow.";

         return ParseResult(oss.str());
         }

         // ...

         return ParseResult(result);           // Success!
         }

        The implementation above relies on ParseResult being able to hold a value of type either
        int or std::string. By encapsulating a C++ union and a Boolean56 discriminator as part
          56 For   sum types comprising more than two types, a larger integral or enumerated type may be used
                                                          310


i



    i                                                                                                           i
    i                                                                                                                    i
                      “emcpps-internal” — 2021/1/16 — 3:34 — page 311 — #313

i



        C++11                                                                                           union '11

        of the ParseResult sum type, we can achieve the desired semantics:
          class ParseResult
          {
          union // storage for either the result or the error
          {
          int         d_value; // result type (trivial)
          std::string d_error; // error type (non­trivial)
          };

          bool d_isError;        // discriminator

          public:
          explicit ParseResult(int value);                                  // value constructor (1)
          explicit ParseResult(const std::string& error);                   // value constructor (2)

          ParseResult(const ParseResult& rhs);                              // copy constructor
          ParseResult& operator=(const ParseResult& rhs);                   // copy assignment

          ~ParseResult();                                                   // destructor
          };

        As discussed in Description on page 307, having a non-trivial type within a union forces the
        programmer to provide each desired special member function and define it manually; note
        that the use of placement new is not required for either of the two value constructors (above)
        because the initializer syntax (below) is suﬀicient to begin the lifetime of even a non-trivial
        object:
          ParseResult::ParseResult(int value) : d_value(value), d_isError(false)
          {
          }

          ParseResult::ParseResult(const std::string& error)
          : d_error(error), d_isError(true)
          // Note that placement new was not necessary here because a new
          // std::string object will be created as part of the initialization of
          // d_error.
          {
          }

        Placement new and explicit destructor calls are, still however, required for destruction and
        both copy operations57 :
          ParseResult::~ParseResult()
          {
          if (d_isError)
          {
          d_error.std::string::~string();

        instead.
           57 For more information on initiating the lifetime of an object, see ?, section 3.8, “Object Lifetime,” pp.

        66–69.
                                                                                                                 311


i



    i                                                                                                                    i
    i                                                                                                           i
                       “emcpps-internal” — 2021/1/16 — 3:34 — page 312 — #314

i



        union '11                                          Chapter 2      Conditionally Safe Features


          // An explicit destructor call is required for d_error because its
          // destructor is non­trivial.
          }
          }

          ParseResult::ParseResult(const ParseResult& rhs) : d_isError(rhs.d_isError)
          {
          if (d_isError)
          {
          new (&d_error) std::string(rhs.d_error);
          // Placement new is necessary here to begin the lifetime of a
          // std::string object at the address of d_error.
          }
          else
          {
          d_value = rhs.d_value;
          // Placement new is not necessary here as int is a trivial type.
          }
          }

          ParseResult& ParseResult::operator=(const ParseResult& rhs)
          {
          if (this == &rhs) // Prevent selfassignment.
          {
          return *;this
          }
          // Destroy lhs's error string if existent:
          if (d_isError) { d_error.std::string::~string(); }

          // Copy rhs's object:
          if (rhs.d_isError) { new (&d_error) std::string(rhs.d_error); }
          else               { d_value = rhs.d_value; }

          d_isError = rhs.d_isError;
          return *this;
          }

        In practice, ParseResult would typically use a more general sum type58 abstraction to
        support arbitrary value types and provide proper exception safety.

        Potential Pitfalls
        Inadvertent misuse can lead to latent undefined behavior at runtime
        When implementing a type that makes use of an unrestricted union, forgetting to initialize a
        non-trivial object (using either a member initialization list or placement new) or accessing
        a different object than the one that was actually initialized can result in tacit undefined
          58 std::variant,   introduced in C++17, is the standard construct used to represent a sum type as a
        discriminated union. Prior to C++17, boost::variant was the most widely used tagged union implemen-
        tation of a sum type.
                                                        312


i



    i                                                                                                           i
    i                                                                                                 i
                      “emcpps-internal” — 2021/1/16 — 3:34 — page 313 — #315

i



        C++11                                                                          union '11

        behavior. Although forgetting to destroy an object does not necessarily result in undefined
        behavior, failing to do so for any object that manages a resource (such as dynamic memory)
        will result in a resource leak and/or lead to unintended behavior. Note that destroying an
        object having a trivial destructor is never necessary; there are, however, rare cases where
        we may choose not to destroy an object having a non-trivial one.

        Annoyances
        None so far

        See Also
          • “Deleted Functions” (Section 1.1, p. 70) ♦ Safe C++11 feature that forbids the
            invocation of a particular function. Similar effects to deleting a function happen when
            we specify a special function within a subobject of a union and when a class has such
            a union as a data member.

        Further Reading
        None so far




                                                                                               313


i



    i                                                                                                 i
    i                                                                                      i
                       “emcpps-internal” — 2021/1/16 — 3:34 — page 314 — #316

i



        Variadic Templates                       Chapter 2   Conditionally Safe Features



        Variable-Argument-Count Templates
        placeholder text.........




                                               314


i



    i                                                                                      i
    i                                                                                      i
                     “emcpps-internal” — 2021/1/16 — 3:34 — page 315 — #317

i



        C++14                                                            Generic Lambdas




        Lambdas Having a Templated Call Operator
        placeholder text.........




                                                                                    315


i



    i                                                                                      i
    i                                                            i
        “emcpps-internal” — 2021/1/16 — 3:34 — page 316 — #318

i




i



    i                                                            i
    i                                                                             i
                   “emcpps-internal” — 2021/1/16 — 3:34 — page 317 — #319

i




        Chapter 3
        Unsafe Features
        Intro text should be here.




                                                                            317


i



    i                                                                             i
    i                                                                                                       i
                      “emcpps-internal” — 2021/1/16 — 3:34 — page 318 — #320

i



        carries_dependency                                            Chapter 3      Unsafe Features




        The [[carries_dependency]] Attribute
        Lorem ipsum dolor sit amet, consectetur adipiscing elit. Proin in consectetur ante. Proin est
        risus, iaculis vitae nisl finibus, gravida scelerisque quam. Nullam urna mauris, eleifend sed
        arcu vitae, laoreet gravida elit. Maecenas varius dolor id lectus elementum, sed posuere nisi
        malesuada. Etiam ornare egestas commodo. Pellentesque sed tortor in sapien pellentesque
        luctus. Ut tempor nisl quis ex convallis scelerisque eu a lacus. Mauris quis feugiat urna.
        Cras id ante sed metus gravida laoreet quis in nisi. Sed suscipit ac massa sit amet laoreet.
        Maecenas sapien urna, tincidunt ac lectus et, ultricies aliquam lectus. Nam vel dictum ligula,
        et condimentum risus. Sed convallis ullamcorper massa sed rutrum. Donec dignissim facilisis
        vulputate. Duis sit amet facilisis odio.
            Sed volutpat magna turpis, in mollis purus scelerisque nec. Proin rhoncus magna quis
        porttitor convallis. Aliquam finibus sit amet eros in suscipit. Integer tristique faucibus plac-
        erat. Etiam finibus commodo tortor in dictum. Morbi vel eros enim. Duis pellentesque varius
        sapien, eget porttitor augue posuere nec. Nulla quis cursus quam, eu molestie turpis. Aenean
        non condimentum augue. Sed ac ornare ligula.
            Ut non tempus tellus. Aenean sit amet purus eu sapien accumsan viverra a nec tellus.
        Suspendisse tincidunt eleifend fringilla. Nulla dapibus molestie nisi, id placerat eros. Pellen-
        tesque ultrices sapien risus, vulputate dignissim purus tempor a. Phasellus blandit laoreet
        orci, at accumsan ligula. Morbi fringilla auctor suscipit. Aenean et velit a ante lobortis mollis
        eu id mauris. Sed interdum dapibus lectus et scelerisque. Duis non lacus justo. Suspendisse
        dui diam, eﬀicitur at orci non, commodo viverra felis. Sed at tempor tellus. Morbi viverra
        arcu neque, nec viverra lorem consequat ac. Vestibulum at blandit elit.
            Praesent dapibus libero ullamcorper, consectetur mi vel, hendrerit quam. Orci varius
        natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Mauris cursus
        lacinia orci sit amet rutrum. Aenean non pharetra urna. Nunc pulvinar nunc eget finibus
        porta. Sed dignissim nunc arcu, non porttitor enim euismod ac. Morbi placerat risus in
        feugiat bibendum. Curabitur in feugiat augue. Vestibulum ante ipsum primis in faucibus
        orci luctus et ultrices posuere cubilia curae; Pellentesque congue justo sed ante congue
        egestas. Nullam dolor turpis, vehicula id elit sed, iaculis pellentesque dui. Orci varius natoque
        penatibus et magnis dis parturient montes, nascetur ridiculus mus. Morbi sed est eros.
            Cras vel cursus ante, quis feugiat tortor. Quisque pulvinar vel justo et fringilla. Etiam
        euismod vel dolor nec consequat. Quisque hendrerit elit tortor, et maximus tellus vulputate
        at. Pellentesque rhoncus tempor laoreet. Mauris eget tristique nisl. Aliquam erat nibh, tin-
        cidunt sit amet arcu in, iaculis eﬀicitur felis. Nulla eget orci eget nibh vulputate sagittis a
        sit amet ex. Duis quis dictum libero, sit amet facilisis magna. Duis sed sollicitudin quam,
        eget placerat nibh. Duis a vehicula massa, vel ultricies leo.
            Phasellus et bibendum lacus. Pellentesque elementum lectus sed elit auctor, eget condi-
        mentum nisi accumsan. Integer tellus elit, pellentesque eget tincidunt vitae, varius et do-
        lor. Curabitur vel lorem mi. Maecenas sed mauris ultricies, ornare purus non, mattis felis.
        Quisque porta sapien id nibh semper finibus. Fusce pharetra nunc a cursus egestas. Aliquam
        viverra metus libero. Quisque ultrices metus non neque fringilla, sit amet ultricies sem var-
        ius. Aenean sagittis nisi non metus blandit, quis laoreet dolor vestibulum. Proin ultrices
        nulla quis vehicula porta. Maecenas ut magna vitae lacus suscipit imperdiet sed quis nulla.
                                                       318


i



    i                                                                                                       i
    i                                                                                                     i
                    “emcpps-internal” — 2021/1/16 — 3:34 — page 319 — #321

i



        C++14                                                                  carries_dependency


            Fusce tincidunt vel purus non ultrices. Donec in vulputate lorem. Vestibulum sed mauris
        ac tellus rutrum tempor. Mauris enim massa, tincidunt vel ullamcorper ac, vulputate a
        nunc. Duis accumsan magna in lorem euismod, at volutpat lorem hendrerit. Curabitur in
        mi sit amet purus viverra volutpat id eu ligula. Aliquam nec sodales nibh. Maecenas eu
        porta tellus, nec tincidunt quam. Sed fringilla nunc orci, at auctor mi feugiat sed. Integer
        rhoncus viverra maximus. Suspendisse iaculis tincidunt nibh vitae vestibulum. Mauris ut ex
        fringilla, fermentum diam vel, dapibus elit.
            Suspendisse justo enim, rhoncus sit amet lectus a, eﬀicitur egestas turpis. Donec pulvinar
        ipsum lorem. Donec aliquam sem nec enim facilisis mollis. Donec vel scelerisque nisl, eu
        euismod est. Maecenas ultrices, leo at ultricies lacinia, diam felis accumsan leo, a lobortis
        quam arcu vel lorem. Proin ut purus vitae nulla tincidunt iaculis. Pellentesque vitae nunc
        mattis, consectetur ligula vitae, pharetra nulla. Ut viverra tortor aliquet ligula accumsan
        aliquet. Duis lacus odio, euismod porttitor egestas quis, pulvinar non dui. Aliquam eget
        risus tempor, pellentesque enim vel, sodales tellus.
            Morbi ut justo metus. Vivamus fringilla nisl nec cursus fermentum. Nunc massa neque,
        aliquam ac ultrices et, pharetra nec libero. Suspendisse at elementum ligula. Nullam vehic-
        ula urna nec sapien vestibulum dapibus. Nunc lorem sapien, mollis nec velit ullamcorper,
        suscipit accumsan orci. Pellentesque molestie mauris ut elit fringilla ullamcorper. Sed in
        ligula sit amet neque consectetur blandit in nec leo. Aliquam dolor nulla, semper quis porta
        in, tincidunt id massa. Nulla molestie turpis dui, non condimentum dolor pretium tristique.
        Integer suscipit gravida urna, a varius nulla.
            Donec dapibus nulla at euismod aliquam. Suspendisse ultricies, dolor id elementum lobor-
        tis, lectus diam tristique neque, ut euismod nulla felis vitae massa. Pellentesque consequat
        nisi ut augue rutrum gravida. Aliquam in congue neque. Nulla tincidunt, quam et convallis
        varius, enim tellus iaculis nisl, et lobortis sem leo vitae eros. Quisque ac imperdiet leo, et
        vulputate nulla. Nulla vitae urna eget erat eﬀicitur porttitor vel sit amet dui. Proin pharetra
        metus ac ornare dignissim. Praesent enim orci, iaculis id lectus vel, consequat fermentum
        arcu. Duis quam metus, tristique ac ante eu, porttitor lobortis mi.




                                                                                                   319


i



    i                                                                                                     i
    i                                                                                     i
                       “emcpps-internal” — 2021/1/16 — 3:34 — page 320 — #322

i



        Deduced Return Type                                 Chapter 3   Unsafe Features



        Function (auto) return-Type Deduction
        placeholder text........




                                               320


i



    i                                                                                     i

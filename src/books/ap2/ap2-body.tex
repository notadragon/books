\section{Introduction}

Effective use of an allocator-aware software infrastructure (AASI) is largely
a matter of selecting the appropriate allocator when constructing
allocator-aware (AA) objects.  Creating AA classes, however, is another matter
and a developer must learn specific techniques, described in this paper, to
perform the task properly. Developers creating applications that necessitate
writing custom AA classes (e.g., to be used within AASI containers) will also
need to assimilate some subset of these techniques.

Making C++ software AA requires “plumbing” each class that might allocate memory to
\begin{enumerate}
\item accept an allocator on construction,
\item store the allocator internally and refrain from changing it throughout
  the lifetime of the object,
\item use the allocator to allocate and deallocate all owned memory, and
\item make the allocator available to AA subobjects (i.e., member, base-class,
  contained-element, or any other logically owned objects).
\end{enumerate}

Depending on the nature of the class, the increase in source code needed to make reusable components AA is typically between 4% and 17%.  Despite this code-size increase, the task of transformation is — for the great majority of types written by application developers — straightforward and mechanical. ,  Unfortunately, undertaking this work at Bloomberg is complicated by three factors:
\begin{enumerate}
\item Continued use of pre-C++11 compilers.
\item A mismatch between the new-style AA interface recommended in this
  paper and the current-style interface used in the vast majority of AA
  code at Bloomberg.
\item nadequate infrastructure support, especially for the new-style interface.
\end{enumerate}

The process described in this paper is, therefore, even more difficult than
it otherwise would be; the paper presents the current state with the expectation
that future revisions thereof will be simpler and more concise as these factors
are resolved.

Through a series of examples, this paper shows the reader how to transform
a C++ class (or class template) into an AA class using the BDE model. The
paper begins by introducing the interface and other requirements for a type
to be AA and then moves on to specific, highly structured categories of AA
types:
\begin{description}
\item{Simple structs with AA members}: demonstration of how to add the necessary
  member types, traits, and constructors so that an (optionally specified)
  allocator can be passed to all AA data members.
\item{Attribute classes}: demonstration of how to identify missing constructors
  and add an optional allocator parameter to each existing constructor.
\item{Classes that allocate memory}: demonstration of how to use the allocator
  directly in the constructors, destructor, assignment operators, and swap
  function.
\item{Class templates}: demonstration of how to work with a type that is
  dependent on a template parameter, where that type might or might not be AA.
\item{Containers}: demonstration of how to extend allocator awareness beyond
  the constructors to include insertion and removal of (possibly AA) elements.
\end{description}

Next, the paper addresses special considerations involving move and swap
operations. It then finishes by describing testing techniques specific to
AA components.

Adding allocator support to special classes such as std::optional,
std::variant, or smart pointers (e.g., std::shared_ptr) is beyond the scope of
this paper. Such classes use allocators in unique ways and require techniques
that do not generalize to most other classes. The author of such an advanced
component is advised to look at the implementation of BDE equivalents, e.g.,
bslstl_optional,  bdlb_variant, or bslstl_sharedptr. This paper, however,
provides sufficient information to render most common components consistently
and interoperably with the BDE AASI.

\section{The Allocator-Aware Interface}
An allocator-aware class is supplied an allocator on construction, either as a
constructor argument or using the current default allocator. This allocator is
used to allocate all memory owned by the object, including memory owned by
subobjects. Once constructed, an object’s allocator does not change for the
remainder of its lifetime.  This section describes the interface features
common to all allocator-aware types consistent with the BDE infrastructure.
Subsequent sections describe how to transform a class that is not AA into an
AA class by adding and implementing these interface features.

The interface features described in this section comprise a concept, i.e., a
set of supported operations on a type, including syntax and semantics, that
can be used in a generic programming context. Even if a type uses an allocator,
if it does not fully model the AA concept, it cannot be used in AA containers
or processed by AA utilities. For example, if a specific constructor does not
have a variant that takes an allocator parameter, then that constructor cannot
be used to emplace an object into a container because the container would not
be able supply its allocator to the element. Similarly, if an object’s
allocator is allowed to change during the object’s lifetime, it would violate
the container’s invariant that all of its elements use the same allocator and
could result in a mismatch between the container’s lifetime and the lifetime
of one or more of its elements.

This paper adheres to a new AA interface style based on the C++17 standard.
To achieve compliance with this style, an AA class, SomeClass, must have the
following features:
\begin{itemize}
\item The type, SomeClass::allocator_type, is a specialization of
  bsl::allocator (often bsl::allocator<char>).
\item Both of the following type traits evaluate true:
  \begin{itemize}
  \item bsl::uses_allocator<SomeClass, bsl::allocator<char>>::value
  \item bslma::UsesBslmaAllocator<SomeClass>::value
  \end{itemize}
\end{itemize}

The former trait evaluates to true if allocator_type exists and is convertible to bsl::allocator<char>; the latter trait must be defined explicitly. 
•	Every constructor has a variant that can be invoked with an allocator to be used by the constructed object.  If an allocator is not specified, a default-constructed allocator is used.
•	All memory belonging to the object or one of its logically owned subobjects is obtained from its allocator. A logically owned subobject is part of the object’s state and is tied to the object’s lifetime; it is not a temporary variable that exists only for the duration of a single member function invocation.  The well-known smart pointers shared_ptr, unique_ptr, and (at Bloomberg) bslma::ManagedPtr can use allocators but follow a different set of rules and do not conform to the AA interface. An object that a smart pointer points to is owned by the pointer but is not a subobject of the pointer.
•	An object’s allocator does not change over the course of its lifetime.
•	The get_allocator() member function returns the allocator used to construct the object.
Most of the components in the BDE library use an older interface style that is no longer recommended. Both styles are compatible with the BDE infrastructure (e.g., container classes can work with AA elements using either style). The two styles render the features listed above differently: 
•	The old-style interface has no allocator_type member.
•	Instead of a bsl::allocator object, an allocator in the old style is represented by a raw pointer to bslma::Allocator.
•	A class for which the bslma::UsesBslmaAllocator and bsl::uses_allocator traits both evaluate to true conforms to the new interface whereas a class for which only bslma::UsesBslmaAllocator is true conforms to the old.
•	Instead of a get_allocator() member function that returns allocator_type, a class using the older interface has an allocator() member function that returns bslma::Allocator*.
The newer style is simpler to use and prevents coding errors that are common when using raw pointers.  The newer interface is also closer to the C++ Standard’s pmr  interface — bsl::allocator is nearly identical to std::pmr::polymorphic_allocator and bslma::Allocator is nearly identical to std::pmr::memory_resource.   The new style is backward-compatible with the old one because bslma::Allocator* is convertible to bsl::allocator<char> (just as std::pmr::memory_resource* is convertible to std::pmr::polymorphic_allocator<>) and the contained bslma::Allocator* can be retrieved using the mechanism method of bsl::allocator should it be required for interoperability with old-style components.
Types that are adapted from the C++ Standard library conform to the new style, but the old style is still the norm in the rest of the Bloomberg codebase; to apply the recipes described in this paper, anyone developing AA software at Bloomberg should have at least a passing familiarity with the old style. Because this paper is primarily concerned with developing new software, it focuses on the new style interface, touching on the old style only in situations where the two come in contact.
The example below shows a minimal class interface using both styles, with the differences highlighted in bold typeface. Move operations were omitted for brevity. Note that the bsl::uses_allocator trait automatically evaluates to the correct value for both interfaces (false for the old style and true for the new style).
Old-style AA interface	New-style AA interface
class MyAAClass {
  public:



    BSLMF_NESTED_TRAIT_DECLARATION(
          MyAAClass,
          bslma::UsesBslmaAllocator);

    MyAAClass();
    explicit
      MyAAClass(bslma::Allocator *);
    MyAAClass(const MyAAClass&,
             bslma::Allocator * = 0);

    bslma::Allocator
        *allocator() const;
};	class MyAAClass {
  public:
    using allocator_type =
                  bsl::allocator<char>;

    BSLMF_NESTED_TRAIT_DECLARATION(
          MyAAClass,
          bslma::UsesBslmaAllocator);

    MyAAClass();
    explicit
      MyAAClass(const allocator_type&);
    MyAAClass(const MyAAClass&,
           const allocator_type& = {});

    allocator_type
        get_allocator() const;
};

MAKING A SIMPLE STRUCT AA
If a struct contains one or more AA data members, the challenge we take on is to pass an allocator to those members when an instance of the struct is created. The currently supported way to add allocator awareness to a struct is to augment it with all of the member types, traits, and constructors needed to give it an AA interface and AA semantics. In the C++ Standard, a simple struct without user-defined constructors belongs to a category of types known as aggregates and is compatible with member-by-member aggregate initialization.  After the transformation described here, the result will, unfortunately, no longer be an aggregate.  Many of the steps needed to transform a simple struct into an AA class apply (sometimes with small variations) to more complex categories of types.
For the next few examples, assume the existence of a type, DataManager, that is AA using the old-style interface. Using the following struct Thing as a starting point, we’ll walk, one step at a time, through its transformation into an AA type:
namespace BloombergLP {
namespace xyzabc {
struct Thing {
    bsl::string d_name;
    DataManager d_data;
    int         d_score;
    int         d_rank;
};
} // close package namespace
} // close enterprise namespace
Our first step is to add the allocator_type member type alias: 
struct Thing {
    // PUBLIC TYPES
    using allocator_type = bsl::allocator<char>;
    //...
To facilitate passing an allocator to the two AA data members (d_name and d_data), we will need to add constructors that take allocator arguments. An allocator-extended constructor is a constructor overload that takes an allocator argument in addition to the usual arguments, typically as an extra argument at the end of the argument list. At a minimum, a default constructor, an allocator-extended version of the default constructor, and an allocator-extended copy constructor are required. It is also typically wise to add an allocator-extended move constructor because classes that allocate memory (e.g., bsl::string and DataManager) usually have efficient move semantics.
The allocator-extended default constructor takes a single argument of type const allocator_type&. To prevent the one-argument constructor from enabling implicit conversion from allocator_type to Thing, we must add the explicit keyword, as well. This example includes a comment that models (in bold) the typical allocator-related language for a constructor contract.  For brevity, contract comments are omitted in subsequent examples.
    // CREATORS
    Thing();
    explicit Thing(const allocator_type& allocator);
        // Create a 'Thing' object having value-initialized (default)
        // values for all attributes.  Optionally specify an 'allocator'
        // (e.g., the address of a 'bslma::Allocator' object) to supply
        // memory; otherwise the default allocator is used.
It would be tempting to combine these two into a single constructor that takes a default allocator argument:
    // BAD IDEA
    explicit Thing(const allocator_type& allocator = {});
This approach, however, causes problems when using C++11 uniform initialization because the combined constructor, being explicit, cannot participate in several desirable patterns:
Thing t = {}; // Won’t compile
extern void f(Thing);
f({});        // Won’t compile
The allocator-extended copy and move constructors have the same parameters as regular copy and move constructors but with an additional allocator parameter:
    Thing(const Thing& original, const allocator_type& allocator);
    Thing(Thing&& original,      const allocator_type& allocator);
The “Rule of Five”  operations (destructor, regular copy constructor, regular move constructor, copy-assignment operator, and move-assignment operator) — none of which take an allocator argument — are automatically generated correctly by the compiler and don’t need to be declared. Note that, unlike the (compiler-generated) move constructor, the extended move constructor cannot be noexcept because it will sometimes require memory allocation, as described later in the section, Implementing a Class That Allocates Memory. 
Within this paper, C++11 syntax is generally assumed, e.g., for declaring rvalue references. Code that must be compatible with C++03 can emulate rvalue references and move operations using the bslmf::MovableRef facility. Though desirable for most for AA types, adding a regular move constructor and move-assignment operator in C++03 complicates the scenario for C++11 because automatic generation of the copy operations is suppressed. Appendix A details how to add move operations to an AA class such that they work correctly for both C++03 and C++11.
Although it is not required, we might want to add a constructor with one argument for each data member, along with an optional allocator argument:
    Thing(const bsl::string_view& name,
          const DataManager&      data,
          int                     score,
          int                     rank,
          const allocator_type&   allocator = {});
The above constructor allows a Thing to be constructed using (brace-style) list initialization,  which looks just like aggregate initialization and thus regains an important feature lost when we changed Thing to no longer be an aggregate:
// Construct a 'Thing' using a default allocator (C++11 and later).
Thing theThing = { "hello", DataManager(), 2, 5 };
The implementations of the allocator-extended constructors simply pass the allocator to the constructors for each of the AA members of the struct in the member initializer list. For members having the old-style AA interface, the bslma::Allocator* resource must be extracted from the bsl::allocator object by means of the mechanism method:
// Regular default ctor
Thing::Thing()
  : d_name(), d_data(), d_score(), d_rank()
{
}

// Allocator-extended default ctor
Thing::Thing(const allocator_type& allocator)
  : d_name(allocator)
  , d_data(allocator.mechanism()) // Old AA interface style
  , d_score()
  , d_rank()
{
}

// Allocator-extended copy ctor
Thing::Thing(const Thing& original, const allocator_type& allocator)
  : d_name(original.d_name, allocator)
  , d_data(original.d_data, allocator.mechanism())
  , d_score(original.d_score)
  , d_rank(original.d_rank)
{
}

// Allocator-extended move ctor. MAY THROW.
Thing::Thing(Thing&& original, const allocator_type& allocator)
  : d_name(std::move(original.d_name), allocator)
  , d_data(std::move(original.d_data), allocator.mechanism())
  , d_score(original.d_score)
  , d_rank(original.d_rank)
{
}

Thing::Thing(const bsl::string&    name,
             const DataManager&    data,
             int                   score,
             int                   rank,
             const allocator_type& allocator)
  : d_name(name, allocator)
  , d_data(data, allocator.mechanism())
  , d_score(score)
  , d_rank(rank)
{
}
Next, we declare and implement the get_allocator() method:
    allocator_type get_allocator() const;
The allocator can be retrieved from any of the AA data members. Thus
Thing::allocator_type Thing::get_allocator() const
    { return d_name.get_allocator(); }
is equivalent to
Thing::allocator_type Thing::get_allocator() const
    { return d_data.allocator(); }
Note that d_data.allocator() returns a bslma::Allocator* that is then implicitly converted to bsl::allocator<char>.
Finally, we use the BSLMF_NESTED_TRAIT_DECLARATION macro to declare that the bslma::UsesBslmaAllocator trait is true for our AA type.
struct Thing {
    ...
    // TRAITS
    BSLMF_NESTED_TRAIT_DECLARATION(Thing, bslma::UsesBslmaAllocator);
An alternative way to define the bslma::UsesBslmaAllocator trait is to specialize it outside of the class, in the BloombergLP::bslma namespace (not in Thing’s namespace):
namespace BloombergLP {
namespace bslma {
template<> struct UsesBslmaAllocator<xyzabc::Thing> : bsl::true_type {};
} // close bslma namespace
} // close enterprise namespace
Both styles are acceptable; some developers prefer the external trait style because it removes implementation details, clutter, and mysterious macro invocations from the public class interface, while others find the nested macro to be less cumbersome, especially for templates. The bsl::uses_allocator trait does not need to be specialized because bsl::uses_allocator<Thing, bsl::allocator<char>> will automatically evaluate to true due to the presence of allocator_type within the class.
Our complete class interface now looks like this:
namespace BloombergLP {
namespace xyzabc {
struct Thing {
    // PUBLIC TYPES
    using allocator_type = bsl::allocator<char>;

    // TRAITS
    BSLMF_NESTED_TRAIT_DECLARATION(Thing, bslma::UsesBslmaAllocator);

    // PUBLIC DATA MEMBERS
    bsl::string d_name;
    DataManager d_data;
    int         d_score;
    int         d_rank;

    // CREATORS
    Thing();
    explicit Thing(const allocator_type& allocator);
    // Compiler generates regular (nonextended) copy and move constructors
    Thing(const Thing& original, const allocator_type& allocator);
    Thing(Thing&& original,      const allocator_type& allocator);

    // ACCESSORS
    allocator_type get_allocator() const;
};
} // close package namespace
} // close enterprise namespace
This simplest category of would-be AA types suffers the most relative increase in size and complexity when transforming to AA.  The size and complexity of this interface comes from two sources:
1)	Making the class AA added a type alias, four constructors, an accessor (getter), and a trait definition.
2)	Providing maximal C++03 compatibility (see Appendix A) would add an additional constructor and both assignment operators. C++03 compatibility also substantially complicates the implementation of the move operations in ways unrelated to allocators.
Subsequent sections will illustrate how the percentage increase in code size becomes progressively smaller as the complexity of the starting point increases.
MAKING AN ATTRIBUTE CLASS AA
An attribute class is similar to a simple struct, but its data members are private and protected by invariant-preserving public manipulators and accessors. As before, if any of the data members are AA, the attribute class should also be AA. Relative to the simple struct, a new challenge is that existing constructors may need to be adapted.
Let’s start with a non-AA attribute-class variant of our Thing example:
namespace BloombergLP {
namespace xyzabc {
class Thing {
    bsl::string d_name;
    DataManager d_data;
    int         d_score;
    int         d_rank;
  public:
    // CREATORS
    Thing();
    explicit Thing(bool dataMode);
    Thing(bsl::string_view   name,
          const DataManager& data,
          int                score = 0,
          int                rank  = 5);
    ~Thing();

    // MANIPULATORS
    setName(bsl::string_view name);
    setScore(int score);
    ...
};
} // close package namespace
} // close enterprise namespace
Defining the allocator_type and get_allocator() members is achieved exactly as it was for the simple struct, as is adding the UsesBslmaAllocator trait. The Rule of Five operations are compiler-generated, but we must declare extended copy and move constructors just as we did for the simple struct example, with identical implementations. 
Unlike a simple struct, our Thing attribute class has existing constructors that we must extend with an allocator. We add a default allocator to the constructor taking a bool parameter like this:
    explicit Thing(bool dataMode, const allocator_type& allocator = {});
The four-argument constructor in our Thing class is a bit trickier than the preceding one. Just adding an allocator to the end of the argument list does not suffice:
    // BAD IDEA. Partial solution at best
    Thing(bsl::string_view      name,
          const DataManager&    data,
          int                   score = 0,
          int                   rank  = 5,
          const allocator_type& allocator = {});
The problem is that, although we can specify a score, rank, and allocator, we cannot specify just a score and an allocator. As was stated in the section titled, “The Allocator-Aware Interface,” every constructor argument list be usable with an allocator argument.  Typically, the way we fix this problem is to create an allocator-parameter overload for the case of no optional arguments, one optional argument, and two optional arguments, as follows:
    Thing(bsl::string_view      name,
          const DataManager&    data,
          const allocator_type& allocator = {});
    Thing(bsl::string_view      name,
          const DataManager&    data,
          int                   score,
          const allocator_type& allocator = {});
    Thing(bsl::string_view      name,
          const DataManager&    data,
          int                   score,
          int                   rank,
          const allocator_type& allocator = {});
A second option is to use the leading-allocator convention, a standard (since C++11) alternative for specifying the allocator whereby the allocator parameter appears at the start of a parameter list, preceded by the special marker type bsl::allocator_arg_t. Using this convention, we need only two overloads for the preceding constructor:
    Thing(bsl::string_view      name,
          const DataManager&    data,
          int                   score = 0,
          int                   rank  = 5);
    Thing(bsl::allocator_arg_t,
          const allocator_type& allocator,
          bsl::string_view      name,
          const DataManager&    data,
          int                   score = 0,
          int                   rank  = 5);
The second constructor is invoked by specifying bsl::allocator_arg as the first argument and an allocator as the second argument:
Thing myThing(bsl::allocator_arg, myAlloc, "Fred", myData, myScore);
If the constructor is a template with a C++11 variadic parameter list (i.e., a parameter list where the last deduced argument contains an ellipsis), the leading-allocator convention is the only way to add an allocator argument.  If there are no variadic constructors, then it is a matter of practicality whether to have multiple overloads or to switch to the leading-allocator convention; if the issue arises for only one or two constructors, with only one or two default arguments each, most people prefer to keep the trailing-allocator convention with a trailing defaulted allocator argument. Because the (C++03 compatible) BDE infrastructure does not have a way to detect which of the two allocator-passing conventions is used for a specific constructor, a class using the leading-allocator convention must define the trait bslmf::UsesAllocatorArgT to be true. Note that this trait is defined on a per-class basis; all constructors (including the extended copy and move constructors) must use the same allocator-passing convention.
IMPLEMENTING A CLASS THAT ALLOCATES MEMORY
Up until now, all memory allocation and deallocation has been managed by the member variables of our class. If a class needs to allocate memory directly, we need to understand additional, not necessarily intuitive, rules and apply them in the destructor, assignment operators, and swap.
Let’s assume that DataManager is a large type and is unused much of the time in our Thing objects. Allocating space for the DataManager (from the allocator) on an as-needed basis is more sensible than having the DataManager object as an always-present data member. For illustrative purposes, the Thing class below uses a raw pointer to hold the address of allocated memory, as though Thing were a low-level data-management component. For classes that directly manage memory, whether they use allocators or not, the Rule of Five members must be defined by the user and must not be compiler–generated as they were in the prior examples. We save ourselves a little work by using a default allocator argument to combine the regular copy constructor and the extended copy constructor into one:
class Thing {
    // DATA
    bsl::string  d_name;
    DataManager *d_data_p;
    int          d_score;
    int          d_rank;
    // ...
  public:
    // TYPES
    using allocator_type = bsl::allocator<char>;

    // TRAITS
    BSLMF_NESTED_TRAIT_DECLARATION(Thing, bslma::UsesBslmaAllocator);

    // CREATORS
    Thing() noexcept;
    explicit Thing(const allocator_type& allocator) noexcept;
    explicit Thing(bool                  dataMode,
                   const allocator_type& allocator = {});
    Thing(const Thing& original, const allocator_type& allocator = {});
    Thing(Thing&& original) noexcept;
    Thing(Thing&& original, const allocator_type& allocator);
    ~Thing();

    // MANIPULATORS
    Thing& operator=(const Thing& rhs);
    Thing& operator=(Thing&& rhs);

    void swap(Thing& other);
    // ...
    // ACCESSORS
    // ...
    allocator_type get_allocator() const{ return d_name.get_allocator(); }
};
The get_allocator method returns the allocator held by the string member. If we did not already have an AA member, we would need to store the allocator separately in a new member of type allocator_type.
All memory allocation and deallocation of owned subobjects should go through the allocator. Using the bslma::Allocator overload of operator new is currently the simplest way to allocate and initialize a single object. This version of operator new takes a reference (not a pointer ) to a bslma::Allocator object and allocates memory from that allocator, as shown in the dataMode and extended copy constructors below:
Thing::Thing(bool dataMode, const allocator_type& allocator)
  : d_name(allocator), d_data_p(nullptr), d_score(0), d_rank(5)
{
    if (dataMode) {
        d_data_p = new(*allocator.mechanism())
                                       DataManager(allocator.mechanism());
    }
}

Thing::Thing(const Thing& original, const allocator_type& allocator)
  : d_name(original.name(), allocator)
  , d_data_p(nullptr)
  , d_score(original.d_score)
  , d_rank(original.d_rank)
{
    if (original.d_data_p) {
        d_data_p = new(*allocator.mechanism())
                   DataManager(*original.d_data_p, allocator.mechanism());
    }
}
Note that these constructors pass the allocator not only to operator new for allocation, but also to the DataManager constructor for use within the allocated object; since DataManager is an old-style AA type, we must pass the allocator as a pointer to bslma::Allocator (hence the call to allocator.mechanism()).
We destroy an object and release its footprint memory back to the allocator by calling bslma::Allocator::deleteObject: 
Thing::~Thing()
{
    get_allocator().mechanism()->deleteObject(d_data_p);
}
As with any class that allocates memory, the copy-assignment operator must take care not to overwrite the d_data_p pointer before deallocating the memory it points to and also not to leave the assigned-to object in an invalid state if an exception is thrown:
Thing& operator=(const Thing& rhs)
{
    if (this == &rhs) {
       return *this;
    }

    // Copy name from rhs using correct allocator
    bsl::string rhsName(rhs.d_name, get_allocator());

    if (!rhs.d_data_p) {
        get_allocator().mechanism()->deleteObject(d_data_p);
        d_data_p = nullptr;
    }
    else if (d_data_p) {
        *d_data_p = *rhs.d_data_p;
    }
    else {
        d_data_p = new(*get_allocator().mechanism())
                  DataManager(*rhs.d_data_p, get_allocator().mechanism());
        return *this;
    }
    
    // The following operations are guaranteed not to throw
    d_name.swap(rhsName);
    d_score = rhs.d_score;
    d_rank  = rhs.d_rank;
    return *this;
}
Move operations (move construction, move assignment, and swap) require special consideration. Ideally, a move operation on an allocating type requires moving only the pointers to allocated memory, without copying the contents of allocated memory. Let’s encapsulate this ideal in a private fastMove member function that will be used to implement the public move operations:
class Thing {
    // ...
    // PRIVATE MANIPULATORS
    void fastMove(Thing& other) noexcept;
        // Move the specified 'other' Thing into '*this'.
        // The behavior is undefined unless 'other' and '*this'
        // have the same allocator.
    //...
};

void
Thing::fastMove(Thing& other) noexcept
{
    BSLS_ASSERT_SAFE(get_allocator() == other.get_allocator());

    get_allocator().mechanism()->deleteObject(d_data_p);

    d_name   = std::move(other.d_name);
    d_data_p = other.d_data_p;  // Pointer move
    d_score  = other.d_score;
    d_rank   = other.d_rank;

    other.d_data_p = nullptr;  // Clear duplicate pointer to data
}
When the caller does not explicitly provide an allocator, the (nonextended) move constructor should use the moved-from object’s allocator for the newly constructed object. This behavior is unlike that of all other constructors, which use the default allocator when the caller does not provide one.  Thus, while the allocator-extended version of most constructors can be expressed using an optional allocator argument, as we did for the copy constructor, a defaulted argument would produce the incorrect result for the move constructor:
    // BAD IDEA
    Thing(Thing&& original, const allocator_type& allocator = {});
Another important difference between the regular (nonextended) move constructor and the extended move constructor is that the former is usually declared noexcept, whereas the latter might allocate memory so it’s not necessarily noexcept.
The nonextended move constructor can simply invoke the extended default-constructor, then delegate to fastMove:
Thing::Thing(Thing&& original) noexcept
  : Thing(original.get_allocator())   // C++11 delegating constructor
//: d_name(original.get_allocator()), d_data_p(nullptr) // C++03 version
{
    fastMove(original);
}
The extended move constructor can be invoked with an allocator different than that of the moved-from object. In that case, moving the pointer is problematic because the moved-to object’s destructor will attempt to deallocate the memory from the wrong allocator. The correct behavior, therefore, is performing a fast move only when the allocators are the same and falling back to a copy if they are not :
Thing::Thing(Thing&& original, const allocator_type& allocator)
  : Thing(original.get_allocator())
{
    // '*this' is in a valid (empty) state
    if (allocator == original.get_allocator()) {
        fastMove(original);
    }
    else {
        operator=(original);  // Copy assignment
    }
}
The same issue affects the move-assignment operator. The allocator used by the moved-to object does not change during move assignment and may differ from the allocator used by the moved-from object. As in the case of the extended move constructor, we must test for the same allocator and move or copy as appropriate:
Thing& Thing::operator=(Thing&& rhs)
{
    if (get_allocator() == rhs.get_allocator()) {
        if (this != &rhs) {
            fastMove(rhs);
        }
    }
    else {
        operator=(rhs);  // Copy assignment
    }
    return *this;
}
The third move operation is swap. Following a BDE rule, an AA class should provide a public member function swap that never throws an exception and may provide an ADL-discoverable free function swap that might throw:
class Thing {
    // ...
  public:
    // ...
    void swap(Thing& other) noexcept;
    // ...
};

void swap(Thing& a, Thing& b);
If a and b use the same allocator, then either swap operation is performed in constant time (no allocations or deallocations) and never throws an exception. Swapping the allocators for the purpose of guaranteeing the O(1), nonthrowing behavior may be tempting, but allowing the allocator to change during an object’s lifetime violates important invariants, especially within containers.  For implementing swap when the objects being swapped have different allocators, we have three options, each of which is slower and uses more temporary memory than the one before:
1)	Require allocator equality as a precondition (typically verified with an assertion). With this implementation, swap can be declared noexcept, and can execute in constant time. 
2)	Perform the traditional three-move swap, where two of the moves will degenerate to copies that allocate memory and might throw. This option is the equivalent of a fully-qualified call to std::swap.
3)	Provide the strong exception guarantee, whereby each object is carefully copied using the other object’s allocator before attempting any moves.
All three options are reasonable choices, but the BDE rule that the member swap must not throw limits its implementation to option 1. By using the regular move constructor and fastMove, we need not concern ourselves with the allocator at all, except (optionally) to assert that they are equal:
void Thing::swap(Thing& other) noexcept {
    BSLS_ASSERT_SAFE(this->get_allocator() == other.get_allocator());

    // All three of the following calls are 'noexcept'.
    Thing temp1(std::move(*this));
    this->fastMove(other);
    other.fastMove(temp1);
}
For the swap free function, all three options are possible, but we’ll implement the third one for illustrative purposes. The strong exception guarantee means that, if the swap fails, the original objects are left unchanged:
void swap(Thing& a, Thing& b)
{
    // Creation of temporaries might allocate and copy, which might throw.
    Thing temp1(std::move(a), b.get_allocator()); 
    Thing temp2(std::move(b), a.get_allocator());

    a.swap(temp2); // No allocation, copy, or throw
    b.swap(temp1); // No allocation, copy, or throw
}
Note that if the objects being swapped have the same allocator, which is always the case when the objects are elements of the same container, then the swap itself requires no allocations and will not throw an exception, regardless of whether we call member swap or free swap. We can use this fact to simplify the move assignment operator and retain the strong guarantee:
Thing& Thing::operator=(Thing&& rhs)
{
    Thing(std::move(rhs), get_allocator()).swap(*this);
    return *this;
}
In this rewritten move-assignment operator, the swap method is invoked only if the extended move constructor succeeds without throwing an exception. The constructed temporary object has the same allocator as *this, so the subsequent swap is guaranteed to succeed in constant time. If the extended move constructor fails, then *this is not modified.
IMPLEMENTING AN AA CLASS TEMPLATE
Before a class template is instantiated, whether a type that relies on a template parameter (known in the C++ Standard as a dependent type) is or is not AA is unknown. One challenge resulting from this uncertainty is that objects of dependent type must be constructed in such a way that an allocator is passed to the constructor if and only if the dependent type is AA. An instantiation of a class template might not be AA unless at least one dependent type is AA, posing the additional challenge of writing an adaptable interface.
For this example, we’ll begin with our Thing attribute class, modified such that, instead of a DataManager member, it holds an object of a type specified by the user as a template parameter:
namespace BloombergLP {
namespace xyzabc {
template <class TYPE>
class Thing {
    // DATA
    bsl::string d_name;
    TYPE        d_data;
    int         d_score;
    int         d_rank;

  public:
    // TYPES
    using allocator_type = bsl::allocator<char>;

    // TRAITS
    BSLMF_NESTED_TRAIT_DECLARATION(Thing, bslma::UsesBslmaAllocator);

    // CREATORS
    Thing();
    explicit Thing(const allocator_type& allocator);
    Thing(bsl::string_view      name,
          const TYPE&           data,
          const allocator_type& allocator = {});
    ...
Our Thing class template is already AA, so the type aliases, traits, and constructor prototypes need not change. The problem comes in the implementation of the constructors. Let’s look at one example:
template <class TYPE>
Thing::Thing(bsl::string_view      name,
             const TYPE&           data,
             const allocator_type& allocator)
  : d_name(name, allocator)
  , d_data(data, ?allocator?)
  , d_score(0)
  , d_rank(5)
{
}
If TYPE is not AA, then the initializer for d_data should be simply d_data(data), but if TYPE is AA, then the initializer should be d_data(data, allocator).  No method exists for writing an initializer that is correct for both cases.
We solve the problem by using the wrapper class bslalg::ConstructorProxy<TYPE>, which offers a unified interface over whatever constructor convention TYPE uses (no allocator, trailing allocator, or leading allocator):
template <class TYPE>
class Thing {
    bsl::string                    d_name;
    bslalg::ConstructorProxy<TYPE> d_dataProxy;
    int                            d_score;
    int                            d_rank;
In all cases ConstructorProxy is passed a bslma::Allocator* using the trailing-allocator convention.  The allocator is either ignored (for non-AA types) or is correctly passed to the object’s constructor (for AA types). Thus, the initializer for d_dataProxy unconditionally becomes d_dataProxy(data, allocator.mechanism()).
Throughout Thing’s implementation, we replace all uses of d_data with d_dataProxy.object():
template <class TYPE>
TYPE& Thing<TYPE>::data() { return d_dataProxy.object(); }
The Thing template described so far is always AA because it contains a bsl::string, which is known to be AA. If we were to remove the string, then the situation would be very different:
template <class TYPE>
class Thing {
    bsl::string                    d_name;
    bslalg::ConstructorProxy<TYPE> d_dataProxy;
    int                            d_score;
    int                            d_rank;
    // ...
If TYPE is AA, then Thing<TYPE> should be AA; otherwise, Thing<TYPE> need not be AA. The easiest way to handle this situation is to artificially make Thing AA in all circumstances, by adding an allocator member:
template <class TYPE>
class Thing {
    bsl::allocator<char>           d_allocator;
    bslalg::ConstructorProxy<TYPE> d_dataProxy;
    int                            d_score;
    int                            d_rank;
    // ...
The allocator, though unused when TYPE is not AA, takes up space in the object footprint, but that is often an acceptable cost to pay for the simplicity of this approach.
If the extra pointer-sized space consumption is an issue or if a pure AA or non-AA interface is important, then some refactoring and metaprogramming will be required. We begin by declaring our Thing template with an extra Boolean parameter that defaults to true if TYPE is AA and false otherwise: 
template <class TYPE, bool USES_ALLOC =
                      BloombergLP::bslma::UsesBslmaAllocator<TYPE>::value>
class Thing;
The partial specialization where USES_ALLOC is true supplies the entire AA interface:
template <class TYPE>
class Thing<TYPE, true> {
    bslalg::ConstructorProxy<TYPE> d_dataProxy;
    int                            d_score;
    int                            d_rank;

  public:
    // PUBLIC TYPES
    using allocator_type = bsl::allocator<char>;

    // TRAITS
    BSLMF_NESTED_TRAIT_DECLARATION(Thing, bslma::UsesBslmaAllocator);

    // CREATORS
    Thing();
    explicit Thing(const allocator_type& allocator);
    explicit Thing(const TYPE& data,
                   const allocator_type& allocator = {});
    // ..
    const TYPE& data() const;
    allocator_type get_allocator() const;
};
Although the TYPE is known to be AA, we still use bslalg::ConstructorProxy because it automatically handles the leading-allocator vs. trailing-allocator convention for us. By supplying an explicit true value for USES_ALLOCATOR, this partial specialization can also be instantiated for non-AA types and we will shortly exploit this feature.
The Thing constructors pass an allocator to d_dataProxy:
template <class TYPE>
Thing<TYPE, true>::Thing(const TYPE&           data,
                         const allocator_type& allocator)
  : d_dataProxy(data, allocator.mechanism())
  , d_score(0)
  , d_rank(5)
{
}
The Thing::get_allocator method retrieves the allocator from the d_dataProxy member :
template <class TYPE>
allocator_type Thing<TYPE, true>::get_allocator() const
{
    return d_dataProxy.object().get_allocator();
}
We create the partial specialization where USES_ALLOC is false to contain a member variable of the other (AA) specialization, forwarding most types, constructors, and member function implementations, but leaving out allocator_type, get_allocator, the bslma::UsesBslmaAllocator trait, and allocator function parameters :
template <class TYPE>
class Thing<TYPE, false> {
    // DATA
    Thing<TYPE, true> d_imp;

  public:
    // CREATORS
    Thing() : d_imp() { }
    explicit Thing(const TYPE& data) : d_imp(data) { }
    ...
    const TYPE& data() const { return d_imp.data(); }
};
This layering of the non-AA specialization on top of the AA specialization works because the (default-constructed) allocator in the AA implementation is ignored by bslalg::ConstructorProxy. The get_allocator() method is never instantiated for non-AA TYPEs, so no compilation errors result from its use of TYPE::get_allocator. 
Unfortunately, duplicate declarations of each member function are present in both specialized versions of our class template, so any interface maintenance must be done in both places. Implementation changes, however, affect only the AA specialization, mitigating the maintenance issue caused by this duplication.
IMPLEMENTING AN AA CONTAINER
The archetypal AA type is a container class (or container class template). The new challenge when implementing a container is insertion and removal of elements (each of which might be AA) outside of the constructors and destructor, especially in the presence of exceptions.
Let’s implement MyList, a simple doubly-linked list AA container template. Our simplified template declaration looks as follows:
template <class TYPE>
struct MyList_Node;

template <class TYPE>
class MyList {
    bsl::allocator<char>  d_allocator;
    MyList_Node          *d_head_p, *d_tail_p;
    
  public:
    using allocator_type = bsl::allocator<char>;

    // TRAITS
    BSLMF_NESTED_TRAIT_DECLARATION(MyList, bslma::UsesBslmaAllocator);

    // CREATORS
    MyList();
    explicit MyList(const allocator_type& allocator);
    MyList(const MyList& original, const allocator_type& allocator = {});
    MyList(MyList&& original);
    MyList(MyList&& original, const allocator_type& allocator);
    ~MyList();

    // MANIPULATORS
    MyList& operator=(const MyList& rhs);
    MyList& operator=(MyList&& rhs);
    template <class... ARGS>
      void emplace_back(ARGS&&... args);
    void pop_back();
    TYPE& front();
    TYPE& back();

    // ACCESSORS
    const TYPE& front() const;
    const TYPE& back() const;
    allocator_type get_allocator() const { return d_allocator; }
};

// FREE FUNCTIONS
bool operator==(const MyList& a, const MyList& b);
bool operator!=(const MyList& a, const MyList& b);
For brevity, the example omits iterators and other operations that a reusable list class would normally supply. We’ll focus on the emplace_back and pop_back member functions, which respectively insert and remove elements at the end of the list. The implementation of the constructors, destructor, assignment operators, accessors, and equality comparison operators present no allocator-related challenges beyond those discussed in previous sections. For example, the destructor can be implemented on top of pop_back:
template <class TYPE>
MyList<TYPE>::~MyList()
{
    while (d_head_p) {
        pop_back();
    }
}
The implementation of emplace_back involves three main steps:
1)	Allocate a new MyList_Node object.
2)	Construct the new element in the node. 
3)	Link the new node onto the list.
Separating step 1 from step 2 is simpler than combining them (explanation follows shortly). To achieve this separation, we need to be able to construct a node without constructing the object that will be stored within that node. The bsls::ObjectBuffer template is designed for this purpose, reserving properly aligned space for an object without actually constructing or destroying the object:
template <class TYPE>
struct MyList_Node {
    bsls::ObjectBuffer<TYPE>  d_value;
    MyList_Node              *d_prev_p;
    MyList_Node              *d_next_p;
};
This simple node type is trivially constructible and destructible, so default construction and destruction can be considered free. The node template is also agnostic to whether or not TYPE is AA. The alternative to using bsls::ObjectBuffer would be to use bslalg::ConstructorProxy, but that would require MyList_Node to itself be conditionally AA, with all of the complications and extra work that entails.
We create a new node (step 1 in our list above) by using placement operator new, as we did to initialize d_data_p earlier:
template <class TYPE>
template <class... ARGS>
void MyList<TYPE>::emplace_back(ARGS&&... args)
{
    MyList_Node<TYPE> *node_p =
                      new(*get_allocator().mechanism()) MyList_Node<TYPE>;
Next, we construct a TYPE object in the node (step 2). If TYPE is AA, we want to construct it using the list’s allocator. We’ll use the bslma::ConstructionUtil::construct function template which, like bslalg::ConstructorProxy, normalizes the constructor argument list. The second argument to construct is an allocator that is either ignored or passed to the object’s constructor using the leading-allocator or trailing-allocator convention, based on TYPE’s traits.
    // NOT YET SAFE IN THE PRESENCE OF EXCEPTIONS (FIX TO FOLLOW)!
    bslma::ConstructionUtil::construct(node_p->d_value.address(),
                                       get_allocator()->mechanism(),
                                       std::forward<ARGS>(args)...);
This call to construct might throw an exception from TYPE’s constructor, which would cause emplace_back to exit without returning the node to the allocator. We’ll address this memory leak in a moment, but let’s first finish our exposition of the nonexceptional path.
The final step is to link the new node into the existing list:
    node_p->d_prev_p = d_tail_p;
    node_p->d_next_p = nullptr;
    d_tail_p = node_p;
    if (!d_head_p) {
        d_head_p = node_p;
    }
}
Returning to the potential memory leak we just identified, we need a way to reliably deallocate the node (i.e., return the memory to the allocator) if the emplace_back operation fails to complete after already having allocated memory (e.g., as a result of an exception). The best way to achieve this exception safety is to use an RAII  object whose destructor will automatically rewind a step if the current function returns prematurely. The BDE library refers to such an object by the unconventional term proctor. Every proctor type has a constructor that gives it control over some resource, a release method that releases control over the resource without destroying it, and a destructor that destroys any resource still under the proctor’s control. In the emplace_back example, we will use a bslma::RawDeleterProctor to unwind the allocation of the node and a bslma::DestructorProctor to unwind the construction of the element if an exception occurs during the emplace_back operation.  The complete emplace_back method looks as follows:
template <class TYPE>
template <class... ARGS>
void MyList<TYPE>::emplace_back(ARGS&&... args)
{
    MyList_Node<TYPE> *node_p =
        new(*get_allocator().mechanism()) MyList_Node;
    bslma::RawDeleterProctor<bslma::Allocator> delProct(node_p,
                                             get_allocator().mechanism());

    bslma::ConstructionUtil::construct(node_p->d_value.address(),
                                       get_allocator()->mechanism(),
                                       std::forward<ARGS>(args)...);
    // Proctor to unwind the 'construct' is not needed (see below).
    //bslma::DestructorProctor<TYPE> dtorProct(node_p->d_value.address());

    node_p->d_prev_p = d_tail_p;
    node_p->d_next_p = nullptr;
    d_tail_p = node_p;
    if (! d_head_p) {
        d_head_p = node_p;
    }

    // Success!  Release all proctors.
    // dtorProct.release();
    delProct.release();
}
The bslma::DestructorProctor is shown here for illustrative purposes but is commented out because, in this example, no potentially throwing operations occur after construction of the element that would necessitate unwinding the construction.
Finally, let’s look at the pop_back member function, which removes the last element from our list. The steps in the implementation are basically the reverse of emplace_back, using bslma::DestructionUtil to destroy the element and deleteObject to release its node back to the allocator.  Using a proctor is unnecessary because neither destruction nor deallocation should ever throw an exception and, even if they did, no method exists to unwind these operations:
template <class TYPE>
void MyList<TYPE>::pop_back()
{
    MyList_Node<TYPE> *node_p = d_tail_p;
    if (node_p) {
        d_tail_p = node_p.d_prev_p;
        if (d_tail_p) {
            d_tail_p->d_next_p = nullptr;
        }
        else {
            d_head_p = nullptr;
        }

        bslma::DestructionUtil::destroy(node_p->d_value.address());
        get_allocator().mechanism()->deleteObject(node_p);
    }
}
This separation between allocating memory and constructing an element in the allocated memory applies as well to array-based containers such as vector. Instead of allocating one node at a time containing one element each, array-based containers allocate a block of memory suitable for holding a contiguous array of elements using the allocator’s allocate method:
    // Following is unnecessary if allocator_type is bsl::allocator<TYPE>
    bsl::allocator<TYPE> typedAlloc = get_allocator();
    d_data = typedAlloc.allocate(numElements);
Operations that construct multiple elements, such as a resize operation, would use a bslma::AutoDestructor to protect all currently constructed elements that need to be unwound instead of creating a separate DestructorProctor for each element constructed. 
TESTING AA COMPONENTS
If we hope to produce quality software, then instrumenting a class to be AA must be paired with testing the AA aspects of that class.  When testing an AA class, we should test that
1)	all memory belonging to the object is allocated from its allocator and not from global operator new or the default allocator;
2)	the object gives all owned memory back to the allocator on destruction;
3)	the class object retains a copy of the specified allocator on construction (or the default allocator if one isn’t specified);
4)	the allocator doesn’t change during copy or move assignment;
5)	AA elements in containers use the same allocator as the container;
6)	memory is not leaked and objects are not corrupted if an exception occurs while allocating memory or while constructing or modifying an AA subobject; and
7)	the object allocates exactly as much memory (blocks and/or bytes) as expected (i.e., a white-box test). (Note that this test is optional.)
The bslma_testallocator and bslma_testallocatormonitor components facilitate achieving these test goals.  The bslma::TestAllocator class is an allocator that tracks blocks and bytes allocated, deallocated, and currently in use. It detects attempts to deallocate the same block twice, to deallocate a block from a different allocator than was used to allocate it, and to destroy the allocator while blocks are still outstanding (i.e., leaked). A bslma::TestAllocator can also be set to throw an exception on a specific allocation attempt for testing exception safety in the AA type. The bslma::TestAllocatorMonitor class captures the state of a specific bslma::TestAllocator and provides concise Boolean queries for whether allocation has gone up, down, or stayed the same since it was created or last reset, and by how much.
Let’s look at a simple example using bslma::TestAllocator and bslma::TestAllocatorMonitor to verify correct allocator-related behavior in our primitive linked-list container. Note that we use the common idiom passing the address of a bslma::Allocator-derived class (bslma::TestAllocator) to the MyList constructor, taking advantage of the implicit conversion from bslma::Allocator* to bsl::allocator:
{
    // If veryVeryVeryVerbose is true, 'ta' prints data on every operation
    bslma::TestAllocator ta("list alloc", veryVeryVeryVerbose);
    // ... Other code that uses 'ta' could go here ...
    bslma::TestAllocatorMonitor tam(&ta);

    MyList<int> theList(&ta);
    ASSERT(&ta == theList.get_allocator());
    ASSERT(tam.isTotalSame());   // No 'ta' allocations in the constructor

    theList.emplace_back(3);
    ASSERT(1 == tam.numBlocksInUseChange());  // Exactly one block used

    theList.pop_back();
    ASSERT(tam.isInUseSame());   // Back to original memory use
    // ... Other code that uses 'ta' could go here here ...
} // ta destructor checks for memory leaks
A class that has been converted from non-AA to AA might erroneously have residual calls to operator new that bypass the allocator. Even more common is forgetting to pass the allocator to a subobject’s constructor, resulting in the subobject erroneously using the default allocator. We can detect improper use of operator new by replacing global operator new with one that directs all allocation requests to a specific test allocator (which gets its memory from malloc, not operator new, thus avoiding recursion) :
namespace { bslma::TestAllocator opNewAllocator; }
void *operator new(std::size_t size)
    { return opNewAllocator.allocate(size); }
void operator delete(void *block_p) noexcept
    { return opNewAllocator.deallocate(block_p); }
We can detect improper use of the default allocator by setting it, either in main or in a specific test case, to a designated test allocator using bslma::DefaultAllocatorGuard. When the guard goes out of scope, the default allocator is automatically restored to its previous value:
bslma::TestAllocator defaultTestAllocator;
bslma::DefaultAllocatorGuard daGuard(&defaultTestAllocator);
Using a bslma::TestAllocatorMonitor, we can verify that operations on the type being tested result in no net allocations from either opNewAllocator or defaultTestAllocator, though transient allocations for local variables, if any, are expected. We’ll improve our previous test by adding these additional checks for incorrect use of operator new or the default allocator. We expect no transient allocations from the default allocator or operator new, so we use the isTotalSame method instead of isInUseSame to verify that no allocations at all were done from those sources:
bslma::TestAllocator da("default alloc", veryVeryVeryVerbose);
bslma::DefaultAllocatorGuard daGuard(&da);
{
    bslma::TestAllocatorMonitor onm(&opNewAllocator);
    bslma::TestAllocatorMonitor dam(&da);

    bslma::TestAllocator ta("list alloc", veryVeryVeryVerbose);
    bslma::TestAllocatorMonitor tam(&ta);

    MyList<int> theList(&ta);
    ASSERT(&ta == theList.get_allocator());
    ASSERT(tam.isInUseSame());   // No memory was consumed by constructor

    theList.emplace_back(3);
    ASSERT(1 == tam.numBlocksInUseChange());  // Exactly one block used

    theList.pop_back();
    ASSERT(tam.isInUseSame());   // Back to original memory use

    ASSERT(dam.isTotalSame());   // Default allocator unused in block
    ASSERT(onm.isTotalSame());   // 'operator new' unused in block

    // 'ta' destructor checks for memory leaks
}
Allocating memory correctly is a distinct concern that is conditioned, but not ensured, by the correct propagation of the allocator itself. For example, once we have tested that calling get_allocator returns the expected allocator (defaulted or not), we can choose any allocator we want for performing the allocation and deallocation tests; testing allocation and deallocation with different allocator arguments is unnecessary:
// Test of default and extended-default constructor
MyList<int> list1;
ASSERT(&da == list1.get_allocator());

MyList<int> list2(&ta);
ASSERT(&ta == list2.get_allocator());
ASSERT(0 == ta.numBlocksInUse()); // Needs to be tested only once per ctor
Special care must be taken to ensure that copy and move constructors and assignment operators allocate the correct amount of memory from the correct allocator. The following list summarizes the requirements:
1)	The nonextended copy constructor must create an object with the default allocator and allocate from only that allocator, regardless of the allocator held by the copied-from object.
2)	The nonextended move constructor typically should not allocate from any allocator. If allocation is required, then such allocation must draw from the same allocator as the moved-from object.
3)	The extended copy constructor must allocate only from the specified allocator.
4)	The extended move constructor should behave like the regular move constructor if the allocator designated for the moved-to object is the same as the allocator of the moved-from object. Otherwise the extended move constructor should behave like the extended copy constructor.
5)	The copy-assignment operator must allocate only from the allocator of the left-hand operand.
6)	The move-assignment operator should not allocate if the moved-to object uses the same allocator as the moved-from object; otherwise, the move-assignment operator should behave like the copy-assignment operator.
When testing a class template, the facilities in the bsltf package  can be of help. The bsltf::AllocTestType, for example, is a very simple AA type that we use to verify that our MyList container propagates its allocator to its contained elements:
bslma::TestAllocator ta1("test alloc 1", veryVeryVeryVerbose);
bslma::TestAllocator ta2("test alloc 2", veryVeryVeryVerbose);
MyList<bsltf::AllocTestType> theList(&ta1);
...
bsltf::AllocTestType val5(5, &ta2);
ASSERT(&ta2 == val5.allocator());  // Uses specified allocator
theList.emplace_back(val5);
ASSERT(&ta1 == theList.back().allocator());  // Uses list's allocator
Our last testing goal is informally referred to as allocation-caused exception safety. Any class that allocates memory might encounter an out-of-memory exception, especially when using an allocator that obtains memory from an intentionally limited pool. The test allocator has a setAllocationLimit(n) manipulator that will cause the allocator to throw an exception at the nth allocation (counting from 0). This manipulator is typically used idiomatically by the BSLMA_TESTALLOCATOR_EXCEPTION_TEST_BEGIN/_END macros to run an exception-safety test on a block of code having a deterministic allocation pattern. The macros execute the code within a try block, catching the exceptions thrown by the test allocator. Starting with an allocation limit of 0, the limit is incremented each time an exception is caught. The process is repeated until the code being tested completes without throwing. This idiom tests that the block of code handles failure cleanly at each possible allocation point. After the _END macro, we should verify that no memory was leaked from the allocator. Thus, to test the exception safety of emplace_back, we write:
bslma::TestAllocator ta("list alloc", veryVeryVeryVerbose);
BSLMA_TESTALLOCATOR_EXCEPTION_TEST_BEGIN(ta) {
    MyList<bsltf::AllocTestType> theList(&ta);
    for (int i = 0; i <= 5; ++i) {
        bsltf::AllocTestType v(i);  // Uses default allocator
        theList.emplace_back(v);
    }
    ASSERT(5 == theList.back().data());  // Minimal sanity check
} BSLMA_TESTALLOCATOR_EXCEPTION_TEST_END
ASSERT(0 == ta.numBlocksInUse());
Each iteration of the for loop requires two allocations: one for the new list node and one for the value of the test object stored in the node. If we had forgotten to add the proctor in our emplace_back implementation, this test would have detected a leak in the final assert.
In rare cases, we want to test specific postconditions for an exception beyond the absence of leaks and corruption. Our emplace_back operation, for example, has the strong guarantee; the list should be unmodified if the operation does not succeed. One way to test these postconditions is to create a class with a destructor that encapsulates those postcondition checks. The class can be either general or tailored for a very specific test. We create such a tailored class for our emplace_back test as follows:
class PushBackExcCheck {
    MyList<bsltf::AllocTestType> const *d_list_p;
    MyList<bsltf::AllocTestType>        d_snapshot; // Uses default alloc
  public:
    explicit PushBackExcCheck(const MyList<bsltf::AllocTestType> *list_p)
      : d_list_p(list_p), d_snapshot() { }

    ~PushBackExcCheck() {
        if (d_list_p) ASSERT(*d_list_p == d_snapshot);
    }

    void checkpoint() { d_snapshot = *d_list_p; }
    void release() { d_list_p = nullptr; }
};
The checkpoint method takes a snapshot of the list and should be called before any potentially-throwing operation having the strong guarantee. The release method should be called when all of the operations have completed successfully, so that the destructor does not test the exceptional conditions when an exception was not thrown. Employing this checker class, we can enhance the previous exception test as follows:
bslma::TestAllocator ta("list alloc", veryVeryVeryVerbose);
BSLMA_TESTALLOCATOR_EXCEPTION_TEST_BEGIN(ta) {
    MyList<bsltf::AllocTestType> theList(&ta);
    PushBackExcCheck excChecker(&theList);
    for (int i = 0; i <= 5; ++i) {
        bsltf::AllocTestType v(i);  // Uses default allocator
        excChecker.checkpoint();
        theList.emplace_back(v);
    }
    excChecker.release();
    ASSERT(5 == theList.back().data()); // Minimal sanity check
} BSLMA_TESTALLOCATOR_EXCEPTION_TEST_END
ASSERT(0 == ta.numBlocksInUse());
Although these allocator-specific tests add bulk to the test driver, they actually highlight one of the strengths of making a type AA: We can instrument every aspect of memory allocation easily, without modifying the allocating class.
CONCLUSION
Ensuring that reusable components are allocator aware is a critical part of Bloomberg’s success in achieving performance, object placement, metrics gathering, thorough testing, and effective debugging. The effort of converting a non-AA component to an AA one, though not negligible, need not be excessive and is in most cases straightforward in nature.
For simple types such as structs and attribute types, the basic guidelines shown in this paper allow readers to swiftly and correctly plumb their own types to be AA. For more sophisticated components, the (open-source) BDE  infrastructure provides low-level components (e.g., bslma_constructionutil and bslma_testallocator) and tools  to facilitate the creation, testing, and validation of AA components. Along with these assets, the recipes delineated in this paper should yield robust and reusable AA software.

APPENDIX A: ALLOCATOR-AWARE MOVE OPERATIONS IN C++03
Types that allocate memory often benefit from efficient move constructors and move-assignment operators that transfer pointers rather than copying objects. Move operations depend on rvalue references, which were introduced in C++11 but are partially emulated in the bslmf_movableref component. Using bslmf::MovableRef instead of rvalue references, we are able to write move constructors and move-assignment operators, as well as their allocator-extended variants, that are portable between C++03 and C++11 and later.
A quick summary of bslmf_movableref :
•	An instantiation of bslmf::MovableRef<T> emulates T&& (i.e., an rvalue reference) when compiled with a pre-C++11 compiler and is identical to T&& when compiled with a C++11 or later compiler.
•	An expression of type bslmf::MovableRef<T> is implicitly convertible to T& (i.e., an lvalue reference). The conversion can be made explicit by calling bslmf::MovableRefUtil::access(movableref) (e.g., to access a member of T through a MovableRef<T>).
•	A call to bslmf::MovableRefUtil::move(ref) emulates std::move(ref), returning a bslmf::MovableRef to the object referenced by (lvalue or rvalue) ref.
To express move operations in C++03, we will need to declare not only the extended move constructor, but also the normal move constructor and move- assignment operator using bslmf::MovableRef. We will also have to define the normal copy constructor and copy-assignment operator because compiler generation of these operations are suppressed in C++11 by the presence of the user-defined move constructor and move-assignment operator, for reasons unrelated to allocators. Adding the allocator-extended copy and move constructors to the Rule of Five gives us the Rule of Five-plus-two. The complete Rule of Five-plus-two set for a Thing class is shown below. Note that the set includes only six separate members because the copy constructor and extended copy constructor are combined into one:
    Thing(const Thing&          original,
          const allocator_type& allocator = allocator_type());
    Thing(bslmf::MovableRef<Thing> original) BSLS_KEYWORD_NOEXCEPT;
    Thing(bslmf::MovableRef<Thing> original,
          const allocator_type&    allocator);
    ~Thing();

    Thing& operator=(const Thing& rhs);
    Thing& operator=(bslmf::MovableRef<Thing> rhs);
The above C++03 declarations require no modifications to work in C++11, though the presence of the user-defined copy constructor, move constructor, copy assignment, and move assignment declarations add significant clutter in cases in which the C++ compiler could have generated them automatically. The destructor declaration is optional in both C++03 and C++11 for a nonallocating type because the compiler can generate a correct destructor automatically. Two additional adaptations for C++03 are the use of allocator_type() instead of {} to initialize the default allocator parameters and the use of BSLS_KEYWORD_NOEXCEPT instead of the noexcept keyword to indicate that an operation cannot throw an exception.
To conclude our exposition of C++03 compatibility, let’s look at the complete implementations of the Rule of Five-plus-two operations for the Thing type described in the section, “Making a Simple struct AA”:
// Combined regular and allocator-extended copy ctor
Thing::Thing(const Thing& original, const allocator_type& allocator)
  : d_name(original.d_name, allocator)
  , d_data(original.d_data, allocator.mechanism())
  , d_score(original.d_score)
  , d_rank(original.d_rank)
{
}

// Regular move ctor
Thing::Thing(bslmf::MovableRef<Thing> original) BSLS_KEYWORD_NOEXCEPT
  : d_name(bslmf::MovableRefUtil::move(
              bslmf::MovableRefUtil::access(original).d_name))
  , d_data(bslmf::MovableRefUtil::move(
              bslmf::MovableRefUtil::access(original).d_data))
  , d_score(original.d_score)
  , d_rank(original.d_rank)
{
}

// Allocator-extended move ctor. MAY THROW.
Thing::Thing(bslmf::MovableRef<Thing> original,
             const allocator_type&    allocator)
  : d_name(bslmf::MovableRefUtil::move(
              bslmf::MovableRefUtil::access(original).d_name)),
           allocator)
  , d_data(bslmf::MovableRefUtil::move(
              bslmf::MovableRefUtil::access(original).d_data)),
           allocator.mechanism())
  , d_score(original.d_score)
  , d_rank(original.d_rank)
{
}

// Destructor
Thing::~Thing()
{
}

// Copy-assignment operator
Thing& Thing::operator=(const Thing& rhs) {
    d_name  = rhs.d_name;
    d_data  = rhs.d_data;
    d_score = rhs.d_score;
    d_rank  = rhs.d_rank;
    return *this;
}

// Move-assignment operator
Thing& Thing::operator=(bslmf::MovableRef<Thing> rhs) {
    Thing& rhsRef = rhs;
    d_name  = bslmf::MovableRefUtil::move(rhsRef.d_name);
    d_data  = bslmf::MovableRefUtil::move(rhsRef.d_data);

    // The use of 'bslmf::MovableRefUtil::move' is optional for the
    // two integer members. 
    d_score = bslmf::MovableRefUtil::move(rhsRef.d_score);
    d_rank  = bslmf::MovableRefUtil::move(rhsRef.d_rank);
    return *this;
}

APPENDIX B: ALTERNATIVES TO STORING THE ALLOCATOR POINTER 
IN THE OBJECT FOOTPRINT
The allocator for an AA class object is typically stored as a data member, contributing the size of a bsl::allocator (one pointer-size) to the footprint of the object. This overhead is unacceptable in some applications. For example, given a vector of ten million vectors, where 90% of the inner vectors are empty, the wasted space due to the allocator members is about 69MB (assuming 64-bit pointers), which might be significant in memory-constrained environments. The allocator member might cause a class that would fit into a single cache line without allocators to, instead, straddle two cache lines.
If measurement and calculation show that the allocator within the memory footprint of a class is a problem for a specific application or library, numerous methods are available to preserve allocator awareness while eliminating the allocator from the object’s footprint; what follows is just a small sampling. Note that all of these examples involve creating classes not usually found in existing AASI libraries, but these new classes are themselves reusable for other situations where a small footprint is critical. Also note that these designs tend to favor reducing memory consumption at a (sometimes significant) cost in the number of instructions executed.
The most practical approach is to store the allocator on the heap as part of the object’s allocated memory and in the object footprint when the object is empty. In our vector example, we could create a custom vector, UsuallyEmptyVector,  where the allocator and the first data pointer share space in a union. The allocator is stored in the union when the vector’s capacity is zero (i.e., no memory has been allocated) and in a prefix to the allocated chunk otherwise. We can do better though. If footprint size truly is critical, we can make our UsuallyEmptyVector footprint just one pointer. Assuming that bslma::Allocator (or pmr::memory_resource) has an alignment requirement of at least 2 bytes, we can steal the low-order bit of a multipurpose pointer to indicate whether the vector is empty; a one would indicate an empty vector, where the rest of the pointer points to the memory resource, and a zero would indicate a nonempty vector, where the rest of the pointer points to the start of the allocated data area. The data area would contain the length, capacity, and allocator, followed by the actual vector elements. Stealing a bit from a pointer technically falls into the realm of undefined behavior but is exactly the kind of practical engineering that is worth doing (taking advantage of known platform behavior) when constraints are especially tight.
Another approach  doesn’t actually reduce the object footprint but uses the footprint more efficiently to implement the small-string optimization. Storing a data pointer, size, capacity, and allocator are all unnecessary when the bytes that make up the string value fit within the string footprint, and this approach capitalizes on that knowledge. Two bits of the last byte of the string footprint are used to hold bookkeeping information indicating a) whether the string exceeds the small-string capacity and b) whether the memory resource is other than the one returned by pmr::new_delete_resource. If both are zero, then the last byte becomes the null terminator for the string and the entire footprint can be used for the small string optimization. Otherwise, the string representation trades off small-string space for storing the additional data necessary for the allocator and capacity. This approach must be applied carefully, with attention to the pointer layout on the particular target hardware. It can be combined with the previous approach to produce a one-pointer string that can still use the small-object optimization for up to 7 bytes if the new/delete resource is used.
Finally, let’s consider ILAR allocators.  This framework involves an external lookup table that maps address ranges to allocators. Instead of storing the allocator in the object footprint, an object finds its allocator by looking up its own address in the external table. In the case of our vector of usually empty vectors, the outer vector’s allocator would register the blocks it allocates in the lookup table so that the inner (usually empty) vectors could find themselves there. ILAR allocators require significant collaboration between allocators and clients, and the lookup table must be carefully managed, especially in a multithreaded environment, but for a memory-constrained application, an ILAR allocator might be a reasonable engineering choice.

APPENDIX C: MAPPING BDE AA DEVELOPMENT TO 
C++20 PMR AA DEVELOPMENT
The C++17/C++20 Polymorphic Memory Resource (PMR) library is an offshoot of the Bloomberg allocator library. The standard std::pmr::memory_resource abstract base class is nearly identical to Bloomberg’s bslma::Allocator class, the major differences being that the PMR allocate method takes an alignment argument in addition to the number of bytes and that the PMR public member functions are nonvirtual functions that call private virtual functions (e.g., allocate is a nonvirtual function that calls the virtual function do_allocate), following the pattern for other abstract base classes in the standard. Similarly, the standard std::pmr::polymorphic_allocator class template is identical to Bloomberg’s bsl::allocator template except that the former stores a pointer to a pmr::memory_resource (returned by the resource method) instead of a pointer to a bslma::Allocator (returned by the mechanism method). In C++20, polymorphic_allocator has additional methods, new_object and delete_object, that simplify allocating and deallocating as well as constructing and destroying an object from an allocator and virtually eliminate the need to call the memory_resource accessor.  Note that BDE’s old-style AA interface has no equivalent in the C++ Standard Library, i.e., none of the AA types use pmr::memory_resource* in their interfaces except indirectly through pmr::polymorphic_allocator.
To construct an object in uninitialized memory, the C++20 library has std::uninitialized_construct_using_allocator, which works nearly identically to bslma::ConstructionUtil::construct in the BDE library, ignoring the allocator for non-AA types and passing it to the constructor for AA types. The easiest way to initialize a member variable or local variable in C++20 is with std::make_using_allocator, which constructs and returns a value of specified type, again handling or ignoring the allocator as appropriate:
template <class TYPE>
class Thing {
    std::pmr::polymorphic_allocator<> d_allocator;
    TYPE                              d_data;
    // ...
  public:
    using allocator_type = std::pmr::polymorphic_allocator<>;

    Thing();
    explicit Thing(const allocator_type& alloc);
    // ...
};

template <class TYPE>
Thing<T>::Thing(const allocator_type& alloc)
  : d_allocator(alloc), d_data(make_using_allocator<TYPE>(alloc)) { }
This idiom relies on C++20’s rules for materialization of temporary variables (sometimes referred to as guaranteed copy elision); the return value of make_using_allocator is constructed directly into the d_data member without invoking a copy or move constructor. These construction rules make it unnecessary to use a wrapper class like bslalg::ConstructorProxy.
The C++20 Standard Library contains no proctors, but std::unique_ptr can be even more effective in this role with the appropriate use of deleters, easy-to-author types that operate on a specified address when a unique_ptr goes out of scope. Creating deleters that mimic the behavior of the destructors for bslma::DeallocatorProctor and bslma::DestructorProctor would be a trivial task. A proposal in the C++ Standards Committee awaits and calls for (among other things) an allocate_unique function that allocates memory, constructs an object in the memory, and returns a unique_ptr, thus combining object allocation, construction, and exception-protection into one step.  Additionally, bslma::TestAllocator has no equivalent in the C++ Standard Library, but one has been proposed and source code is available. 

APPENDIX D: CONVERTING FROM OLD-STYLE AA TO NEW-STYLE AA
As of June 2020, most AA classes at Bloomberg use an old interface style in which allocators are conveyed as raw pointers of type bslma::Allocator* instead of as objects of type bsl::allocator<T>. Transitioning to the new style provides the following benefits.
•	The new style is more similar to the C++ Standard’s pmr style and will eventually be built on and compatible with pmr.
•	The allocator can never accidentally be null because bsl::allocator has a default constructor that selects the currently installed default allocator.
•	The new style is compatible with C++11 AA constructs. For example, a new-style AA type X can be stored in a vector<X, std::scoped_allocator_adaptor<bsl::allocator<X>> and will correctly inherit its allocator instance from the vector.
To convert a class from the old-style AA interface to the new-style interface, follow the listed steps.
1.	Make bsl::allocator available for use:
Add	#include <bslma_stdallocator.h>
2.	Add an allocator_type alias (or typedef in C++03) into the public part of the class:
Add	  public:
    // TYPES
    using allocator_type = bsl::allocator<char>;
3.	If the class has a member variable of type bslma::Allocator*, change it to allocator_type (and remove the _p suffix in the name, if any):
Before	bslma::Allocator *d_alloc_p;
After	allocator_type d_alloc;
4.	Change any constructors that take a bslma::Allocator* parameter to take a const allocator_type& parameter instead. Since it is no longer a base-class type, change the name basicAllocator to just allocator. If the allocator parameter has a 0 default value, change it to an empty initializer list:
Before	explicit Thing(int, bslma::Allocator *basicAllocator = 0);
After	explicit Thing(int, const allocator_type& allocator = {});

Note that if C++03 compatibility is needed, the empty initializer list ({}) must be replaced with an explicit constructor call (allocator_type()). Don’t forget to update the constructor documentation to reflect the new parameter names and defaults.
5.	Remove the use of bslma::Default::allocator for unnullifying an allocator argument:
Before	Thing::Thing(int, bslma::Allocator *basicAllocator)
  : d_alloc_p(bslma::Default::allocator(basicAllocator))
After	Thing::Thing(int, const allocator_type& allocator)
  : d_alloc(allocator)
6.	If the class code initializes any old-style AA class members, then call the mechanism() method on the allocator to get the bslma::Allocator pointer:
Before	Thing::Thing(int, bslma::Allocator *basicAllocator)
  : d_name(basicAllocator)         // new-style AA member
  , d_data(basicAllocator)         // old-style AA member
After	Thing::Thing(int, const allocator_type& allocator)
  : d_name(allocator)              // new-style AA member
  , d_data(allocator.mechanism())  // old-style AA member
7.	Add a new get_allocator method but keep a modified version of the old-style allocator method for backward compatibility.
Before	inline bslma::Allocator *Thing::allocator() const
  { return d_alloc; }
After	inline Thing::allocator_type Thing::get_allocator() const
  { return d_alloc; }

inline bslma::Allocator *Thing::allocator() const
  { return get_allocator().mechanism(); }
8.	Until the BDE infrastructure catches up to the new style (expected in 2020) raw allocation, deallocation, and construction of dynamically-allocated objects will rely on the bslma::Allocator*-based tools in the bslma package, again through the use of get_allocator().mechanism(). Because the allocator() method remains for backward compatibility, the “Before” code below will continue to work properly but doesn’t reveal that that a compatibility feature is being used.
Before	MyList_Node<TYPE> *node_p = new(*allocator()) MyList_Node;
bslma::DeallocatorProctor<bslma::Allocator>
     nodeProct(node_p, allocator());
bslma::ConstructionUtil::construct(node_p->d_value.address(),
                                   allocator(), value);
...
bslma::DestructionUtil::destroy(node_p->d_value.address());
allocator()->deleteObject(node_p);
After	MyList_Node<TYPE> *node_p =
    new(*get_allocator().mechanism()) MyList_Node;
bslma::DeallocatorProctor<bslma::Allocator>
    nodeProct(node_p, get_allocator().mechanism());
bslma::ConstructionUtil::construct(node_p->d_value.address(),
                                 get_allocator().mechanism(),
                                 value);
...
bslma::DestructionUtil::destroy(node_p->d_value.address());
get_allocator().mechanism()->deleteObject(node_p);
Alternatively, the allocator member can be stored as an appropriate instantiation of bsl::allocator and used directly to allocate and deallocate, but that does not make the code any more compact in most cases.
After (Alter-native)	bsl::allocator<MyList_Node<TYPE>> nodeAlloc(get_allocator());
MyList_Node<TYPE> *node_p = nodeAlloc.allocate(1);
nodeAlloc.construct(node_p);  // Begin lifetime
bslma::DeallocatorProctor<bslma::Allocator>
nodeProct(node_p, nodeAlloc.mechanism());

bslma::ConstructionUtil::construct(node_p->d_value.address(),
                                   nodeAlloc.mechanism(),
                                   value);
...
bslma::DestructionUtil::destroy(node_p->d_value.address());
nodeAlloc.destroy(node_p);
nodeAlloc.dallocate(node_p);
9.	The existing test driver should compile and run with no changes. However, you should at least add tests for the bsl::uses_allocator trait and the get_allocator method:
Before	typedef MyList<int> Obj;
ASSERT(bslma::UsesBslmaAllocator<Obj>::value);
...
Obj mX(&theTestAlloc); const Obj& X = mX;
ASSERT(&theTestAlloc == X.allocator());
After	typedef MyList<int> Obj;
ASSERT(bslma::UsesBslmaAllocator<Obj>::value);
ASSERT((bsl::uses_allocator<Obj,
                            bsl::allocator<char>>::value));
...
Obj mX(&theTestAlloc); const Obj& X = mX;
ASSERT(&theTestAlloc == X.allocator());
ASSERT(&theTestAlloc == X.get_allocator());

% 10 June 2021, LaTeX cleanup and updating commands
% 15 June 2021, to Josh for code check



\emcppsFeature{
    short={{\itshape Rvalue} References},
    tocshort={{\sfitwelveRomeo Rvalue} References},
    long={Move Semantics and {\sfbsectionitalRomeo Rvalue} References ({\SecCode \&\&})},
    toclong={Move Semantics and {\itshape Rvalue} References (\lstinline!\&\&!)},
    rhshort={{\sfiRHRomeo Rvalue} References},
}{Rvalue-References}
\label{move-semantics-and-rvalue-references}
\setcounter{table}{0}
\setcounter{footnote}{0}
\setcounter{lstlisting}{0}
%\section[{\itshape rvalue} References]{Rvalue References: {\SecCode \&\&}}\label{Rvalue-References}
%\section[Move Semantics and Rvalue References]{Move Semantics and Rvalue References}\label{move-semantics-and-rvalue-references}




The introduction of \emcppsgloss[rvalue reference]{\romeovalue{rvalue} references} in C++11 provides
a consistent mechanism to identify circumstances under which an object's
state may be safely \emph{moved} to a new object, a.k.a. \emcppsgloss{move
semantics}. Operations having \emcppsgloss{move semantics} often afford a
more runtime-efficient alternative to conventional copy operations.
Moreover, \emcppsgloss[rvalue reference]{\romeovalue{rvalue} references} enable the creation of
\emcppsgloss[move only type]{move-only types}, which can be used to represent unique,
transferable ownership of a given resource.

\subsection[Description]{Description}\label{description-rvalueref}

\emcppsgloss[rvalue reference]{\romeovalue{Rvalue} references} are perhaps the defining language feature of
modern C++. To enable the introduction of move semantics, the C++
language evolved the notion of \romeovalue{lvalues} and non\romeovalue{lvalues} to a
number of value categories, allowing for a mostly smooth ability to
capture the moment when an object's value is no longer needed and can,
consequently, can have its internal state taken instead of copied. For a
discussion of the history and motivation of the evolution of value
categories as well as the foundation of their meaning prior to C++11,
see \intraref{appendix-rvalueref}{the-evolution-of-value-categories}.

\subsubsection[Introduction to {\itshape rvalue} references]{Introduction to {\sfbsubsubsecitalRomeo rvalue} references}\label{introduction-to-rvalue-references}

Prior to C++11, the only kind of reference type in C++ was the
\emcppsgloss[lvalue reference]{\romeovalue{lvalue} reference}. For any type \lstinline!T!, the type
\lstinline!T&! is an \emcppsgloss[lvalue reference]{\romeovalue{lvalue} reference} to \lstinline!T!, and entities
with this reference type act as alternate names for the objects they
refer to:

\begin{emcppslisting}
int  c;
int& cr  = c;   // (ù{\emphincomments{lvalue}}ù) reference to (ù{\codeincomments{c}}ù)
int* p   = &c;
int& cpr = *p;  // also (ù{\emphincomments{lvalue}}ù) reference to (ù{\codeincomments{c}}ù)
\end{emcppslisting}
    
    
\noindent Binding a \lstinline!const! \emcppsgloss[lvalue reference]{\romeovalue{lvalue} reference} to an expression that
can be used to initialize a temporary object, such as a literal value or
a call to a function that returns by value (which are examples of
\romeovalue{prvalues}; see \intrarefsimple{prvalues-in-c++11/14}), creates a temporary object whose lifetime will be extended to
that of the \emcppsgloss[lvalue reference]{\romeovalue{lvalue} reference}; see \intraref{appendix-rvalueref}{lifetime-extension-of-a-temporary-bound-to-a-reference}:

\begin{emcppslisting}
const int& d = 5;    // (ù{\emphincomments{lvalue}}ù) reference to temporary with value (ù{\codeincomments{5}}ù)

int v();             // returns an (ù{\codeincomments{int}}ù) by value
const int& e = v();  // (ù{\emphincomments{lvalue}}ù) reference to temporary returned by (ù{\codeincomments{v}}ù)
\end{emcppslisting}
    
    
\noindent Non\lstinline!const! \emcppsgloss[lvalue reference]{\romeovalue{lvalue} references} cannot, however, bind to
temporaries:

\begin{emcppslisting}
int& f = 7;    // Error, cannot bind temporary to non(ù{\codeincomments{const}}ù) (ù{\emphincomments{lvalue}}ù) reference
int& g = v();  // Error,    "     "      "      "  "    "       "       "
\end{emcppslisting}
    
    
\noindent Being unable to bind non\lstinline!const! \emcppsgloss[lvalue reference]{\romeovalue{lvalue} references} to
temporaries protects programmers from inadvertently storing information
in an object that is clearly at the end of its lifetime. On the other
hand, this restriction also prevents programmers from taking advantage
of the imminent destruction of the referent by assuming ownership of any
resources that it might control.

To support creating references to objects that are at the end of their
lifetimes and to enable modification of such objects, \emcppsgloss[rvalue reference]{\romeovalue{rvalue} references} were added in C++11. For any type \lstinline!T!, the type
\lstinline!T&&! is an \emcppsgloss[rvalue reference]{\romeovalue{rvalue} reference} to \lstinline!T!. The
primary distinction between an \emcppsgloss[lvalue reference]{\romeovalue{lvalue} reference} and an
\emcppsgloss[rvalue reference]{\romeovalue{rvalue} reference} is that non\lstinline!const! \emcppsgloss[rvalue reference]{\romeovalue{rvalue}
references} can bind to temporary objects:

\begin{emcppslisting}
int&& rf = 7;    // OK, (ù{\emphincomments{rvalue}}ù) reference to temporary with value (ù{\codeincomments{7}}ù)
int&& rg = v();  // OK, (ù{\emphincomments{rvalue}}ù) reference to temporary returned by (ù{\codeincomments{v}}ù)
\end{emcppslisting}
    
    
\noindent An \emcppsgloss[rvalue reference]{\romeovalue{rvalue} reference} will not, however, bind to \romeovalue{lvalues}:

\begin{emcppslisting}
int   h;
int&& rvh1 = h;    // Error, cannot bind (ù{\emphincomments{rvalue}}ù) reference to (ù{\emphincomments{lvalue}}ù)
int*  hp   = &h;
int&& rvh2 = *hp;  // Error, cannot bind (ù{\emphincomments{rvalue}}ù) reference to (ù{\emphincomments{lvalue}}ù)
\end{emcppslisting}
    
    
\noindent Importantly, \romeovalue{lvalues} can be explicitly cast to
\emcppsgloss[rvalue reference]{\romeovalue{rvalue} references} using a \lstinline!static_cast!:

\begin{emcppslisting}
int&& rvh3 = static_cast<int&&>(h);    // OK
int&& rvh4 = static_cast<int&&>(*hp);  // OK
\end{emcppslisting}
    
    
\noindent These restrictions prevent creating \emcppsgloss[rvalue reference]{\romeovalue{rvalue} references} to
objects where there has been no implicit or explicit indication that the
object's value is no longer going to be needed.

\subsubsection[Introduction to {\itshape xvalues}]{Introduction to {\sfbsubsubsecitalRomeo xvalues}}\label{introduction-to-xvalues}

The quality of having a clear distinction for a reference to an object
whose value is no longer needed is essential to understanding the
purpose and use of \emcppsgloss[rvalue reference]{\romeovalue{rvalue} references}. Objects whose lifetime
has already been started can only be bound to an \emcppsgloss{rvalue
reference} when they are identified by an expression with the
\romeovalue{xvalue} \emcppsgloss{value category}, which is new to C++11. As we saw
above, \emcppsgloss[rvalue reference]{\romeovalue{rvalue} references} can also bind to \romeovalue{prvalues}; in
that case, a temporary is created to which the reference is bound.

The C++11 \romeovalue{xvalue} value category can arise in two primary ways.
Any expression that produces a temporary value will have the
\romeovalue{xvalue} value category, enabling an \emcppsgloss[rvalue reference]{\romeovalue{rvalue} reference} to
bind to the temporary and make use of its contents:

\begin{emcppslisting}
struct S { };
S f();          // OK, function that returns by value
S&& rs1 = f();  // OK, (ù{\emphincomments{rvalue}}ù) reference binds to temporary (ù{\codeincomments{S}}ù) object
\end{emcppslisting}
    
    
\noindent The other way to have an expression with the \romeovalue{xvalue} \emcppsgloss{value
category} is to explicitly form an expression with a type that is an
\emcppsgloss[rvalue reference]{\romeovalue{rvalue} reference}, either by invoking a function that returns
such a type or by using a cast to convert an \romeovalue{lvalue} to an
\emcppsgloss[rvalue reference]{\romeovalue{rvalue} reference}:

\begin{emcppslisting}
S&& g();
S&& rs2 = g();                  // OK
S s;
S&& rs3 = static_cast<S&&>(s);  // OK
\end{emcppslisting}
    
    
\noindent Of particular note is the Standard Library utility \lstinline!std::move!,
which is a function returning an \emcppsgloss[rvalue reference]{\romeovalue{rvalue} reference}, like
\lstinline!g! in the example above, with an implementation like the
initializer for \lstinline!rs3! above --- namely, just a
\lstinline!static_cast! to an \emcppsgloss[rvalue reference]{\romeovalue{rvalue} reference}; see \intrarefsimple{the-std::move-utility}:

\begin{emcppslisting}
#include <utility>  // (ù{\codeincomments{std::move}}ù)

S&& rs4 = std::move(s);  // OK, same initialization as (ù{\codeincomments{rs3}}ù)
\end{emcppslisting}
    
    
\noindent Casting an \romeovalue{lvalue} into an \romeovalue{xvalue} like this allows for the
explicit indication that a \emcppsgloss[move operations]{move operation} is allowed on the
object being referenced and that its value is no longer going to be
needed.

\subsubsection[Introduction to modern overload resolution]{Introduction to modern overload resolution}\label{introduction-to-modern-overload-resolution}

During overload resolution, when choosing between a function with a
matching \emcppsgloss[rvalue reference]{\romeovalue{rvalue} reference} parameter and a function with a
matching \lstinline!const! \emcppsgloss[lvalue reference]{\romeovalue{lvalue} reference} parameter, the
\emcppsgloss[rvalue reference]{\romeovalue{rvalue} reference} parameter has higher priority. This
prioritization comes into play when the argument is an \romeovalue{xvalue} or
a \romeovalue{prvalue}:

\begin{emcppslisting}
void f(const int&);  // (1) (ù{\codeincomments{const}}ù) (ù{\emphincomments{lvalue}}ù) reference
void f(int&&);       // (2) (ù{\emphincomments{rvalue}}ù) reference

void test()
{
    int i;
    f(i);             // (ù{\emphincomments{lvalue}}ù), invokes (1)
    f(std::move(i));  // (ù{\emphincomments{xvalue}}ù), invokes (2)
    f(5);             // (ù{\emphincomments{prvalue}}ù), invokes (2)
}
\end{emcppslisting}
    

\subsubsection[Move operations]{Move operations}\label{move-operations}

To take advantage of the new kind of reference type, C++11 also added
two new \emcppsgloss{special member functions} to user-defined class types:
the \emcppsgloss{move constructor} and the \emcppsgloss[move assignment operator]{move-assignment operator}.
The \emcppsgloss{move constructor} parallels the \emcppsgloss{copy constructor} of
a class but instead of taking an \emcppsgloss[lvalue reference]{\romeovalue{lvalue} reference} parameter
(which is usually \lstinline!const!), it takes an \emcppsgloss[rvalue reference]{\romeovalue{rvalue} reference}
parameter:

\begin{emcppslisting}
struct S1
{
    S1(const S1&);  // copy constructor
    S1(S1&&);       // move constructor
};
\end{emcppslisting}
    
    
\noindent Similarly, the \emcppsgloss[move assignment operator]{move-assignment operator} parallels the
\emcppsgloss[copy assignment operator]{copy-assignment operator} but takes an \emcppsgloss[rvalue reference]{\romeovalue{rvalue} reference}
parameter instead:

\begin{emcppslisting}
struct S2
{
    S2& operator=(const S2&);  // copy-assignment operator
    S2& operator=(S2&&);       // move-assignment operator
};
\end{emcppslisting}
    
    
\noindent Both of these new special member functions participate in overload
resolution alongside the corresponding copy operations and are eligible
and preferred for arguments that are \romeovalue{xvalues} or \romeovalue{prvalues}.
These move operations can then do what their name suggests and move the
value of the source object, along with any resources that it owns, into
the target object without regard for leaving the source object in a
useful state, though see \intraref{potential-pitfalls-rvalueref}{inconsistent-expectations-on-moved-from-objects} for many considerations about what
state in which it should be left.

When programming with objects that support \emcppsgloss{move operations}, the
general assumption is to have no expectations on the state of a
moved-from object, although most well-behaved types will support
destruction of a moved-from object and assignment of a new value to the
object. The unspecified state of a moved-from object can be, if
appropriate, the same as its state prior to the move, and from a user
perspective, the copy operation on a type generally meets the contract
of a move operation. In cases where a type has a copy operation, the
move operation often ends up as an optimization that seamlessly reuses
no-longer-needed resources from a source object and results in a
destination object with the same value that copying would have produced.

\subsubsection[Motivation]{Motivation}\label{motivation}

The motivation for the introduction of \emcppsgloss{move semantics} was the
desire to address common problems involving potentially expensive
copying of data in situations where such copies were unnecessary.
Consider, for example, the task of swapping the values of two vectors. A
simple C++03 implementation would involve at least one allocation and
deallocation as well as multiple element-wise copies:

\begin{emcppslisting}
void swapVectors(std::vector<int>& v1, std::vector<int>& v2)
{
    std::vector<int> temp = v1;
    v1 = v2;
    v2 = temp;
}
\end{emcppslisting}
    
    
\noindent These allocations and copies are, however, unnecessary in principle:
After execution of \lstinline!swapVectors!, the program still refers to two
heap-allocated buffers containing the values, and simply exchanging the
pointers within the vectors being swapped would suffice to achieve the
same result. This issue would be further exacerbated if the elements of
the vectors were expensive to copy, such as elements of type
\lstinline!std::vector! or \lstinline!std::string!. Similarly, when growing
the buffer within a \lstinline!std::vector<std::string>! (e.g., to
accommodate an additional element), making a copy of each string despite
a clear understanding that the old ones will be destroyed immediately
after copying them is inefficient.{\cprotect\footnote{Note that, for
clarity, we're not involving the strong exception-safety guarantee
provided by \lstinline!std::vector! in this discussion. For more on
moves, vectors, and the exception-safety guarantee, see
\featureref{\locationc}{noexceptoperator}.}} Finally, copying a
temporary object that is about to be destroyed is equally wasteful. Move
semantics addresses these issues by allowing a potentially more
efficient transfer (move) of resource ownership from one object to
another in circumstances where a copy would be followed by discarding
the original.

C++11 added \emcppsgloss[rvalue reference]{\romeovalue{rvalue} references}, \emcppsgloss{move operations}, and
\romeovalue{xvalues} as a new \emcppsgloss{value category}. These all work together
to enable the use of move semantics as an optimization of copy semantics
in a number of scenarios. In addition to the potential for optimization,
by providing \emph{only} move operations and \emph{no} copy operations,
\emcppsgloss[move only type]{move-only types} can be developed. The prototypical
\emcppsgloss[move only type]{move-only type}, \lstinline!std::unique_ptr!, was introduced to
solve the long-standing problem of the many pitfalls of using
\lstinline!std::auto_ptr!. This new type allowed \lstinline!std::auto_ptr!
to be deprecated in C++11.{\cprotect\footnote{Unlike most other
deprecations, \lstinline!std::auto_ptr! has not lingered in the standard
  and was completely removed in C++17.}}

\subsubsection[Extended value categories in C++11/14]{Extended value categories in C++11/14}\label{extended-value-categories-in-c++11/14}

There are three disjoint \emcppsgloss[value category]{value categories} in modern C++.

\begin{enumerate}
\item{\romeovalue{lvalues} comprise objects in memory that could conceivably have their address taken but which have not been designated, either implicitly or explicitly, as no longer needing their values and potentially nearing the end of their lifetimes. One important characteristic of \romeovalue{lvalues} is that the address operator \lstinline!&! requires an \romeovalue{lvalue} as its operand.}
\item{\romeovalue{xvalues} are also objects in memory but specifically include those that are nearing the end of their lifetime. This includes temporary objects and \romeovalue{lvalues} that have been transformed through various means involving \emcppsgloss[rvalue reference]{\romeovalue{rvalue} references}, such as \lstinline!static_cast<T&&>! or the Standard Library \lstinline!std::move! utility function. Many operations that access subobjects of an \romeovalue{xvalue} expression also yield \romeovalue{xvalues}.}
\item{\romeovalue{prvalues} are values that have not \emph{yet} been used to populate an object but could be used to do so. This includes literals such as \lstinline!12!, \lstinline!7.3e5!, and \lstinline!true! as well as functions that return values that are not references.}
\end{enumerate}

Two additional \emcppsgloss[value category]{value categories}
 have been defined that capture
some of the common properties amongst the value categories: \textbf{[AUs: do you want to continue the previous numbering and make these 4 and 5?]}
\begin{enumerate}
\item{\emph{glvalues}, also called generalized \romeovalue{lvalues}, are all expressions that are either an \romeovalue{lvalue} or an \romeovalue{xvalue}. All \emph{glvalues} represent objects in memory that have an address in memory, although the \lstinline!&! operator can only be applied to \romeovalue{lvalues}. Many operations, such as applying an operator other than \lstinline!&! or invoking a member function, require a \emph{glvalue} as an operand or argument. When an expression is a \romeovalue{prvalue} but not a \emph{glvalue} and a \emph{glvalue} is needed, a process called \emcppsgloss{temporary materialization} initializes a temporary to effectively convert the \romeovalue{prvalue} into an \romeovalue{xvalue} and thus a \emph{glvalue}.}
\item{\romeovalue{rvalues} are those expressions that are not \romeovalue{lvalues} or, alternatively, expressions that are neither an \romeovalue{xvalue} nor a \romeovalue{prvalue}. All expressions that are \romeovalue{rvalues} can be bound to \emcppsgloss[rvalue reference]{\romeovalue{rvalue} references}; \romeovalue{xvalues} can be bound directly, and \romeovalue{prvalues} can be bound through implicit \emcppsgloss{temporary materialization} to produce an \romeovalue{xvalue} to which the reference, in turn, can be bound.\cprotect\footnote{In general, the distinction between a \romeovalue{prvalue} and an \romeovalue{xvalue} is not critical, as they interact with most other features in the same way. In C++17, however, changes are coming that leverage the distinction to cause a \romeovalue{prvalue} returned from a function to be used to initialize the return value directly, with no intervening temporary that might be inconsistently elided. The distinction between the two \romeovalue{rvalue} subcategories facilitates \emcppsgloss{guaranteed copy elision}, introduced to C++17 through P0135R0 (\cite{smith15c}) since \romeovalue{prvalues} are those expressions that can be used to initialize an object directly instead of indirectly creating a temporary that will then be used to initialize the object through the invocation of copy or move constructors.}}
\end{enumerate}

\paragraph[{\itshape Lvalues} in C++11/14]{{\sfbparaitalRomeo Lvalues} in C++11/14}\label{lvalues-in-c++11/14}

An \emcppsgloss[lvalue]{\romeovalue{lvalue}} expression is, by definition, one for which the
built-in \emph{address-of} operator, \lstinline!&!, can be applied to
obtain an address:

%%%%%% leave this as code; do not set as a table. 
\begin{emcppslisting}
// named (ù{\emphincomments{lvalue}}ù)        Taking the address of an (ù{\emphincomments{lvalue}}ù) using (ù{\codeincomments{\&}}ù)
// --------------        -------------------------------------------

double d;                double* dp            = &d;
                         double* dp2           = &(d += 0.5);

double& dr = d;          double*  dp3          = &dr;
                         double** dpp          = &dp3;

const int& cir = 1;      const int*  cip       = &cir;
                         const int** cipp      = &cip;

int f();                 int (*fp)()           = &f;

char a[10];              char (*ap)[10]        = &a;
                         char* cp              = &a[5];

struct S { int x; } s;   S* sp                 = &s;
                         S* sp2                = &(s = s);
                         int* ip               = &s.x;

unsigned& g();           unsigned* up          = &g();

                         const char (*lp)[14]  = &"Hello, World!";
                         const char* lp2       = &"Hello, World!"[5];
\end{emcppslisting}
    

An \romeovalue{lvalue} expression is never a \emph{temporary}; it identifies,
e.g., by name or address, a pre-existing object that will outlive the
end of the largest enclosing expression in which it resides. Applying
the built-in dereference operator \lstinline!*! to any valid, nonnull
pointer variable (i.e., to any type other than \lstinline!void!), such as
\lstinline!dp! or \lstinline!fp! in the example above, will produce an unnamed
\romeovalue{lvalue} (i.e., \lstinline!*dp! and \lstinline!*fp! are \romeovalue{lvalues})
as will invoking a function, such as \lstinline!g()! in the example above,
returning a pre-existing object by \romeovalue{lvalue} reference (i.e.,
\lstinline!g()! is an \romeovalue{lvalue}).

Our ability to assign to or otherwise modify an \romeovalue{lvalue} of
built-in type is governed entirely by whether it is
\lstinline!const!-qualified; for user-defined types, assignment is
additionally governed by whether \emph{copy} and/or \emph{move}
assignment is supported for that type; see \intraref{appendix-rvalueref}{special-member-function-generation}. Finally, note that character-string
literals (e.g., ``Hello, World!''), unlike other literals, are
considered \romeovalue{lvalues}, as illustrated by initializing \lstinline!lp!
and \lstinline!lp2! with extracted addresses, also shown in the example
above.

The invocation of assignment or compound assignment operators on
built-in types produces an \romeovalue{lvalue} as does the invocation of any
user-defined function or operator that returns an \emcppsgloss[lvalue reference]{\romeovalue{lvalue}
reference}:

\begin{emcppslisting}
struct S
{
    S& operator+=(const S&);  // operator returning (ù{\emphincomments{lvalue}}ù) reference
};

int& h();   // (ù{\codeincomments{h()}}ù) is an (ù{\emphincomments{lvalue}}ù) of type (ù{\codeincomments{int}}ù)
S& j();     // (ù{\codeincomments{j()}}ù) is an (ù{\emphincomments{lvalue}}ù) of type (ù{\codeincomments{S}}ù)

void testAssignment()
{
    int x = 7;
    x = 5;     // (ù{\codeincomments{x = 5}}ù) is an (ù{\emphincomments{lvalue}}ù) of type (ù{\codeincomments{int}}ù).
    x *= 13;   // (ù{\codeincomments{x *= 13}}ù) is an (ù{\emphincomments{lvalue}}ù) of type (ù{\codeincomments{int}}ù).
    h() = x;   // (ù{\codeincomments{h() = x}}ù) is an (ù{\emphincomments{lvalue}}ù) of type (ù{\codeincomments{int}}ù).
    S(s) = s;  // (ù{\codeincomments{S(s) = s}}ù) is an (ù{\emphincomments{lvalue}}ù) of type (ù{\codeincomments{S}}ù).
    j() = s;   // (ù{\codeincomments{j() = s}}ù) is an (ù{\emphincomments{lvalue}}ù) of type (ù{\codeincomments{S}}ù).

    S s;
    s += s;    // (ù{\codeincomments{s += s}}ù) is an (ù{\emphincomments{lvalue}}ù) of type (ù{\codeincomments{S}}ù).
}
\end{emcppslisting}
    
    
\noindent Just like for \emcppsgloss[lvalue reference]{\romeovalue{lvalue} references}, a pointer cannot be created to
point to an \emcppsgloss[rvalue reference]{\romeovalue{rvalue} reference}. Pointers themselves, however, can
be of any value category, and a reference of either variety \emph{to} a
pointer can be created. However, dereferencing any non\lstinline!void!
pointer, regardless of the value category of the pointer, produces an
\romeovalue{lvalue}:

\begin{emcppslisting}
int* pf();  // (ù{\codeincomments{pf()}}ù) is a (ù{\emphincomments{prvalue}}ù) of type (ù{\codeincomments{int*}}ù).
void testDereference()
{
    *pf();  // (ù{\codeincomments{*pf()}}ù) is an (ù{\emphincomments{lvalue}}ù) of type (ù{\codeincomments{int}}ù).

    int* p = pf();  // (ù{\codeincomments{p}}ù) is an (ù{\emphincomments{lvalue}}ù) of type (ù{\codeincomments{int*}}ù).
    *p;             // (ù{\codeincomments{*p}}ù) is an (ù{\emphincomments{lvalue}}ù) of type (ù{\codeincomments{int}}ù).
}
\end{emcppslisting}
    
    
\noindent Finally, the name of a variable is an \romeovalue{lvalue}, independent of
whether that variable is a reference, even if it is itself an
\emcppsgloss[rvalue reference]{\romeovalue{rvalue} reference}:

\begin{emcppslisting}
void testNames()
{
    int x     = 17;
    int& xr   = x;
    int&& xrv = std::move(x);

    x;    // (ù{\codeincomments{x}}ù)   is an (ù{\emphincomments{lvalue}}ù) of type (ù{\codeincomments{int}}ù)
    xr;   // (ù{\codeincomments{xr}}ù)   " "      "     "   "    "
    xrv;  // (ù{\codeincomments{xrv}}ù)  " "      "     "   "    "
}
\end{emcppslisting}
    

\paragraph[Prvalues in C++11/14]{Prvalues in C++11/14}\label{prvalues-in-c++11/14}

A \emcppsgloss[prvalue]{\romeovalue{prvalue}}, also called a pure \romeovalue{rvalue}, expression
represents a value that is not necessarily associated with an object in
memory and definitely cannot have its address taken without a conversion
that creates an object in memory. Such conversions create
\emcppsgloss[temporary object]{temporary objects} that are destroyed at the end of the
outermost enclosing expression or, if bound to a reference satisfying
the rules of \emcppsgloss{lifetime extension}, when the reference to which
they are bound ends its own lifetime; see \intraref{appendix-rvalueref}{lifetime extension}. 
%%%
[\textbf{AUs: there is no subsection called ``lifetime extension"; did you mean ``Lifetime extension of a temporary bound to a reference"?}] 
%%%
There is no requirement for the compiler to
\emcppsgloss{materialize} a \emph{temporary} underlying object representation
unless and until one is needed (e.g., to be mutated, to be moved from,
or to be bound to a named reference), and that need is fulfilled by
converting the \romeovalue{prvalue} to an \romeovalue{xvalue}, possibly creating a
temporary object in the process. One other property particular to a
\romeovalue{prvalue} expression is that it must be of \emcppsgloss{complete type},
i.e., sufficient to determine any underlying object's \emcppsgloss{size}
using the built-in \lstinline!sizeof! operator.

Literals are all \romeovalue{prvalue} expressions:

\begin{emcppslisting}
void testLiterals()
{
    5;        // (ù{\codeincomments{5}}ù)    is a literal (ù{\emphincomments{prvalue}}ù) of type (ù{\codeincomments{int}}ù).
    1.5;      // (ù{\codeincomments{1.5}}ù)  is a literal (ù{\emphincomments{prvalue}}ù) of type (ù{\codeincomments{double}}ù).
    '5';      // (ù{\codeincomments{'5'}}ù)  is a literal (ù{\emphincomments{prvalue}}ù) of type (ù{\codeincomments{char}}ù).
    true;     // (ù{\codeincomments{true}}ù) is a literal (ù{\emphincomments{prvalue}}ù) of type (ù{\codeincomments{bool}}ù).
}
\end{emcppslisting}
    
    
\noindent \noindent Enumerators are also \romeovalue{prvalues}:

\begin{emcppslisting}
enum E { B };        // (ù{\codeincomments{B}}ù) is a named (ù{\emphincomments{prvalue}}ù) of type (ù{\codeincomments{E}}ù).
\end{emcppslisting}
    
    
\noindent The results of numeric operators on built-in types are also all
\romeovalue{prvalues}:

\begin{emcppslisting}
void testExpressions()
{
    const int x = 3;     // (ù{\codeincomments{x}}ù) is a named, nonmodifiable (ù{\emphincomments{lvalue}}ù) of type (ù{\codeincomments{int}}ù).
    int y = 4;           // (ù{\codeincomments{y}}ù) is a named, modifiable (ù{\emphincomments{lvalue}}ù) of type (ù{\codeincomments{int}}ù).

    3 + 2;  // (ù{\codeincomments{3 + 2}}ù) is a compile-time (ù{\emphincomments{prvalue}}ù) of type (ù{\codeincomments{int}}ù).
    x * 2;  // (ù{\codeincomments{x * 2}}ù) is a compile-time (ù{\emphincomments{prvalue}}ù) of type (ù{\codeincomments{int}}ù).
    y - 2;  // (ù{\codeincomments{y - 2}}ù) is a (ù{\emphincomments{prvalue}}ù) of type (ù{\codeincomments{int}}ù).
    x / y;  // (ù{\codeincomments{x / y}}ù) is a (ù{\emphincomments{prvalue}}ù) of type (ù{\codeincomments{int}}ù).

    x && y;    // (ù{\codeincomments{x \&\& y}}ù) is a (ù{\emphincomments{prvalue}}ù) of type (ù{\codeincomments{bool}}ù).
    x == y;    // (ù{\codeincomments{x == y}}ù) is a (ù{\emphincomments{prvalue}}ù) of type (ù{\codeincomments{bool}}ù).
    &x;        // (ù{\codeincomments{\&x}}ù)     is a (ù{\emphincomments{prvalue}}ù) of type (ù{\codeincomments{const int*}}ù).
    int(x);    // (ù{\codeincomments{int(x)}}ù) is a (ù{\emphincomments{prvalue}}ù) of type (ù{\codeincomments{int}}ù).
}
\end{emcppslisting}
    
    
\noindent Functions that return by value and explicit temporaries of user-defined
types are also \romeovalue{prvalues}:

\begin{emcppslisting}
struct S { } s;  // (ù{\codeincomments{s}}ù) is a named, modifiable (ù{\emphincomments{lvalue}}ù) of type (ù{\codeincomments{S}}ù).
int f();         // (ù{\codeincomments{f}}ù) is a named, nonmodifiable (ù{\emphincomments{lvalue}}ù) of type (ù{\codeincomments{int(*)()}}ù).
S g();           // (ù{\codeincomments{g}}ù) is a named, nonmodifiable (ù{\emphincomments{lvalue}}ù) of type (ù{\codeincomments{S(*)()}}ù).

void testCalls()
{
    S();  // (ù{\codeincomments{S()}}ù) is a (ù{\emphincomments{prvalue}}ù) of type (ù{\codeincomments{S}}ù).
    f();  // (ù{\codeincomments{f()}}ù) is a (ù{\emphincomments{prvalue}}ù) of type (ù{\codeincomments{int}}ù).
    g();  // (ù{\codeincomments{g()}}ù) is a (ù{\emphincomments{prvalue}}ù) of type (ù{\codeincomments{S}}ù).
}
\end{emcppslisting}
    

\paragraph[Xvalues in C++11/14]{Xvalues in C++11/14}\label{xvalues-in-c++11/14}

An \emcppsgloss[xvalue]{\romeovalue{xvalue}}, also known as an expiring value, expression is
entirely new in C++11. The most salient difference between an
\romeovalue{xvalue} and a \romeovalue{prvalue} is that an \romeovalue{xvalue} expression
is \emph{guaranteed} to already be represented by an underlying object
that resides within the virtual memory space of the running process; no
such guarantee exists for a \romeovalue{prvalue} expression, leaving its
internal representation an implementation detail of the compiler.

\romeovalue{Xvalue} expressions arise when an \romeovalue{lvalue} is explicitly cast
to an \emcppsgloss[rvalue reference]{\romeovalue{rvalue} reference}:

\begin{emcppslisting}
void testXvalues()
{
    int x = 9;
    static_cast<int&&>(x);  // (ù{\codeincomments{static\_cast<int\&\&>(x)}}ù) is an (ù{\emphincomments{xvalue}}ù) of type (ù{\codeincomments{int}}ù).
    const_cast<int&&>(x);   // (ù{\codeincomments{const\_cast<int\&\&>(x)}}ù) is an (ù{\emphincomments{xvalue}}ù) of type (ù{\codeincomments{int}}ù).
    (int&&) x;              // (ù{\codeincomments{(int\&\&) x}}ù) is an (ù{\emphincomments{xvalue}}ù) of type (ù{\codeincomments{int}}ù).
}
\end{emcppslisting}
    
    
\noindent Functions and operators that return an \emcppsgloss[rvalue reference]{\romeovalue{rvalue} reference} produce
\romeovalue{xvalues} when invoked:

\begin{emcppslisting}
int&& f();  // (ù{\codeincomments{f()}}ù) is an (ù{\emphincomments{xvalue}}ù) of type (ù{\codeincomments{int}}ù).
S&& g();    // (ù{\codeincomments{g()}}ù) is an (ù{\emphincomments{xvalue}}ù) of type (ù{\codeincomments{S}}ù).

S&& operator*(const S&, const S&);  // oddly defined operator

void testOperator()
{
    int i, j;
    i * j;  // (ù{\codeincomments{i * j}}ù) is a (ù{\emphincomments{prvalue}}ù) of type (ù{\codeincomments{int}}ù).
    S a, b;
    a * b;  // (ù{\codeincomments{a * b}}ù) is an (ù{\emphincomments{xvalue}}ù) of type (ù{\codeincomments{S}}ù).
}
\end{emcppslisting}
    
    
\noindent The Standard Library utility function, \lstinline!std::move!, also produces
\romeovalue{xvalues}, as it is nothing more than a function defined to return
an \emcppsgloss[rvalue reference]{\romeovalue{rvalue} reference} to the type passed to it; see
\intrarefsimple{the-std::move-utility}.

Finally, expressions that access subobjects of any non\romeovalue{lvalue} are
\romeovalue{xvalues}, including nonstatic data member access, array
subscripting, and dereferencing pointers to data members. Note that when
any of these operations are applied to a \romeovalue{prvalue}, a temporary
needs to be created from that \romeovalue{prvalue} to contain the subobject,
so the subobject is an \romeovalue{xvalue}{\cprotect\footnote{The
identification of subobjects as \romeovalue{xvalues} rather than
\romeovalue{prvalues} or, in some cases, \romeovalue{lvalues}, has been the
subject of a number of core issues, all of which were accepted as
\emcppsgloss[defect report]{defect reports} between C++14 and C++20. Specifically,
  CWG issue 616 (\cite{stroustrup07}) and CWG issue 1213 (\cite{merrill10}) both dealt with
  changes to the \emcppsgloss[value category]{value categories} of subobject expressions.
  Also note that compiler implementations of these clarifications took
  some time, with GCC not fully supporting them until GCC 9.}}:

\begin{emcppslisting}
struct C  // (ù{\codeincomments{C()}}ù) is a (ù{\emphincomments{prvalue}}ù) of type (ù{\codeincomments{C}}ù).
{
    int d_i;
    int d_arr[5];
};

C&& h();                // (ù{\codeincomments{h()}}ù) is an (ù{\emphincomments{xvalue}}ù) of type (ù{\codeincomments{C}}ù).
int C::* pd = &C::d_i;  // pointer to (ù{\codeincomments{C::d\_i}}ù)

void testSubobjects()
{
    h().d_i;       // (ù{\codeincomments{h().d\_i}}ù) is an (ù{\emphincomments{xvalue}}ù) of type (ù{\codeincomments{int}}ù).
    C().d_i;       // (ù{\codeincomments{C().d\_i}}ù)  "  "     "     "   "    "
    h().d_arr;     // (ù{\codeincomments{h().d\_arr}}ù) is an (ù{\emphincomments{xvalue}}ù) of type (ù{\codeincomments{int[5]}}ù).
    C().d_arr;     // (ù{\codeincomments{C().d\_arr }}ù) "  "     "     "   "     "
    h().d_arr[0];  // (ù{\codeincomments{h().d\_arr[0]}}ù) is an (ù{\emphincomments{xvalue}}ù) of type (ù{\codeincomments{int}}ù).
    C().d_arr[0];  // (ù{\codeincomments{C().d\_arr[0]}}ù)  "  "     "     "   "    "
    h().*pd;       // (ù{\codeincomments{h().*pd}}ù) is an (ù{\emphincomments{xvalue}}ù) of type (ù{\codeincomments{int}}ù).
    C().*pd;       // (ù{\codeincomments{C().*pd}}ù)  "  "     "     "   "    "
}
\end{emcppslisting}
    

\subsubsection[{\itshape Rvalue} references]{{\sfbsubsubsecitalRomeo Rvalue} references}\label{rvalue-references}

C++11 introduced \romeovalue{rvalue} references, a new reference type that
uses a double ampersand, \lstinline!&&!, as part of its syntax (e.g.,
\lstinline!int&&!):

\begin{emcppslisting}
int&& r = 5;  // (ù{\codeincomments{r}}ù) is an (ù{\emphincomments{rvalue}}ù) reference initialized with a literal (ù{\codeincomments{int 5}}ù).
\end{emcppslisting}
    
    
\noindent The goal of expanding the type system to include \emcppsgloss[rvalue reference]{\romeovalue{rvalue}
references} is to allow function overloading on values that are safe to
be moved from, i.e., non\romeovalue{lvalues}. What distinguishes an
\romeovalue{rvalue} reference from the familiar \romeovalue{lvalue} reference is
that an \romeovalue{rvalue} reference will bind to \emph{only}
non\romeovalue{lvalues}. When initialized with an \romeovalue{xvalue}, an
\romeovalue{rvalue} reference is bound to the object identified by that
\romeovalue{xvalue}. When initialized with a \romeovalue{prvalue}, a temporary is
implicitly created that will have the same lifetime as the
\emcppsgloss[rvalue reference]{\romeovalue{rvalue} reference}, and the reference is bound to that temporary.

We can now exploit \emcppsgloss[value category]{value categories} to show exactly what binds
to what in the presence of a \lstinline!const!
qualifier{\cprotect\footnote{If we were to include \lstinline!volatile!, we
would double the number of possible qualifier combinations that could,
in theory, be applied to each of the three \emph{value categories};
since we know of no practical application for \lstinline!volatile!, we
  leave combinations involving it as an exercise for the reader.}}:

\begin{emcppslisting}
      int        fi();       // returns (ù{\emphincomments{prvalue}}ù) of type         (ù{\codeincomments{int}}ù)
const int       fci();       // returns (ù{\emphincomments{prvalue}}ù) of type (ù{\codeincomments{const int}}ù)
      int&    flvri();       // returns  (ù{\emphincomments{lvalue}}ù) of type         (ù{\codeincomments{int}}ù)
const int&   fclvri();       // returns  (ù{\emphincomments{lvalue}}ù) of type (ù{\codeincomments{const int}}ù)
      int&&   frvri();       // returns  (ù{\emphincomments{xvalue}}ù) of type         (ù{\codeincomments{int}}ù)
const int&&  fcrvri();       // returns  (ù{\emphincomments{xvalue}}ù) of type (ù{\codeincomments{const int}}ù)

int&& r0 =     fi();         // OK
int&& r1 =    fci();         // Error, cannot bind to (ù{\codeincomments{const}}ù) (ù{\emphincomments{prvalue}}ù).
int&& r2 =  flvri();         // Error, cannot bind to          (ù{\emphincomments{lvalue}}ù).
int&& r3 = fclvri();         // Error, cannot bind to (ù{\codeincomments{const}}ù)  (ù{\emphincomments{lvalue}}ù).
int&& r4 =  frvri();         // OK
int&& r5 = fcrvri();         // Error, cannot bind to (ù{\codeincomments{const}}ù)  (ù{\emphincomments{xvalue}}ù).

const int&& cr0 =     fi();  // OK
const int&& cr1 =    fci();  // OK
const int&& cr2 =  flvri();  // Error, cannot bind to          (ù{\emphincomments{lvalue}}ù).
const int&& cr3 = fclvri();  // Error, cannot bind to (ù{\codeincomments{const}}ù)  (ù{\emphincomments{lvalue}}ù).
const int&& cr4 =  frvri();  // OK
const int&& cr5 = fcrvri();  // OK
\end{emcppslisting}
    
    
\noindent An \romeovalue{rvalue} returned from a function can be modified provided (1)
it is of user-defined type and (2) there exists a mutating member
function; see \intraref{appendix-rvalueref}{modifiable-rvalues}. Assignment to fundamental types is not permitted
for \romeovalue{rvalues}:

\begin{emcppslisting}
struct V
{
    int d_i;                                           // public (ù{\codeincomments{int}}ù) member
    V(int i) : d_i(i) { }                              // (ù{\codeincomments{int}}ù) value constructor
    V& operator=(int rhs) { d_i = rhs; return *this; } // assignment from (ù{\codeincomments{int}}ù)
};
      V  fv(int i) { return V(i); }  // Returns non(ù{\codeincomments{const}}ù) (ù{\emphincomments{prvalue}}ù) of type (ù{\codeincomments{V}}ù).
const V fcv(int i) { return V(i); }  // Returns    (ù{\codeincomments{const}}ù) (ù{\emphincomments{prvalue}}ù) of type (ù{\codeincomments{V}}ù).

void test1()
{
    fv(2).d_i = 5;       // Error, cannot assign to (ù{\emphincomments{rvalue}}ù) (ù{\codeincomments{int}}ù)
    fv(2).operator=(5);  // OK, member assignment can be invoked on an (ù{\emphincomments{rvalue}}ù).
    fv(2) = 5;           // OK,    "        "      "   "    "     "  "     "

    fcv(2).d_i = 5;      // Error, cannot assign to (ù{\codeincomments{const}}ù) (ù{\emphincomments{rvalue}}ù) (ù{\codeincomments{int}}ù)
    fcv(2).operator=(5); // Error, assignment is a non(ù{\codeincomments{const}}ù) member function.
    fcv(2) = 5;          // Error,      "      " "  "    "       "       "
}
\end{emcppslisting}
    
    
\noindent What's more, that modified value will be preserved until the end of the
outermost expression containing the \romeovalue{rvalue} subexpression:

\begin{emcppslisting}
#include <cassert>  // standard C (ù{\codeincomments{assert}}ù) macro

void test2()
{
    int x = 1 + (V(0) = 2).d_i + 3 + (fv(0) = 4).d_i + 5;
    assert(15 == x);       // 15 == 1 + 2 + 3 + 4 + 5
}
\end{emcppslisting}
    
    
\noindent The ability to modify an unnamed, temporary \romeovalue{rvalue} directly,
however, is distinct from that of modifying a named, nontemporary
\romeovalue{rvalue} reference, which is itself an \romeovalue{lvalue}. Binding any
\romeovalue{rvalue} --- such as a default-constructed object, e.g.,
\lstinline!S()!, or a literal, e.g., \lstinline!1! --- to a \lstinline!const!
\romeovalue{lvalue} reference was always possible in C++, but subsequently
modifying it through that reference was not:

\begin{emcppslisting}
void test3()
{
      S&  lvrs = S();      // Error, cannot bind to a non(ù{\codeincomments{const}}ù) (ù{\emphincomments{lvalue}}ù) ref
const S& clvrs = S();      // OK, can bind any value to a (ù{\codeincomments{const}}ù) (ù{\emphincomments{lvalue}}ù) ref
         clvrs = S();      // Error, cannot modify via a (ù{\codeincomments{const}}ù) (ù{\emphincomments{lvalue}}ù) ref
const S* pcs1  = &clvrs;   // OK, (ù{\emphincomments{any}}ù) (ù{\codeincomments{const}}ù) (ù{\emphincomments{lvalue}}ù) reference is an (ù{\emphincomments{lvalue}}ù).

      int&  lvri = 5;      // Error, cannot bind to a non(ù{\codeincomments{const}}ù) (ù{\emphincomments{lvalue}}ù) ref
const int& clvri = 5;      // OK, can bind any value to a (ù{\codeincomments{const}}ù) (ù{\emphincomments{lvalue}}ù) ref
           clvri = 5;      // Error, cannot modify via a (ù{\codeincomments{const}}ù) (ù{\emphincomments{lvalue}}ù) ref
const int* pci1  = &clvri; // OK (ù{\emphincomments{any}}ù) (ù{\codeincomments{const}}ù) (ù{\emphincomments{lvalue}}ù) reference is an (ù{\emphincomments{lvalue}}ù).
}
\end{emcppslisting}
    
    
\noindent Notice, however, that each of the named references in the example above,
when used in an expression, is itself an \romeovalue{lvalue}, and hence it is
possible for the programmer to use the built-in unary address-of
operator, \lstinline!&!, to take the address of the possibly temporary
underlying object that initialized it.

\emcppsgloss[rvalue reference]{\romeovalue{Rvalue} references} behave similarly in that, when a
\romeovalue{prvalue} is assigned to a named \romeovalue{rvalue} reference, it too
becomes an object whose lifetime is the same as the temporary to which
the reference is bound. Unlike a non\lstinline!const! \romeovalue{lvalue}
reference, however, a non\lstinline!const! \romeovalue{rvalue} reference can be
bound to a non\lstinline!const! \romeovalue{rvalue} of the same type, in which
case that same underlying object can be subsequently modified via the
reference:

\begin{emcppslisting}
void test4()
{
      S&&  rvrs = S();    // OK, can bind a non(ù{\codeincomments{const}}ù) (ù{\emphincomments{rvalue}}ù) to an (ù{\emphincomments{rvalue}}ù) ref
const S&& crvrs = S();    // OK, can bind any (ù{\emphincomments{rvalue}}ù) to a (ù{\codeincomments{const}}ù) (ù{\emphincomments{rvalue}}ù) ref
           rvrs = S();    // OK, can modify via a (ù{\emphincomments{named}}ù) non(ù{\codeincomments{const}}ù) (ù{\emphincomments{rvalue}}ù) ref
          crvrs = S();    // Error, cannot modify via any (ù{\codeincomments{const}}ù) (ù{\emphincomments{rvalue}}ù) ref
      S* ps2  = &rvrs;    // OK, a named non(ù{\codeincomments{const}}ù) (ù{\emphincomments{rvalue}}ù) ref is an (ù{\emphincomments{lvalue}}ù).
const S* pcs2 = &crvrs;   // OK, a named (ù{\codeincomments{const}}ù) (ù{\emphincomments{rvalue}}ù) ref is an (ù{\emphincomments{lvalue}}ù).

      int&&  rvri = 5;    // OK, can bind a non(ù{\codeincomments{const}}ù) (ù{\emphincomments{rvalue}}ù) to an (ù{\emphincomments{rvalue}}ù) ref
const int&& crvri = 5;    // OK, can bind any (ù{\emphincomments{rvalue}}ù) to a (ù{\codeincomments{const}}ù) (ù{\emphincomments{rvalue}}ù) ref
             rvri = 5;    // OK, can modify via a (ù{\emphincomments{named}}ù) non(ù{\codeincomments{const}}ù) (ù{\emphincomments{rvalue}}ù) ref
            crvri = 5;    // Error, cannot modify via any (ù{\codeincomments{const}}ù) (ù{\emphincomments{rvalue}}ù) ref
      int* pi2  = &rvri;  // OK, a named non(ù{\codeincomments{const}}ù) (ù{\emphincomments{rvalue}}ù) ref is an (ù{\emphincomments{lvalue}}ù).
const int* pci2 = &crvri; // OK, a named (ù{\codeincomments{const}}ù) (ù{\emphincomments{rvalue}}ù) ref is an (ù{\emphincomments{lvalue}}ù).
}
\end{emcppslisting}
    
    
\noindent Recall that \romeovalue{rvalue} references were invented to allow library
developers to discriminate --- using overloaded functions --- between
\emph{movable} arguments, i.e., those that can be moved from safely, and
nonmovable arguments. For this reason, it was necessary to ensure that
an \romeovalue{rvalue} reference of a given type never implicitly binds to an
\romeovalue{lvalue} of corresponding type, as allowing such liberal binding
would result in \emcppsgloss{move operations} cannibalizing the state of
objects that had not been identified as ready for such activity. So
while a \lstinline!const! \romeovalue{lvalue} reference binds to \emph{all}
values, a \lstinline!const! \romeovalue{rvalue} reference is deliberately
designed \emph{not} to bind to an \romeovalue{lvalue} of the \emph{same} type
but to happily bind to an \romeovalue{rvalue} that is the result of an
implicit conversion, including an \emcppsgloss{integral promotion}, from any
other type:

\begin{emcppslisting}
double d;                       // (ù{\codeincomments{d}}ù) is a named (ù{\emphincomments{lvalue}}ù) of type (ù{\codeincomments{double}}ù).
const double cd = 0;            // (ù{\codeincomments{cd}}ù) is a named (ù{\emphincomments{lvalue}}ù) of type (ù{\codeincomments{const double}}ù).
const double fcd();             // (ù{\codeincomments{fcd}}ù) returns a (ù{\emphincomments{prvalue}}ù) of type (ù{\codeincomments{const double}}ù).

const double& clr1 = d;         // Initialize with (ù{\emphincomments{lvalue}}ù) of type (ù{\codeincomments{double}}ù).
const double& clr2 = cd;        // Initialize with (ù{\emphincomments{lvalue}}ù) of type (ù{\codeincomments{const double}}ù).
const double& clr3 = double();  // Initialize with (ù{\emphincomments{prvalue}}ù) of type (ù{\codeincomments{double}}ù).
const double& clr4 = fcd();     // Initialize with (ù{\emphincomments{prvalue}}ù) of type (ù{\codeincomments{const double}}ù).

const double&& crr1 = d;        // Error, cannot bind to (ù{\emphincomments{lvalue}}ù) of same type
const double&& crr2 = cd;       // Error, cannot bind to (ù{\emphincomments{lvalue}}ù) of same type
const double&& crr3 = double(); // Initialize with (ù{\emphincomments{prvalue}}ù) of type (ù{\codeincomments{double}}ù).
const double&& crr4 = fcd();    // Initialize with (ù{\emphincomments{prvalue}}ù) of type (ù{\codeincomments{const double}}ù).

float f;                        // (ù{\codeincomments{f}}ù) is a named (ù{\emphincomments{lvalue}}ù) of type (ù{\codeincomments{float}}ù).
const float cf = 0.0;           // (ù{\codeincomments{cf}}ù) is a named (ù{\emphincomments{lvalue}}ù) of type (ù{\codeincomments{const float}}ù).
const float fcf();              // (ù{\codeincomments{fcf}}ù) returns a (ù{\emphincomments{prvalue}}ù) of type (ù{\codeincomments{const float}}ù).

const double&& cfr1 = f;        // OK, (ù{\codeincomments{f}}ù) is converted to (ù{\emphincomments{rvalue}}ù) of type (ù{\codeincomments{double}}ù).
const double&& cfr2 = cf;       // OK, (ù{\codeincomments{cf}}ù) is converted to (ù{\emphincomments{rvalue}}ù) of type (ù{\codeincomments{double}}ù).
const double&& cfr3 = float();  // Initialize with (ù{\emphincomments{prvalue}}ù) of type (ù{\codeincomments{double}}ù).
const double&& cfr4 = fcf();    // Initialize with (ù{\emphincomments{prvalue}}ù) of type (ù{\codeincomments{const double}}ù).

short z;                        // (ù{\codeincomments{z}}ù) is a named (ù{\emphincomments{lvalue}}ù) of type (ù{\codeincomments{short int}}ù).
const int&& czr = z;            // OK, (ù{\codeincomments{z}}ù) is promoted to an (ù{\emphincomments{rvalue}}ù) of type (ù{\codeincomments{int}}ù).
\end{emcppslisting}
    
    
\noindent If the type of the \romeovalue{rvalue} initializing a non\lstinline!const!
\romeovalue{rvalue} reference is \emph{not} the same type as that of the
reference, a new underlying object will be \emcppsgloss[materialize]{materialized}; any
subsequent modification via the reference will have no effect on the
original value. Note that, in the example below, we have used the
\lstinline!std::move! utility to cast the \romeovalue{lvalues} \lstinline!c! and
\lstinline!u! to their respective \romeovalue{xvalue} ---i.e., unnamed
\romeovalue{rvalue} reference --- counterparts, which are now treated as
\romeovalue{rvalues} and are therefore \emph{movable}; see \intrarefsimple{the-std::move-utility}:

\begin{emcppslisting}
#include <cassert>  // standard C (ù{\codeincomments{assert}}ù) macro

void test4()
{
    char          c  = 1;
    unsigned char u  = 2;

    char&& rc = std::move(c);  // (ù{\codeincomments{rc}}ù) refers to (ù{\codeincomments{c}}ù).
    char&& ru = std::move(u);  // temporary (ù{\codeincomments{char}}ù) created

    assert(&rc == &c);  // (ù{\codeincomments{rc}}ù) refers to (ù{\codeincomments{c}}ù).
    assert(&ru != &u);  // (ù{\codeincomments{ru}}ù) refers to a different (ù{\codeincomments{char}}ù).

    rc = 7;  assert(7 == c);  // (ù{\codeincomments{c}}ù) modified through (ù{\codeincomments{rc}}ù)
    ru = 8;  assert(2 == u);  // (ù{\codeincomments{u}}ù) unchanged
}  // Temporary lifetime ends with all other variables here.
\end{emcppslisting}
    
    
\paragraph[Overloading on reference types]{Overloading on reference types}\label{overloading-on-reference-types}

The entire purpose of having a new kind of reference that binds
exclusively to \romeovalue{rvalues} is so that existing overload sets
employing a \lstinline!const! \romeovalue{lvalue} reference can be augmented so
that, when the same named function is invoked with a non\romeovalue{lvalue},
the new overload will be given preference, which can then move from its
argument. For example, consider a function, e.g., \lstinline!g! in the
example below, that takes an object of user-defined type \lstinline!C!,
which it \emph{might} need to copy and manipulate internally before
returning a value, e.g., an \lstinline!int!{\cprotect\footnote{Note that,
even if we were sometimes inclined to pass user-defined types by
value, we would \emph{not} want to do so here for fear we might end up
making an expensive copy for no reason; see \intrarefsimple{passing-movable-objects-by-value}.}}:

\begin{emcppslisting}
class C { /*...*/ };  // some UDT that might benefit from being "moved"

int g(const C& c);  // (1) [original] takes argument by (ù{\codeincomments{const}}ù) (ù{\emphincomments{lvalue}}ù) reference.
int g(C&& c);       // (2) [additional] takes argument by non(ù{\codeincomments{const}}ù) (ù{\emphincomments{rvalue}}ù) ref.
\end{emcppslisting}
    
    
\noindent Let's now consider calling this function \lstinline!g! on expressions
having various kinds of values, e.g., \romeovalue{lvalues} versus
\romeovalue{rvalues} and \lstinline!const! versus non\lstinline!const!:

\begin{emcppslisting}
      C c;     // (ù{\codeincomments{c}}ù) is a named (ù{\emphincomments{lvalue}}ù) of type (ù{\codeincomments{C}}ù).
const C cc;    // (ù{\codeincomments{cc}}ù) is a named (ù{\emphincomments{lvalue}}ù) of type (ù{\codeincomments{const C}}ù).
const C fc();  // (ù{\codeincomments{fc()}}ù) is an unnamed (ù{\emphincomments{rvalue}}ù) of type (ù{\codeincomments{const C}}ù).

int i1 = g(c);     // OK, invokes overload (ù{\codeincomments{g(const C\&)}}ù) because (ù{\codeincomments{c}}ù) is an (ù{\emphincomments{lvalue}}ù)
int i2 = g(C());   // OK, invokes overload (ù{\codeincomments{g(C\&\&)}}ù) because (ù{\codeincomments{C()}}ù) is a (ù{\emphincomments{prvalue}}ù)
int i3 = g(cc);    // OK, invokes overload (ù{\codeincomments{g(const C\&)}}ù) because (ù{\codeincomments{cc}}ù) is (ù{\codeincomments{const}}ù)
int i4 = g(fc());  // OK, invokes overload (ù{\codeincomments{g(const C\&)}}ù) because (ù{\codeincomments{fc()}}ù) is (ù{\codeincomments{const}}ù)
\end{emcppslisting}
    
    
\noindent In this scenario, if an argument to \lstinline!g! in the code snippet above
is a non\lstinline!const! \romeovalue{rvalue} (and therefore known to be movable
and potentially a \emph{temporary}), it will bind more strongly to
\lstinline!g(C&&)!. Non\romeovalue{rvalue} and \lstinline!const! arguments to
\lstinline!g! will not consider \lstinline!g(C&&)! at all but are viable to
pass to \lstinline!g(const!~\lstinline!C&)!, so that overload will be chosen.
Should either overload be chosen with a \romeovalue{prvalue}, a temporary will
be created that will then be destroyed at the end of the invoking
expression.

Note that adding an \romeovalue{rvalue} reference overload of \lstinline!g! does
not add to the set of usable arguments for \lstinline!g!. That is, anything
that can bind to a \lstinline!C&&! can also bind to a
\lstinline!const!~\lstinline!C&!. A corollary to this observation is that,
given any function having an overload set that contains a
\lstinline!const!~\lstinline!T&! parameter, one can \emph{safely} introduce a
parallel overload having a \lstinline!T&&! parameter in the corresponding
position with the desired effect that, when that function is called with
an argument that is safely movable in that position, the newly added
\romeovalue{rvalue}-reference overload will be called instead.

In the most general case, there are six --- twelve if you consider
\lstinline!volatile! --- combinations of ways to pass an argument to a
function (see Table \ref{rvalueref-table1}).\newpage%%%%% 
\begin{table}[h!]
\begin{center}
\begin{threeparttable}
\caption{AUs: Pls add a caption.}\label{rvalueref-table1} \vspace{1.5ex}
{\small \begin{tabular}{c|c|c}\thickhline
\rowcolor[gray]{.9} {} &   {\sffamily\bfseries non\lstinline!const!} & {\sffamily\bfseries \lstinline!const!} \\\hline
value & \lstinline!T! & \lstinline!const!~\lstinline!T!\\ \hline
\romeovalue{lvalue} reference  & \lstinline!T&! & \lstinline!const!~\lstinline!T&!\\ \hline
\romeovalue{rvalue} reference & \lstinline!T&&! & \lstinline!const!~\lstinline!T&&!\\ \thickhline
\end{tabular}
}
\end{threeparttable}
    \end{center}
\end{table}



\noindent One could, in principle, overload a function such as \lstinline!g! in Table \ref{rvalueref-table1} with all six variants, but doing so would lead to ambiguity
as passing \emph{by} \emph{value}, \lstinline!T!, and passing \emph{by}
\romeovalue{lvalue} \emph{reference}, \lstinline!T&!, are equivalently good
matches as are passing by value, \lstinline!T!, and passing by
\lstinline!const! value, \lstinline!const!~\lstinline!T!. Hence, in practice, one
passes an object either by value (or \lstinline!const! value) or else some
subset of the four possible reference variants (see the example below).
Having such flexibility, however, is seldom useful.

Consider, for example, a function \lstinline!h! that is overloaded on a
non\lstinline!const! \romeovalue{lvalue} and a non\lstinline!const! \romeovalue{rvalue}:

\begin{emcppslisting}
void h(C&  inOut);   // (3) OK, accepts only non(ù{\codeincomments{const}}ù) (ù{\emphincomments{lvalues}}ù)
void h(C&& inOnly);  // (4) OK, accepts only non(ù{\codeincomments{const}}ù) (ù{\emphincomments{rvalues}}ù)
\end{emcppslisting}
    
    
\noindent As was the explicit intent of the inventors of \emph{rvalue references},
an overload set like \lstinline!h! provides the ability to distinguish
programmatically between non\lstinline!const! objects that are (1)
\romeovalue{lvalues}, and therefore are \emph{not} known to be safe to be
\emph{moved from}, and (2) non\romeovalue{lvalues}, and therefore \emph{are}
presumed to be safe to be \emph{moved from}, yet exclude any object
whose type is qualified with \lstinline!const!:

\begin{emcppslisting}
void test(C& lv, const C& clv, const C&& crv)
{
    h(lv);              // (5) OK, invokes (ù{\codeincomments{(3)}}ù) because (ù{\codeincomments{lv}}ù) is an (ù{\emphincomments{lvalue}}ù)
    h(C());             // (6) OK, invokes (ù{\codeincomments{(4)}}ù) because (ù{\codeincomments{C()}}ù) is an (ù{\emphincomments{rvalue}}ù)
    h(clv);             // (7) Error, (ù{\codeincomments{clv}}ù) is (ù{\codeincomments{const}}ù). No overload of (ù{\codeincomments{h}}ù) matches.
    h(std::move(crv));  // (8) Error, (ù{\codeincomments{crv}}ù) is (ù{\codeincomments{const}}ù). No overload of (ù{\codeincomments{h}}ù) matches.
}
\end{emcppslisting}
    
    
\noindent But consider that having such an overload set is typically
counterindicated. Without the \romeovalue{rvalue} reference overload, invoking
\lstinline!h! on a \emph{temporary} would simply fail to compile, thereby
avoiding a runtime defect. With that \romeovalue{rvalue}-reference overload
present, the code will in fact compile, but now any output written to
that \emph{temporary} will silently disappear along with that temporary.

Although seldom needed, we provide in Table \ref{rvalueref-table2} for completeness the relative
priority in which pass-by-reference members of an overload set would be
selected.\newpage%%%%%%%
\begin{table}[h!]
\begin{center}
\begin{threeparttable}
\caption{AUs: pls add a caption}\label{rvalueref-table2} \vspace{1.5ex}
{\small \begin{tabular}{c|c|c|c|c|c}\thickhline
\rowcolor[gray]{.9}    {\sffamily\bfseries Value Category} & {\sffamily\bfseries E.g.} & {\sffamily\bfseries \lstinline!g(C&)!} & {\sffamily\bfseries \lstinline!g(const C&)!} & {\sffamily\bfseries \lstinline!g(C&&)!} & {\sffamily\bfseries \lstinline!g(const C&&)!}\\\hline
non\lstinline!const! \romeovalue{lvalue} & \lstinline!c! & 1 & 2 & N/A & N/A\\ \hline
\lstinline!const! \romeovalue{lvalue}  & \lstinline!cc! & N/A & 1 & N/A & N/A\\ \hline
non\lstinline!const! \romeovalue{rvalue} & \lstinline!C()! & N/A & 3 & 1 & 2\\ \hline
\lstinline!const! \romeovalue{rvalue} & \lstinline!fc()! & N/A & 2 & N/A & 1\\ \thickhline
\end{tabular}
}
\end{threeparttable}
    \end{center}
\end{table}
    
    
\noindent Note that the equivalent function to \lstinline!fc! for a built-in type,
\lstinline!const!~\lstinline!int!~\lstinline!fi()!, would return a
non\lstinline!const! \romeovalue{rvalue}, as fundamental types returned by
\lstinline!const! value are treated as if they had been returned by
non\lstinline!const! value. The only way to have a function that returns a
\lstinline!const! \romeovalue{rvalue} of primitive type \lstinline!T! is to have it
return \lstinline!const!~\lstinline!T&&!, such as
\lstinline!const!~\lstinline!int&&!~\lstinline!fi2()!.

\paragraph[{\itshape Rvalue} references in expressions]{{\sfbparaitalRomeo Rvalue} references in expressions}\label{rvalue-references-in-expressions}

Recall from \intrarefsimple{lvalues-in-c++11/14} that the name
of any variable, including an \emcppsgloss[rvalue reference]{\romeovalue{rvalue} reference}, is itself an
\romeovalue{lvalue}:

\begin{emcppslisting}
#include <utility>  // (ù{\codeincomments{std::move}}ù)

struct S { };

void test()
{
    S   s1;                  // local variable of type (ù{\codeincomments{S}}ù)
    S&& s2 = s1;             // Error, (ù{\codeincomments{s1}}ù) is an (ù{\emphincomments{lvalue}}ù).
    S&& s3 = std::move(s1);  // OK, (ù{\codeincomments{std::move(s1)}}ù) is an (ù{\emphincomments{xvalue}}ù).
    S&& s4 = s3;             // Error, (ù{\codeincomments{s3}}ù) is an (ù{\emphincomments{lvalue}}ù).
    S&& s5 = std::move(s3);  // OK, (ù{\codeincomments{std::move(s3)}}ù) is an (ù{\emphincomments{xvalue}}ù).
}
\end{emcppslisting}
    
    
\noindent This important fact helps to ensure that a reference is not accidentally
used as an \romeovalue{xvalue} prior to the last time that its value is
needed:

\begin{emcppslisting}
void f(const S& s);  // only reads the value of (ù{\codeincomments{s}}ù)
void f(S&& s);       // consumes the value of (ù{\codeincomments{s}}ù)

void test2(S&& s)
{
    f(s);             // invokes (ù{\codeincomments{int f(constS\&)}}ù)
    f(std::move(s));  // invokes (ù{\codeincomments{int f(S\&\&)}}ù)
}
\end{emcppslisting}
    
    
\noindent While unintuitive at first glance, it is important to consider how the
function \lstinline!test2!, in the example above, would behave if an
\emcppsgloss[rvalue reference]{\romeovalue{rvalue} reference} were itself an \romeovalue{rvalue}. The invocation
\lstinline!f(s)! would invoke \lstinline!void!~\lstinline!f(S&&)!, which would
result in consuming the value of \lstinline!s! and leaving it in an
unspecified state. The subsequent invocation of \lstinline!f(std::move(s))!
would then be attempting to process a moved-from object, which almost
certainly would not be the intent of the writer of \lstinline!test2!.

The final use of an \emcppsgloss[rvalue reference]{\romeovalue{rvalue} reference} in a given context could
conceivably be treated as an \romeovalue{xvalue}, but up to this point in the
evolution of C++, that has been done only in the relatively narrow case
where variables having \emcppsgloss{automatic storage duration} are used in
\lstinline!return! statements; see \intrarefsimple{implicit-moves-from-lvalues-in-return-statements}. Additional
implicit moves might be added to the language in the future but only if
it the proposals brought to the Standards committee make a convincing
case that such additions carry little or no risk of silently doing harm.

\paragraph[The \lstinline!std::move! utility]{The {\ParaCode std::move} utility}\label{the-std::move-utility}

A large part of the original motivation for having a new value category,
dubbed \romeovalue{xvalues}, was to intersect the notions of
\emph{reachability} and \emph{movability}; see {Appendix - Why do we
need another value category?}. The way we typically do that, e.g., in
the case of moving an element in a vector from one position to another,
is to cast a pre-existing \romeovalue{lvalue} to an \emcppsgloss[rvalue reference]{\romeovalue{rvalue} reference}:

\begin{emcppslisting}
struct S { };  // some UDT that might benefit from being moved

int f(const S&  s);  // (1) takes any kind of (ù{\codeincomments{S}}ù) but with lower priority
int f(      S&& s);  // (2) takes only (ù{\emphincomments{movable}}ù) kinds of (ù{\codeincomments{S}}ù) with high priority

S s;  // (ù{\codeincomments{s}}ù) is a named (ù{\emphincomments{lvalue}}ù); (ù{\codeincomments{(s)}}ù) is a non(ù{\codeincomments{const}}ù) (ù{\emphincomments{lvalue}}ù)-(ù{\emphincomments{reference}}ù) expression.

int i1 = f(s);                  // calls (1); can (ù{\emphincomments{copy}}ù)-construct local (ù{\codeincomments{S}}ù) from (ù{\codeincomments{s}}ù)
int i2 = f(const_cast<S&&>(s)); // calls (2); can (ù{\emphincomments{move}}ù)-construct local (ù{\codeincomments{S}}ù) from (ù{\codeincomments{s}}ù)
\end{emcppslisting}
    
    
\noindent Note that use of a \lstinline!const_cast! would allow even a
\lstinline!const!~\lstinline!S! to be converted to a non\lstinline!const!
\romeovalue{rvalue} reference, while a \lstinline!static_cast! would enable a
conversion from a type convertible to \lstinline!S! to be bound to an
\romeovalue{rvalue} \emph{reference}, either of which would typically have
unintended consequences. Given that an essential part of the design of
\romeovalue{rvalue} references involves a specialized \emph{cast} that must
preserve the C++ type and \lstinline!const!ness, while changing the value
category, it was decided that the best approach to performing the
conversion was a library utility function template that deduced the C++
type, ignoring reference qualifiers, and then used a
\lstinline!static_cast!, as opposed to a \lstinline!const_cast!, in its
implementation. One plausible implementation --- using forwarding
references, \lstinline!constexpr!, and the \lstinline!noexcept! decorator ---
is provided here for concreteness; see \featureref{\locationc}{forwardingref}, \featureref{}{}, 
% 
\textbf{[AUs: there is no feature called constexpr keyword; we have constexpr function, constexpr variable, and relaxed constexpr]}
%
and
\featureref{\locatione}{noexcept-specifier}:

\begin{emcppslisting}
// utility:
namespace std
{
    template <typename T> struct __RemoveReference      { typedef T type; };
    template <typename T> struct __RemoveReference<T&>  { typedef T type; };
    template <typename T> struct __RemoveReference<T&&> { typedef T type; };

    template <typename T>
    constexpr typename __RemoveReference<T>::type&& move(T&& expression) noexcept
    {
        return static_cast<typename RemoveReference<T>::type&&>(expression);
    }
}
\end{emcppslisting}
    
    
\noindent As the example implementation above indicates, the name of this standard
function template is \lstinline!move!, it resides in the \lstinline!std!
namespace, and it can be found in the Standard \lstinline!<utility>! header
file. This function is used just as one would use a
\lstinline!static_cast! to convert an \romeovalue{lvalue}-reference expression
to an unnamed, \romeovalue{rvalue}-reference expression, except that the C++
type is deduced automatically rather than giving the user the
opportunity to accidentally misspecify it:

\begin{emcppslisting}
#include <utility>  // (ù{\codeincomments{std::move}}ù)

S t1, t2;  // two similar objects that are each movable

int i3 = f(static_cast<S&&>(t1));  // can (ù{\emphincomments{move}}ù)-construct a local (ù{\codeincomments{S}}ù) from (ù{\codeincomments{t1}}ù)
int i4 = f(std::move(t2));         // can (ù{\emphincomments{move}}ù)-construct a local (ù{\codeincomments{S}}ù) from (ù{\codeincomments{t2}}ù)
\end{emcppslisting}
    
    
\noindent The choice of \emph{move} for the name of this specialized cast to
\romeovalue{rvalue} reference can, however, be confusing; see
\intraref{annoyances-rvalueref}{std::move-does-not-move}.

\paragraph[Special member function generation]{Special member function generation}\label{special-member-function-generation}

Given the new capability of having additional function overloads for
\emcppsgloss[rvalue reference]{\romeovalue{rvalue} reference} parameters, two new \emcppsgloss{special member
functions} were also added in C++11.

\begin{enumerate}
%
\item{A \emcppsgloss{move constructor} for a type, \lstinline!X!, is a constructor that can be invoked with a single \emcppsgloss[rvalue reference]{\romeovalue{rvalue} reference} to \lstinline!X!. There are two requirements: (1) The first parameter of the constructor must be a \emcppsgloss[cv qualifiers]{cv-qualified} \emcppsgloss[rvalue reference]{\romeovalue{rvalue} reference} to \lstinline!X!, i.e., either \lstinline!X&&!, \lstinline!const!~\lstinline!X&&!, \lstinline!volatile!~\lstinline!X&&!, or \lstinline!const!~\lstinline!volatile!~\lstinline!X&&!, and (2) the constructor must have exactly one parameter or all parameters after the first must have default values:
\begin{emcppslisting}
struct S1 { S1(S1&&); };             // move constructor
struct S2 { S2(const S2&&); };       //  "        "
struct S3 { S3(S3&&, int i = 0); };  //  "        "
struct S4 { S4(S4&&, int i); };      // not a move constructor
struct S5 { S5(int&&); };            //  "  "  "        "
struct S6 { S6(S6&); };              //  "  "  "        "
\end{emcppslisting}
}
%
\item{A \emcppsgloss[move assignment operator]{move-assignment operator} for a type \lstinline!X! is a nonstatic, nontemplate member function named \lstinline!operator=! with exactly one parameter that is a \emcppsgloss[cv qualifiers]{cv-qualified} \emcppsgloss[rvalue reference]{\romeovalue{rvalue} reference} to \lstinline!X!, i.e., either \lstinline!X&&!, \lstinline!const!~\lstinline!X&&!, \lstinline!volatile!~\lstinline!X&&!, or \lstinline!const!~\lstinline!volatile!~\lstinline!X&&!. Any return type and value is valid for a \emcppsgloss[move assignment operator]{move-assignment operator}, but the common convention is to have a return type of \lstinline!X&! and to return \lstinline!*this!.}
\end{enumerate}

Just as with other special member functions, when not declared
explicitly it is possible for the \emcppsgloss{move constructor} and
\emcppsgloss[move assignment operator]{move-assignment operator} to be implicitly declared for a
\lstinline!class!, \lstinline!struct!, or \lstinline!union!.

% note: removed xref to specific section within another feature; John changed his mind and doesn't want that. 
\begin{itemize}
\item{An implicitly declared \emcppsgloss{move constructor} will be declared if there are no user-declared copy or move constructors, no user-declared copy or move-assignment operators, and no user-declared \emcppsgloss{destructor}.\cprotect\footnote{For more on the implicit generation of special member functions, see 
%\intraref{appendix-default}{special-member-function-generation} within 
\featureref{\locationa}{defaulted-special-member-functions}.} The implicit move constructor for a type, \lstinline!X!, will have the signature \lstinline!X::X(X&&)!. The exception specification and triviality of this constructor is determined by the element-wise move constructors of all bases and nonstatic data members of \lstinline!X!, and the definition will do a memberwise move-construction of all bases and nonstatic data members.}
\end{itemize}

\begin{itemize}
\item{An implicitly declared \emcppsgloss[move assignment operator]{move-assignment operator} will be declared if there are no user-declared copy or move constructors, no user-declared copy or move-assignment operators, and no user-declared \emcppsgloss{destructor}. The implicit move-assignment operator for a type, \lstinline!X!, will have the signature \lstinline!X&!~\lstinline!operator=(X&&)!. The exception specification and triviality of this operator is determined by the element-wise move-assignment operators of all bases and nonstatic data members of \lstinline!X!, and the definition will do a memberwise move-assignment of all bases and nonstatic data members.}
\end{itemize}

\paragraph[Moves from {\itshape rvalues} in \lstinline!return! statements]{Moves from {\sfbparaitalRomeo rvalues} in {\ParaCode return} statements}\label{moves-from-rvalues-in-return-statements}

When the expression returned from a function is a \romeovalue{prvalue}, the
return value will be initialized via move construction:

\begin{emcppslisting}
struct S { };

S f1() { return S{}; }  // returns a (ù{\emphincomments{prvalue}}ù)

void test1()
{
    S s = f1();
}
\end{emcppslisting}
    
    
\noindent The local variable \lstinline!s! in \lstinline!test1! above may be initialized
in one of two ways. At a minimum, a temporary will be created within the
body of \lstinline!f1! and used as an \romeovalue{rvalue} to copy construct
\lstinline!s! within \lstinline!test1!. The example is a perfect example for
what has come to be known as \emcppsgloss[return value optimization (RVO)]{return-value optimization (RVO)}.
Instead of constructing the object within the function and then copying
--- or even moving --- it to the caller, space for the
\emcppsgloss{footprint} of the object is reserved in the caller's scope, and
then the object is constructed just once, \emcppsgloss{in place}, and is
initialized by the returned \romeovalue{prvalue}; see \intraref{potential-pitfalls-rvalueref}{RVO and NRVO affect observable behavior}. 
%
[\textbf{AUs: there is no Pitfalls subsection called ``RVO and NRVO affect observable behavior"; what did you intend?}]
%
This reduces to zero the number of additional constructor calls beyond
the initial call, the best number of operations to invoke from the
perspective of the performance-minded.{\cprotect\footnote{C++17 mandates
that there be no additional object created when a function returns a
  \romeovalue{prvalue}, effectively guaranteeing \emcppsgloss{copy elision}.}}

Return values can be move-constructed when the returned expression is an
\romeovalue{xvalue} as well:

\begin{emcppslisting}
S f2()
{
    S s;
    return std::move(s);  // returns an (ù{\emphincomments{xvalue}}ù)
}
\end{emcppslisting}
    
    
\noindent In this case, the object initialized by the return value of this
function will be constructed with an \emcppsgloss[rvalue reference]{\romeovalue{rvalue} reference} to
\lstinline!s!. It is important to note, however, that explicitly making
such \romeovalue{lvalues} into \romeovalue{xvalues} on return might not be needed
and, in some cases, might prevent \emcppsgloss[named return value optimization]{NRVO}; see
\intrarefsimple{implicit-moves-from-lvalues-in-return-statements}.


Finally, if a \romeovalue{prvalue} expression is to be returned, it is
strongly contraindicated to use \lstinline!std::move! to force a move from
that \romeovalue{prvalue}:

\begin{emcppslisting}
S f3()
{
    return std::move(S{});  // BAD IDEA
}
\end{emcppslisting}
    
    
\noindent Applying \lstinline!std::move! as in \lstinline!f3! in the example above does
more than just cast an expression to a particular type; it requires that
there be an object to pass to the utility function. In this case, a
temporary will have to be materialized to be the argument to
\lstinline!std::move!, and there will no longer be the possibility of
eliding all moves and applying \emcppsgloss[return value optimization (RVO)]{RVO}.

\paragraph[Implicit moves from {\itshape lvalues} in \lstinline!return! statements]{Implicit moves from {\sfbparaitalRomeo lvalues} in {\ParaCode return} statements}\label{implicit-moves-from-lvalues-in-return-statements}

Any time the use of an object coincides with the last time that object
can be referenced, it might be beneficial to treat that object as an
\romeovalue{xvalue} instead of an \romeovalue{lvalue} so we can reuse the resources
owned by that object before they are released by the destructor. As we
have seen, temporaries created by an expression will automatically be
treated as \romeovalue{xvalues} and are one of the primary means by which
\romeovalue{xvalues} are generated by expressions.

In a \lstinline!return! statement, the lifetime of all variables with
\emcppsgloss{automatic storage duration} --- namely, non\lstinline!volatile!
local variables and function parameters --- ends implicitly after the
statement. This enables any \lstinline!return! statement that names such a
variable to treat the returned expression as an \romeovalue{xvalue} instead of
an \romeovalue{lvalue}, resulting in move construction of the return value
instead of copy construction{\cprotect\footnote{C++20 introduced the
concept of an \emcppsgloss{implicitly movable entity} for those automatic
storage duration objects that will implicitly be moved when returned
in this way. This concept was also extended to include \emcppsgloss[rvalue reference]{\romeovalue{rvalue}
references} (to non\lstinline!volatile! objects):

\begin{emcppslisting}[style=footcode]
S f3(S&& in)
{
    return in;  // (ù{\codeincomments{in}}ù) is an (ù{\emphincomments{lvalue}}ù) in C++11-17 and an (ù{\emphincomments{xvalue}}ù) in C++20.
}
\end{emcppslisting}
\vspace*{-2ex}
      }}:

\begin{emcppslisting}

struct S { };
void g(const S&);
void g(S&&);

S f1()
{
    S s;
    g(s);      // (ù{\codeincomments{s}}ù) is (ù{\codeincomments{not}}ù) an (ù{\emphincomments{xvalue}}ù) and selects (ù{\codeincomments{g(const S\&)}}ù).
    return s;  // (ù{\codeincomments{s}}ù) is an (ù{\emphincomments{xvalue}}ù).
}

S f2(S in)
{
    g(in);      // (ù{\codeincomments{in}}ù) is (ù{\codeincomments{not}}ù) an (ù{\emphincomments{xvalue}}ù) and selects (ù{\codeincomments{g(const S\&)}}ù).
    return in;  // (ù{\codeincomments{in}}ù) is an (ù{\emphincomments{xvalue}}ù).
}
\end{emcppslisting}
    
    
\noindent This conversion to \romeovalue{xvalue} broadly overlaps the cases where an
automatic variable is eligible for \emcppsgloss{copy elision}, otherwise
known as the \emcppsgloss[named return value optimization]{named return-value optimization}. When an automatic
variable has the same type as the return type of a function and when
that variable is named as the expression of a \lstinline!return! statement,
the copy implied by the \lstinline!return! statement can be omitted, and
instead only one object will be constructed in the footprint of the
target of the return value:

\begin{emcppslisting}
S* s1Addr = nullptr;

S nrvo1()
{
    S s1;
    s1Addr = &s1;   // store address of automatic variable
    return s1;
}

void callNrvo1()
{
    S s2 = nrvo1();
    assert(s1Addr == &s2);  // implementation dependent, not guaranteed
}
\end{emcppslisting}
    
    
\noindent This optimization is not guaranteed and might be dependent on
optimization levels and properties of the type in question; see
\intraref{potential-pitfalls-rvalueref}{RVO and NRVO affect
observable behavior}.
%
[\textbf{AUs: there is no Pitfalls subsection called ``RVO and NRVO affect observable behavior"; what did you intend?}]
%

Functions that are eligible for \emcppsgloss{NRVO} also meet the requirements
for move-constructing their return values, even if \emcppsgloss{NRVO} does
not take effect. This means that, at worst, functions like \lstinline!f1!
and \lstinline!nrvo1! in the code snippet above will invoke a single
\emcppsgloss{move constructor} to initialize their return values and, at
best, will invoke nothing at all. Compare this to the following
function:

\begin{emcppslisting}
S f4()
{
    S s;
    return std::move(s);
}
\end{emcppslisting}
    
    
\noindent Here, by explicitly using \lstinline!std::move! to move from the local
variable to the return value, we have also made this function no longer
eligible for \emcppsgloss{NRVO}, as the return expression is a function call
and not just the name of a local variable. This results in \emph{always}
invoking a \emcppsgloss{move constructor} to initialize the return value and
never eliding the additional object at all.

In general, when an object's lifetime is about to end and it will
potentially be treated implicitly as an \romeovalue{xvalue}, it is a
reasonable, relatively future-proof, rule of thumb to \emph{not}
explicitly use \lstinline!std::move!. In current code, the move will happen
either way, and in future Standards the extra object might be elided
completely as the language evolves.{\cprotect\footnote{Proposals such as
\cite{zhilin21} which makes \emcppsgloss{NRVO} apply more broadly and be
guaranteed in a fashion similar to \emcppsgloss[return value optimization (RVO)]{RVO} in C++17,
\cite{odwyer19}, which added \emcppsgloss[implicitly movable entity]{implicitly movable entities} to
C++20, and \cite{odwyer21} which improves the handling of
\emcppsgloss[implicitly movable entity]{implicitly movable entities}, all lead to improvements to
functions that do not explicitly move, while making no changes or
  improvements to functions that explicitly move.}}

When the type of a local variable used in a \lstinline!return! statement
does \emph{not} exactly match the nonreference C++ type being returned,
then the explicit use of \lstinline!std::move! \emph{is} indicated: A
conversion to the return type will always occur in that case. The
explicit cast to an \romeovalue{rvalue} reference guarantees that the result
of the conversion will be created by \emph{moving} \emph{from} the
object named in the \lstinline!return! statement. Note that some types of
\emph{move} \emph{conversions}, e.g., those resulting from \emph{move}
\emph{construction}, would happen even without the explicit use of
\lstinline!std::move! but there is, however, no situation where having an
explicit \lstinline!std::move! pessimizes the creation of the result
object, but see \intraref{potential-pitfalls-rvalueref}{}.
% 
\textbf{[AUs: there is no section within Pitfalls called ``Pessimizing moves"; what did you intend?]}
%

When something more complicated than the name of an automatic variable
is used as the expression of a \lstinline!return! statement, the explicit
use of \lstinline!std::move! is also indicated, as none of the rules that
might enable \emcppsgloss{copy elision} are potentially applicable:

\begin{emcppslisting}
S f5(bool flag)
{
    S a, b;
    return flag ? std::move(a) : std::move(b);  // (ù{\codeincomments{std::move}}ù) needed
}

S f6()
{
    S a;
    return 1, std::move(s);  // (ù{\codeincomments{std::move}}ù) needed
}
\end{emcppslisting}
    

\paragraph[When to move return values]{When to move return values}\label{when-to-move-return-values}

What can a poor programmer do to ensure that (1) a copy is always
avoided where possible and (2) copy elision is never pessimized by an
explicit cast?

Following six simple rules of thumb will achieve both of these goals
now, and the resulting code should remain future-proof in perpetuity.

\begin{enumerate}
%
\item{First, do no harm. If there is a possibility that a value might subsequently be referenced from some other part of the program, then an explicit cast is \emph{not} indicated:
\begin{emcppslisting}
S f1(S* s)
{
    return *s;  // explicit cast (ù{\emphincomments{not}}ù) indicated
}

S s1;  // externally reachable variable

S g1()
{
    return s1;  // explicit cast (ù{\emphincomments{not}}ù) indicated
}
\end{emcppslisting}
    
\noindent Moving from such an object might result in unintended and possibly
incorrect behavior.}
%
\item{If the expression being returned is a \romeovalue{prvalue} (e.g., the anonymous construction of an object or a call to a function returning an object by value), then an explicit cast is \emph{not} indicated:
\begin{emcppslisting}
S f2()
{
    return S(/*...*/);  // explicit cast (ù{\emphincomments{not}}ù) indicated
}

S g2()
{
    return f2(/*...*/);  // explicit cast (ù{\emphincomments{not}}ù) indicated
}
\end{emcppslisting}
       
\noindent It is precisely these cases in which the unnamed, return-value
optimization (\emcppsgloss[return value optimization (RVO)]{RVO}) is likely to kick in, thereby eliding even
move construction; providing an explicit cast would effectively disable
\emcppsgloss[return value optimization (RVO)]{RVO}, forcing two objects to be created instead of just one.}
%
\item{If the expression in a \lstinline!return! statement consists of just the name of a locally declared nonreference variable, including a by-value parameter or one in a local \lstinline!catch! clause, and exactly matches the \lstinline!return! type of the function, an explicit cast is \emph{not} indicated:
\begin{emcppslisting}
S f3()
{
    S s;
    return s;  // explicit cast (ù{\emphincomments{not}}ù) indicated
}

S g3(S s)
{
    return s;  // explicit cast (ù{\emphincomments{not}}ù) indicated
}

S h3()
{
    try
    {
        // ...
    }
    catch (S s)
    {
        return s;  // explicit cast (ù{\emphincomments{not}}ù) indicated
    }
}
\end{emcppslisting}
    
\noindent In some cases, \emcppsgloss{NRVO} will cause local objects to be constructed
directly in the result; otherwise, an implicit cast is guaranteed so the
object will move if the type supports move construction. Although the
argument of a \lstinline!catch!-clause parameter will never be optimized
away, it too will be moved implicitly, and attempting to explicitly cast
it unnecessarily might even trigger compiler warnings.}
%
\item{If the expression in a \lstinline!return! statement consists of the name of a locally declared nonreference variable that does not exactly match the \lstinline!return! type of the function, an explicit cast \emph{is} indicated:
\begin{emcppslisting}
T f4()  // (ù{\codeincomments{S}}ù) is convertible to (ù{\codeincomments{T}}ù).
{
    S s;
    return std::move(s);  // explicit cast (ù{\emphincomments{is}}ù) indicated
}
\end{emcppslisting}
    
\noindent Not all move conversions are guaranteed to occur implicitly; since copy
elision doesn't apply when the types do not match exactly, having an
explicit cast cannot pessimize object creation but might enable a
\emph{move} instead of a \emph{copy} operation.}
%
\item{If the expression being returned is any kind of reference and it is clear that it is appropriate to move the object being referenced, then an explicit cast \emph{is} indicated:
\begin{emcppslisting}
S f5()
{
    S s;
    S& r = s;
    return std::move(r);  // Explicit cast (ù{\emphincomments{is}}ù) indicated.
}

S g5(S&& s)  // Being passed as an (ù{\emphincomments{rvalue}}ù) reference indicates (ù{\codeincomments{s}}ù) should be moved.
{
    return std::move(s);  // Explicit cast (ù{\emphincomments{is}}ù) indicated.
}
\end{emcppslisting}
        
\noindent There are no implicit conversions from references; since copy elision
doesn't apply either, having an explicit cast cannot pessimize object
creation but might enable a move instead of a
copy.{\cprotect\footnote{While the \emcppsgloss[rvalue reference]{\romeovalue{rvalue} reference} parameter
of \lstinline!g5! will be implicitly moved in C++20, there is also no
apparent downside here to explicitly requesting the move and avoiding
  changes in meaning with different language standards.}}}
%
\item{Additionally, when an expression resides in a \lstinline!throw! statement, an explicit cast \emph{is} indicated but only when it is \emph{safe} to do so:
\begin{emcppslisting}
void f6(S s)
{
    throw std::move(s);  // Explicit cast (ù{\emphincomments{is}}ù) indicated.
}

void g6()
{
    S s;
    S& r = s;
    throw std::move(r);  // Explicit cast (ù{\emphincomments{is}}ù) indicated.
}

void h6()
{
    S s;  // used below by (ù{\codeincomments{f6}}ù)

    try
    {
        throw s;  // Explicit cast is (ù{\emphincomments{not}}ù) indicated.
    }
    catch (...) { }

    f6(s);  // uses (ù{\codeincomments{s}}ù) after being thrown
}
\end{emcppslisting}
        
\noindent An exception object will always be created, and, without an explicit
cast, it is not guaranteed that a viable move constructor will be
invoked, especially when the thrown expression is of reference type.
There is no situation where using \lstinline!std::move! pessimizes the
creation of the exception object, whereas not using it might result in
its being \emph{copied} instead of \emph{moved}. If, however, the thrown
object were to be caught within the same function and later used, then
an explicit cast would \emph{not} be indicated.}
\end{enumerate}

\subsubsection[Summary]{Summary}\label{summary}

The introduction of the extended value categories in C++ was a
fundamental part of introducing move semantics into the language. While
an understanding of the concepts of \romeovalue{lvalues} and \romeovalue{rvalues} is
usually sufficient for most programming tasks, it is, in fact, a
simplified model of the C++ value categories. Knowing the complete story
can help programmers to understand move semantics in a deeper way, which
can enable developers to write and understand more sophisticated code.

There are now two main categories, \emph{glvalue} and \romeovalue{rvalue},
with three disjoint subcategories, \romeovalue{lvalue}, \romeovalue{xvalue}, and
\romeovalue{prvalue}. One way to think of the new value categories is to note
that C++ expressions have two independent properties: identity, or
reachability, and movability. Objects are reachable if we can take their
address. Objects are movable if they cannot be referenced or if we
explicitly tell the compiler that it is safe to move them. \romeovalue{Lvalue}
expressions have identity, we can take their address, and they are
reachable. \romeovalue{Prvalues} have no identity and can be moved from.
\romeovalue{Xvalues} have identity and can be moved from.

\emcppsgloss[rvalue reference]{\romeovalue{Rvalue} references} as function parameters in overload sets
enable functions and, most importantly, constructors and assignment
operators to distinguish between cases where they are passed an
\romeovalue{lvalue} or an \romeovalue{rvalue} and decide based on which they
received whether they can cannibalize the contents of their arguments to
avoid expensive copy operations.

\subsection[Use Cases]{Use Cases}\label{use-cases-rvalueref}

\subsubsection[Move operations as optimizations of copying]{Move operations as optimizations of copying}\label{move-operations-as-optimizations-of-copying}

With the introduction of \emcppsgloss[rvalue reference]{\romeovalue{rvalue} references}, we are now
able to discriminate between a reference bound to an object that is
eligible to be moved from, i.e., an \emcppsgloss[rvalue reference]{\romeovalue{rvalue} reference},
from that which is bound to an object that must be copied, i.e., an
\emcppsgloss[lvalue reference]{\romeovalue{lvalue} reference}. That is, we are now able to
\emcppsgloss{overload} our constructors and assignment operators for both
\romeovalue{rvalues} and \romeovalue{lvalues}.

Constructing an object from an \romeovalue{lvalue} expression of the same type
is called \emph{copy construction}. Constructing an object from an
\romeovalue{rvalue} expression of the same type is called \emph{move
construction}. The term \emph{move} colloquially expresses the idea of
transferring \emcppsgloss{owned resources}, typically dynamically allocated
memory blocks, from one object to another as opposed to that of somehow
duplicating, e.g., allocating and copying, them.

In most practical applications, \emph{moving} can be reasonably
interpreted and properly implemented as an \emph{optimization} of
\emph{copying} in that the requirements on the target object are the
same, whereas the requirements on the source object are relaxed such
that it need not retain the same state --- or \emcppsgloss{value}, where
applicable --- after the operation completes. Importantly, knowing that
the semantics of \emph{move} operations can be fully defined in terms of
their corresponding \emph{copy} operations makes them easy to
understand. What's more, these newly added \emcppsgloss[move semantics]{move-semantic}
operations can be tested using unit tests that are modified only
slightly from their existing \emcppsgloss[copy semantics]{copy-semantic} counterparts.

Repurposing internal resources from an object that no longer needs them
can lead to faster \emph{copy}-like operations, especially when dynamic
allocation and deallocation of memory is involved. Countervailing
considerations, such as \emcppsgloss{locality of reference}, can, however,
suggest that preferring \emph{move} operations to \emph{copy} operations
might, in some circumstances, be contraindicated for overall optimal
runtime performance, especially at scale.{\cprotect\footnote{\cite{halpern21}}}
%%% This citation may need to be updated or removed. 

Properly implementing \emph{move} operations that, for \emcppsgloss{expiring}
objects, act like optimized \emcppsgloss{copy operations} will depend on the
specifics of how we chose to implement a type, e.g., an object that (1)
is written to manage its own resources explicitly (see \intrarefsimple{creating-a-low-level-value-semantic-type-(vst)}) or (2) delegates resource
management to its subobjects (see \intrarefsimple{UDTs having implicitly generated
move operations}). 
%%%
\textbf{[AUs: there is no section called ``UDTs having implicitly generated move operations"; what did you intend?]}
%%%

\paragraph[Creating a low-level value-semantic type (VST)]{Creating a low-level value-semantic type (VST)}\label{creating-a-low-level-value-semantic-type-(vst)}

Often, we want to create a \emcppsgloss[user defined type (UDT)]{user-defined type (UDT)} that
represents a \emcppsgloss{value}. When implemented properly, we refer to such
a type generally as a \emcppsgloss[value semantic type (VST)]{value-semantic type (VST)}. Although there
are some cases where a VST might be implemented as a simple
\emcppsgloss{aggregate type} (see {UDTs having implicitly generated
\emph{move} operations}), 
%%%
\textbf{[AUs: there is no section called ``UDTs having implicitly generated
\emph{move} operations"; what did you intend?]}
%%%
there are other cases where a VST might,
instead, manage its internal resources directly. The latter explicit
implementation of a VST is the subject of this subsection.

For illustration purposes, consider a simple VST,
\lstinline!class!~\lstinline!String!, that maintains, as an \emcppsgloss[object
invariants]{object
invariant}, a null-\emph{terminated} string value; i.e., this string
class explicitly does not support having a \emph{null} pointer value. In
addition to a \emph{value} constructor and a single \lstinline!const!
member function to access the value of the object, each of the four
C++03 \emcppsgloss{special member functions} --- default constructor, copy
constructor, assignment operator, and destructor --- are
\emcppsgloss{user provided}, i.e., defined explicitly by the programmer. To
keep this example focused, however, we will \emph{not} store separately
the length of the string, and we'll omit the notion of \emph{excess}
capacity altogether, leaving just a single
non\lstinline!static!~\lstinline!const!~\lstinline!char*! data member,
\lstinline!d_str_p!, to hold the address of the dynamically allocated
memory:

\begin{emcppslisting}
class String { const char *d_str_p; /*...*/ };  // (ù{\emphincomments{null}}ù)-terminated-string manager
\end{emcppslisting}
    
    
\noindent One practical aspect that we preserve is that default-constructed
container types --- going back to C++98 --- are well advised, on purely
performance grounds, never to pre-allocate resources, lest creating a
large array of such empty containers be impracticably runtime-intensive
to construct:

\begin{emcppslisting}
String s;  // no memory is allocated
\end{emcppslisting}
    
    
\noindent To avoid checking, internally, whether a given string representation is
a \emcppsgloss{null pointer value} on each access, we instead create a common
\lstinline!static! \emph{empty} string, \lstinline!s_empty!, nested within
our \lstinline!String! class, and install its address during default
construction or when we would otherwise want to represent an empty
string. This address serves as a sentinel whose requisite runtime
checking is be properly relegated to more costly and/or presumably less
frequent operations, such as copy construction, assignment and
destruction. Thus, a second object invariant is that a string value
whose representation is dynamically allocated is never empty.

Finally, to provide better factoring, the definition of our
\emcppsgloss[value semantic]{value-semantic} \lstinline!String! class declares a private
\lstinline!static! member function, \lstinline!dupStr!, that dynamically
allocates and populates a new block of memory exactly sized to hold a
supplied, nonempty \emcppsgloss[null terminated string]{null-terminated-string} value:

\begin{emcppslisting}
// my_string.h:
// ...

class String  // greatly simplified (ù{\emphincomments{null}}ù)-terminated-string manager
{
    const char* d_str_p;  // immutable value, often allocated dynamically

    static const char s_empty[1];  // empty, used as sentinel indicating (ù{\emphincomments{null}}ù)

    static const char* dupStr(const char* str);  // allocate/return copy of (ù{\codeincomments{str}}ù)

public:
    // C++03
    String();                              // default constructor
    String(const char* value);             // value constructor
    String(const String& original);        // copy constructor
    ~String();                             // destructor
    String& operator=(const String& rhs);  // copy-assignment operator
    const char* str() const;

    /* C++11 (to be added later)
    String(String&& expiring) noexcept;    // move constructor
    String& operator=(String&& expiring);  // move-assignment operator
    */
};
\end{emcppslisting}
    
    
\noindent Perhaps the best way to unpack the C++03 class definition of
\lstinline!String! in the code snippet above is to define its members in
order of declaration in a corresponding \lstinline!.cpp! file, realizing,
of course, that all but the definition of the \lstinline!static! data
member, \lstinline!s_empty!, would most likely be moved to the \lstinline!.h!
file as \lstinline!inline! functions:

\begin{emcppslisting}
// my_string.cpp:
#include <my_string.h>  // Component header is routinely included first.
#include <cstddef>      // (ù{\codeincomments{std::size\_t}}ù)
#include <cstring>      // (ù{\codeincomments{std::memcpy}}ù), (ù{\codeincomments{std::strlen}}ù)
#include <cassert>      // standard C (ù{\codeincomments{assert}}ù) macro

/* C++11 (to be added later)
#include <utility>   // (ù{\codeincomments{std::move}}ù)
*/

const char String::s_empty[1] = {'\0'};  // (ù{\codeincomments{const}}ù) needs explicit initialization.
\end{emcppslisting}
    
    
\noindent The static helper, \lstinline!dupStr!, provides a factored implementation
to create a copy of a \emph{nonempty} \emcppsgloss[null terminated string]{null-terminated string}.
Note that, while this function would work on an empty string, our
\emcppsgloss[object invariants]{object invariant} is that all empty strings are represented by
the \emph{sentinel}, \lstinline!s_empty!, thus avoiding any gratuitous
memory allocation:

\begin{emcppslisting}
const char* String::dupStr(const char *str)
{
    assert(str && *str);                     // (ù{\codeincomments{str}}ù)s are expected to be nonempty.
    std::size_t capacity = strlen(str) + 1;  // Calculate capacity.
    char* tmp = new char[capacity];          // Allocate memory.
    memcpy(tmp, str, capacity);              // Copy all chars thru final (ù{\codeincomments{'$\backslash$0'}}ù).
    return tmp;                              // Return duplicate of (ù{\codeincomments{str}}ù).
}
\end{emcppslisting}
    
    
\noindent Our deliberate choice to avoid coupling the clean implementation in the
example above with the \lstinline!s_empty! sentinel --- and thereby
further reducing the amount of repetitive source code --- allows us to
express explicitly and more precisely detailed design and coding
decisions that are generally applicable. For example, calling
\lstinline!dupStr! on either a null pointer value, e.g., \lstinline!0!, or an
empty string, e.g., \lstinline!""!, is \emcppsgloss{out of contract} and, in a
debug build, would be flagged as an error. Given a defect-free
implementation of \lstinline!String!, however, this assertion can never be
triggered as it is a \emph{manifestly} \emcppsgloss{defensive check}.

With these \emph{independent} primitive utilities in hand, we are now
ready to implement the client-facing interface. The simplest and most
straightforward member function is the default constructor, which simply
installs the sentinel, \lstinline!s_empty!, as its string value:

\begin{emcppslisting}
String::String() : d_str_p(s_empty) { }  // set (ù{\codeincomments{d\_str\_p}}ù) to (ù{\emphincomments{null}}ù) value
\end{emcppslisting}
    
    
\noindent We say that the object is effectively set to a ``null'' value internally
because \lstinline!s_empty!, although not literally a \emcppsgloss{null pointer
value}, consumes no dynamic-memory resources; externally, however, it
represents efficiently an empty string value (\lstinline!""!).

Next let's consider the value constructor, which allocates memory only
when the supplied string buffer is neither a null pointer value
(\lstinline!0!) nor empty (\lstinline!""!):

\begin{emcppslisting}
String::String(const char* value)
    // Value constructor allocates only if nonempty and then exactly as needed.
{
    if (!value || !*value)        // if (ù{\codeincomments{value}}ù) is (ù{\emphincomments{null}}ù) or empty
    {
        d_str_p = s_empty;        // no dynamic memory allocation
    }
    else                          // not empty
    {
        d_str_p = dupStr(value);  // allocated copy
    }
}
\end{emcppslisting}
    
    
\noindent If the supplied \lstinline!value! is either a null pointer value or an
empty string, the sentinel is stored; otherwise, our trusty
\lstinline!dupStr! function will dynamically allocate and populate an
appropriately sized \lstinline!char! array to be managed by the
\lstinline!String! object going forward.

Next, let's consider what it means to copy construct a \lstinline!String!
object from another. In this case, we know that the internal
representation of the other string cannot be a null address or even a
dynamically allocated empty string; \lstinline!d_str_p! holds either the
sentinel, \lstinline!s_empty!, or else a nonempty dynamically allocated
string:

\begin{emcppslisting}
String::String(const String& original)
    // Copy constructor allocates exactly what's needed.
{
    if (s_empty == original.d_str_p)         // if (ù{\codeincomments{original}}ù) is (ù{\emphincomments{null}}ù)
    {
        d_str_p = s_empty;                   // no dynamic allocation
    }
    else                                     // not empty
    {
        d_str_p = dupStr(original.d_str_p);  // allocated copy
    }
}
\end{emcppslisting}
    
    
\noindent If the original object is \emph{null}, then so too will be a copy;
otherwise, a new resource will be allocated via \lstinline!dupStr! to be
managed by this object.

The destructor needs to deallocate when the object being managed isn't
\emph{null}:

\begin{emcppslisting}
String::~String()
    // Destructor deallocates only if needed.
{
    if (s_empty != d_str_p)  // if not (ù{\emphincomments{null}}ù)
    {
        delete[] d_str_p;    // deallocate dynamic memory
    }
}
\end{emcppslisting}
    
    
\noindent Thus, an empty \lstinline!String! object, or an array thereof, requires no
allocation on construction and no corresponding deallocation on
destruction.

By far the most complex of the special member functions to implement
explicitly is the copy-assignment operator. First, we must guard against
classic aliasing in which the source and the destination of the
assignment refer to the same object, or, if it is a possibility with the
type in question, overlapping parts of the same object; in such cases,
no state change is indicated. Second, we must secure any needed
resources; that way, if an exception is thrown (e.g., due to being out
of available memory), the destination will be unaffected. Third, we can
now proceed to deallocate any resource currently managed by the object.
Fourth, we install the new resource into the destination object. Fifth,
we must remember to return a reference to the destination object:

\begin{emcppslisting}
String& String::operator=(const String& rhs)
     // Copy-assignment operator deallocates and allocates if and as needed.
{
    if (&rhs != this)                   // (1) Avoid assignment to self.
    {
        const char* tmp;                // (2) Hold preallocated resource.

        if (s_empty == rhs.d_str_p)     // If the (ù{\codeincomments{rhs}}ù) string is (ù{\emphincomments{null}}ù),
        {
            tmp = s_empty;              // make this string (ù{\emphincomments{null}}ù) too.
        }
        else                            // (ù{\codeincomments{rhs}}ù) string is not empty.
        {
            tmp = dupStr(rhs.d_str_p);  // allocated copy
        }

        if (s_empty != d_str_p)         // (3) If this object isn't (ù{\emphincomments{null}}ù),
        {
            delete[] d_str_p;           // deallocate storage.
        }

        d_str_p = tmp;                  // (4) Assign the resource.
    }

    return *this;                       // (5) (ù{\emphincomments{lvalue}}ù) reference
}
\end{emcppslisting}
    
    
\noindent The comparatively greater complexity of copy assignment derives, in
part, from there being two objects involved, either of which may be
managing dynamically allocated memory resources.{\cprotect\footnote{Implementing
assignment operations becomes even more challenging in the presence of
  locally supplied memory allocators; see \cite{lakos17}.\textbf{This is the Meeting C++17 talk (two parts)}.}} Again,
to ensure exception safety (in this case, the \emcppsgloss{strong
guarantee}), we must \emph{always} remember to allocate any new resource
before modifying the state of the destination object.


One last function needed to complete the example is the \lstinline!str!
accessor, which affords direct, efficient access to a
\emph{null}-terminated string representing the value managed by a
\lstinline!String! object:

\begin{emcppslisting}
const char* String::str() const { return d_str_p; }
    // Value accessor returns null-terminated string with maximal efficiency.
\end{emcppslisting}
    
    
\noindent Note that much of the prep work that was done already was in
anticipation of making the implementation of this accessor function as
streamlined and runtime efficient as possible, e.g., no conditional
branching on each access.

The C++03 example above was written in a style that is consistent with
sound C++03 design. We can, for example, create a large array of empty
strings without having to separately allocate dynamic memory for each
element:

\begin{emcppslisting}
String a[10000] = {};  // allocates no dynamic memory

static_assert(sizeof a == sizeof(char*) * 10000);
\end{emcppslisting}
    
    
\noindent For a fixed-size array, we're in good shape; we'll allocate memory if
and when we want to install a nonempty string. For a dynamically growing
container, however, substantial inefficiencies can occur. For example,
suppose we create an empty \lstinline!std::vector<String>! object,
\lstinline!vs!, and then append, using \lstinline!push_back!, 5 nonempty
\lstinline!String! objects using values \lstinline!"a"!, \lstinline!"bb"!,
\lstinline!"ccc"!, \lstinline!"dddd"!, and \lstinline!"eeeee"!. Assuming a
geometric growth strategy for the capacity of the vector starting with
the sequence $0$, $1$, $2$, $4$, $8$ $..$, we might expect a
total of $17$ dynamic allocations due to constructing \lstinline!String!
objects on top of the $4$ dynamic allocations needed to resize the
\lstinline!vector! from $0$ to $1$ to $2$ to $4$ to $8$ elements,
along with all the deallocations associated with those allocations; note
that this illustration assumes 8-byte \lstinline!char! pointers, which
dictates the footprint size of our \lstinline!String! object:

\begin{emcppslisting}
#include <my_string.h>
#include <vector>  // (ù{\codeincomments{std::vector}}ù)

void test1() // using C++03's (ù{\codeincomments{vector::push\_back}}ù) with C++03 (ù{\codeincomments{String}}ù)
{
    std::vector<String> vs;  // no dynamic allocation or deallocation
    vs.push_back("a");       // 2 8 2 -2
    vs.push_back("bb");      // 3 16 3 2 -2 -8 -3
    vs.push_back("ccc");     // 4 32 4 2 3 -2 -3 -16 -4
    vs.push_back("dddd")     // 5 5 -5
    vs.push_back("eeeee");   // 6 64 6 2 3 4 5 -2 -3 -4 -5 -32 -6
}                            // -2 -3 -4 -5 -6 -64
\end{emcppslisting}
    
    
\noindent In the \lstinline!test1! function above, an empty \lstinline!std::vector!,
\lstinline!vs!, is created without any memory being allocated dynamically.
The first time we ``push back'' a value, \lstinline!"a"!, a temporary
\lstinline!String! object is constructed, requiring an allocation of 2
bytes. The vector \lstinline!vs! is then resized from a capacity of $0$
to $1$, allocating 8 bytes on a 64-bit platform, and then the
temporary \lstinline!String! is copy constructed into this dynamic array of
1 element, requiring another 2 bytes to be allocated. When the original
temporary is destroyed, those two bytes are reclaimed (-2 bytes).

Adding a second string, \lstinline!"bb"!, to \lstinline!vs! requires a
reallocation by \lstinline!std::vector! to a capacity of two
\lstinline!String! objects (16 bytes). So 3 bytes for a temporary to hold
\lstinline!"bb"!, 16 bytes for the new capacity, 3 bytes to copy construct
the temporary into the array, and 2 bytes to copy over the
\lstinline!String! representing \lstinline!"a"!. After that, the original
string holding \lstinline!"a"! in the array of smaller capacity is
destroyed (-2 bytes), the old capacity is deallocated (-8 bytes), and
the original temporary used to ``push back'' the \lstinline!"bb"! value is
destroyed (-3 bytes).

Adding \lstinline!"ccc"! is again similar. However, adding \lstinline!"dddd"!
is different in that, for the first time, there is sufficient capacity
in the array \emph{not} to have to resize. The temporary \lstinline!String!
needed to hold \lstinline!"dddd"! is created (5 bytes), it is copied into
the vector (5 bytes), and the temporary is then destroyed (-5 bytes).
Adding \lstinline!"eeeee"! is analogous to adding \lstinline!"ccc"!.

Finally, when \lstinline!vs! goes out of scope, there are 5 calls to the
\lstinline!String! destructor, each requiring a deallocation, plus a call
to the destructor of \lstinline!std::vector!, deallocating the
64-byte-capacity buffer stored within.

The excessive cost due to copying results from two distinct causes. 1.
Having to construct a temporary string object before copying it into the
vector 2. Having to copy each string from the old-capacity buffer to the
new one each time the vector is resized

As of C++11, the Standard Library version of \lstinline!std::vector!
provides a more efficient member function, \lstinline!emplace_back!, that
makes use of \emcppsgloss[forwarding reference]{forwarding references} (see \featureref{\locationc}{forwardingref}) to construct the string only once \emph{in}
\emph{place}, thus reducing the number of allocations resulting from
constructing \lstinline!String! objects from 17 to 12:

\begin{emcppslisting}
void test2() // using C++11's (ù{\codeincomments{vector::emplace\_back}}ù) with C++03 (ù{\codeincomments{String}}ù)
{
    std::vector<String> vs;    // no dynamic allocation or deallocation
    vs.emplace_back("a");      // 8 2
    vs.emplace_back("bb");     // 16 3 2 -2 -8
    vs.emplace_back("ccc");    // 32 4 2 3 -2 -3 -16
    vs.emplace_back("dddd")    // 5
    vs.emplace_back("eeeee");  // 64 6 2 3 4 5 -2 -3 -4 -5 -32
}                              // -2 -3 -4 -5 -6 -64
\end{emcppslisting}
    
    
\noindent But the real win comes from adding the two missing move operations to
the C++03 version of class \lstinline!String! without changing a single
character in the existing class definition. Note the \emph{essential}
use of \lstinline!noexcept! following the parameter list in the move
constructor, which enables \lstinline!std::vector! to choose to \emph{move}
rather than \emph{copy}; see \featureref{\locatione}{noexcept-specifier}:

\begin{emcppslisting}
#include <utility>  // (ù{\codeincomments{std::move}}ù)

String::String(String&& expiring) noexcept
    // Move constructor never allocates or deallocates.
: d_str_p(expiring.d_str_p)      // Assign address of (ù{\codeincomments{expiring}}ù)'s resource.
{
    expiring.d_str_p = s_empty;  // (ù{\codeincomments{expiring}}ù) is now (ù{\emphincomments{null}}ù) but valid/empty.
}
\end{emcppslisting}
    
    
\noindent The \emph{move} constructor in the example above never allocates or
deallocates memory; instead, it simply propagates whatever resource was
employed by the \emph{expiring} source to the destination. Then, to
establish unique ownership by the destination, the address of the
sentinel value, \lstinline!s_empty!, is used to overwrite the previous
address in the expiring source.

The move-assignment operator, not necessary for this demonstration, is
again somewhat more involved in that it must (1) guard against move
assignment to self, (2) ensure that the resource is deallocated if the
destination is managing a nonempty string, (3) assign the
\lstinline!expiring! object's resource to the destination object, (4)
unconditionally overwrite the previous resource with the empty-string
sentinel, and (5) always return an \romeovalue{lvalue}, not an \romeovalue{rvalue},
reference to the destination object:

\begin{emcppslisting}
String& String::operator=(String&& expiring)
    // Move-assignment operator never allocates; deallocates if necessary.
{
    if (&expiring != this)           // (1) Avoid assignment to self.
    {
        if (s_empty != d_str_p)      // (2) If this object isn't (ù{\emphincomments{null}}ù),
        {
            delete[] d_str_p;        // deallocate dynamic storage.
        }

        d_str_p = expiring.d_str_p;  // (3) Assign address of (ù{\codeincomments{expiring}}ù)'s resource.

        expiring.d_str_p = s_empty;  // (4) (ù{\codeincomments{expiring}}ù) is now (ù{\emphincomments{null}}ù) but valid/empty
    }

    return *this;                    // (5) (ù{\emphincomments{lvalue}}ù) reference
}
\end{emcppslisting}
    
    
\noindent Note that we have chosen \emph{not} to provide the \lstinline!noexcept!
specifier here because, for the \emph{move}-assignment operator, the
\lstinline!noexcept! specifier is typically not needed and not always
appropriate; see \featureref{\locatione}{noexcept-specifier}.

Now that the \lstinline!String! class has been properly augmented with the
two missing C++11 move operations (\emcppsgloss{move construction}, in
particular), the number of allocations resulting from constructing
\lstinline!String! objects under the same \lstinline!test2! goes from 12 to 5,
where the 5 allocations result from constructing each unique object from
its literal string value exactly once. Importantly, allocation and
deallocation resulting from copying over elements from the old to the
new storage in the \lstinline!std::vector<String>! is eliminated entirely:

\begin{emcppslisting}
void test2() // using C++11's (ù{\codeincomments{vector::emplace\_back}}ù) with C++11 (ù{\codeincomments{String}}ù)
{
    std::vector<String> vs;    // no dynamic allocation or deallocation
    vs.emplace_back("a");      // 8 2
    vs.emplace_back("bb");     // 16 3 -8
    vs.emplace_back("ccc");    // 32 4 -16
    vs.emplace_back("dddd")    // 5
    vs.emplace_back("eeeee");  // 64 6 -32
}                              // -2 -3 -4 -5 -6 -64
\end{emcppslisting}
    
    
\noindent The use of the \lstinline!noexcept! specifier in the implementation of the
move constructor is essential because of the \emcppsgloss{strong
exception-safety guarantee} promised by the Standard when inserting or
emplacing an element at the end of a \lstinline!std::vector!; see
\featureref{\locationc}{noexceptoperator}. It will turn out that, once
our \lstinline!String! class is outfitted with a \emph{move} constructor,
the \romeovalue{rvalue} reference of \lstinline!vector::push_back! will avoid
the dynamic allocation and deallocation of a copy, substituting just a
single additional \emph{move} operation; \lstinline!vector::emplace_back!
avoids even that tiny overhead.

Finally, the design of a class that supports \emph{move} operations
follows from the general idea that construction of an empty container
should be inexpensive (i.e., not require memory allocation), as was done
here. One could imagine making other trade-offs that would simplify the
implementation at the expense of necessitating that every \emph{valid}
object maintains allocated resources, which would undermine a primary
advantage of \emph{move} operations, i.e., faster copy operations. For
move operations to be both efficient and generally applicable, it is
essential that the object has at least one valid state that does not
require it to be managing external resources; see \intraref{potential-pitfalls-rvalueref}{requiring-owned-resources-to-be-valid}.

\paragraph[Creating a high-level VST]{Creating a high-level VST}\label{creating-a-high-level-vst}

Implementing move operations for higher-level types, such as
\emcppsgloss[aggregate]{aggregates}, that merely comprise other types that support move
operations, is fairly straightforward when compared with lower-level
types that manage resources explicitly. Because the resources are
managed independently by the move-operation-enabled base class and/or
member subobjects themselves, all that's required is to ensure that
those move operations are employed.

\begin{enumerate}
%%% item 1
\item{No special member functions are \emcppsgloss{user provided}. As an example, suppose we want to create a class that comprises two independent strings, \lstinline!firstName! and \lstinline!lastName!, describing a person. For this application, there is no special constraint between the two string data members, and we will want to provide \emph{write} as well as \emph{read} access to each member unless the object of that class is itself \lstinline!const! or accessed via a \lstinline!const! pointer or reference. We will therefore elect to implement our class as a \lstinline!struct! having two public data members of a \emcppsgloss[regular type]{regular} \emcppsgloss[value semantic type (VST)]{value-semantic type}, such as \lstinline!std::string!, that manages its own resources. For concreteness of exposition, however, we will use the \lstinline!String! class developed in \intrarefsimple{creating-a-low-level-value-semantic-type-(vst)}:
\begin{emcppslisting}
struct Person  // C++03 and C++11 aggregate type
{
    String firstName;
    String lastName;
};
\end{emcppslisting}
    
\noindent The \lstinline!Person! class above does not declare any explicit
constructors of its own, yet it can be \emcppsgloss{default constructed} and
\emcppsgloss[braced initialization]{braced initialized} (see \featureref{\locationc}{bracedinit}):

\begin{emcppslisting}
Person p0;                               // (ù{\codeincomments{p0}}ù) holds (ù{\codeincomments{\{ "", "" \}}}ù)
Person p1 = {};                          // (ù{\codeincomments{p1}}ù) holds (ù{\codeincomments{\{ "", "" \}}}ù)
Person p2 = { "Slava" };                 // (ù{\codeincomments{p2}}ù) holds (ù{\codeincomments{\{ "Slava", "" \}}}ù)
Person p3 = { "Alisdair", "Meredith" };  // (ù{\codeincomments{p3}}ù) holds (ù{\codeincomments{\{ Alisdair, "Meredith" \}}}ù)
\end{emcppslisting}
    
    
\noindent Note that, in the code sample above, \lstinline!p0! is \emcppsgloss{default
initialized} by an implicitly generated default constructor, whereas
\lstinline!p1!, \lstinline!p2!, and \lstinline!p3! follow the rules of
\emcppsgloss{aggregate initialization}; see \featureref{\locationc}{bracedinit}.

Once constructed, the individual members of a \lstinline!Person! object can
be manipulated directly:

\begin{emcppslisting}
void test0()
{
    p0.firstName = "Vittorio";  // OK, (ù{\codeincomments{p0}}ù) holds (ù{\codeincomments{\{ "Vittorio", "" \}}}ù).
    p0.lastName = "Romeo";      // OK, (ù{\codeincomments{p0}}ù) holds (ù{\codeincomments{\{ "Vittorio", "Romeo" \}}}ù).
}
\end{emcppslisting}
    
    
\noindent Moreover, a \lstinline!Person! object, as a whole, can be both \emcppsgloss[copy constructor]{copy
constructed} and \emcppsgloss[copy assigned]{copy assigned} via its corresponding,
implicitly generated \emcppsgloss{special member functions}:

\begin{emcppslisting}
void test1()
{
    Person x(p3);  // (ù{\codeincomments{x}}ù) holds (ù{\codeincomments{\{ "Alisdair", "Meredith" \}}}ù); (ù{\codeincomments{p3}}ù) is unchanged.
    x = p0;        // (ù{\codeincomments{x}}ù) now holds (ù{\codeincomments{\{ "Vittorio", "Romeo" \}}}ù); (ù{\codeincomments{p0}}ù) is unchanged.
}                  // (ù{\codeincomments{x}}ù) destroys both of its member objects as it leaves scope.
\end{emcppslisting}
    
    
\noindent What's more, when a \lstinline!Person! object, e.g., \lstinline!x! in the code
snippet above, leaves scope, its respective members are destroyed by its
implicitly generated \emcppsgloss{destructor}. That is, a C++03 aggregate
that comprises objects that individually support all of the needed
special member functions will tacitly make the corresponding operations
available to the overall aggregate type.

To update the \lstinline!Person! object to support \emcppsgloss{move
operations}, there is literally nothing to do! Provided that each member
(and base) subobject supports the desired move operations for itself (as
we know to be the case for \lstinline!String! objects), the compiler
generates them implicitly for the \lstinline!Person!~\lstinline!struct! as
well:

\begin{emcppslisting}
#include <utility>  // (ù{\codeincomments{std::move}}ù)

void test2()
{
    Person x(p3);            // (ù{\codeincomments{x}}ù) holds (ù{\codeincomments{\{ "Alisdair", "Meredith" \}}}ù).
                             // (ù{\codeincomments{p3}}ù) still holds (ù{\codeincomments{\{ "Alisdair", "Meredith" \}}}ù).

    Person y(std::move(x));  // (ù{\codeincomments{y}}ù) holds (ù{\codeincomments{\{ "Alisdair", "Meredith" \}}}ù).
                             // (ù{\codeincomments{x}}ù) might now hold (ù{\codeincomments{\{ "", "" \}}}ù).

    x = std::move(y);        // (ù{\codeincomments{x}}ù) now holds (ù{\codeincomments{\{ "Alisdair", "Meredith" \}}}ù).
                             // (ù{\codeincomments{y}}ù) might now  hold (ù{\codeincomments{\{ "", "" \}}}ù).
}
\end{emcppslisting}
    
    
\noindent The example above demonstrates that moving from an object that has been
explicitly designated as \emcppsgloss{expiring} enables the \lstinline!Person!
class to, in turn, \emph{allow} its member types to steal resources from
the corresponding individual members of the other object during both
move construction and move assignment. The result is just a more
efficient copy provided that we no longer rely on knowing the value of
the moved-from object.

With respect to the specific state of moved-from \lstinline!String! data
members of a \lstinline!Person!, the example code above --- though
illustrative of what we know to be the currently implemented behavior of
our own \lstinline!String! --- would not necessarily be true of another
string type, e.g., the vendor-supplied implementation of
\lstinline!std::string!, or even a future version of \lstinline!String!; see
\intraref{potential-pitfalls-rvalueref}{inconsistent-expectations-on-moved-from-objects}.

Although pure \emcppsgloss[aggregate type]{aggregate types} often suffice, we might sometimes
find that we need to augment such an \emcppsgloss{aggregate type} with one or
more \emcppsgloss[user provided]{user-provided} \emcppsgloss{special member functions} or other
constructors; doing so, however, may affect the implicit generation of
other such functions and/or strip the type of its \emcppsgloss{aggregate
type} status.

In what follows, we will proceed to add a \emcppsgloss{value constructor}
(see item 1) followed by each of the six \emcppsgloss{special member
functions} in turn (see items 2--7). \textbf{[AUs: You started your list with item 0; our list style starts with item 1. Please double-check the prev sentence and change as needed: item 1 might need to be item 2, and items 2--7 might need to be items 3--8.]} After adding each function, we will
observe the consequences of having added it and then default back
whatever was removed. We will repeat this process until all of the
missing functionality is restored. The process provides insight into the
deeper meaning embedded in the \emcppsgloss[special member
functions]{special-member-function} table
provided in the appendix within \featureref{\locationa}{defaulted-special-member-functions}.}
%%%% item 2
\item{\emcppsgloss[user provided]{User-provided} \emcppsgloss{value constructor}. As it stands now, there is no \emcppsgloss{value constructor} that takes the two member values and constructs a \lstinline!Person! object:

\begin{emcppslisting}
Person nonGrata("John", "Lakos");  // Error, no matching constructor
\end{emcppslisting}
    
    
\noindent Suppose we want to make it possible for a person class, e.g.,
\lstinline!Person1!, to be constructed in this way. We will, at a minimum,
need to provide a \emcppsgloss{value constructor} for that purpose:

\begin{emcppslisting}
struct Person1  // We want to add a value constructor.
{
    String firstName;
    String lastName;

    Person1(const char* first, const char* last)  // value constructor
    : firstName(first), lastName(last) { }
};
\end{emcppslisting}
    
    
\noindent By adding this \emcppsgloss{value constructor} in the example above, we
necessarily suppress the implicit declaration of the \emcppsgloss{default
constructor}. Moreover, a class having a \emcppsgloss[user provided]{user-provided} 
constructor of any kind is automatically no longer considered an
\emcppsgloss{aggregate}; see \featureref{\locationc}{bracedinit}:

\begin{emcppslisting}
Person1 w1("John", "Lakos");           // OK, invokes value constructor
Person1 x1;                            // Error, no default constructor
Person1 y1 = { "Vittorio" };           // Error, no longer an aggregate
Person1 z1 = { "Vittorio", "Romeo" };  // OK, calls value ctor as of C++11
\end{emcppslisting}
    
    
\noindent As the example above illustrates, we can now \emcppsgloss[direct initialized]{direct initialize}
\lstinline!w1! via the new, \emcppsgloss[user provided]{user-provided} value constructor, but
there is now no implicitly declared default constructor for \lstinline!x1!.
Since \lstinline!Person1! is no longer considered an aggregate, we cannot
use \emcppsgloss{aggregate initialization} to initialize (in this case, just
some of) the members of \lstinline!y1!. C++11, however, extends what can be
done via braced-list initialization and thus allows this value
constructor to be invoked via the rules of \emcppsgloss[braced list initialization]{braced-list
initialization}; see \featureref{\locationc}{bracedinit} and also
\featureref{\locationc}{initlist}.

Still, we would like a way to somehow support the functionality provided
by the implicit implementation of all \emph{six} of the C++11
\emcppsgloss{special member functions}. Fortunately, C++11 offers a companion
feature that allows us to declare and default the compiler-generated
implementation of each special member function explicitly (see
\featureref{\locationa}{defaulted-special-member-functions}):

\begin{emcppslisting}
struct Person1a  // We want to add a value constructor (Revision a).
{
    String firstName;
    String lastName;

    Person1a(const char* first, const char* last)  // value constructor
    : firstName(first), lastName(last) { }

    // New here in (ù{\codeincomments{Person1a}}ù).
    Person1a() = default;                          // default constructor
};
\end{emcppslisting}
    
    
\noindent Notice that \lstinline!Person1a! differs from \lstinline!Person1! in the
earlier example only in the addition of a \emph{defaulted}
\emcppsgloss{default constructor} on the final line of its class definition,
thus restoring default construction but not \emcppsgloss{aggregate
initialization}:

\begin{emcppslisting}
Person1a x1a("John", "Lakos");           // OK, invokes value constructor
Person1a y1a;                            // OK, invokes default constructor
Person1a z1a = { "Vittorio" };           // Error, still not an aggregate
Person1a w1a = { "Vittorio", "Romeo" };  // OK, calls value ctor as of C++11
\end{emcppslisting}
    
    
\noindent Adding \emph{any} nonspecial constructor would have the same effect on
the implicit generation of the six special member functions, which in
this case was to suppress implicit generation of only the
\emcppsgloss{default constructor}. This invites the question, What affect
does explicitly declaring the \emcppsgloss{default constructor} have on other
special functions, e.g., \emcppsgloss{move construction}? The answer in this
specific case is none, but that's the exception; the ultimate answer for
each of the other five special member functions is elucidated in items
2--7.}\textbf{[AUs: You started your list with item 0; our list style starts with item 1. Please double-check the prev sentence and change as needed: items 2--7 might need to be items 3--8.]}

%%%%%%% item 3
\item{\emcppsgloss[user provided]{User-provided} \emcppsgloss{default constructor}. We may, at times, need to augment an \emcppsgloss{aggregate} with one or more \emcppsgloss[user provided]{user-provided} \emcppsgloss{special member functions}, e.g., for debugging or logging purposes, that would \emph{not} alter how we would have the compiler generate the remaining ones.

Suppose that, for whatever reason, we'd like to add some
metrics-gathering code to the \emcppsgloss{default constructor} of our
original, \emcppsgloss{aggregate} \lstinline!Person! class; we'll call this
modified class \lstinline!Person2!:

\begin{emcppslisting}
struct Person2  // We want to employ a user-provided default constructor.
{
    String firstName;
    String lastName;

    Person2() { /* user-provided */ }  // default constructor
};
\end{emcppslisting}
    
    
\noindent No other \emcppsgloss{special member function} is affected but, because we
have provided a nondefault implementation of a constructor (namely, the
\emcppsgloss{default constructor}), the class is no longer considered an
aggregate:

\begin{emcppslisting}
Person2 w2("abc", "def");       // Error, no value constructor is provided.
Person2 x2;                     // OK, invokes user-provided default ctor
Person2 y2 = { "abc" };         // Error, not an aggregate and no 1-arg ctor
Person2 z2 = { "abc", "def" };  // Error, not an aggregate and no value ctor
\end{emcppslisting}
}
    
%%%%% item 4
\item{\emcppsgloss[user provided]{User-provided} \emcppsgloss{destructor}. More typically, augmenting an \emcppsgloss{aggregate} with a \emcppsgloss[user provided]{user-\linebreak[4]provided} \emcppsgloss{special member function} will suppress the implicit generation of others. In such cases, we can apply the same \lstinline!=!\,\lstinline!default! approach used in item 0 to automatically generate the default implementations of those special member functions that were suppressed.

A \emcppsgloss[user provided]{user-provided} \emcppsgloss{destructor}, unlike a \emcppsgloss{default
constructor}, has far-reaching implications on the implicit generation
of both \emcppsgloss[move operations]{\emph{move} operations} that, absent thorough unit
testing, might go unnoticed and remain latent defects even after being
released to production. Suppose we'd like to add some benign code to the
\emcppsgloss{destructor} of the \emcppsgloss{aggregate} class \lstinline!Person! and
call the new class \lstinline!Person3!:

\begin{emcppslisting}
struct Person3  // We want to employ a user-provided destructor.
{
    String firstName;
    String lastName;

    ~Person3() { /* user-provided */ }  // destructor
};
\end{emcppslisting}
    
    
\noindent Declaring the destructor suppresses the declaration and implicit
generation of both the \emcppsgloss{move constructor} and
\emcppsgloss[move assignment operator]{move-assignment operator} but leaves the object of
\emcppsgloss{aggregate} type. Absent proper unit testing, the object might
appear to work as before, though it silently \emph{copies} rather than
\emph{moves} its subobjects:

\begin{emcppslisting}
Person3 x3 = { "abc", "def" };  // OK, still an aggregate
Person3 y3;                     // OK, default constructor is still available.
Person3 z3(std::move(x3));      // Bug, invokes implicit copy constructor
y3 = std::move(z3);             // Bug, invokes implicit copy assignment
\end{emcppslisting}
    
    
\noindent Although we can still \emcppsgloss[aggregate initialization]{aggregate initialize} (\lstinline!x3!) and
\emcppsgloss[default constructed]{default construct} (\lstinline!y3!) a \lstinline!Person3! object, no
\emph{move} operations are declared, so when we try to \emcppsgloss[move construction]{move
construct} (\lstinline!z3!) or \emcppsgloss{move assign} (\lstinline!y3!) a
\lstinline!Person3!, the corresponding implicitly generated \emph{copy}
operations are invoked automatically instead. The result is that each of
the three objects --- \lstinline!x3!, \lstinline!y3!, and \lstinline!z3! --- now
manages its own dynamically allocated memory to represent needlessly the
same overall person value, namely
\lstinline!{}!~\lstinline!"abc",!~\lstinline!"def"!~\lstinline!}!:
%%%%%% NOTE: have AUs check above line and make sure the brackets are correct

\begin{emcppslisting}
#include <cstring>  // (ù{\codeincomments{std::strlen}}ù)
#include <cassert>  // standard C (ù{\codeincomments{assert}}ù) macro

void test3()
{
    assert(strcmp(x3.firstName.str(), ""));     // Error, still holds (ù{\codeincomments{"abc"}}ù)
    assert(strcmp(y3.firstName.str(), "abc"));  // OK, holds (ù{\codeincomments{"abc"}}ù)
    assert(strcmp(z3.firstName.str(), ""));     // Error, still holds (ù{\codeincomments{"abc"}}ù)
}
\end{emcppslisting}
    
Suppose we now decide to default both of these suppressed \emcppsgloss[move operations]{move
operations explicitly} in \lstinline!Person3a!:

\begin{emcppslisting}
struct Person3a  // Adding user-provided destructor (Revision a)
{
    String firstName;
    String lastName;

    ~Person3a() { /* user-provided */ }         // destructor

    Person3a(Person3a&&) = default;             // move constructor
    Person3a& operator=(Person3a&&) = default;  // move assignment
};
\end{emcppslisting}
    
    
\noindent By explicitly declaring the \emcppsgloss[move assignment operator]{move-assignment operator} to be
\emcppsgloss{defaulted}, we restore that capability but implicitly
\lstinline!delete! (see \featureref{\locationa}{deleted-functions}) both the \emcppsgloss{copy
constructor} and \emcppsgloss[copy assignment operator]{copy-assignment operator}. By explicitly
defaulting the \emcppsgloss{move constructor}, however, not only do we
implicitly suppress both copy operations, but we also suppress
\emcppsgloss[default constructed]{default construction}. However, because no constructor has been
\emcppsgloss[user provided]{user-provided} (merely \emcppsgloss[defaulted]{defaulting} and/or
\emcppsgloss[delete]{deleting} them would not be considered \emcppsgloss[user provided]{user-provided}),
the overall object remains of \emcppsgloss{aggregate} type:

\begin{emcppslisting}
Person3a x3a = {"abc", "def" };  // OK, still an aggregate
Person3a y3a;                    // Error, default constructor is not declared.
Person3a z3a(x3a);               // Error, copy constructor is deleted.
x3a = z3a;                       // Error, copy assignment is deleted.
\end{emcppslisting}
    
    
\noindent Defaulting both copy operations and the \emcppsgloss{default destructor},
e.g., \lstinline!Person3b!, restores the type to its previous functionality
as a proper aggregate:

\begin{emcppslisting}
struct Person3b  // Adding a user-provided destructor (Revision b)
{
    String firstName;
    String lastName;

    ~Person3b() { /* user-provided */ }              // destructor

    // Already added to (ù{\codeincomments{Person3a}}ù).
    Person3b(Person3b&&) = default;                  // move constructor
    Person3b& operator=(Person3b&&) = default;       // move assignment

    // New here in (ù{\codeincomments{Person3b}}ù).
    Person3b() = default;                            // default constructor
    Person3b(const Person3b&) = default;             // copy constructor
    Person3b& operator=(const Person3b&) = default;  // copy assignment
};
\end{emcppslisting}
    
    
\noindent To recap, adding the \emcppsgloss[user provided]{user-provided} \emcppsgloss{destructor} in
\lstinline!Person3! suppressed both \emcppsgloss{move operations}. Defaulting
these \emcppsgloss{move operations} in \lstinline!Person3a!, in turn, suppressed
both \emcppsgloss{copy operations} and, because of the \emcppsgloss{move
constructor} specifically, the \emcppsgloss{default constructor} as well.
Defaulting those three operations in \lstinline!Person3b! restores
everything we had in the original \lstinline!Person! aggregate yet allows
us to add benign metrics to a \emcppsgloss[user provided]{user-provided} \emcppsgloss{destructor}
as we see fit.}

%%%% item 5
\item{\emcppsgloss[user provided]{User-provided} \emcppsgloss{copy constructor}. Once we understand the consequences of defining our own \emcppsgloss{destructor} (e.g., \lstinline!Person!~\lstinline!3! in the most recent example), the story behind adding a \emcppsgloss{copy constructor} to our original aggregate \lstinline!Person! class will seem remarkably similar. Rather than repeat that laborious discovery process in all its detail, starting with \lstinline!Person4! (the original aggregate + the copy constructor, not shown), we’ll instead provide only the end result, namely \lstinline!Person4c! with all special member functionality restored:

\begin{emcppslisting}
struct Person4c  // adding a user-provided copy constructor
{
    String firstName;
    String lastName;

    Person4c(const Person4c& original)               // copy constructor
    : firstName(original.firstName)
    , lastName(original.lastName) { /* user-provided */ }

    // Already added to (ù{\codeincomments{Person4a}}ù) (not shown).
    Person4c() = default;                            // default constructor

    // Already added to (ù{\codeincomments{Person4b}}ù) (not shown).
    Person4c(Person4c&&) = default;                  // move constructor
    Person4c& operator=(Person4c&&) = default;       // move assignment

    // New here in (ù{\codeincomments{Person4c}}ù).
    Person4c& operator=(const Person4c&) = default;  // copy assignment
};
\end{emcppslisting}
    
    
\noindent Though we don't show the revisions to \lstinline!Person!,
\lstinline!Person!~\lstinline!4a!, and \lstinline!Personb! in the example above,
we'll walk through those changes. The class necessarily forfeits its
aggregate status in the first revision to \lstinline!Person!, namely
\lstinline!Person4a!, by user-providing a \emcppsgloss{copy constructor} or a
constructor of any kind. What's more, explicitly declaring a
\emcppsgloss{copy constructor} (in any way) suppresses implicit generation of
the \emcppsgloss{default constructor}. Hence, any unit test expecting to
construct the newly augmented person object using either a
\emcppsgloss{default constructor} or \emcppsgloss{aggregate initialization} will
not compile.

By \emcppsgloss[defaulted]{defaulting} the \emcppsgloss{default constructor} in
\lstinline!Person4a!, we regain the ability to compile our unit test driver
and can now observe that, by having declared the copy constructor
explicitly, we had suppressed both \emcppsgloss{move construction} and
\emcppsgloss{move assignment}, thus introducing a potentially latent
performance defect. Defaulting the two \emcppsgloss{move operations} in
\lstinline!Person4b! restores their respective move capabilities.
Defaulting \emcppsgloss{move assignment} in particular, however, now causes
\emcppsgloss{copy assignment} to be implicitly \emcppsgloss[delete]{deleted}; see
\featureref{\locationa}{deleted-functions}.

Finally, by defaulting the \emcppsgloss[copy assignment operator]{copy-assignment operator} in
\lstinline!Person4c! (shown in the example above), we regain all of the
\emcppsgloss[regular type]{regular} functionality of the original aggregate class but,
because of the \emcppsgloss[user provided]{user-provided} \emcppsgloss{copy constructor},
\lstinline!Person4c! no longer amenable to \emcppsgloss{aggregate
initialization}. Note that the \emcppsgloss{destructor} is \emph{never}
suppressed by the explicit declaration of any other function.}

%%%% item 6
\item{\emcppsgloss[user provided]{User-provided} \emcppsgloss[copy assignment operator]{copy-assignment operator}. Once we understand the consequences of \emcppsgloss[user provided]{user-providing} a \emcppsgloss{copy constructor} (e.g., \lstinline!Person4c! in the example in item 4), there are no surprises here. Again, we’ll provide, for reference, only the final, transitive result, \lstinline!Person5b!:

\begin{emcppslisting}
struct Person5b  // adding a user-provided copy-assignment operator
{
    String firstName;
    String lastName;

    Person5b& operator=(const Person5b& rhs)    // copy assignment
    {
        firstName = rhs.firstName;
        lastName  = rhs.lastName;
        return *this;
    }

    // Already added to (ù{\codeincomments{Person5a}}ù) (not shown).
    Person5b(Person5b&&) = default;             // move constructor
    Person5b& operator=(Person5b&&) = default;  // move assignment

    // New here in (ù{\codeincomments{Person5b}}ù).
    Person5b() = default;                       // default constructor
    Person5b(const Person5b&) = default;        // copy constructor
};
\end{emcppslisting}
    
    
\noindent Again, we've omitted \lstinline!Person5! and \lstinline!Person5a! from the
example above, but we'll walk through those revisions. Providing a
user-defined \emcppsgloss[copy assignment operator]{copy-assignment operator} in \lstinline!Person5!,
unlike providing a \emcppsgloss{copy constructor}, leaves the class of
\emcppsgloss{aggregate type} but similarly suppresses the declaration of both
the \emcppsgloss{move constructor} and \emcppsgloss[move assignment operator]{move-assignment operator}.
Restoring \emcppsgloss{move assignment} in \lstinline!Person5a! has no further
suppressive effects, but restoring \emcppsgloss{move construction} in turn
suppresses both \emcppsgloss[default constructed]{default construction} and \emcppsgloss[copy constructor]{copy
construction}. Class \lstinline!Person5b!, shown in the code snippet above,
provides the same functionality as the original aggregate
\lstinline!Person! class, i.e., including aggregate initialization, along
with the ability to add a benign implementation, affecting no other
special-member implementations, to the \emcppsgloss[user provided]{user-provided} \emcppsgloss[copy assignment operator]{copy-assignment operator}.}

%%%%% item 7
\item{\emcppsgloss[user provided]{User-provided} \emcppsgloss{move constructor}. Instrumenting a \emcppsgloss{move constructor} during development, if just to ensure that it is being called when expected, isn’t a bad idea. Again, we will provide the final result and an appropriate analysis of how we got here:

\begin{emcppslisting}
struct Person6b  // adding a user-provided move constructor
{
    String firstName;
    String lastName;

    Person6b(Person6b&& expiring)                    // move constructor
    : firstName(std::move(expiring.firstName))
    , lastName (std::move(expiring.lastName)) { /* user-provided */ }

    // Already added to (ù{\codeincomments{Person6a}}ù) (not shown).
    Person6b() = default;                            // default constructor
    Person6b(const Person6b&) = default;             // copy constructor
    Person6b& operator=(const Person6b&) = default;  // copy assignment

    // New here in (ù{\codeincomments{Person6b}}ù).
    Person6b& operator=(Person6b&&) = default;       // move assignment
};
\end{emcppslisting}
    
    
\noindent First note the use of \lstinline!std::move! in the user-provided
implementation of the \emcppsgloss{move constructor} in the example above.
Recall that a parameter of type \romeovalue{rvalue} reference (\lstinline!&&!)
is an \romeovalue{lvalue}, so \lstinline!std::move! is \emph{required} to enable
a move from such a parameter. Not employing \lstinline!std::move! would
mean that these data members would be individually copied rather than
moved. Absent a thorough unit test, such inadvertent, pessimizing
omissions might well find their way into widespread use.

In the original enhanced version (\lstinline!Person6a!, which is not shown
in the example), the \emcppsgloss[user provided]{user-provided} \emcppsgloss{move constructor}
immediately renders the class to be of non\emcppsgloss{aggregate type}.
Moreover, both the \emcppsgloss{copy constructor} and the
\emcppsgloss[copy assignment operator]{copy-assignment operator} are deleted, and the \emcppsgloss{default
constructor} and the \emcppsgloss[move assignment operator]{move-assignment operator} are not
implicitly generated. Since there is no way to create an object and then
learn that the \emcppsgloss[move assignment operator]{move-assignment operator} is missing (short of
knowing, as we do here), the first step is to get the unit test driver
to compile, which is accomplished by defaulting the \emcppsgloss{default
constructor}, \emcppsgloss{copy constructor}, and \emcppsgloss[copy assignment operator]{copy-assignment
operator} in \lstinline!Person6a!.

After that, our thorough unit tests can observe that what should be
\emcppsgloss{move assignment} is falling back on \emcppsgloss{copy assignment},
which needlessly allocates new resources rather than transferring them
when the source is \emcppsgloss{expiring}. By now also defaulting the
\emcppsgloss[move assignment operator]{move-assignment operator}, we arrive at a class that again has
all the \emcppsgloss[regular type]{regular} functionality of the original \lstinline!Person!
class, namely \lstinline!Person6b! (shown in the code snippet above), but
absent the ability to be \emcppsgloss[aggregate initialization]{aggregate-initialized}.}

%%%%%% item 8
\item{\emcppsgloss[user provided]{User-provided} \emcppsgloss[move assignment operator]{move-assignment operator}. Instrumenting a \emcppsgloss[move assignment operator]{move-assignment operator} during development, just like a \emcppsgloss{move constructor}, can be useful:

\begin{emcppslisting}
struct Person7b  // adding a user-provided move-assignment operator
{
    String firstName;
    String lastName;

    Person7b& operator=(Person7b&& expiring)         // move assignment
    {
        firstName = std::move(expiring.firstName);
        lastName  = std::move(expiring.lastName);
        return *this;
    }

    // Previously added to (ù{\codeincomments{Person7a}}ù) (not shown).
    Person7b(const Person7b&) = default;             // copy constructor
    Person7b& operator=(const Person7b&) = default;  // copy assignment
    Person7b(Person7b&&) = default;                  // move constructor

    // New here in (ù{\codeincomments{Person7b}}ù).
    Person7b() = default;                            // default constructor
};
\end{emcppslisting}
    
    
\noindent Again, we've omitted \lstinline!Person7! and \lstinline!Person7a!, but we'll
discuss those revisions. Importantly, let's again note the use of
\lstinline!std::move! in the implementation of the \emcppsgloss[user provided]{user-provided}
\emcppsgloss[move assignment operator]{move-assignment operator}; without it, the members would instead
be \emph{copied} undesirably rather than \emph{moved}. In the original
version (\lstinline!Person7!), the \emcppsgloss[user provided]{user-provided}
\emcppsgloss[move assignment operator]{move-assignment operator} results in the deletion of both
\emcppsgloss{copy operations} as well as the suppression of the implicit
declaration of the \emcppsgloss{move constructor}. However, unlike the
\emcppsgloss[user provided]{user-provided} \emcppsgloss{move constructor}, the
\emcppsgloss[user provided]{user-provided} \emcppsgloss[move assignment operator]{move-assignment operator} doesn't affect
the \emcppsgloss{aggregate} nature of the overall type nor does it
immediately suppress the \emcppsgloss{default constructor}.

Since there is neither a \emcppsgloss{copy constructor} nor a
\emcppsgloss{move constructor} available, both omissions would
likely show up as compile-time errors in a thorough unit-test suite. By
subsequently defaulting all three missing \emcppsgloss{special member
functions} (\lstinline!Person7a!), we would discover that the defaulting of
the \emcppsgloss[copy constructor]{copy} and \emcppsgloss[move constructor]{move constructors} has, in turn,
suppressed the implicit declaration of the \emcppsgloss{default constructor}.

Finally, by defaulting the \emcppsgloss{default constructor}
(\lstinline!Person7b!), we regain all of the original functionality of the
aggregate \lstinline!Person! class including the ability to
\emcppsgloss[aggregate initialization]{aggregate initialize} it.}
\end{enumerate}
%%%%%%%%%%%%%%%

In summary: We can create a higher-level, value-semantic type (VST)
quickly and reliably by combining lower-level ones. These higher-level
VSTs can be aggregate initialized, default initialized, copied, and
moved as a unit, provided the types of the respective, lower-level, base
and member subobjects support the needed operations.

Sometimes a user will need to provide a custom implementation of one or
more of these special member functions, which may affect implicit
generation of other member functions and/or the ability to
\emcppsgloss[aggregate initialization]{aggregate initialize} the object; see \featureref{\locationc}{bracedinit}.

One might reasonably decide to just explicitly \emcppsgloss[defaulted]{default}
\emph{all} of the remaining \emcppsgloss{special member functions}, and that
works well in most practical cases. Note, however, that, unlike
suppression of the \emcppsgloss{copy operations}, when the \emcppsgloss{default
constructor} or either \emcppsgloss[move operations]{move operation} is suppressed by an
explicit declaration of some other function, it is left
\emcppsgloss{undeclared} rather than being \emph{declared} but
\emcppsgloss[delete]{deleted}, which in turn can have subtle implications.

Explicitly or implicitly \emcppsgloss[defaulted]{defaulting} (see \featureref{\locationa}{defaulted-special-member-functions}) or \emcppsgloss[delete]{deleting} (see \featureref{\locationa}{deleted-functions}) a function ensures that it \emph{is} \emcppsgloss[declare]{declared}
and, hence, may participate in overload resolution as well as affect the
outcome of certain compile-time type traits, such as
\lstinline!std::is_literal_type!, which can be found in the standard
header \lstinline!<type_traits>! (see \featureref{\locationc}{constexprfunc}).

Explicitly \emcppsgloss[define]{defining} a \emcppsgloss{special member function} to have the same implementation as would have been generated had that function
been declared implicitly will produce the same behavior locally but may
affect the outcome of certain type-wide traits such as \lstinline!std::is_aggregate!, which also can be found in \lstinline!<type_traits>!.{\cprotect\footnote{Rule C.20 of the \emph{C++ Core Guidelines} advises, ``If you can avoid defining default operations, do.''; see \cite{stroustrup20}.}}

\paragraph[Creating a generic value-semantic container type]{Creating a generic value-semantic container type}\label{creating-a-generic-value-semantic-container-type}

A primary motivation for the introduction of \romeovalue{rvalue} references
into C++11 was the desire to provide ubiquitous, uniform support for a
pair of \emcppsgloss{special member functions}, parallel to the \emcppsgloss{copy
constructor} and the \emcppsgloss[copy assignment operator]{copy-assignment operator}, that distinguish
when it is permissible to \emph{steal} resources from the source object.

In particular, for a standard container, such as \lstinline!std::vector!,
to provide the \emcppsgloss{strong exception-safety guarantee} for public
member functions, e.g., \lstinline!push_back!, was deemed unacceptably
inefficient in C++03 because resizing capacity necessitated copying over
all of its element subobjects only to then immediately (and wastefully)
destroy the original ones. The gratuitous copying made necessary to
preserve the \emcppsgloss{strong guarantee} could be sidestepped provided the
element-type argument supplied to the \lstinline!vector! template sports a
nonthrowing \emcppsgloss{move constructor}.

Proper implementation of \lstinline!std::vector! requires the ability to
detect, at compile time, whether the \emcppsgloss{move constructor} of the
specified element type is permitted to throw; a thorough discussion of
how to implement robust \lstinline!std::vector!-like operations, such as
\lstinline!push_back! and \lstinline!emplace_back!, along with the
\emcppsgloss{strong guarantee} is provided in \featureref{\locationc}{noexceptoperator}. Here, we will introduce a simplified, fixed-size-array type
to illustrate the straightforward benefits of \romeovalue{rvalue} references
while sidestepping distractions arising from the \emcppsgloss{strong
guarantee}, resizing capacity, and local memory allocators.{\cprotect\footnote{A thorough description of the practical use of \emcppsgloss{C++11 memory allocators} and, especially, \emcppsgloss[C++17 pmr allocators]{C++17 \lstinline!pmr! allocators} is anticipated in \cite{lakos22}.}}

Let's now consider the class definition for a simple generic container
type, \lstinline!FixedArray<T>!, that provides a minimal set of
capabilities to manage a dynamically allocated, ``fixed-size'' array of
elements of type \lstinline!T!. The implementations of all six special
member functions are \emcppsgloss[user provided]{user-provided}, along with an ``extra''
(\lstinline!explicit!) size constructor, used to set the fixed
capacity of the array at construction. Note that only the \emph{copy}
and \emph{move} assignment operators may change the size and capacity of
an existing array object.

Finally, three more member functions are provided to access array
elements by index of a non\lstinline!const! and \lstinline!const! array, along
with a \lstinline!const! member function to access the array's size. Note
that the behavior is undefined unless the user-supplied element index is
less than the array size:

\begin{emcppslisting}
#include <cstddef>  // (ù{\codeincomments{std::size\_t}}ù)

template <typename T>
class FixedArray
{
    T*           d_ary_p;  // dynamically allocated array of fixed size
    std::size_t  d_size;   // number of elements in dynamically allocated array

public:
    FixedArray();                                      // default constructor
    explicit FixedArray(std::size_t size);             // size constructor
    ~FixedArray();                                     // destructor
    FixedArray(const FixedArray& original);            // copy constructor
    FixedArray& operator=(const FixedArray& rhs);      // copy-assignment
    FixedArray(FixedArray&& expiring) noexcept;        // move constructor
    FixedArray& operator=(FixedArray&& expiring) noexcept;  // move-assignment

    T& operator[](std::size_t index);              // modifiable element access
    const T& operator[](std::size_t index) const;  // (ù{\codeincomments{const}}ù) element access
    std::size_t size() const;                      // number of array elements
};
\end{emcppslisting}
    
    
\noindent The class definition in the example above --- apart from the two C++11
\emcppsgloss{move operations} --- would be the same in C++03. Moreover, we
can instantiate and use a \lstinline!FixedArray! on any VST that supports
at least the four classic special member functions:

\begin{emcppslisting}
FixedArray<double> ad;           // empty array of (ù{\codeincomments{double}}ù) objects
FixedArray<int>    ai(5);        // array of 5 zero-valued (ù{\codeincomments{int}}ù) objects

#include <string>                // (ù{\codeincomments{std::string}}ù)
FixedArray<std::string> as(10);  // array of 10 empty (ù{\codeincomments{std::string}}ù) objects
\end{emcppslisting}
    
    
\noindent Note that if the element type supplied for the template parameter,
\lstinline!T!, does not support C++11 \emcppsgloss{move operations}, then
neither will the \lstinline!FixedArray<T>! container itself.

Let's now consider the implementation, which --- apart from the two move
operations --- is the same as it would have been in C++03. Notably,
creating a default-constructed container ideally allocates no resources
(if just for performance reasons), and the \emcppsgloss{size constructor} is
deliberately made explicit to avoid inadvertently creating a fixed array
via an unexpected implicit conversion from an \lstinline!int! (see
\featureref{\locationa}{explicit-conversion-operators}):

\begin{emcppslisting}
template <typename T>  // default constructor
FixedArray<T>::FixedArray() : d_ary_p(0), d_size(0) { }

template <typename T>                    // size constructor
FixedArray<T>::FixedArray(std::size_t size) : d_size(size)
{
    d_ary_p = size ? new T[size]() : 0;  // value initialize each element
}
\end{emcppslisting}
    
    
\noindent When allocating a resource, we always consistently do so using array
\lstinline!new!. Notice that we have deliberately \emcppsgloss{value
initialized} --- i.e., \lstinline!new!~\lstinline!T[size]()! --- the
dynamically allocated array. For an object that has a default
constructor, that constructor would be called regardless; for scalar or
user-defined \emcppsgloss{aggregate} types, failing to \emcppsgloss[value initialized]{value
initialize} --- i.e., \lstinline!new!~\lstinline!T[size]! --- could leave the
elements, or parts thereof, in an uninitialized state.

It is not uncommon to place \emcppsgloss[defensive check]{defensive checks} for \emcppsgloss{object
invariants} at the top of the body of a destructor as this is the one
place every object must pass through before it is destroyed:

\begin{emcppslisting}
#include <cassert>  // standard C (ù{\codeincomments{assert}}ù) macro

template <typename T>  // destructor
FixedArray<T>::~FixedArray()
{
     assert(!d_ary_p == !d_size);  // Assert object invariant.
     delete[] d_ary_p;            // resource released as an array of (ù{\codeincomments{T}}ù)
}
\end{emcppslisting}
    
    
\noindent Our object invariant for this \lstinline!FixedArray! type requires that a
memory resource is allocated if and only if the array size is nonzero.
Notice also that every allocation is presumed to be allocated by array
\lstinline!new! and never directly, e.g., via
\lstinline!operator!~\lstinline!new!.

When it comes to \emcppsgloss[copy constructor]{copy construction}, the implementation is
mostly straightforward. If the size of the original object is nonzero,
we allocate enough memory to hold the requisite number of elements ---
nothing more --- and then proceed to copy assign them one by one; if the
original object was empty, then we make this object's resource handle
\emph{null} too:

\begin{emcppslisting}
template <typename T>  // copy constructor
FixedArray<T>::FixedArray(const FixedArray& original) : d_size(original.d_size)
{
    if (d_size)  // if (ù{\codeincomments{original}}ù) array is (ù{\emphincomments{not}}ù) empty
    {
        d_ary_p = new T[d_size];         // default initialize each element

        for (std::size_t i = 0; i < d_size; ++i)  // for each array element
        {
            d_ary_p[i] = original.d_ary_p[i];     // copy-assign value
        }
    }
    else  // else (ù{\codeincomments{original}}ù) array (ù{\emphincomments{is}}ù) empty
    {
        d_ary_p = 0;  // Make this array (ù{\emphincomments{null}}ù) too.
    }
}  // Note that we already set (ù{\codeincomments{d\_size}}ù) in the initialization list up top.
\end{emcppslisting}
    
    
\noindent Notice that here we have allocated the array using \emcppsgloss{default
initialization} to minimize unnecessary initializations prior to copy
assigning them. In a more efficient implementation, we might consider
using \lstinline!operator!~\lstinline!new! directly and then copy constructing
each object in place, but we would then need to destroy each element in
a loop as well where we currently use
\lstinline!operator!~\lstinline!delete[]!; see \featureref{\locationc}{noexceptoperator}. What's more, we could even check whether the element type
is \emcppsgloss{trivially copyable} and, if so, use \lstinline!memcpy! instead;
see \featureref{\locationc}{gpods}.

As ever, copy assignment inherently has the most complex implementation
of all the special member functions. First we must guard against
assignment to self. If the two objects are not the same size, then we
will need to make them so. If the target object holds a resource, we'll
need to free it before allocating another. Once the two resources are
the same size, we'll need to copy the elements over:

\begin{emcppslisting}
template <typename T>  // copy-assignment operator
FixedArray<T>& FixedArray<T>::operator=(const FixedArray& rhs)
{
    if (&rhs != this)  // guard against self aliasing
    {
        if (d_size != rhs.d_size)  // If sizes differ, make this same as other.
        {
            if (d_ary_p)  // If this array was not (ù{\emphincomments{null}}ù), clear it.
            {
                 delete[] d_ary_p;  // Release resource as an array of (ù{\codeincomments{T}}ù).
                 d_ary_p = 0;        // Make null. (Note size isn't yet updated.)
                 d_size  = 0;        // Make empty. (Reestablish obj. invariant.)
            }

            assert(!d_ary_p == !d_size);  // Assert object invariant.
            d_ary_p = new T[rhs.d_size];  // Default initialize each element.
            d_size  = rhs.d_size;         // Make this size same as (ù{\codeincomments{rhs}}ù) size.
        }

        assert(d_size == rhs.d_size);  // The two sizes are now the same.

        for (std::size_t i = 0; i < d_size; ++i)  // for each element
        {
            d_ary_p[i] = rhs.d_ary_p[i];  // Copy-assign value.
        }
    }
    return *this;  // (ù{\emphincomments{lvalue}}ù) reference to self
}
\end{emcppslisting}
    
    
\noindent Notice that we (1) released any current resources assuming that they
were allocated using array \lstinline!new! and (2) deliberately default
initialized each allocated element prior to \emcppsgloss[copy assigned]{copy assigning} to
it. Also notice that we have introduced two \emcppsgloss[defensive check]{defensive checks} in
the middle of our implementation to serve as ``active commentary'' to
state that, no matter how we got here, what is asserted is either
\lstinline!true! or else the program itself is defective.

Let's now turn to what is new in C++11. We'll first need to
\lstinline!#include! the standard header that defines \lstinline!std::move!,
namely \lstinline!<utility>!. To implement the \emcppsgloss{move constructor},
we'll use the member-initializer list to copy the size and address of
the resource to the object. After that, we'll just assign those values
to render the source object \emph{null}, i.e., managing no resources, as
if it had just been \emcppsgloss{default constructed}:

\begin{emcppslisting}
#include <utility>  // (ù{\codeincomments{std::move}}ù)

template <typename T>      // move constructor
FixedArray<T>::FixedArray(FixedArray&& expiring) noexcept
: d_size(expiring.d_size)
, d_ary_p(expiring.d_ary_p)
{
    expiring.d_ary_p = 0;  // Relinquish ownership.
    expiring.d_size  = 0;  // Reestablish object invariant.
}
\end{emcppslisting}
    
    
\noindent In this case, we always know that the value of a moved-from
\lstinline!FixedArray! object will be empty, but see \intraref{potential-pitfalls-rvalueref}{inconsistent-expectations-on-moved-from-objects}.

Next, we consider \emcppsgloss{move assignment}. We must, as ever, first
check for assignment to self. If not, we unconditionally delete our
resource, knowing that it is a no-op if the resource handle is
\emph{null}. We then copy over the resource address and size from
\lstinline!expiring! and restore \lstinline!expiring! to its
default-constructed state:

\begin{emcppslisting}
template <typename T>       // move-assignment operator
FixedArray<T>& FixedArray<T>::operator=(FixedArray&& expiring)
{
    if (&expiring != this)  // Guard against self-aliasing.
    {
        delete[] d_ary_p;  // Release resource from this obj. as array of (ù{\codeincomments{T}}ù).
        d_ary_p = expiring.d_ary_p;  // Copy address of resource.
        d_size  = expiring.d_size;   // Copy size of resource.
        expiring.d_ary_p = 0;        // Make (ù{\codeincomments{expiring}}ù) relinquish ownership.
        expiring.d_size  = 0;        // Re-establish object invariants in (ù{\codeincomments{expiring}}ù).
    }

    return *this;  // Return (ù{\emphincomments{lvalue}}ù) (not (ù{\emphincomments{rvalue}}ù)) reference to self.
}
\end{emcppslisting}
    
    
\noindent Note that the \emcppsgloss[move assignment operator]{move-assignment operator} takes an \romeovalue{rvalue}
reference but, like its copy-assignment counterpart, returns an
\romeovalue{lvalue} reference.

Finally, for completeness, we show the three methods to access the
modifiable and \lstinline!const! elements and the size of the array,
respectively:

\begin{emcppslisting}
template <typename T>                              // modifiable element access
T& FixedArray<T>::operator[](std::size_t index)
{
    assert(index < d_size);  // Assert precondition.
    return d_ary_p[index];   // Return (ù{\emphincomments{lvalue}}ù) reference to modifiable element.
}

template <typename T>                              // (ù{\codeincomments{const}}ù) element access
const T& FixedArray<T>::operator[](std::size_t index) const
{
    assert(index < d_size);  // Assert precondition.
    return d_ary_p[index];   // Return (ù{\emphincomments{lvalue}}ù) reference to (ù{\codeincomments{const}}ù) element.
}

template <typename T>                              // number of array elements
std::size_t FixedArray<T>::size() const { return d_size; }
\end{emcppslisting}
    
    
\noindent Note that the functionality provided by each of the three member
functions above is entirely independent of the augmented functionality
afforded by the two \emcppsgloss[move semantics]{move-semantic} \emcppsgloss{special member
functions}, the \emcppsgloss{move constructor}, and the
\emcppsgloss[move assignment operator]{move-assignment operator}.

For an industrial-strength implementation example involving a
\lstinline!push_back! operation overloaded on \emcppsgloss[rvalue reference]{\romeovalue{rvalue}
reference} for a \lstinline!std:vector!, see \featureref{\locationc}{noexceptoperator}.

\subsubsection[Move-only types]{Move-only types}\label{move-only-types}

We may want some classes to represent \emcppsgloss{unique ownership} of a
resource. For resources without intrinsic copyability, the standard copy
operations would not make sense. A \emcppsgloss[move only type]{move-only type} can be used
when only one object should have a particular piece of state at any
given time. As long as the particular object that owns the state does
not need to remain constant (i.e., pointers to the owning object are not
maintained in external data structures), adding move operations can
bring additional utility to a type without requiring copyability.

For example, \lstinline!std::thread!, introduced in C++11, represents an
underlying operating system thread. There is no way to create a second
copy of a running operating system thread, and it would be significantly
unintuitive if \lstinline!std::thread! objects could be easily copied when
the underlying resource was not going to be duplicated. On the other
hand, since a \lstinline!std::thread! is primarily a handle to the
underlying resource, its own identity does not need to be set in stone,
so moving that handle to a different instance of \lstinline!std::thread! is
very natural. This is accomplished by defining a \emcppsgloss{move
constructor} and then deleting the \emcppsgloss{copy constructor}; see
\featureref{\locationa}{deleted-functions} and \featureref{\locatione}{noexcept-specifier}:

\begin{emcppslisting}
class thread
{
    // ...
    thread() noexcept;
    thread(thread&& other) noexcept;
    thread(const thread&) = delete;
    // ...
};
\end{emcppslisting}
    
    
\noindent To transfer the ownership of a thread, we must use \lstinline!std::move!:

\begin{emcppslisting}
#include <thread>  // (ù{\codeincomments{std::thread}}ù)

void test1()
{
    std::thread t{[] { std::cout << "hello!"; }};
    std::thread tCopy  = t;             // Error, cannot copy
    std::thread tMoved = std::move(t);  // OK
}
\end{emcppslisting}
    
    
\noindent If we want to transfer the ownership of the thread to another
\lstinline!std::thread! instance, we are forced to explicitly convert
\lstinline!t! to an \emcppsgloss[rvalue reference]{\romeovalue{rvalue} reference}. By using \lstinline!std::move!
we communicate to the compiler and to those reading the code that a new
object will now own the underlying operating system thread and that the
old object will be put in an empty state.

A related type, \lstinline!std::unique_lock!, exemplifies the ability to
move responsibility between objects, specifically the responsibility to
release a lock when destroyed. By combining movability with standard
\emcppsgloss{RAII} there is increased flexibility, enabling the passing and
returning of responsibility without the risk of failing to execute it
when all objects are destroyed:

\begin{emcppslisting}
#include <mutex>  // (ù{\codeincomments{std::mutex}}ù), (ù{\codeincomments{std::unique\_lock}}ù)

void test2()
{
    std::mutex m;
    std::unique_lock<std::mutex> ul{m};

    {
        std::unique_lock<std::mutex> ulMoved = std::move(ul);  // OK
    }  // (ù{\codeincomments{ulMoved}}ù) destroyed, lock released

    assert(ul.mutex() == nullptr);  // (ù{\codeincomments{ul}}ù) is moved-from.
}
\end{emcppslisting}
    
    
\noindent Finally, the Standard provides \lstinline!std::unique_ptr! to manage
unique ownership of a resource identified by a pointer with a
compile-time customizable deleter that will be used to free that
resource when a \lstinline!std::unique_ptr! is destroyed without having
had its resource moved away. The most common and default use for this
type is to manage heap-allocated memory, where the default deleter will
simply invoke \lstinline!delete! on the pointer. C++14 also adds a helper
utility, \lstinline!std::make_unique!, that encapsulates heap allocation
with \lstinline!new!:

\begin{emcppslisting}
#include <memory>  // (ù{\codeincomments{std::unique\_ptr}}ù), (ù{\codeincomments{std::make\_unique}}ù)

void test3()
{
    std::unique_ptr<int> up1{new int(1)};       // OK, heap alloc #1
    up1 = std::make_unique<int>(2);             // OK, frees #1, new alloc #2

    std::unique_ptr<int> up2 = std::move(up1);  // OK, (ù{\codeincomments{up2}}ù) now owns #2.
    assert( up1 == std::unique_ptr<int>());     // OK, (ù{\codeincomments{up1}}ù) is moved-from.
    assert(*up2 == 2);                          // OK
}  // Destruction of (ù{\codeincomments{up2}}ù) deletes alloc #2; destruction of (ù{\codeincomments{up1}}ù) does nothing.
\end{emcppslisting}
    
    
\noindent \lstinline!std:unique_ptr! can be very useful when an object that cannot
be copied needs to be referenced by an object whose state might need to
move around. While one pre-C++11 solution to this need might be to
dynamically allocate the object and track the object's lifetime with a
reference-counted smart pointer (such as \lstinline!std::tr1::shared_ptr!
or \lstinline!boost::shared_ptr!), the addition of that tracking incurs
additional overhead that might not be warranted. Using
\lstinline!std::unique_ptr! instead will manage the lifetime of the
heap-allocated object correctly, allowing it to remain in a stable
location from construction to destruction and letting the client's
handle to the object --- a \lstinline!std::unique_ptr! --- move to where
it needs to be.

\paragraph[Implementing a move-only type]{Implementing a move-only type}\label{implementing-a-move-only-type}

For general purposes, the standard library templates already capture in
a reusable fashion the proper implementation of a move-only type, e.g.,
\lstinline!std:unique_ptr!. To understand what is involved in such
implementations, let's explore how we might implement a subset of the
functionality of \lstinline!std::unique_ptr!. The declaration of our
\lstinline!UniquePtr! with no support for custom deleters simply needs to
\lstinline!=!\,\lstinline!delete! the \emcppsgloss{copy constructor} and provide the
appropriate \emcppsgloss{move constructor} and \emcppsgloss[move assignment
operator]{move-assignment
operator}. Along with the basic accessors to implement a typical
\emcppsgloss{smart pointer}, a complete implementation of a move-only owning
pointer is not tremendously involved:

\begin{emcppslisting}
#include <utility>  // (ù{\codeincomments{std::swap}}ù)

template <typename T>
class UniquePtr  // simple move-only owning pointer
{
    T* d_ptr_p;   // owned object

public:
    UniquePtr() : d_ptr_p{nullptr} { }         // construct an empty pointer
    UniquePtr(T* p) noexcept : d_ptr_p(p) { }  // value ctor, take ownership

    UniquePtr(const UniquePtr&) = delete;    // not copyable

    UniquePtr(UniquePtr&& expiring) noexcept // move constructor
    : d_ptr_p(expiring.release()) { }

    ~UniquePtr()                             // destructor
    {
        reset();
    }

    UniquePtr& operator=(const UniquePtr&) = delete;     // no copy assignment

    UniquePtr& operator=(UniquePtr&& expiring) noexcept  // move assignment
    {
        reset();
        std::swap(d_ptr_p, expiring.d_ptr_p);
        return *this;
    }

    T& operator*() const           { return *d_ptr_p; }  // dereference
    T* operator->() const noexcept { return d_ptr_p; }   // pointer

    explicit operator bool() const noexcept
    { return d_ptr_p != nullptr; }                       // conversion to (ù{\codeincomments{bool}}ù)

    T* release()  // Release ownership of (ù{\codeincomments{d\_ptr\_p}}ù) without deleting it.
    {
        T* p    = d_ptr_p;
        d_ptr_p = nullptr;
        return p;
    }

    void reset()  // Clear the value of this object.
    {
        T* p    = d_ptr_p;
        d_ptr_p = nullptr;
        if (p != nullptr) { delete p; }
    }
};
\end{emcppslisting}
    
    
\noindent Even this straightforward implementation can then be used for a variety
of purposes. With little overhead, \emcppsgloss{RAII} principles can be used
for managing heap-allocated objects. \lstinline!UniquePtr<T>! also meets
the requirements for being placed in a standard container, letting it be
used to build containers of types that are not themselves eligible to be
placed in a container, such as creating a \lstinline!std::vector! of
nonmovable noncopyable objects. Marking the move operations
\lstinline!noexcept! will also allow standard containers to provide the
strong exception guarantee even though our \lstinline!UniquePtr! cannot be
copied; see \featureref{\locatione}{noexcept-specifier}.

\subsubsection[Passing around resource-owning objects by value]{Passing around resource-owning objects by value}\label{passing-around-resource-owning-objects-by-value}

\paragraph[Passing movable objects by value]{Passing movable objects by value}\label{passing-movable-objects-by-value}

Prior to the introduction of move semantics, if we passed objects around
by value, we would incur the cost of a lot of copies. With move
semantics, this might be less problematic. There are several ways that
resource-owning objects can be passed around.

Overload sets consisting of corresponding parameters that are passed by
both reference and value, e.g., \lstinline!poor! in the example below, are
possible, but attempts to invoke such a function can result in overload
resolution failures and, hence, are not typically useful in practice:

\begin{emcppslisting}
void poor(int);       // (1) pass by non(ù{\codeincomments{const}}ù)  (ù{\emphincomments{value}}ù)
void poor(int&);      // (2) pass by non(ù{\codeincomments{const}}ù) (ù{\emphincomments{lvalue}}ù) reference
void poor(int&&);     // (3) pass by non(ù{\codeincomments{const}}ù) (ù{\emphincomments{rvalue}}ù) reference

void testPoor()
{
    int        i;        //   (ù{\codeincomments{i}}ù) is a    modifiable (ù{\emphincomments{lvalue}}ù).
    const int  ci  = i;  //  (ù{\codeincomments{ci}}ù) is a nonmodifiable (ù{\emphincomments{lvalue}}ù).
    int&       ri  = i;  //  (ù{\codeincomments{ri}}ù) is a    modifiable (ù{\emphincomments{lvalue}}ù) reference.
    const int& cri = i;  // (ù{\codeincomments{cri}}ù) is a nonmodifiable (ù{\emphincomments{lvalue}}ù) reference.

    poor(3);    // Error, ambiguous: (1) or (3)
    poor(i);    // Error, ambiguous: (1) or (2)
    poor(ci);   // OK, invokes (1)
    poor(ri);   // Error, ambiguous: (1) or (2)
    poor(cri);  // OK, invokes (1)
}
\end{emcppslisting}
    
    
\noindent In the next example, we see the benefits of an overload set, e.g.,
\lstinline!good! in the example below, that consists of corresponding
parameters declared as both a nonmodifiable \romeovalue{lvalue} reference
(\lstinline!const!~\lstinline!T&!) and a modifiable \romeovalue{rvalue} reference
(\lstinline!T&&!):

\begin{emcppslisting}
struct S  // some UDT that might benefit from being "moved"
{
    S();          // (ù{\emphincomments{default}}ù) constructor
    S(const S&);  // (ù{\emphincomments{copy}}ù) constructor
    S(S&&);       // (ù{\emphincomments{move}}ù) constructor
};

int good(const S& s);  // (4) binds to any (ù{\codeincomments{S}}ù) object, but with lower priority
int good(S&& s);       // (5) binds to (ù{\emphincomments{movable}}ù) (ù{\codeincomments{S}}ù) objects with high priority

void testGood()
{
    S        s;        //   (ù{\codeincomments{s}}ù) is a    modifiable (ù{\emphincomments{lvalue}}ù).
    const S  cs  = s;  //  (ù{\codeincomments{cs}}ù) is a nonmodifiable (ù{\emphincomments{lvalue}}ù).
    S&       rs  = s;  //  (ù{\codeincomments{rs}}ù) is a    modifiable (ù{\emphincomments{lvalue}}ù) reference.
    const S& crs = s;  // (ù{\codeincomments{crs}}ù) is a nonmodifiable (ù{\emphincomments{lvalue}}ù) reference.

    good(S());                 // OK, invokes (5) - guts of (ù{\codeincomments{S()}}ù) available
    good(s);                   // OK, invokes (4) - read only
    good(cs);                  // OK, invokes (4) - read only
    good(rs);                  // OK, invokes (4) - read only
    good(crs);                 // OK, invokes (4) - read only
    good(static_cast<S&&>(s)); // OK, invokes (5) - guts of (ù{\codeincomments{s}}ù) available
}
\end{emcppslisting}
    
    
\noindent In the example code above, we have called function \lstinline!good! with
six different expressions involving the (unqualified) user-defined type
\lstinline!S!. Notice that passing anything other than the modifiable
\romeovalue{prvalue} \lstinline!S()! or the modifiable \romeovalue{xvalue}
\lstinline!static_cast<S&&>(s)! invokes the overload (4) which accepts
the object by \lstinline!const! \romeovalue{lvalue} reference, not modifying it.
If a copy is needed internally within the function \lstinline!good!, it can
be made in the usual way using \lstinline!S!'s \emph{copy} constructor.

If the object being passed is either a \emph{temporary} or an explicitly
cast, unnamed \romeovalue{xvalue}, overload (5) is invoked and the object is
passed as a non\lstinline!const! \romeovalue{rvalue} reference. If a ``copy'' is
needed internally, it can now be made safely --- and
\emph{perhaps}{\cprotect\footnote{When data that is initially proximate
in the virtual address space is allowed to \emph{diffuse} due to
either deallocation/reallocation or a \emph{move} operation,
\emph{locality} of reference can suffer. Depending on the relative
frequency with which the moved data is subsequently accessed, overall
performance may be served by performing a \emph{copy} instead, even
when the \emph{move} operation itself would be faster. We plan to
discuss memory allocation and, specifically, \emph{diffusion}, in
  \cite{lakos22}.}} more efficiently --- using \lstinline!S!'s
\emph{move} constructor, but see \intraref{potential-pitfalls-rvalueref}{failure-to-std::move-a-named-rvalue-reference}.

Let's now consider the alternative of having just one overload e.g.,
\lstinline!func! in the example below, in which a potentially
\emph{movable}, e.g., user-defined or generic, type is passed \emph{by}
\emph{value}:

\begin{emcppslisting}
template <typename T>
int func(T t);  // (6) single "overload" that binds to any (ù{\codeincomments{T}}ù) object

void testFunc()
{
    S        s;        //   (ù{\codeincomments{s}}ù) is a    modifiable (ù{\emphincomments{lvalue}}ù)
    const S  cs  = s;  //  (ù{\codeincomments{cs}}ù) is a nonmodifiable (ù{\emphincomments{lvalue}}ù)
    S&       rs  = s;  //  (ù{\codeincomments{rs}}ù) is a    modifiable (ù{\emphincomments{lvalue}}ù) reference
    const S& crs = s;  // (ù{\codeincomments{crs}}ù) is a nonmodifiable (ù{\emphincomments{lvalue}}ù) reference

    func(S());                   // OK, invokes (6) - constructed in (ù{\codeincomments{func}}ù)
    func(s);                     // OK, invokes (6) - (ù{\emphincomments{copied}}ù) into (ù{\codeincomments{func}}ù)
    func(cs);                    // OK, invokes (6) - (ù{\emphincomments{copied}}ù) into (ù{\codeincomments{func}}ù)
    func(rs);                    // OK, invokes (6) - (ù{\emphincomments{copied}}ù) into (ù{\codeincomments{func}}ù)
    func(crs);                   // OK, invokes (6) - (ù{\emphincomments{copied}}ù) into (ù{\codeincomments{func}}ù)
    func(static_cast<S&&>(s));   // OK, invokes (6) - (ù{\emphincomments{moved}}ù) into (ù{\codeincomments{func}}ù)
}
\end{emcppslisting}
    
    
\noindent A function (template), such as \lstinline!func! in the example above, that
accepts a movable object \emph{by} \emph{value} behaves, in some ways,
similarly to the more traditional two-overload set, e.g., \lstinline!good!
in the example above. If the object being passed in is a \romeovalue{prvalue}
(i.e., a not yet constructed temporary), it can be constructed \emph{in}
\emph{place} as a local variable with no copy or move overhead at all.
If the object is an \romeovalue{xvalue} (i.e., it already exists either as an
unnamed \emph{temporary} or as the result of an explicit cast to an
unnamed \romeovalue{rvalue} reference), then \lstinline!S!'s \emcppsgloss{move
constructor} will be invoked to ``copy'' it. In all other cases,
\lstinline!S!'s \emcppsgloss{copy constructor} will be invoked. The net result
is two-fold: (1) From the perspective of the user of \lstinline!func!, an
efficient copy will always be made from the arguments supplied; (2) from
the implementer's perspective, a mutable copy for internal use will
always be available as an automatic variable.

Passing a potentially movable argument by value to a function is not
generally indicated. Unless the \emph{contract} for the function states
or implies that a potentially movable argument will necessarily be
copied (e.g., by any implementation), passing that argument \emph{by}
\emph{value} might incur gratuitous runtime overhead. In cases where it
is appropriate, passing specifically a \romeovalue{prvalue} --- e.g., just the
first call to \lstinline!func!, in the example above, which passes
\lstinline!S()! --- will cause the object to be constructed within the
function itself, thereby avoiding even a \emph{move} operation but has
absolutely no runtime performance benefit for any of the other calls
where a \emph{glvalue}, i.e., \romeovalue{xvalue} or \romeovalue{lvalue}, is passed.

Passing movable objects \emph{by} \emph{value} (where applicable) means
that only a single function overload need be written. This argument
becomes even more compelling when we consider a function taking multiple
movable arguments:

\begin{emcppslisting}
int good2(const S&   s1, const S&  s2);  // both passed by (ù{\codeincomments{const}}ù) (ù{\emphincomments{lvalue}}ù) ref
int good2(const S&   s1,       S&& s2);  // passed by (ù{\codeincomments{const}}ù) (ù{\emphincomments{lvalue}}ù), (ù{\emphincomments{rvalue}}ù)
int good2(      S&&  s1, const S&  s2);  // passed by (ù{\emphincomments{rvalue}}ù), (ù{\codeincomments{const}}ù) (ù{\emphincomments{lvalue}}ù)
int good2(      S&&  s1,       S&& s2);  // both passed by (ù{\emphincomments{rvalue}}ù) reference

int func2(      S    s1,       S   s2);  // both passed (ù{\emphincomments{by}}ù) (ù{\emphincomments{value}}ù)
\end{emcppslisting}
    
    
\noindent When passing potentially movable objects \emph{by} \emph{value} is
either not applicable or otherwise undesirable, the general approach is
to employ forwarding references (see {\featureref{\locationc}{forwardingref}) to preserve the value category of the argument through to
the implementation:

\begin{emcppslisting}
template <typename T1, typename T2, typename T3>
int great3(T1&& t1, T2&& t2, T3&& t3)  // each passed by (ù{\emphincomments{forwarding}}ù) (ù{\emphincomments{reference}}ù)
\end{emcppslisting}
    
    
\noindent See \intraref{annoyances-rvalueref}{visual-similarity-to-forwarding-references}.

\paragraph[Return by value]{Return by value}\label{return-by-value}

Now that we have covered the ideas behind passing around resource-owning
objects by value, we provide more realistic examples of these principles
at work.

Our first example illustrates a simple output parameter for a function
that creates a temporary filename. We consider two ways in which such a
function might be designed. First, we pass in an output parameter by
address:

\begin{emcppslisting}
void generateTemporaryFilename(std::string* outPath, const char* prefix)
{
    char suffix[8];
    // ... Create a unique suffix.

    *outPath = prefix;
    outPath->append(suffix);
}
\end{emcppslisting}
    
    
\noindent Alternately, we can return an output \lstinline!std::string! by value:

\begin{emcppslisting}
#include <cstring>  // (ù{\codeincomments{strlen}}ù)

std::string generateTemporaryFilename(const char* prefix)
{
    char suffix[8];
    // ... create a unique suffix

    std::string rtnValue;
    rtnValue.reserve(strlen(prefix) + strlen(suffix));
    rtnValue.assign(prefix);
    rtnValue.append(suffix);
    return rtnValue;
}
\end{emcppslisting}
    
    
\noindent In the first implementation, the caller must create a
\lstinline!std::string! on the stack and pass its address to the function.
The second version presents a clearer interface for the caller. In
C++03, without move semantics, this second version would have had more
allocations and copying, but with \romeovalue{rvalue} references and move
semantics, there is only an additional move. This is an example where
\romeovalue{rvalue} references and move semantics come into effect and enable
us to have interfaces that are easier and more natural for many to use
but do not incur the often hidden penalties that these patterns can
contain; however, see \intraref{potential-pitfalls-rvalueref}{sink-arguments-require-copying} and \intraref{potential-pitfalls-rvalueref}{disabling-nrvo}.

In the second version, we always create a \lstinline!std::string! object to
return, which could become a performance issue if we are repeatedly
invoking this function. In cases where a function may be called many
times in a loop, a much more efficient alternative is to reuse the same
capacity in the string.

\subsubsection[Sink arguments]{Sink arguments}\label{sink-arguments}

A \emcppsgloss{sink argument} is an argument to a function or constructor
that will be retained or consumed. Before C++11, it was common to take
sink arguments as \lstinline!const&! and copy them, e.g., how an
\lstinline!HttpRequest! class might have been written in C++03:

\begin{emcppslisting}
class HttpRequest
{
    std::string d_path;

public:
    HttpRequest(const std::string& path) : d_path(path) { }

    // (ù{\codeincomments{path}}ù) is a sink argument
    void set_path(const std::string& path)
    {
        d_path = path;
    }
};
\end{emcppslisting}
    
    
\noindent With that interface, even in C++11, if an \romeovalue{rvalue}, e.g., a
temporary, is passed, there is no way to avoid a copy. However, we can
support move operations for sink arguments to prevent these unnecessary
copies, e.g., writing \lstinline!HttpRequest! another way:

\begin{emcppslisting}
class HttpRequest
{
    std::string d_path;

public:
    HttpRequest(const std::string& path) : d_path(path) { }  // as before

    HttpRequest(std::string&& path) : d_path{std::move(path)} { }

    void set_path(const std::string& path)  // as before
    {
        d_path = path;
    }

    void set_path(std::string&& path)
    {
        d_path = std::move(path);
    }
};
\end{emcppslisting}
    
    
\noindent In this case, we have provided overloads for \romeovalue{rvalue} references in
the constructor and the \lstinline!set_path! function. Having the extra
overloads is optimal for users of \lstinline!HttpRequest!. Note, however,
that this involves code repetition: The logic of the constructor and
\lstinline!set_path! are essentially repeated. In addition, this approach
can become cumbersome; to provide this behavior in our classes, we have
to write $2^{N}$ overloads for functions taking $N$ arguments. That
is, an overload for each combination of \lstinline!const! \romeovalue{lvalue} and
\emcppsgloss[rvalue reference]{\romeovalue{rvalue} reference} types for each argument. Reducing this need
for extra code bloat is the motivation for the ``pass-by-value and
move'' idiom:

\begin{emcppslisting}
class HttpRequest
{
    std::string d_path;

public:
    HttpRequest(std::string path) : d_path(std::move(path)) { }

    void set_path(std::string path)
    {
        d_path = std::move(path);
    }
};
\end{emcppslisting}
    
    
\noindent We achieve close-to-optimal behavior by taking \emcppsgloss[sink argument]{sink arguments}
by value and unconditionally moving them. This idiom adds only the cost
of a limited number of move operations per argument over the fully
general case with $2^{N}$ overloads and, importantly, does not add any
extraneous copies.

With this version, if a user passes an \romeovalue{lvalue} to
\lstinline!set_path!, the \romeovalue{lvalue} will be copied in the
\lstinline!path! argument, and then the argument will be moved into the
data member: There will be one copy plus one move. If a user passes an
\romeovalue{rvalue} to \lstinline!set_path!, the \romeovalue{rvalue} will be moved
into the the \lstinline!path! argument, and then the argument will be moved
into the data member: There will be two moves. In both cases, there is
one more move than would be needed for the multioverload implementation.

The perfect-forwarding solution for \lstinline!HttpRequest!, which will
produce all possible overloads for qualified parameters at the cost of
needing to be a template, would be:

\begin{emcppslisting}
class HttpRequest
{
    template <typename S>
    HttpRequest(S&& path) : d_path(std::forward<S>(path)) { }

    template <typename S>
    void set_path(S&& path)
    {
        d_path = std::forward<S>(path);
    }
};
\end{emcppslisting}
    
    
\noindent Importantly, taking a \emcppsgloss{sink argument} by value will
\emph{always} make a copy. When that copy will be retained (such as the
initialization of a member variable above), this is no additional cost.
When there is a code path where the copy is not retained, this copy
becomes unnecessary and would be best avoided; see \intraref{potential-pitfalls-rvalueref}{sink-arguments-require-copying}.

\paragraph[Factories from sink arguments]{Factories from sink arguments}\label{factories-from-sink-arguments}

Occasionally, a \emcppsgloss{factory function} is designed to take an object
of a particular type and produce a modified version of the same object.
Classically, the input to such a function would be taken by
\lstinline!const&!, and the output would be a named local variable that
would be initialized and eventually returned:

\begin{emcppslisting}
std::string to_uppercase(const std::string& input)
{
    std::string result;
    result.reserve(input.size());

    for (int i = 0; i < input.size(); ++i)  // copy input
    {
        result += toupper(input[i]);        // Modify as we populate result.
    }

    return result;
}
\end{emcppslisting}
    
    
\noindent This implementation has the downside of making an extraneous copy when
passed a temporary:

\begin{emcppslisting}
void testToUppercase()
{
    std::string upperHi = to_uppercase("Hi");  // copy twice
    assert(upperHi == "HI");
}
\end{emcppslisting}
    
    
\noindent Alternatively, the same pattern used for \emcppsgloss[sink argument]{sink arguments} can be
used to initialize what will be our return value; take a \emcppsgloss{sink
argument} by value:

\begin{emcppslisting}
// by-value version
std::string to_uppercase(std::string input)
{
    for (int i = 0; i < input.size(); ++i)
    {
        input[i] = toupper(input[i]);       // Modify (ù{\codeincomments{input}}ù) in-place
    }

    return input;
}

std::string output = to_uppercase("hello");
\end{emcppslisting}
    
    
\noindent This avoids extraneous copies, at the hopefully reasonable cost of
always requiring an extra move. As with the previous \emcppsgloss{sink
argument} examples, higher maintenance options, which come with
different associated compile-time costs, would be to provide both \linebreak[4]%%%%%
\lstinline!const!~\lstinline!std::string&! and \lstinline!std::string&&!
overloads, minimizing both moves and copies, or to reimplement the
function as a template with a forwarding reference parameter.

\subsubsection[Identifying value categories]{Identifying value categories}\label{identifying-value-categories}

Understanding the rules for which \emcppsgloss{value category} a particular
expression belongs to can be challenging, and having a concrete tool to
identify how a compiler will interpret an expression can be very
helpful. Building such a tool requires functionality that will behave in
a distinct and observably different fashion for each of the three
disjoint \emcppsgloss[value category]{value categories}: \romeovalue{lvalue}, \romeovalue{xvalue}, and
\romeovalue{prvalue}. An operator that has such distinct behavior is the
\lstinline!decltype! operator when applied to a non-\emcppsgloss[id expression]{id-expression}
argument; see \featureref{\locationa}{decltype}.

When applied to a non-\emcppsgloss[id expression]{id-expression}, \lstinline!e!, with an
underlying type of \lstinline!T!, \lstinline!decltype! will return the
following types.

\begin{itemize}
\item{If \lstinline!e! is an \romeovalue{xvalue}, then \lstinline!decltype(e)! is \lstinline!T&&!.}
\item{If \lstinline!e! is an \romeovalue{lvalue}, then \lstinline!decltype(e)! is \lstinline!T&!.}
\item{If \lstinline!e! is a \romeovalue{prvalue}, then \lstinline!decltype(e)! is \lstinline!T!.}
\end{itemize}

We can then apply this to various expressions, using
\lstinline!std::is_same! to verify that the type produced by the
\lstinline!decltype! operator is what we expect. When passed an
\emcppsgloss[id expression]{id-expression} naming an entity, we get the type of that entity,
which is not helpful in identifying the value category of the
\emcppsgloss[id expression]{id-expression}, so we will always use an additional set of
parentheses to obtain only the \emcppsgloss[value category]{value-category}-based
determination of the type produced by \lstinline!decltype!:

\begin{emcppslisting}
#include <utility>
#include <type_traits>  // (ù{\codeincomments{std::is\_same}}ù)

int x = 5;
int& y = x;
int&& z = static_cast<int&&>(x);
int f();
int& g();
int&& h();

// (ù{\emphincomments{lvalues}}ù)
static_assert( std::is_same< decltype(( x )),   int& >::value, "" );
static_assert( std::is_same< decltype(( y )),   int& >::value, "" );
static_assert( std::is_same< decltype(( z )),   int& >::value, "" );
static_assert( std::is_same< decltype(( g() )), int& >::value, "" );

// (ù{\emphincomments{xvalues}}ù)
static_assert( std::is_same< decltype(( std::move(x) )), int&& >::value, "" );
static_assert( std::is_same< decltype(( std::move(y) )), int&& >::value, "" );
static_assert( std::is_same< decltype(( std::move(z) )), int&& >::value, "" );
static_assert( std::is_same< decltype(( h() )),          int&& >::value, "" );

// (ù{\emphincomments{prvalues}}ù)
static_assert( std::is_same< decltype(( 5 )),     int >::value, "" );
static_assert( std::is_same< decltype(( x + 5 )), int >::value, "" );
static_assert( std::is_same< decltype(( y + 5 )), int >::value, "" );
static_assert( std::is_same< decltype(( z + 5 )), int >::value, "" );
static_assert( std::is_same< decltype(( f() )),   int >::value, "" );
\end{emcppslisting}
    
    
\noindent Note the importance of adding the additional set of \lstinline!()!s around
the expression when it is an \emcppsgloss[id expression]{id-expression}, i.e., just a single
qualified or unqualified identifier. For all expressions that are not
just \emcppsgloss[id expression]{id-expressions}, an extra pair of \lstinline!()!s will not
alter the type produced by \lstinline!decltype!. Without the extra
parenthesization, the reference qualifiers, or lack thereof, of the
entity named by an \emcppsgloss[id expression]{id-expression} become part of the type
produced by \lstinline!decltype!:

\begin{emcppslisting}
static_assert( std::is_same< decltype( x ),   int   >::value, "" );
static_assert( std::is_same< decltype( y ),   int&  >::value, "" );
static_assert( std::is_same< decltype( z ),   int&& >::value, "" );
\end{emcppslisting}
    
    
\noindent Encapsulating this logic to build a utility will require working with
\emcppsgloss[expression]{expressions} as operands. We do not have the ability to do
high-level manipulation of expressions in the language, but we can use a
lower-level and less-structured tool to do so in this case, building
macros to identify value categories of expressions passed to them. To
better handle any expression, including those with commas that are not
nested within \lstinline!()!s, we use a new feature that C++11 inherited
from the C99 preprocessor, \emcppsgloss{variadic macros}:

\begin{emcppslisting}
#include <type_traits> // (ù{\codeincomments{std::is\_reference}}ù), (ù{\codeincomments{std::is\_lvalue\_reference}}ù),
                       // (ù{\codeincomments{std::is\_rvalue\_reference}}ù)

#include <utility>

#define IS_LVALUE( ... ) \
    std::is_lvalue_reference< decltype(( __VA_ARGS__ )) >::value

#define IS_XVALUE( ... ) \
    std::is_rvalue_reference< decltype(( __VA_ARGS__ )) >::value

#define IS_PRVALUE( ... ) \
   !std::is_reference< decltype(( __VA_ARGS__ )) >::value

template <typename T, typename U>
struct S { };

S<int, long> s = {};

static_assert( IS_LVALUE(  s ),             "");  // OK
static_assert( IS_XVALUE(  std::move(s) ),  "");  // OK
static_assert( IS_PRVALUE( S<int, int>() ), "");  // OK, needs (ù{\codeincomments{\_\_VA\_ARG\_\_}}ù)
\end{emcppslisting}
    
    
\noindent Finally, for completeness, we can see how macros can be written to
identify the remaining value categories:

\begin{emcppslisting}
#define IS_GLVALUE( ... ) (IS_LVALUE(__VA_ARGS__) || IS_XVALUE(__VA_ARGS__))
#define IS_RVALUE( ... ) (IS_XVALUE(__VA_ARGS__) || IS_PRVALUE(__VA_ARGS__))

static_assert( IS_GLVALUE(x),                                       "");  // OK
static_assert( IS_GLVALUE(std::move(x)) && IS_RVALUE(std::move(x)), "");  // OK
static_assert( IS_RVALUE(x + 5),                                    "");  // OK
\end{emcppslisting}
    

\subsection[Potential Pitfalls]{Potential Pitfalls}\label{potential-pitfalls-rvalueref}

\subsubsection[Sink arguments require copying]{Sink arguments require copying}\label{sink-arguments-require-copying}

The introduction of move semantics and \romeovalue{rvalue} references has
prompted many to try to employ these features wherever possible, but we
need to be aware of a number of pitfalls. Perhaps the most important
piece of advice is, Do not overuse it.

As we saw in \intraref{use-cases-rvalueref}{sink-arguments}, passing by
value and moving can offer benefits. However, we must be careful not to
employ this pattern without thinking through the ramifications. However,
we must carefully think through the ramifications before employing this
pattern. If you design a class, settle on an implementation, decide to
use pass-by-value in the constructor, and then later decide to change
the underlying representation, you may wind up with worse performance.
If a copy is inevitable in the implementation and there is no chance
that will change, passing by value may be beneficial. If ever it is or
will be the case that you don't need to make the copy, then providing
both \lstinline!const&! and \lstinline!&&! overloads or a template using
\emcppsgloss[forwarding reference]{forwarding references} is needed to mitigate the risk.

For example, here we have written a class \lstinline!S! that holds a
\lstinline!std::string! data member. We decide to take a
\lstinline!std::string! by value in the constructor and initialize our data
member by applying \lstinline!std::move! to the argument. Later, we decide
to change our implementation to use our own \lstinline!String! class. Our
\lstinline!String! has a converting constructor that takes a
\lstinline!std::string! and copies it (and does whatever else presumably
motivated our change to \lstinline!String!). If we neglect to update the
constructor of class \lstinline!S! (i.e., it still takes a
\lstinline!std::string! by-value and initializes the member with
\lstinline!std::move! of that string), we will wind up with less-efficient
code:

\begin{emcppslisting}
#include <string>  // (ù{\codeincomments{std::string}}ù)

class S
{
    std::string d_s;  // initial implementation

public:
    S(std::string s) : d_s(std::move(s)) { }  // sink argument constructor
};

std::string getStr();

int main()
{
    std::string lval;

    S s1(lval);     // copy and move
    S s2(getStr()); // move and move
}
\end{emcppslisting}
    
    
\noindent In the code above, we incur a copy and a move if we pass an
\romeovalue{lvalue} to the \lstinline!S! constructor, and we experience two moves
if we pass a temporary.

Suppose we then change \lstinline!S! to use our own \lstinline!String! class,
but we neglect to change the constructor:

\begin{emcppslisting}
#include <string>  // (ù{\codeincomments{std::string}}ù)

class String
{
public:
    String(const std::string&);  // Copy the contents of string.
};

class S
{
    String d_s;  // Implementation changed.

public:
    S(std::string s) : d_s(std::move(s)) { }  // Implementation did (ù{\emphincomments{not}}ù) change.
};

int main()
{
    std::string lval;

    S s1(lval);     // 2 copies
    S s2(getStr()); // move and copy
}
\end{emcppslisting}
    
    
\noindent The problem is that now we are copying \lstinline!lval! once into the
argument and again into the \lstinline!String! data member, thereby copying
twice.

Had we written the requisite overloads, we would not be in this
situation:

\begin{emcppslisting}
class S
{
    String d_s;

public:
    S(const std::string& s) : d_s(s)            { }
    S(std::string&& s)      : d_s(std::move(s)) { }
};
\end{emcppslisting}
    
    
\noindent So, unless we are absolutely certain that we will never change the
implementation of our class, designing our class to take a sink argument
by value can be a pitfall.

\subsubsection[Disabling NRVO]{Disabling NRVO}\label{disabling-nrvo}

\emcppsgloss[NRVO]{Named return value optimization (NRVO)} can only occur if the
expression being returned is the name of a local variable. If we use
\lstinline!std::move! in a return statement, we are returning the return
value of another function, i.e., \lstinline!std::move!, and not a local
variable by name, even though as developers we know that
\lstinline!std::move! is just going to be a cast applied to the argument we
provide to it:

\begin{emcppslisting}
std::string expectingNRVO()
{
    std::string rtn;
    // ...
    return std::move(rtn);  // pessimization, no NRVO
}

std::string enablingNRVO()
{
    std::string rtn;
    // ...
    return rtn;             // optimization, NRVO possible
}
\end{emcppslisting}
    
    
\noindent In the example above, the return value of the function is
\lstinline!std::string!, but, after invoking \lstinline!std::move!, the return
expression is of type \lstinline!std::string&&!. In general, when
returning an object by value, we avoid \lstinline!std::move!. While moving
was once thought to be a faster way to return values from a function,
testing validates that this is not the case.{\cprotect\footnote{See
  \cite{orr18}.}}

\subsubsection[Failure to \lstinline!std::move! a named {\itshape rvalue} reference]{Failure to {\SubsubsecCode std::move} a named {\sfbsubsubsecitalRomeo rvalue} reference}\label{failure-to-std::move-a-named-rvalue-reference}

It is important to remember that we must use \lstinline!std::move! on a
named \romeovalue{rvalue} reference if we wish to move the referenced object's
contents somewhere. Even if a function parameter type is an
\romeovalue{rvalue} reference, that parameter --- by virtue of having a name
--- is, in fact, an \romeovalue{lvalue}. If an \emcppsgloss[rvalue reference]{\romeovalue{rvalue} reference}
overload has the same implementation as the corresponding
\lstinline!const! \romeovalue{lvalue} reference overload, then it will likely
be invoking the same \romeovalue{lvalue} overloads of any functions it calls.
If the final use of the \emcppsgloss[rvalue reference]{\romeovalue{rvalue} reference} parameter does not
employ \lstinline!std::move!, then the function is likely failing to take
advantage of whatever move operations the parameter type provides and is
instead falling back to a higher-overhead copy operation.

Consider a large user-defined type, \lstinline!C!, and an associated API
that has a well-designed overload set that takes objects of type
\lstinline!C! by either \lstinline!const! \romeovalue{lvalue} reference or
\emcppsgloss[rvalue reference]{\romeovalue{rvalue} reference}:

\begin{emcppslisting}
class C { /*...*/ };  // some UDT that might benefit from being "moved"

void processC(const C&);  // (ù{\emphincomments{lvalue}}ù) reference overload for processing (ù{\codeincomments{C}}ù) objects
void processC(C&&);       // (ù{\emphincomments{rvalue}}ù) reference overload for processing (ù{\codeincomments{C}}ù) objects

void applicationFunction(const C& c)
{
    // ...
    processC(c);  // OK, invokes (ù{\codeincomments{const C\&}}ù) overload of (ù{\codeincomments{processC}}ù)
    // ...
}

void applicationFunction(C&& c)
{
    // ...
    processC(c);  // Bug, invokes (ù{\codeincomments{const C\&}}ù) overload of (ù{\codeincomments{processC}}ù)
    // ...
}
\end{emcppslisting}
    
    
\noindent The intent of the second overload of \lstinline!applicationFunction! was
clearly to move the contents of \lstinline!c! into the appropriate
\romeovalue{rvalue} overload of \lstinline!processC!, but as the function
parameter is itself an \romeovalue{lvalue}, the wrong overload is invoked. The
proper solution is for the \romeovalue{rvalue} overload of
\lstinline!applicationFunction! to make an \romeovalue{xvalue} out of \lstinline!c!
before passing it to \lstinline!processC!, since the state of \lstinline!c! is
no longer needed by the function:

\begin{emcppslisting}
void applicationFunction(C&& c)
{
    // ...
    processC(std::move(c();  // OK, invokes (ù{\codeincomments{C\&\&}}ù) overload of (ù{\codeincomments{processC}}ù)
    // ...
}
\end{emcppslisting}
    

\subsubsection[Repeatedly calling \lstinline!std::move! on a named {\itshape rvalue} reference]{Repeatedly calling {\SubsubsecCode std::move} on a named {\sfbsubsubsecitalRomeo rvalue} reference}\label{repeatedly-calling-std::move-on-a-named-rvalue-reference}

Utilizing \lstinline!std::move! on \emcppsgloss[rvalue reference]{\romeovalue{rvalue} reference} parameters in
a function is necessary but should never be done ubiquitously. Recall
that once an object has been moved from, the object's state should be
considered unspecified, and, importantly, the object is certainly
capable of no longer having the same value it originally had. When
applying the same transformation from a \lstinline!const!~\lstinline!C&!
overload of a function to a \lstinline!C&&! overload, as we did in
\intrarefsimple{failure-to-std::move-a-named-rvalue-reference}, it can be easy to falsely assume that all uses of the
\emcppsgloss[rvalue reference]{\romeovalue{rvalue} reference} parameter should be wrapped in
\lstinline!std::move!:

\begin{emcppslisting}
void processTwice(const C& c)  // original (ù{\emphincomments{lvalue}}ù) reference overload
{
    processC(c);
    processC(c);
}

void processTwice(C&& c)  // naive transformation to (ù{\emphincomments{rvalue}}ù) overload
{
    processC(std::move(c));  // OK, invokes (ù{\codeincomments{C\&\&}}ù) overload of (ù{\codeincomments{processC}}ù)
    processC(std::move(c));  // Bug, (ù{\codeincomments{c}}ù) is already moved-from.
}
\end{emcppslisting}
    
    
\noindent The proper approach here is to always be aware that \lstinline!std::move!
should be used only when an object's state is no longer needed. Though
any non\lstinline!std::move! call might result in a copy (depending on what
\lstinline!processC! does), using \lstinline!std::move! solely on the last use
of \lstinline!c! in \lstinline!processTwice! is the only approach that will
keep this overload correct and consistent with the original overload:

\begin{emcppslisting}
void processTwice(C&& c)  // fixed (ù{\emphincomments{rvalue}}ù) overload
{
    processC(c);             // OK, invokes (ù{\codeincomments{const C\&}}ù) overload of (ù{\codeincomments{processC}}ù)
    processC(std::move(c));  // OK, invokes (ù{\codeincomments{C\&\&}}ù) overload of (ù{\codeincomments{processC}}ù)
}
\end{emcppslisting}
    

\subsubsection[Returning \lstinline!const! {\itshape rvalues} pessimizes performance]{Returning {\SubsubsecCode const} {\sfbsubsubsecitalRomeo rvalues} pessimizes performance}\label{returning-const-rvalues-pessimizes-performance}

Prior to the introduction of move semantics, marking objects
\lstinline!const! when returning by value was sometimes recommended as good
practice. For example, a convincing argument was made that applying
postfix \lstinline!operator++! to a temporary is not only useless, but also
almost certainly a bug.{\cprotect\footnote{See \cite{meyers96}, Item 6, ``Distinguish between prefix and postfix forms of
  increment,'' pp.~31--34.}} In the specific case of postfix \lstinline!operator++!,
because the the operator returns the previous value, an object must be
returned, i.e., not a reference but a temporary. It was further
recommended that the operator return a \lstinline!const! object to prevent
the application of postfix \lstinline!operator++! twice.

The goal was to prevent postfix \lstinline!operator++! as well as any other
non\lstinline!const! member function from being applied to a returned
temporary object:

\begin{emcppslisting}
struct A
{
   // ...
   A& operator++();    // prefix (ù{\codeincomments{operator++}}ù)
   A operator++(int);  // postfix (ù{\codeincomments{operator++}}ù)

};
const A operator+(const A&, const A&);

void test1()
{
    A a, b;
    (a + b)++;  // Error, result of (ù{\codeincomments{a + b}}ù) is (ù{\codeincomments{const A}}ù).
}
\end{emcppslisting}
    
    
\noindent The collateral damage of returning by const value, however, is that
operations that seek to make use of the contents of the returned
temporary will instead risk silently making additional copies, which can
have significant overhead when not expected:

\begin{emcppslisting}
void processA(const A&a);  // Copy (ù{\codeincomments{a}}ù) and send it off for processing.
void processA(A&& a);      // Move contents of (ù{\codeincomments{a}}ù) to be sent for processing.

void test2()
{
    A a, b;
    processA(a + b);  // Bug, invokes (ù{\codeincomments{processA(constA\&)}}ù)
}
\end{emcppslisting}
    
    
\noindent Overall, though the advice to return by \lstinline!const! value produced
some minor benefits in averting highly dubious modifications of
temporaries prior to modern C++, it is now a form of antipattern that
should be avoided. For cases where explicitly calling out operations
that should not be invoked on temporaries is helpful, consider using
reference qualifiers; see \featureref{\locatione}{refqualifiers}.

If presented with a library that still chooses to return by
\lstinline!const! value, one potential workaround is to use a
\lstinline!const_cast! to move out of the \lstinline!const! temporary return
value:

\begin{emcppslisting}
void test3()
{
    A a, b;
    processA(const_cast<A&&>(a + b));  // OK, invokes (ù{\codeincomments{processA(A\&\&)}}ù)
}
\end{emcppslisting}
    

\subsubsection[Move operations that throw]{Move operations that throw}\label{move-operations-that-throw}

A move constructor that can throw is not useful in generic contexts
where operations seek to provide the \emcppsgloss{strong exception-safety
guarantee}; i.e., the operation will either succeed or throw an
exception while leaving the object in its prior, valid state. Algorithms
providing the \emcppsgloss{strong guarantee} would need to copy objects
rather than move them, since they need to maintain the ability to unwind
their work when an exception is thrown without risking further
exceptions. This issue was, in fact, the very reason for the
introduction of the \lstinline!noexcept! keyword. Late in the development
of C++11, this issue was discovered specifically with
\lstinline!std::vector! reallocations; see \featureref{\locationc}{noexceptoperator}.

\subsubsection[Some moves are equivalent to copies]{Some moves are equivalent to copies}\label{some-moves-are-equivalent-to-copies}

There is no need to provide move operations for a type for which copying
and moving have the same effect, and doing so simply increases the
maintenance cost of a type, the cost of compilation, and the risk of
errors. In particular, built-in types do not have move operations, as
there is no advantage to employing \lstinline!std::move! over just copying
them. For example, suppose we have a \lstinline!Date! type comprising three
\lstinline!int! fields:

\begin{emcppslisting}
class Date
{
    int day;
    int month;
    int year;

public:
    // ...
};
\end{emcppslisting}
    
    
\noindent There is no added value in writing move operations for \lstinline!Date! in
the example above since copying cannot be optimized via move-like
adoption of resources from the source object.

Given a move operation and a copy operation that have identical effects,
eliminating the move operation will produce the same results in all
situations with half the code. In general, it is best to avoid writing
either operation and to let the compiler choose to generate both by
following the \emcppsgloss{rule of zero}, and for a type such as \lstinline!Date!
in the example above, that is likely what we would do.

\subsubsection[Enabling moves on previously nonmovable objects]{Enabling moves on previously nonmovable objects}\label{enabling-moves-on-previously-nonmovable-objects}

If a type is designed initially to be nonmovable, an object of that type
often uses its address as a form of identity. When this is done, the
object's address becomes a \emcppsgloss{salient attribute} of its value, and
is one attribute that decidedly cannot move with an object's internal
state if it were to be moved with a \emcppsgloss[move operations]{move operation}.

The advent of \emcppsgloss{move operations} in C++11 might invite making all
objects movable in some fashion, but doing so is actively dangerous for
any object whose address is shared externally. The motivation to make
such objects movable is often to put them in containers or to pass
ownership of them around after construction and initialization. The
cleanest answer in most cases is not to make the objects themselves
movable, as that would require redesigning their interaction with all
other components, but to instead manage instances of these nonmovable
objects through a smart pointer, such as \lstinline!std::unique_ptr! or
\lstinline!std::shared_ptr!, creating them in one location and then
passing around the owning handle to the object with minimal overhead few
limitations.

\subsubsection[Inconsistent expectations on moved-from objects]{Inconsistent expectations on moved-from objects}\label{inconsistent-expectations-on-moved-from-objects}

When creating a type that supports move operations, a key decision that
needs to be made is in what states moved-from objects of that type may
be left and what operations will be valid on such objects. When writing
code that uses a movable type, especially generic code, it is equally
important to understand and document what the requirements are on the
template parameters that are supported. When a generic type has higher
expectations for what can be done with moved-from objects than are
actually supported, possibly subtle runtime bugs will likely arise.
Importantly, this conundrum is entirely about objects in a certain state
(moved-from) not being valid for certain operations (e.g., destruction,
copying, assignment, comparison, user-defined utility functions, and so
on), which is entirely a runtime property, and, hence, a source of
runtime bugs that are potentially very hard to track down.

The choice of which of a type's operations should be valid on moved-from
objects of that type has numerous ramifications on the user-friendliness
of the type and what algorithms will safely work with the type. Let's
explore, with example types that manage a simple heap-allocated
\lstinline!int! in different ways, five various choices that can be made
regarding support for objects in a moved-from state. While these
examples all fail in a common manner that is seemingly easily alleviated
(dereferencing a \lstinline!nullptr!), the structure of what works and what
doesn't for these types will often occur in much larger contexts, and
the considerations of what operations a type can and should support for
moved-from objects apply equally to more involved scenarios.

\begin{enumerate}
% item 1
\item{The C++ language makes no explicit requirements that any operation in particular should be valid for moved-from objects. This freedom leads to the possibility for implementing a type that supports no operations on moved-from objects of that type, including destruction. Our first example type, \lstinline!S1! in the example below, was originally written with the assumption that a heap-allocated \lstinline!int! resource was always owned by every \lstinline!S1! object. At a later time, \emcppsgloss{move operations} were added to \lstinline!S1! that leave moved-from objects no longer managing a resource, and, furthermore, all operations were modified to have \emcppsgloss{undefined behavior} when invoked on moved-from objects. A misguided attempt to always set the value of a heap-allocated \lstinline!int! to \lstinline!-1! prior to its being deleted then makes even the destructor invalid for moved-from objects:
\begin{emcppslisting}
class S1
{
    int* d_r_p;  // owned heap-allocated resource

public:
    S1() : d_r_p(new int(1)) { }  // allocate on construction

    S1(const S1& original)
    : d_r_p(new int(*original.d_r_p)) { }  // no check for (ù{\codeincomments{nullptr}}ù)

    ~S1() { *d_r_p = -1; delete d_r_p; }   // "    "    "     "

    S1& operator=(const S1& rhs)
    {
        *d_r_p = *rhs.d_r_p;   // no check for either (ù{\codeincomments{nullptr}}ù)
        return *this;
    }

    void set(int i) { *d_r_p = i; }     // no check for (ù{\codeincomments{nullptr}}ù)
    int get() const { return *d_r_p; }  // "    "    "     "


    S1(S1&& expiring) : d_r_p(expiring.d_r_p)
    {
        expiring.d_r_p = nullptr;  // (ù{\codeincomments{expiring}}ù) now invalid for most operations
    }

    S1& operator=(S1&& expiring)
    {
        *d_r_p = -1;  // no check for (ù{\codeincomments{nullptr}}ù)
        delete d_r_p;
        d_r_p = expiring.d_r_p;
        expiring.d_r_p = nullptr;  // (ù{\codeincomments{expiring}}ù) now invalid for most operations
        return *this;
    }
};

void test1()
{
    S1 s1;
    S1 s2 = std::move(s1);  // OK, (ù{\codeincomments{s1.d\_r\_p == nullptr}}ù)
    s1.set(17);             // Bug, dereferences (ù{\codeincomments{nullptr s1.d\_r\_p}}ù)
}  // destruction of (ù{\codeincomments{s1}}ù) dereferences (ù{\codeincomments{nullptr}}ù)
\end{emcppslisting}
     
\noindent A type such as \lstinline!S1! becomes very difficult to use in many places
where an implicit move might occur:
\begin{emcppslisting}
S1 createS1(int i, bool negative)
{
    S1 output1, output2;
    output1.set(i); output2.set(-i);
    return negative ? output2 : output1;  // no NRVO possible
}

void test2()
{
   S1 s;
   s = createS1(17, false);  // creates (ù{\emphincomments{rvalue}}ù) temporary and move-assigns to (ù{\codeincomments{s}}ù)
                             // destruction of temporary dereferences (ù{\codeincomments{nullptr}}ù)
}
\end{emcppslisting}
     
\noindent In general, a type with an unforgiving state like that of a moved-from
\lstinline!S1! object is possible, but using it without the greatest of
care is difficult. Most object creation, by design, leads to invocation
of destructors, and many common programming constructs can lead to the
creation of temporaries that are then moved from and destroyed. The only
advantage of intentionally designing a type of this sort is that it pays
no cost in checks for \lstinline!nullptr! to support the moved-from state.}
% item 2
\item{The primary downside of the fully unforgiving moved-from state can be alleviated by only making the destructor safe to invoke on a moved-from object:
\begin{emcppslisting}
class S2
{
    // ...          (identical to (ù{\codeincomments{S1}}ù) above)

    ~S2() { delete d_r_p; }  // Safe to use if (ù{\codeincomments{d\_r\_p == nullptr}}ù)
};
\end{emcppslisting}
    
\noindent While silent use of \lstinline!S2! temporaries will not directly result in
bugs, this minimal support for the moved-from state still leaves
\lstinline!S2! unusable in a number of algorithms. Consider the following
use of \lstinline!std::swap! on \lstinline!S2! objects, an operation performed
internally by many standard algorithms:
\begin{emcppslisting}
void test3()
{
    S2 a, b;
    std::swap(a, b);  // Bug!
}
\end{emcppslisting}    
    
\noindent Internally, the invocation of \lstinline!std::swap! would expand:
\begin{emcppslisting}
void test4()
{
    S2 a, b;
    S2 temp = std::move(a);  // OK, (ù{\codeincomments{a.d\_r\_p == nullptr}}ù)
    a = std::move(b);        // Bug, dereferences (ù{\codeincomments{nullptr a.d\_r\_p}}ù), and
                             // also (ù{\codeincomments{b.d\_r\_p == nullptr}}ù).
    b = std::move(temp);     // Bug, dereferences (ù{\codeincomments{nullptr b.d\_r\_p}}ù)
}
\end{emcppslisting}
        
\noindent Note that, even though \lstinline!S2! is move-constructible and
move-assignable, \lstinline!std::swap! has \emcppsgloss{undefined behavior} when
applied to \lstinline!S2! objects. Supporting only destruction and no other
operations allows for basic use of a type but still fails to work
correctly with even the simplest of standard algorithms.}
% item 3
\item{To enable our type to be used with \lstinline!std::swap! and, consequently, many common algorithms, the \emph{copy} and \emph{move} assignment operators can be made safe for objects in the moved-from state. This allows algorithms such as \lstinline!std::swap! and many algorithms that either rely on \lstinline!std::swap! or directly move objects around within a container to safely work with objects that have been previously moved from:
\begin{emcppslisting}
class S3
{
    // ...          (identical to (ù{\codeincomments{S2}}ù) above)

    S3& operator=(const S3& rhs)
    {
        if (d_r_p == nullptr)
        {
            d_r_p = new int(*rhs.d_r_p);  // no check for (ù{\codeincomments{rhs.d\_r\_p == nullptr}}ù)
        } else {
            *d_r_p = *rhs.d_r_p;          // no check for (ù{\codeincomments{rhs.d\_r\_p == nullptr}}ù)
        }
        return *this;
    }

    S3& operator=(S3&& expiring)
    {
        delete d_r_p;
        d_r_p = expiring.d_r_p;
        expiring.d_r_p = nullptr;  // (ù{\codeincomments{expiring}}ù) now in moved-from state.
        return *this;
    }
};
\end{emcppslisting}
      
\noindent With the assignment operators now modified to support assignment
\emph{to} an object in the moved-from state (but not necessarily
\emph{from} an object in the moved-from state), we can now safely use
\lstinline!std::swap! and build algorithms on top of that:
\begin{emcppslisting}
void test5()
{
    S3 a, b;
    std::swap(a, b);
}

void sort3(S3& a, S3& b, S3& c)
{
    if (a.get() > b.get()) std::swap(a, b);
    if (b.get() > c.get()) std::swap(b, c);
    if (a.get() > b.get()) std::swap(a, b);
}
\end{emcppslisting}
        
\noindent Frustratingly, the moved-from state of \lstinline!S3! is not valid for all
operations expected of an element of a standard container, so
\lstinline!S3! is not supported in any standard container; see \intraref{annoyances-rvalueref}{standard-library-requirements-on-a-moved-from-object-are-overly-strict}.

That an \lstinline!S3! object in the moved-from state cannot itself be
moved means all objects of unknown provenance must be treated with great
care. Any object that client code might have moved from cannot be used
for any purpose other than as the target of an assignment, and, in the
case of \lstinline!S3!, there is not even a way to safely identify if an
object has been moved from:
\begin{emcppslisting}
void test6(const S3& inputS)
{
    S3 localS = inputS;   // UB if (ù{\codeincomments{inputS}}ù) is in moved-from state
}
\end{emcppslisting}
       
\noindent This could be addressed by simply giving a function, such as
\lstinline!test6!, a \emcppsgloss{narrow contract} prescribing that its argument
must not be in the moved-from state. The difficulty is that this
stipulation cannot be enforced at compile time and might be hard to
diagnose at run time. The moved-from state can also make otherwise
\emcppsgloss[wide contract]{wide-contract} operations on a container into a source of
problems if an element is put in the ``poisonous'' moved-from state:
\begin{emcppslisting}
#include <vector>  // (ù{\codeincomments{std::vector}}ù)
void test7()
{
    std::vector<S3> vs1;  // OK
    vs1.push_back(S3());  // OK
    vs1.push_back(S3());  // OK

    S3 s = std::move(vs1[0]);   // OK

    std::vector<S3> vs2 = vs1;  // Bug, copying moved-from (ù{\codeincomments{vs1[0]}}ù)
}
\end{emcppslisting}}
% item 4   
\item{Fully supporting moving objects in the moved-from state removes a significant source of pitfalls when dealing with objects of unknown provenance:
\begin{emcppslisting}
class S4
{
    // ...          (identical to (ù{\codeincomments{S2}}ù) above)

    S4& operator=(const S4& rhs)
    {
        if (rhs.d_r_p == nullptr)
        {
            delete d_r_p;
            d_r_p = nullptr;
        }
        else if (d_r_p == nullptr)
        {
            d_r_p = new int(*rhs.d_r_p);
        }
        else
        {
            *d_r_p = *rhs.d_r_p;
        }

        return *this;
    }

    S4& operator=(S4&& expiring)
    {
        if (expiring.d_r_p == nullptr)
        {
            delete d_r_p;
            d_r_p = nullptr;
        }
        else if (d_r_p == nullptr)
        {
            d_r_p = expiring.d_r_p;
            expiring.d_r_p = nullptr;
        }
        else
        {
            *d_r_p = *expiring.d_r_p;
            delete expiring.d_r_p;
            expiring.d_r_p = nullptr;
        }

        return *this;
    }
};
\end{emcppslisting}
       
\noindent This additional support for use of the moved-from state allows basic
algorithms to manipulate collections of objects with no concern for
their value or whether they are in a moved-from state. In general,
though, without a way to identify the moved-from state, it is still not
viable to make use of objects of unknown provenance. Before considering
altering a type's functionality to make more operations valid for
objects in the moved-from state, see \intraref{potential-pitfalls-rvalueref}{requiring-owned-resources-to-be-valid}.}
% item 5
\item{Making additional user-defined operations usable for objects in a moved-from state can be done in a number of ways. The most common guidance and that expected by the Standard Library containers is for the moved-from state to be \emcppsgloss{valid but unspecified}; i.e., all operations that have \emcppsgloss[wide contract]{wide contracts} can still be invoked on objects in the moved-from state, but there is no guarantee what results those operations will have. We can adjust the remaining operations of \lstinline!S4! accordingly:
\begin{emcppslisting}
class S5a
{
    // ...          (identical to (ù{\codeincomments{S4}}ù) above)

    void set(int i)
    {
        if (d_r_p == nullptr)
        {
            d_r_p = new int(i);
        }
        else
        {
            *d_r_p = i;
        }
    }

    int get() const
    {
        return (d_r_p == nullptr) ? std::rand() : *d_r_p;
    }
};
\end{emcppslisting}
        
\noindent \lstinline!S5a! in the example above is the first type that meets the full
requirements for being an element in a standard container. On the other
hand, calling \lstinline!get()! on a moved-from object and making use of
that value is likely a sign of a bug, and \lstinline!S5a! does nothing to
facilitate identifying that bug.

An alternate approach is to make the moved-from state fully specified,
which we could do by replacing the call to \lstinline!std::rand()! above by
a fixed return value, such as \lstinline!0!. This attempt to have a
reliable moved-from state can lead to confusion, as it cannot always be
determined if a move, a copy, or nothing has happened when a move has
been requested:
\begin{emcppslisting}
class S5b
{
    // ...          (identical to (ù{\codeincomments{S5a}}ù) above)

    int get() const
    {
        return (d_r_p == nullptr) ? 0 : *d_r_p;
    }
};

void mightMove(S5b&&);  // function that might move from its argument

void test8()
{
    S5b s;
    s.set(17);
    mightMove(std::move(s));
    assert(s.get() == 0);  // Bug, if (ù{\codeincomments{mightMove}}ù) did not actually move.
}
\end{emcppslisting}
        
\noindent Consider the example of the standard containers themselves. A
\lstinline!std::vector! that has been moved from either will be empty or
will maintain its original value. All of the \emcppsgloss[wide contract]{wide-contract}
operations of \lstinline!std::vector!, e.g., \lstinline!push_back! or
\lstinline!size()!, can be applied to a \lstinline!std::vector! that has been
moved from. These operations can, in turn, be used to identify the full
state of the object and check the preconditions of all of the other
operations of \lstinline!std::vector!, e.g., \lstinline!front! or
\lstinline!operator[]!.}
\end{enumerate}
%%%%%%%%%%%%%%%%%%%%%

The various options available for what a type might support for
moved-from objects must be matched to the requirements any given
algorithm has on the types it makes use of. This applies broadly to both
concrete algorithms using types supplied by other libraries and generic
algorithms using types that have not yet been written.

The most general approach is to require the minimum functionality from a
type and to require only that functionality of the values that will
actually be passed to a particular algorithm. This choice can lead to
narrow contracts requiring that a client not pass in objects in a
moved-from state but maximizes the flexibility available to the client
as to what they need to support.

The most restrictive approach and the one taken by the Standard Library
is to require all moved-from objects be in a valid state. This choice
can make it far less likely for \emcppsgloss{undefined behavior} when
combining an algorithm having these requirements with an arbitrary type
also meeting these requirements, but it significantly inhibits the
ability for code \emcppsgloss[sanitizer]{sanitizers} and other debugging tools to detect
bugs when a moved-from object is being used.

When writing a type that will be used in a wide variety of scenarios,
failing to meet the broadest possible set of requirements is often risky
unless there is a compelling reason to do so. An algorithm is maximally
applicable when it has the fewest possible requirements on the types it
will work with.

\subsubsection[Requiring owned resources to be valid]{Requiring owned resources to be valid}\label{requiring-owned-resources-to-be-valid}

Objects that manage resources and support move operations will generally
transfer ownership of their owned resource to the moved-to object when
possible in lieu of somehow duplicating the owned resource. Fundamental
to the design of such a resource-owning type that might move is deciding
what the moved-from state should be and whether the moved-from state
should also own a resource. Often, this moved-from state can match the
default-constructed state and involves very similar trade-offs.
Maintaining as an invariant that a resource is always owned can bring
with it significant costs, namely the cost of acquiring a resource even
if it will never be used. This price has to be weighed against the
advantage of never needing to verify that the resource is there,
simplifying some code and avoiding some branches.

Though it doesn't own resources outside of its own footprint, an
important type worth considering is a very common one, \lstinline!int!, or,
in general, any of the various \emcppsgloss[fundamental type]{fundamental types}. Moving from
an \lstinline!int! leaves it unchanged, more because of the cheaper cost of
leaving a source \lstinline!int! unchanged than it being fundamental to the
design. The default-initialized state of an \lstinline!int!, however, is
fraught with \emcppsgloss{undefined behavior} any time an attempt is made to
use its value. This state is, in many ways, similar to a moved-from
state that is not valid for any operations other than destruction and
being assigned to. The value of an uninitialized \lstinline!int! cannot be
used in any meaningful way, and there is no way to query if a particular
\lstinline!int! object is properly initialized. This behavior comes with a
large advantage of keeping \lstinline!int! trivial and the associated
performance advantage of not having to do any writes when creating an
\lstinline!int! that will never be read:

\begin{emcppslisting}
void populate(int* i);
    // Populate the location pointed to by (ù{\codeincomments{i}}ù) with a value.

void test9()
{
   int i;         // OK, leave (ù{\codeincomments{i}}ù) uninitialized.
   populate(&i);  // OK, (ù{\codeincomments{i}}ù) is never read by (ù{\codeincomments{populate}}ù).
}
\end{emcppslisting}
    
    
\noindent The author of a heap-allocating movable type can learn an important
lesson from \lstinline!int! as to what the type's default-constructed state
should be and, consequently, what its moved-from state should be.
Consider the type \lstinline!S4! discussed in \intraref{potential-pitfalls-rvalueref}{inconsistent-expectations-on-moved-from-objects}, which
supports assignment and destruction of moved-from objects and no other
operations. Rather than have the default constructor allocate, we can
instead make the default-constructed state be the same as the moved-from
state:

\begin{emcppslisting}
class S4b
{
    // ...          (identical to (ù{\codeincomments{S4}}ù) above)

    S4b() : d_r_p(nullptr) { }  // same state as the moved-from state
};
\end{emcppslisting}
    
    
\noindent This implementation has a big advantage over the versions presented
earlier that attempted to have a resource allocated for the
default-constructed state in that it avoids that allocation completely.
Any situation in which an object is default constructed and then
immediately assigned a new value from a different object offers a
potentially major performance improvement. The \lstinline!String! example
in \intraref{use-cases-rvalueref}{creating-a-low-level-value-semantic-type-(vst)} achieved the same benefit by using a \emcppsgloss{sentinel}
value with static storage duration for the moved-from and
default-constructed states, with slightly different trade-offs and
similar benefits.

\subsection[Annoyances]{Annoyances}\label{annoyances-rvalueref}

\subsubsection[RVO and NRVO require a declared copy or move constructor]{RVO and NRVO require a declared copy or move constructor}\label{rvo-and-nrvo-require-a-declared-copy-or-move-constructor}

To create a \emcppsgloss{factory function} for a type that returns objects of
that type by value, the type is required to have an accessible
\emph{copy} or \emph{move} constructor, either implicitly or explicitly
declared. Frustratingly, even if the copy or move is always elided by
\emcppsgloss[return value optimization (RVO)]{RVO} or \emcppsgloss{NRVO}, at least one of the constructors must
still be either implicitly generated or have an accessible declaration:

\begin{emcppslisting}
class S1  // noncopyable nonmovable type
{
    S1() = default;  // private constructibility needed by (ù{\codeincomments{factory}}ù)

public:
    S1(const S1&);             // never defined
    S1& operator=(const S1&);  // never defined

    static S1 factory()
    {
        S1 output;
        return output;
    }
};

int test1()
{
    S1 s1 = S1::factory();  // OK, links without definition of (ù{\codeincomments{S1(const\&)}}ù)
    S1 s2 = s1;             // Link-Time Error
    return 0;
}
\end{emcppslisting}
    
    
\noindent The publicly accessible copy operation needed to facilitate the static
\lstinline!factory! function, however, will cause link-time errors in any
code that \emph{does} attempt to copy an object of the noncopyable
\lstinline!S1! type. This delay until link time of what ideally should be a
compile-time error can make use of types like this
burdensome.{\cprotect\footnote{C++17 introduced \emcppsgloss{guaranteed copy
elision} not requiring declared copy and move constructors; copy and
move constructors and assignment operators can be private or deleted,
and factory functions can still be implemented to return such objects
by value. C++23 seems likely to extend this guarantee to a limited
  number of \emcppsgloss{NRVO} eligible cases as well.}} Move operations
slightly mitigate this annoyance as declaring, but not defining, move
operations, as in \lstinline!S2! in the example below, instead of copy
operations, as in \lstinline!S1! in the example above, will both suppress
implicit copy operations and make attempting to copy (but not move)
objects a compile-time error:

\begin{emcppslisting}
class S2  // noncopyable nonmovable type
{
    S2() = default;  // private constructibility needed by (ù{\codeincomments{factory}}ù)

public:
    S2(const S2&&);             // never defined
    S2& operator=(const S2&&);  // never defined

    static S2 factory()
    {
        return S2{};
    }
};

int test2()
{
    S2 s1 = S2::factory();  // OK, links without definition of (ù{\codeincomments{S2(const\&)}}ù)
    S2 s2 = s1;             // Error, no copy constructor
    S2 s3 = std::move(s1);  // Link-Time Error
    return 0;
}
\end{emcppslisting}
    

\subsubsection[\lstinline!std::move! does not move]{{\SubsubsecCode std::move} does not move}\label{std::move-does-not-move}

Despite the name, \lstinline!std::move! does not \emph{move} anything and
is simply an unconditional cast to an \romeovalue{rvalue} reference; see
\intrarefsimple{the-std::move-utility}:

\begin{emcppslisting}
template <typename T>
void swap(T& t1, T& t2)
{
    T temp = std::move(t1);
    t1 = std::move(t2);
    t2 = std::move(temp);
}
\end{emcppslisting}
    
    
\noindent We can note that the invocation of \lstinline!std::move! did no moving of
anything. The invocations of \lstinline!std::move! just unconditionally
cast the arguments to \romeovalue{rvalue} references. The constructor and
assignment operator for \lstinline!T! found through overload resolution
that take a single \romeovalue{rvalue} reference to \lstinline!T!, which might
very well be the \emcppsgloss{copy constructor} and \emcppsgloss[copy assignment
operator]{copy-assignment
operator}, are what do the work of \lstinline!std::swap!, and though those
might be move operations, nothing about that is guaranteed. This
function can be written in a a more verbose, less expressive yet
identical way:

\begin{emcppslisting}
template <typename T>
void swap(T& t1, T& t2)
{
    T temp = static_cast<T&&>(t1);
    t1 = static_cast<T&&>(t2);
    t2 = static_cast<T&&>(temp);
}
\end{emcppslisting}
    
    
\noindent \lstinline!std::move! might have been more expressively named
\lstinline!std::make_movable!, \lstinline!std::as_xvalue!, or any similar
name that conveyed that the qualities of the object are changed, but no
action is explicitly being performed.

\subsubsection[Visual similarity to forwarding references]{Visual similarity to forwarding references}\label{visual-similarity-to-forwarding-references}

The syntax for \emcppsgloss[rvalue reference]{\romeovalue{rvalue} references} has been overloaded with the
similar but distinct concept of a \emcppsgloss{forwarding reference}; see
\featureref{\locationc}{forwardingref}. In hindsight, having a distinct
syntax for \emcppsgloss[forwarding reference]{forwarding references} --- even one as possibly
distasteful as \lstinline!&&&! --- would allow for a clear distinction,
preventing the case of \emph{not} having a forwarding reference when one
is intended.

To be a forwarding reference, a parameter's type must be an
\emcppsgloss[rvalue reference]{\romeovalue{rvalue} reference} to a function template parameter that is
\emph{not} \emcppsgloss[cv qualifiers]{cv-qualified}:

\begin{emcppslisting}
template <typename T>
void f1(T&& t);  // (ù{\codeincomments{t}}ù) is a forwarding reference.
\end{emcppslisting}
    
    
\noindent Thus, using a class template parameter, adding a \lstinline!const! or
\lstinline!volatile! qualifier, or using a concrete type will all make a
function parameter an \emcppsgloss[rvalue reference]{\romeovalue{rvalue} reference} and not a
\emcppsgloss{forwarding reference}:

\begin{emcppslisting}
template <typename T>
struct S
{
    void f2(T&& t);    // (ù{\codeincomments{t}}ù) is not a forwarding reference.
};

template <typename T>
void f4(const T&& t);  // (ù{\codeincomments{t}}ù) is not a forwarding reference.
void f5(int&& i);      // (ù{\codeincomments{i}}ù) is not a forwarding reference.
\end{emcppslisting}
    
    
\noindent In practice, when implementing \emcppsgloss{perfect forwarding}, making a
mistake in any one of these facets will result in not having a
\emcppsgloss{forwarding reference} and compilation errors. Being unable to
state clearly the intent to have a forwarding reference makes these
compilation errors significantly more obtuse.

\subsubsection[Value categories are a moving target]{Value categories are a moving target}\label{value-categories-are-a-moving-target}

C++98/03 had just \romeovalue{lvalues} and \romeovalue{rvalues}. In the original
design of C++11, the only \romeovalue{xvalues} were once \romeovalue{lvalues}. In
C++14, members of \romeovalue{prvalue} user-defined types also became
\romeovalue{xvalues}. In C++17 even more \romeovalue{prvalues} were identified as
\romeovalue{xvalues}. Some of these changes have been adopted as
\emcppsgloss[defect report]{defect reports} against older standards, and some have
introduced subtle changes in behavior between language standards.
%<!-- Lori: want to move this C++17 reference to a footnote or leave as is?  @Lori: Leave as is, the future is specifically part of this annoyance-->

In any case, the progression is in one direction: there were no
\romeovalue{rvalues} in C++03 that were not \romeovalue{prvalues} in C++11, and then
the demarcation between \romeovalue{prvalue} and \romeovalue{xvalue} continued to
drift so that the categories of non\romeovalue{lvalues} that were deemed to be
\romeovalue{xvalues} grew. The criteria now is \emph{not} that an
\romeovalue{xvalue} is reachable but that it refers to an object in memory and
that a \romeovalue{prvalue} is everything and must be a complete type. Note
that the direction of motion is one way. Once something is an
\romeovalue{xvalue} in the Standard, it can never go back. Understanding the
evolution is helpful to understanding how the C++ language is evolving;
see the \intraref{appendix-rvalueref}{the-evolution-of-value-categories}.

Overall, what the literature has lacked and the Standard's evolution has
made difficult to understand is a clear designation of what the value
categories are and what their purpose is. The realization that the
\romeovalue{xvalue} category needed to encompass all objects whose data is no
longer needed, whether due to being a temporary whose lifetime is ending
or due to an explicit cast in code, took a great deal of time to
clarify, and the various edge cases have only slowly been
clarified.\footnote{Similarly, while the distinction between a \romeovalue{prvalue} and an \romeovalue{xvalue} is largely academic prior to C++17, with the adoption of proposal P0135R0 (\cite{smith15c}), the distinction is heavily leveraged for \emcppsgloss{guaranteed copy elision}.}

\subsubsection[Standard Library requirements on a moved-from object are overly strict]{Standard Library requirements on a moved-from object are overly strict}\label{standard-library-requirements-on-a-moved-from-object-are-overly-strict}

\noindent\textbf{By Sean Parent}\\[0.5ex]

Given an object, \lstinline!rv!, of type \lstinline!T! that has been moved
from, the C++14{\cprotect\footnote{Similar wording with the same intent
  appears in every version of the C++ Standard since C++11.}} Standard
specifies the required postconditions of a moved-from
object{\cprotect\footnote{\cite{iso14}, Table 20, p.~427}}:
%<!-- Lori: I checked this with the published version, and we're all good. -->

\begin{quote}
rv's state is unspecified [\emph{Note}\/: rv must still
meet the requirements of the library component that is using it. The
operations listed in those requirements must work as specified whether
rv has been moved from or not. --- \emph{end note}\/]
\end{quote}

The requirement applies to both move construction and move assignment
for types used with the Standard Library containers and algorithms. The
note is not \emcppsgloss{normative} but does clarify that the requirements on
a moved-from object are not relaxed.

To understand how this requirement causes an issue in practice, consider
the following simple class definition. The intent of \lstinline!my_type!
is to create a class that always holds a valid value, is
\emcppsgloss{copyable} and \emcppsgloss{equality comparable}, and happens to
contain a remote part. The remote part in this example is held as a
\lstinline!std::unique_ptr! to an \lstinline!implementation! object. A remote
part might be employed to improve compile times by separating the
implementation from the interface, to allow a polymorphic implementation
using inheritance, or to trade off a slower copy for a faster move:

\begin{emcppslisting}
class implementation;  // forward declaration

class my_type
{
    std::unique_ptr<implementation> d_remote;  // remote part

public:
    explicit my_type(int a)
    : d_remote{std::make_unique<implementation>(a)}
    { }

    my_type(const my_type& a)
    : d_remote{std::make_unique<implementation>(*a.d_remote)}
    { }

    my_type& operator=(const my_type& a)
    {
        *d_remote = *a.d_remote;
        return *this;
    }

    friend bool operator==(const my_type& a, const my_type& b)
    {
        return *a.d_remote == *b.d_remote;
    }
};
\end{emcppslisting}
    
    
\noindent We can add the ability to move the object by using a default
\emcppsgloss{move constructor} and \emcppsgloss[move assignment operator]{move-assignment operator}:

\begin{emcppslisting}
class my_type
{
    //...
public:
    //...
    my_type(my_type&&) noexcept = default;
    my_type& operator=(my_type&&) noexcept = default;
    // ...
};
\end{emcppslisting}
    
    
\noindent If we ignore the library requirements and consider only the language
requirements, this implementation is sufficient. The only language
requirement is that a moved-from object be destructible because, without
a cast, the only operation the compiler will perform on a moved-from
object is to destroy it. By definition, an \emcppsgloss{rvalue} is a
temporary object, and no other operations will be performed. The
assignment \lstinline!a!~\lstinline!=!~\lstinline!f()! where \lstinline!a! is of
type \lstinline!my_type! and \lstinline!f()! returns a value of type
\lstinline!my_type!, will work correctly with the default member-wise
implementations.

However, using \lstinline!my_type! in a standard container or algorithm
will likely fail. Consider inserting an element into a vector at a
position, \lstinline!p!:

\begin{emcppslisting}
void test1()
{
    my_type a{42};
    std::vector<my_type> v;
    //...
    v.insert(p, a); // undefined behavior
}
\end{emcppslisting}
    
    
\noindent If \lstinline!p! is not at the end of \lstinline!v!, the implementation of
\lstinline!std::vector! may move the range of elements
\lstinline![p,!~\lstinline!end(v))! and then copy \lstinline!a! over a moved-from
object. Implementations of the Standard Library may use a different
approach to implementing \lstinline!insert! that would not encounter this
issue.{\cprotect\footnote{The 11.0.1 version of the \lstinline!libc++!
Standard Library does use the described approach and will result in a
  crash.}} The copying of \lstinline!a! results in a statement with the
effect of \lstinline!*p!~\lstinline!=!~\lstinline!a! where \lstinline!*p! is a
moved-from instance of \lstinline!my_type!. The copy operation is likely
to crash because of the implementation of copy assignment:

\begin{emcppslisting}
my_type& my_type::operator=(const my_type& rhs)
{
    *d_remote = *rhs.d_remote;
    return *this;
}
\end{emcppslisting}
    
    
\noindent Following the move of the range of elements starting at \lstinline!p!,
\lstinline!d_remote! of \lstinline!*p! is equal to \lstinline!nullptr!, and
dereferencing \lstinline!d_remote! has undefined behavior. There are
multiple ways to fix the copy-assignment operator; for illustration
purposes, we'll simply add a conditional to test \lstinline!d_remote! and,
if it is equal to \lstinline!nullptr!, use an alternative implementation:

\begin{emcppslisting}
my_type& my_type::operator=(const my_type& rhs)
{
    if (d_remote == nullptr)
    {
        *this = my_type(rhs);  // copy-construct and move-assign
    }
    else
    {
        *d_remote = *rhs.d_remote;
    }

    return *this;
}
\end{emcppslisting}
    
    
\noindent The additional check is sufficient to make \emph{all} of the standard
containers and algorithms work correctly. Unfortunately, this check is
not sufficient to satisfy a strict reading of the Standard's
requirements for element types.

\begin{itemize}
\item{Copy construction from a moved-from object will fail.}
\item{Copy assignment from a moved-from object will fail.}
\item{Equality will fail if either operand has been moved from.}
\end{itemize}

All of these operations would cause a \lstinline!nullptr! to be
dereferenced. The Standard Library states that these operations must be
valid for \emph{all} values of a given type.

The implementations of functions associated with the containers and
algorithms in the Standard Library will never perform any operation on a
moved-from object other than to destroy it or assign a new value to it
\emph{unless} called with an object that has already been moved from,
i.e., by the caller directly. The operations in the list above will
never be invoked.

The \lstinline!std::swap! algorithm imposes one additional requirement.
Consider swapping a value --- e.g., \lstinline!std::swap(a,!~\lstinline!a)!
--- with itself:

\begin{emcppslisting}
void test2()
{
    my_type a;
    // inlined (ù{\codeincomments{std::swap(a, a)}}ù):
    my_type tmp = std::move(a);
    a = std::move(a); // self-move-assignment of a moved-from object
    a = std::move(tmp);
}
\end{emcppslisting}
    
    
\noindent The statement \lstinline!a!~\lstinline!=!~\lstinline!std::move(a)! is doing a
self-move-assignment of a moved-from object. The default move-assignment
in the above implementation of \lstinline!my_type! will work correctly for
self-move-assignment of a moved-from object. The default implementation
satisfies the postconditions for both the right-hand and left-hand
arguments and does not affect the value of \lstinline!a!. The left-hand
argument of move assignment must be equal to the prior value of the
right-hand argument. The containers and algorithms in the Standard
Library do not self-swap objects, but \lstinline!std::swap! annoyingly
provides the guarantee that self-swap will work if the arguments satisfy
the requirements for the \emph{move constructible} and \emph{move
assignable} concepts. The requirement for self-swap is both a legacy
requirement from when \lstinline!std::swap! was implemented in terms of
copy and follows from a general requirement in the Standard that, unless
otherwise specified, operations should work even if reference arguments
alias each other in whole or in part. There is no known value in
supporting self-swap, and a self-swap usually indicates a defect in the
algorithm.

Adding the additional checks to satisfy the Standard's wording has an
otherwise unnecessary performance impact and proves to be error-prone to
implement. Beyond that, the additional code introduces a new
\emph{empty} state for \lstinline!my_type!, which must be considered if we
introduce an ordering with \lstinline!operator<()! or any other operation
the Standard Library may invoke. The gratuitously induced empty state
defeats the purpose of value semantics because coding with an object
that may or may not be empty is equivalent to coding with a pointer that
may or may not be null.

The root cause of this issue is broader than just the postconditions of
move operations. There is a Standard proposal to address these
issues.{\cprotect\footnote{\cite{parent21}}} Until the proposal is
adopted (and it may not be), a type must include these additional checks
to adhere to the standard requirements.

\subsubsection[Lack of destructive move]{Lack of destructive move}\label{lack-of-destructive-move}

As far back as Hinnant's proposal,{\cprotect\footnote{\cite{hinnant02}}} 
the paper that first brought a complete approach to \emcppsgloss[rvalue reference]{\romeovalue{rvalue} references} to C++ in 2002, a gap was recognized: the lack of a single
function that can both move the contents out of an object and also
destroy it. The ability to combine moving from an object and destroying
that same object into one operation would enable the design of types
that do not have a resourceless moved-from state, avoiding the need for
many of the considerations brought up in \intraref{potential-pitfalls-rvalueref}{inconsistent-expectations-on-moved-from-objects}.

The complications in providing this form of destructive move or
relocation functionality are numerous, and no refined proposal for a
complete solution, that we are aware of, has come forward in the years
since \emcppsgloss[rvalue reference]{\romeovalue{rvalue} references} were first officially proposed. A
complete solution would need to address at least three items. 1. A
syntactic and semantic mechanism to distinguish this new form for
destroying an object from other ways in which an object can be passed
and not destroyed would need to be designed. 2. The ability to apply
operations of this sort to automatic variables would seem necessary to
make the cost of another new language feature worth the benefits, but
that would require some mechanism to ensure that destructively moved
objects can no longer be referenced once destroyed. This would involve
potentially complex changes to name-lookup rules and object-lifetime
rules. 3. The definition of destructive moves in a class hierarchy would
be complicated by the requirement that the destruction of the members
and bases of an expiring object and the construction of the
corresponding members and bases of a new object must happen in the
opposite order and thus cannot be done in parallel. This was, perhaps,
one of the biggest unsolved sticking points when
Hinnant{\cprotect\footnote{\cite{hinnant02}}} explored this design
space.

Many of these problems are not applicable when relocation can be
accomplished with a \emcppsgloss{trivial copy operation} combined with simply
not invoking a destructor on the source object. A surprising number of
types meet this criteria since any type that uniquely owns a resource by
pointer is a potential candidate, and this includes most common
implementations of \lstinline!std::string!, \lstinline!std::vector!, and
\lstinline!std::unique_ptr!. Various production platforms have observed
and leveraged this behavior, e.g., BDE{\cprotect\footnote{The BDE
library from Bloomberg (\cite{bde14}) identifies types that can
support this form of relocation with a user-specializable type trait,
\lstinline!bslmf::IsBitwiseMoveable!, and takes advantage of that trait
  in many of the containers it provides.}} and
Folly.{\cprotect\footnote{Facebook's Folly library
(\cite{facebook}) has a type trait,
\lstinline!folly::isRelocatable!, that identifies trivially relocatable
objects, which is used to advantage in Folly containers such as
  \lstinline!fbvector!.}} This partial approach to enabling types to
support a limited form of destructive move is being considered for
standardization.{\cprotect\footnote{\cite{odwyer20}}} The great benefit
of having a trivial operation of this sort is that mass moves of objects
between blocks of memory, such as that done by \lstinline!std::vector! on
insertions and resizes, can become single invocations of
\lstinline!std::memcpy! with no loss of correctness.

\subsection[See Also]{See Also}\label{see-also}

\begin{itemize}
\item{\seealsoref{decltype}{\seealsolocationa}explains an operator that depends heavily on the \emcppsgloss{value category} of its arguments.}
\item{\seealsoref{defaulted-special-member-functions}{\seealsolocationa}}
\item{\seealsoref{deleted-functions}{\seealsolocationa}}
\item{\seealsoref{explicit-conversion-operators}{\seealsolocationa}}
\item{\seealsoref{bracedinit}{\seealsolocationc}}
\item{\seealsoref{constexprfunc}{\seealsolocationc}}
\item{\seealsoref{forwardingref}{\seealsolocationc}describes another use of the double-ampersand (\lstinline!&&!) syntax, closely related but distinct from \emcppsgloss[rvalue reference]{\romeovalue{rvalue} references}.}
\item{\seealsoref{gpods}{\seealsolocationc}}
\item{\seealsoref{initlist}{\seealsolocationc}}
\item{\seealsoref{noexceptoperator}{\seealsolocationc}}
\item{\seealsoref{noexcept-specifier}{\seealsolocatione}}
\item{\seealsoref{refqualifiers}{\locatione}explains a feature that allows for overloading member functions on the \emcppsgloss{value category} of the object they are invoked on.}
\end{itemize}

\subsection[Further Reading]{Further Reading}\label{further-reading}

\begin{itemize}
\item{For the definitive retrospective on value category naming in C++11 by Stroustrup himself, see \cite{stroustrup}.}
\item{For the trail of papers that introduced move semantics, \romeovalue{rvalue} references, and the refined C++11 value categories, start with N1377 (\cite{hinnant02}) and continue to N3055 (\cite{miller10}). Produced in 2006 during the evolution of the feature, N2027 (\cite{hinnant06}) gives an overview of the basics and cites many of the papers that contributed to how the feature took shape.}
\item{For a thorough treatment of reference declarations in C++, see \cite{cpprefrefdec}.}
\item{For a solid treatment of the theory value semantics along with its practical applications, see \cite{lakos15a} and \cite{lakos15b}.}
\item{\emph{Effective Modern C++} (\cite{meyers15}) discusses value categories, \romeovalue{rvalue} references, move semantics, and perfect forwarding in the way that only Scott Meyers can.}
\item{\emph{C++ Move Semantics — The Complete Guide} is a recent attempt by a world-renowned author to capture all things related to move semantics, including value categories, \romeovalue{rvalue} references and perfect forwarding; see \cite{josuttis20b}.}
\end{itemize}

\subsection[Appendix]{Appendix}\label{appendix-rvalueref}

\subsubsection[The evolution of value categories]{The evolution of value categories}\label{the-evolution-of-value-categories}

\paragraph[What is a value category?]{What is a value category?}\label{what-is-a-value-category?}

In C++, we use declaration statements to introduce named objects and
functions into a scope:

\begin{emcppslisting}
const int i = 5;  // variable (ù{\codeincomments{i}}ù) of type (ù{\codeincomments{const int}}ù) having the value (ù{\codeincomments{5}}ù)
double d = 3.14;  // variable (ù{\codeincomments{d}}ù) of type (ù{\codeincomments{double}}ù) having the value (ù{\codeincomments{3.14}}ù)
double* p = &d;   // variable (ù{\codeincomments{p}}ù) of type (ù{\codeincomments{double*}}ù) holding the address of (ù{\codeincomments{d}}ù)
char f();         // function (ù{\codeincomments{f}}ù) returning a value of type (ù{\codeincomments{char}}ù)
enum E { A } e;   // variable (ù{\codeincomments{e}}ù) of type (ù{\codeincomments{E}}ù) enumerating (ù{\codeincomments{A}}ù)
\end{emcppslisting}
    
    
\noindent We can then combine these functions and objects along with literals to
form expressions. Some of these expressions might identify an object,
and these expressions are all collectively known as \romeovalue{lvalues}:

\begin{emcppslisting}
i        // a nonmodifiable (ù{\codeincomments{int}}ù) value whose address (ù{\emphincomments{can}}ù) be taken
(i)      // "  "      "       "     "     "      "      "    "   "
d        // a modifiable (ù{\codeincomments{double}}ù) value whose address (ù{\emphincomments{can}}ù) be taken
p        // "      "     (ù{\codeincomments{double*}}ù)  "     "      "      "    "   "
*p       // "      "     (ù{\codeincomments{double}}ù)   "     "      "      "    "   "
e        // a modifiable (ù{\codeincomments{E}}ù) value whose address (ù{\emphincomments{can}}ù) be taken
\end{emcppslisting}
    
    
\noindent The ``l'' in \romeovalue{lvalue} is often taken to mean ``left'' since these
expressions can all conceivably appear on the left-hand side of an
assignment operator. Even expressions with \lstinline!const!-qualified
type, which actually makes them ineligible to be the target of
assignment, are considered \romeovalue{lvalues} since they identify an object
in memory. Another common interpretation of the ``l'' is ``live'' since
the objects, in general, reside in memory throughout the duration of
their lifetime. However, being an \romeovalue{lvalue} is a compile-time
property that is not dependent on the runtime value of the expression;
for example, even if an expression dereferences a null pointer, it is
still considered an \romeovalue{lvalue}.

All other expressions are then collectively known as non\romeovalue{lvalues}.
Often, this category is identified as \romeovalue{rvalues}, with the ``r''
taken to mean ``right'' since these expressions are those that can
appear on the right-hand side of an assignment operator:

\begin{emcppslisting}
5        // (ù{\codeincomments{int}}ù) value whose address (ù{\emphincomments{cannot}}ù) be taken
(i + 1)  //   "     "     "      "        "     "   "
(d + i)  // (ù{\codeincomments{double}}ù) value whose address (ù{\emphincomments{cannot}}ù) be taken
f()      // (ù{\codeincomments{char}}ù) value whose address (ù{\emphincomments{cannot}}ù) be taken
f() + 1  // (ù{\codeincomments{int}}ù)    "     "               "     "   "
A        // (ù{\codeincomments{E}}ù) value whose address (ù{\emphincomments{cannot}}ù) be taken
\end{emcppslisting}
    
    
\noindent Each of these non\romeovalue{lvalue} expressions identifies a value but not
necessarily an object that resides in memory. All \romeovalue{lvalues} can
also be implicitly converted to \romeovalue{rvalues}, referred to as
\emcppsgloss[lvalue to rvalue conversion]{\romeovalue{lvalue}-to-\romeovalue{rvalue} conversion}, which is how the
value in an \romeovalue{lvalue} is accessed. Another common interpretation for
the ``r'' in \romeovalue{rvalue} is ``read-only,'' as these values can be used
to initialize other objects but cannot generally be modified.

\paragraph[Value categories prior to C++11]{Value categories prior to C++11}\label{value-categories-prior-to-c++11}

%% The inconsistency in the title capitalization and in the sectioning numbering of the citations is accurate. 
Early on --- well before C++ --- the classic, pre-Standard C programming
language had already made the distinction between \romeovalue{lvalues} and
non\romeovalue{lvalues}, a.k.a \romeovalue{rvalues}.{\cprotect\footnote{\cite{kernighan78},
  Appendix A, section 5, ``Objects and lvalues,'' p.~183}} In that
characterization, the ``l'' in \romeovalue{lvalue} stood for ``left'' (as in
what could appear on the left side of an assignment operator) and,
similarly, the ``r'' in \romeovalue{rvalue} stood for ``right,'' as in what
could appear on the right side. Along with the introduction of ANSI
C,{\cprotect\footnote{\cite{kernighan88}, Appendix A, section A.5,
  ``Objects and Lvalues,'' p.~197}} the common characterization of an
\romeovalue{lvalue} had evolved: ``L'' had come to stand for where the object
``lives,'' as in \emph{object identity}; a value that is not associated
with physical storage, i.e., one having a unique address, is referred to
as a non\romeovalue{lvalue}. One could think of an \romeovalue{lvalue} as an
expression --- e.g., a named variable, an element of an array, or a
field of a \lstinline!struct! or \lstinline!union! --- whose address could be
taken, e.g., using the unary address-of operator \lstinline!&!.

C also identified a third category, \emcppsgloss{function designator}, that
--- except when used as the operand of \lstinline!&! (address-of
operator), \lstinline!sizeof!, and \lstinline!_Alignof! --- \emcppsgloss[decay]{decays},
i.e., is converted automatically, to the non\romeovalue{lvalue} address of the
designated function, much like how a C-style array \emcppsgloss[decay]{decays} to
the address of its first element. As all function-like behavior became
part of the C++ type system, anything C identified as a \emcppsgloss{function
designator} became a nonmodifiable \romeovalue{lvalue} in classical C++.

C++ restored the term ``\romeovalue{rvalue},'' replacing ``non\romeovalue{lvalue},''
to refer to any value not associated with physical storage, e.g., an
arithmetic literal, enumerator, or nonreference value returned from a
function.

\paragraph[Lvalue reference declarations prior to C++11]{Lvalue reference declarations prior to C++11}\label{lvalue-reference-declarations-prior-to-c++11}

C++ introduced the notion of an \romeovalue{lvalue} reference that can be
\lstinline!const! or non\lstinline!const!.{\cprotect\footnote{Independently of
whether the reference is declared \lstinline!const!, it can also be
declared \lstinline!volatile!; similar to \lstinline!const! qualifiers and
\emph{pointer} variables, a non\lstinline!volatile! \emph{reference} may
not be initialized with the address of a \lstinline!volatile! object. As
the \lstinline!volatile! qualifier is seldom used (productively) in
  practice, we will omit further consideration of it here.}}
\emcppsgloss[lvalue reference]{\romeovalue{Lvalue} references} allow for giving a name to the result
of an \emcppsgloss[lvalue expression]{\romeovalue{lvalue} expression}, and later that reference could
be used anywhere the \emcppsgloss[lvalue expression]{\romeovalue{lvalue} expression} could be used:

\begin{emcppslisting}
      int     i;       // modifiable (ù{\emphincomments{lvalue}}ù)
const int    ci = 5;   // nonmodifiable (ù{\emphincomments{lvalue}}ù) initialized to value (ù{\codeincomments{5}}ù)

      int&  ri1 =  i;  // OK
      int&  ri2 = ci;  // Error, modifiable reference to (ù{\codeincomments{const}}ù) object
const int& rci1 =  i;  // OK
const int& rci2 = ci;  // OK
\end{emcppslisting}
    
    
\noindent The original use case motivating references in C++ was to declare
overloaded operators for user-defined types:

\begin{emcppslisting}
struct Point  // user-defined value type
{
    int d_x;
    int d_y;
    Point(int x, int y) : d_x(x), d_y(y) { }  // value constructor
};

Point operator+(const Point& lhs, const Point& rhs)
    // Return the vector sum of the specified (ù{\codeincomments{lhs}}ù) and (ù{\codeincomments{rhs}}ù) objects.
{
    return Point(lhs.d_x + rhs.d_x, lhs.d_y + rhs.d_y);
}
\end{emcppslisting}
    
    
\noindent That said, \romeovalue{lvalue} references in C++ also make it possible for the
value returned by a function to be an \romeovalue{lvalue}:

%%% JOSH: please fix the overly long line.
%%% Note: In this case we're keeping the Scott Meyers comment.  
\begin{emcppslisting}
Point& singletonPoint()  // Scott Meyers is known for this pattern of singleton. 
{
    static Point meyersSingleton(0, 0);
    return meyersSingleton;  // Return reference to function-local (ù{\codeincomments{static Point}}ù).
}

Point *address = &singletonPoint();  // address of value returned from function returning (ù{\emphincomments{lvalue}}ù)
\end{emcppslisting}
    
    
\noindent What's more, many expressions involving built-in operators that were
considered non\romeovalue{lvalues} in C became \romeovalue{lvalues} in C++:

\begin{emcppslisting}
#include <cassert>  // standard C (ù{\codeincomments{assert}}ù) macro
void f0()
{
    int x = 1, y = 2;  // modifiable (ù{\codeincomments{int}}ù) variables
                       assert(1 == x);  assert(2 == y);
    (x = y) += 1;      assert(3 == x);  assert(2 == y);
    ++x += y;          assert(6 == x);  assert(2 == y);
    --x -= 2;          assert(3 == x);  assert(2 == y);
    x++ *= 3;          // Error, (ù{\codeincomments{x++}}ù) is a non(ù{\emphincomments{lvalue}}ù) (even in C++).
    (y, x) = 6;        assert(6 == x);  assert(2 == y);
    (x ? x : y) = 7;   assert(7 == x);  assert(2 == y);
}
\end{emcppslisting}
    
    
\noindent As illustrated above, the affected operations include each of the
built-in assignment operators (e.g., \lstinline!x!~\lstinline!*=!~\lstinline!2!),
the built-in \emph{prefix} but not \emph{postfix} increment
(\lstinline!++x!) and decrement (\lstinline!--x!) operators, potentially the
comma operator (\lstinline!x,!~\lstinline!y!), and potentially the ternary
operator (\lstinline!x!~\lstinline!?!~\lstinline!y!~\lstinline!:!~\lstinline!z!):

\begin{emcppslisting}
void f1()
{
    int x, y = 0;  // modifiable (ù{\codeincomments{int}}ù) variables
    x = 1;         // (ù{\emphincomments{lvalue}}ù) in C++ (but not in C)
    x *= 2;        //     "     "  "    "   "   " "
    ++x;           //     "     "  "    "   "   " "
    --x;           //     "     "  "    "   "   " "
    x, y;          //     "     "  "    "   "   " "
    1, x;          //     "     "  "    "   "   " "
    x ? x : y;     //     "     "  "    "   "   " "

    x++;           // non(ù{\emphincomments{lvalue}}ù) in C++ (and C too)
    x--;           //  "     "      "  "    "  "  "
    x, 1;          //  "     "      "  "    "  "  "
    x ? 1 : y;     //  "     "      "  "    "  "  "
    y ? x : 1;     //  "     "      "  "    "  "  "
}
\end{emcppslisting}
    
    
\noindent With \romeovalue{lvalue} originally deriving from ``left,'' intuition might
lead one to think that being an \romeovalue{lvalue} is fundamentally tied to
modifiability through assignment. C++ instead focuses on whether an
expression represents an object in memory and whether taking the address
of that object is a wise decision. Expressions that resolve to
\lstinline!const! built-in types or to user-defined types that fail to find
a matching overload of \lstinline!operator=! cannot be on the left-hand
side of an assignment expression. Interestingly, for admittedly odd,
user-defined types with a \lstinline!const! overload of \lstinline!operator=!,
a non\romeovalue{lvalue} can be placed on the left-hand side of an assignment
expression:

\begin{emcppslisting}
struct Odd
{
    const Odd& operator=(const Odd& rhs) const { return *this; }
};

void test()
{
    Odd() = Odd();  // (ù{\emphincomments{rvalue}}ù) assignment to (ù{\emphincomments{rvalue}}ù)

    const int x = 7;
    x = 8;          // Error, cannot assign to (ù{\codeincomments{const int}}ù) (ù{\emphincomments{lvalue}}ù)
}
\end{emcppslisting}
    
    
\noindent The address-of operator, \lstinline!&!, is the primary language tool that
is applicable only to \romeovalue{lvalues}. Any \romeovalue{lvalue} expression
identifies an object in memory, generally one that has a lifetime beyond
that expression, so the address-of operator is allowed to apply to such
expressions:

\begin{emcppslisting}
void f2(bool e)
{
     int a = 1, b = 2;   // modifiable integer variables

     &(a);          // OK
     &(++a);        // OK

     &(a + 5);      // Error, (ù{\codeincomments{a + 5}}ù) is a non(ù{\emphincomments{lvalue}}ù).
     &(a++);        // Error, (ù{\codeincomments{a++}}ù) is a non(ù{\emphincomments{lvalue}}ù).
     &(b, a);       // OK
     &(e ? a : b);  // OK
}
\end{emcppslisting}
    

\paragraph[Temporaries: nonreference values returned from a function]{Temporaries: nonreference values returned from a function}\label{temporaries:-nonreference-values-returned-from-a-function}

When a function returns an object via a nonreference type, an object
might be created in memory whose lifetime will generally end after the
statement invoking the function. Expressions that create and refer to
such temporary objects are a form of non\romeovalue{lvalue}:

\begin{emcppslisting}
double f() { return 3.14; }  // function returning a nonref. type by value
\end{emcppslisting}
    
    
\noindent The lifetime of a temporary is guaranteed to last until the end of the
largest expression in which it is contained, after which the temporary
is destroyed:

\begin{emcppslisting}
#include <iostream>  // (ù{\codeincomments{std::cout}}ù)
void g() { std::cout << "pi = " << f() << '\n'; }  // prints: pi = 3.14
\end{emcppslisting}
    
    
\noindent If more than one temporary is created within an expression, they are
destroyed in the reverse order in which they were created:

\begin{emcppslisting}
struct S  // This (ù{\codeincomments{struct}}ù) prints upon each construction and destruction.
{
     int d_i;  // holds constructor argument
     S(int i) : d_i(i) { std::cout << " C" << d_i; }  // print: C*i*
     S(const S&) { std::cout << "COPY";  exit(-1); }  // never called!
     ~S()              { std::cout << " D" << d_i; }  // print: D*i*
};

S f(int i) { return S(i); }  // (ù{\emphincomments{factory}}ù) function returning (ù{\codeincomments{S(i)}}ù) (ù{\emphincomments{by}}ù) (ù{\emphincomments{value}}ù)

void g()  // demonstrates relative order of ctor/dtor of (ù{\emphincomments{temporary}}ù) objects
{
    f(1);              // prints: C1 D1
    f(2), f(3);        // prints: C2 C3 D3 D2
    f(4), f(5), f(6);  // prints: C4 C5 C6 D6 D5 D4
}
\end{emcppslisting}
    
    
\noindent In the example above, \lstinline!S! prints a \lstinline!C*i*! on construction
and a corresponding \lstinline!D*i*! when the object is destroyed. Notice
that, despite the factory function constructing and returning an
\lstinline!S! by value, no copy operation occurs due to an optimization
known as \emcppsgloss[return value optimization (RVO)]{return-value optimization (RVO)}. Although neither of
the C++11 and C++14 Standards mandate it, this optimization has been
implemented by virtually every popular C++ compiler since the early
2000s, provided an accessible \emph{copy} or \emph{move} constructor is
declared, even if none is defined.

\paragraph[Lifetime extension of a temporary bound to a reference]{Lifetime extension of a temporary bound to a reference}\label{lifetime-extension-of-a-temporary-bound-to-a-reference}

Recall from \intrarefsimple{lvalue-reference-declarations-prior-to-c++11} that \romeovalue{lvalue} references can bind to an \romeovalue{lvalue}
expression of matching type. Non\lstinline!const! \romeovalue{lvalue} references
cannot bind to \lstinline!const! \romeovalue{lvalues}, whereas \lstinline!const!
\romeovalue{lvalue} references can bind to both \lstinline!const! and
non\lstinline!const! \romeovalue{lvalues}:

\begin{emcppslisting}
      int  i;          // non(ù{\codeincomments{const int}}ù) variable  (ù{\codeincomments{i}}ù)
const int ci = 0;      //    (ù{\codeincomments{const int}}ù) variable (ù{\codeincomments{ci}}ù)

      int&  ri0 =  i;  // OK, non(ù{\codeincomments{const}}ù) (ù{\emphincomments{lvalue}}ù) reference, non(ù{\codeincomments{const}}ù) (ù{\emphincomments{lvalue}}ù)
      int&  ri1 = ci;  // Error, non(ù{\codeincomments{const}}ù) (ù{\emphincomments{lvalue}}ù) reference, (ù{\codeincomments{const}}ù) (ù{\emphincomments{lvalue}}ù)
const int& cri0 =  i;  // OK, (ù{\codeincomments{const}}ù) (ù{\emphincomments{lvalue}}ù) reference, non(ù{\codeincomments{const}}ù) (ù{\emphincomments{lvalue}}ù)
const int& cri1 = ci;  // OK, (ù{\codeincomments{const}}ù) (ù{\emphincomments{lvalue}}ù) reference, (ù{\codeincomments{const}}ù) (ù{\emphincomments{lvalue}}ù)
\end{emcppslisting}
    
    
\noindent More interestingly, a \lstinline!const! \romeovalue{lvalue} reference can bind to
\romeovalue{rvalue} expressions of matching type, while a non\lstinline!const!
\romeovalue{lvalue} reference cannot bind to \emph{any} \romeovalue{rvalue}
expression:

\begin{emcppslisting}
      int fi();           // function returning an (ù{\emphincomments{rvalue}}ù) temporary (ù{\codeincomments{int}}ù)
const int fci();          // function returning a (ù{\codeincomments{const}}ù) (ù{\emphincomments{rvalue}}ù) temporary (ù{\codeincomments{int}}ù)

      int&  ri2 =  fi();  // Error, non(ù{\codeincomments{const}}ù) (ù{\emphincomments{lvalue}}ù) ref, non(ù{\codeincomments{const}}ù) (ù{\emphincomments{rvalue}}ù)
      int&  ri3 = fci();  // Error, non(ù{\codeincomments{const}}ù) (ù{\emphincomments{lvalue}}ù) ref, (ù{\codeincomments{const}}ù) (ù{\emphincomments{rvalue}}ù)
const int& cri2 =  fi();  // OK, (ù{\codeincomments{const}}ù) (ù{\emphincomments{lvalue}}ù) reference, non(ù{\codeincomments{const}}ù) (ù{\emphincomments{rvalue}}ù)
const int& cri3 = fci();  // OK, (ù{\codeincomments{const}}ù) (ù{\emphincomments{lvalue}}ù) reference, (ù{\codeincomments{const}}ù) (ù{\emphincomments{rvalue}}ù)
\end{emcppslisting}
    
    
\noindent Whenever a temporary object or a subobject of a temporary object is
bound to an \romeovalue{lvalue} reference, the lifetime of the temporary is
extended to be that of the reference to which it is bound:

\begin{emcppslisting}
struct S  // example (ù{\codeincomments{struct}}ù) containing data members and accessor functions
{
    int d_i;                    // integer data member
    int d_a[5];                 // integer array data member
    int i() { return d_i; }     // function returning data by value
    int& ir() { return d_i; }   // function returning data by reference
};

S f()  // example function constructing temporaries of varying lifetimes
{
    S();                         // temporary (ù{\codeincomments{S}}ù) destroyed after the semicolon
    const   S& r0 = S();         //     "      "      "     when (ù{\codeincomments{r0}}ù) leaves scope
    const int& r1 = S().d_i;     //     "      "      "     when (ù{\codeincomments{r1}}ù) leaves scope
    const int& r2 = S().d_a[3];  //     "      "      "     when (ù{\codeincomments{r2}}ù) leaves scope
    const int& r3 = S().i();     //     "      "      "     after the semicolon
    const int& r4 = S().ir();    //     "      "      "     after the semicolon

    int i1 = r3;                 // OK, copies from lifetime-extended temporary
    int i2 = r4;                 // Bug, undefined behavior

    return S();                  // temporary (ù{\codeincomments{S}}ù) returned as (ù{\emphincomments{rvalue}}ù) to caller
}
\end{emcppslisting}
    
    
\noindent Note that binding a reference to a member keeps the entire temporary
object alive. Similarly, binding a reference to an element of an array
keeps the array alive, and transitively keeps the complete object alive.
There is no such connection between the return value of a function, such
as the return values of \lstinline!i()! and \lstinline!ir()! above, and the
object on which that function is invoked, so the \lstinline!S! objects used
to initialize \lstinline!r3! and \lstinline!r4! do not offer anything that
extends their lifetimes beyond the statement in which they are created.
In the case of \lstinline!r3!, a temporary \lstinline!int! \emph{is} created,
and the lifetime of that \lstinline!int! extends to the end of the scope.
In the case of \lstinline!r4!, the referenced \lstinline!int! is destroyed in
the statement where \lstinline!r4! is initialized, making access through
\lstinline!r4! have \emcppsgloss{undefined behavior} anywhere later in the
function.

\paragraph[Modifiable {\itshape rvalues}!]{Modifiable {\sfbsubsubsecitalRomeo rvalues}!}\label{modifiable-rvalues}
\textbf{[AUs: was the ! in the title intended?]}

Given \romeovalue{rvalue}'s historical roots in C, some may find it
incongruous that an ``rvalue'' could ever be modified because many used
to think the ``r'' stood for ``read-only.'' Before expounding on modern
C++ value categories in the next section, let's observe that
modifiability is, and always has been, a separable property of a C++
expression that is largely orthogonal to its value category.
User-defined, non\lstinline!const! operators can be invoked on temporary
objects capable of modifying --- or even relinquishing the address of
--- such temporaries:

\begin{emcppslisting}
struct S
{
    int d_i;

    S() : d_i(0) { }

    S* addr() { return this; }          // Accessor mostly equivalent to (ù{\codeincomments{\&}}ù).
    S& incr() { ++d_i; return *this; }  // manipulator
};

void test()
{
    S* tempPtr = S{}.addr();  // Address of temporary acquired.
                              // (ù{\codeincomments{tempPtr}}ù) invalidated.

    int i = S{}.incr().d_i;   // Temporary created, modified, and accessed.
    assert(i == 1);
}
\end{emcppslisting}
    
    
\noindent Importantly, this sort of access to temporaries does not alter their
fundamental nature; they are temporary. Even though the address of a
temporary is acquired in \lstinline!tempPtr! in the example above, the
temporary itself will be destroyed after the statement is completed.
Similarly, the member variable \lstinline!d_i! of the temporary in the
initializer for \lstinline!i! is initialized itself, modified, accessed,
and then destroyed, all within the same expression.

\romeovalue{Rvalues} of fundamental types in C++03, however, are not
modifiable. The reason is two-fold: (1) \romeovalue{rvalues} are not permitted
to bind to non\lstinline!const! \romeovalue{lvalue} references, and (2)
fundamental types have no member functions. Hence, all operations that
mutate fundamental types behave as if they were passed in as the first
argument to a free operator with the first parameter passed as a
non\lstinline!const! \romeovalue{lvalue} reference:

\begin{emcppslisting}
// pseudocode illustrating how operators on fundamental types behave

int& operator=(int& lhs, const int& rhs);  // free operator function
    // Assign the value of (ù{\codeincomments{rhs}}ù) to the modifiable (ù{\codeincomments{int}}ù) object bound to (ù{\codeincomments{lhs}}ù),
    // and return an (ù{\emphincomments{lvalue}}ù) reference to (ù{\codeincomments{lhs}}ù).

int& operator+=(int& lhs, const int& rhs);  // free operator function
    // Assign the value that is the sum of (ù{\codeincomments{rhs}}ù) and (ù{\codeincomments{lhs}}ù) to the modifiable
    // (ù{\codeincomments{int}}ù) object bound to (ù{\codeincomments{lhs}}ù), and return an (ù{\emphincomments{lvalue}}ù) reference to (ù{\codeincomments{lhs}}ù).
\end{emcppslisting}
    
    
\noindent In the same way that a member function can be restricted to only apply
to \lstinline!const! objects with a \lstinline!const! qualifier, in C++11 a
member function can be restricted to only apply to \romeovalue{lvalues} with
an \romeovalue{lvalue}-reference qualifier; see \featureref{\locatione}{refqualifiers}.
Applying such a reference qualifier to the assignment operator is the
only way to get the same behavior for the assignment operator on a
user-defined type that exists for fundamental types.

Occasionally, the ability to modify (and, usually, cannibalize) the
state of a temporary is eminently useful. This will turn out to be the
driving force behind the addition of \emcppsgloss[rvalue reference]{\romeovalue{rvalue} references} and the
expansion of value categories to include \romeovalue{xvalues} in C++11.

\paragraph[Rationale: Why do we want move semantics?]{Rationale: Why do we want move semantics?}\label{rationale:-why-do-we-want-move-semantics}

Like many engineering solutions, necessity is the mother of invention.
Make no mistake: The very notion of an \romeovalue{rvalue} reference was
\emph{invented} as part of a much larger feature engineered to solve a
common, objectively verifiable performance problem involving (1)
gratuitous memory allocations and deallocations and (2) excessive data
copying. Consider the following program that does nothing more than
build up a \lstinline!std::vector! of \lstinline!std::vector!s of
\lstinline!std::string!s, either by appending to the nested vectors or by
inserting them at the front:

\begin{emcppslisting}
#include <vector>   // (ù{\codeincomments{std::vector}}ù)
#include <string>   // (ù{\codeincomments{std::string}}ù)
#include <cstdlib>  // (ù{\codeincomments{std::atoi}}ù), (ù{\codeincomments{std::abs}}ù)

int main(int argc, char *argv[])
{
    int k = argc > 1 ? std::atoi(argv[1]) : 8;
    bool front = k < 0;
    int N = 1 << std::abs(k);

    std::string s = "The quick brown fox jumped over the lazy dog.";
        // string value that is too long for short-string optimization

    std::vector<std::string> vs;
    for (int i = 0; i < N; ++i) { vs.push_back(s); }
        // Create an (inner) vector-of-strings *exemplar* of (ù{\codeincomments{size N}}ù).

    std::vector<std::vector<std::string> > vvs;
        // Create an empty vector of vectors of strings to be loaded in two ways.

    for (int i = 0; i < N; ++i)  // Make the outer vector of (ù{\codeincomments{size N}}ù) as well.
    {
        if (front)
        {
            vvs.insert(vvs.begin(), vs);  // Insert copy of (ù{\codeincomments{vs}}ù) at the beginning.
        }
        else
        {
            vvs.push_back(vs);            // Append copy of (ù{\codeincomments{vs}}ù) at the end.
        }
    }

    return 0;
}
\end{emcppslisting}
    
    
\noindent This program, valid in both C++03 and C++11, behaves very differently
with the changes in C++11, and algorithms such as this that were the
intended target of the introduction of \emcppsgloss{move operations} to the
language.

In C++03, the calls to \lstinline!push_back! will, when needed, grow the
internal capacity buffer of \lstinline!vvs! a logarithmic number of times,
e.g., capacity $ = 1, 2, 4, \ldots, 2^{N}$, and copy all
of the already-added elements to the new storage on each resize.
Alternatively, when inserting at the front, each individual
\lstinline!insert! operation must copy all elements in \lstinline!vvs! to the
next element in the capacity buffer and then put the new element at
index \lstinline!0!.

In C++11, both of these operations are vastly improved by the addition
of \emcppsgloss{move semantics} to \lstinline!std::vector!. Independently of the
mechanics of the language feature, when a \lstinline!std::string! or
\lstinline!std::vector! is moved from one location to another, it gives
ownership of the allocated data buffer to the target object and leaves
the source object empty (with \lstinline!0! size and capacity and no data
buffer). This constant-time operation, consisting of nothing more than
the assignment of a small number of fundamental data members replaces a
linear operation involving many allocations, comes at the cost of
altering the state of the source object. When able, growing the data
buffer in C++11 can take advantage of this moving behavior to move
elements from the older, smaller data buffer to the newer,
larger-capacity buffer. A constant-time move operation allows insertion
at the front of the vector to become a linear-time operation, with no
need to perform any extra operations regardless of the contents of the
contained elements.

Running this program on a range of input values, all on the same host
and compiler,{\cprotect\footnote{The numbers shown were generated by
timing the program on a T480 Thinkpad laptop with GCC version 7.4.0,
setting optimization to \lstinline!-O2!, and using \lstinline!-std=c++03! or
  \lstinline!-std=c++11! appropriately.}} can show dramatic differences in
performance for the same source code; see Table~\ref{rvalueref-table3}.

\begin{table}[h!]
\begin{center}
\begin{threeparttable}
\caption{Runtime impact of move semantics}\label{rvalueref-table3} \vspace{1.5ex}
{\small \begin{tabular}{r|r|r|r|r|r}\thickhline
\rowcolor[gray]{.9}    \multicolumn{4}{c|}{\sffamily\bfseries \lstinline!push_back!} & \multicolumn{2}{c}{\sffamily\bfseries \lstinline!insert!} \\ \hline
\rowcolor[gray]{.9}    \multicolumn{1}{c|}{\sffamily\bfseries $\bm k$} & \multicolumn{1}{c|}{\rule[0mm]{0mm}{3mm}\sffamily\bfseries $\bm N = 2^{k}$}  & \multicolumn{1}{c|}{\sffamily\bfseries C++03} & \multicolumn{1}{c|}{\sffamily\bfseries C++11} & \multicolumn{1}{c|}{\sffamily\bfseries C++03} &  \multicolumn{1}{c|}{\sffamily\bfseries C++11} \\ \hline
 8  &    256 &       0.029s &     0.030s &            0.028s &     0.030s \\ \hline
 9  &    512 &       0.037s &     0.033s &            0.235s &     0.032s \\ \hline
10  &  1,024 &       0.065s &     0.039s &            1.560s &     0.048s \\ \hline
11  &  2,048 &       0.179s &     0.114s &           13.704s &     0.112s \\ \hline
12  &  4,096 &       0.628s &     0.359s &           99.057s &     0.373s \\ \hline
13  &  8,192 &       2.409s &     1.338s &          764.613s &     1.364s \\ \hline
14  & 16,384 &       9.728s &     5.347s &        5,958.029s &     5.463s \\ \hline
15  & 32,768 &      66.789s &    35.418s &       40,056.858s &    34.318s \\ \hline
16  & 65,576 &    \multicolumn{1}{c|}{core dump} & 97.943s & \multicolumn{1}{c|}{core dump} &    92.920  \\ \thickhline
\end{tabular}
}
\end{threeparttable}
    \end{center}
\end{table}

%@LORI For Typesetting: Table headings should look roughly like this,
%latex to produce this is below with use of multirow and multicolumn.
%
%\begin{emcppslisting}
%                       (ù{\codeincomments{push\_back}}ù)                      (ù{\codeincomments{insert}}ù)
% k    N = 2^k       C++03         C++11            C++03          C++11
%\end{emcppslisting}
%    
%\begin{emcppslisting}
%\begin{table}[]
%\caption{Runtime impact of move semantics}
%\begin{tabular}{|l|l|l|l|l|l|}
%\hline
%\multirow{2}{*}{$k$} & \multirow{2}{*}{$N=2^k$} & \multicolumn{2}{l|}{\lstinline!push\_back!} & \multicolumn{2}{l|}{\lstinline!insert!} \\ \cline{3-6}
%                     &                          & C++03           & C++11           & C++03         & C++11         \\ \hline
% 8  &    256 &       0.029s &     0.030s &            0.028s &     0.030s \\
% 9  &    512 &       0.037s &     0.033s &            0.235s &     0.032s \\
%10  &  1,024 &       0.065s &     0.039s &            1.560s &     0.048s \\
%11  &  2,048 &       0.179s &     0.114s &           13.704s &     0.112s \\
%12  &  4,096 &       0.628s &     0.359s &           99.057s &     0.373s \\
%13  &  8,192 &       2.409s &     1.338s &          764.613s &     1.364s \\
%14  & 16,384 &       9.728s &     5.347s &        5,958.029s &     5.463s \\
%15  & 32,768 &      66.789s &    35.418s &       40,056.858s &    34.318s \\
%16  & 65,576 &    core dump &    97.943s &         core dump &    92.920  \\
%
%\end{tabular}
%\end{table}
%\end{emcppslisting}
    
    
\noindent This dramatic improvement comes from the \emcppsgloss{move semantics} of
\lstinline!std::vector!'s \emcppsgloss{move operations} enabling a constant-time
instead of linear-time move, combined with the language facilitating
\lstinline!std::vector! being able to generically take advantage of that
functionality when its \lstinline!value_type! supports it. While nothing
about these algorithms is impossible in C++03, having generic types able
to reliably express and take advantage of this kind of improvement was
deemed worth the cost of dramatically changing the language.

\paragraph[Why do we need {\itshape rvalue} references?]{Why do we need {\sfbsubsubsecitalRomeo rvalue} references?}\label{why-do-we-need-rvalue-references?}

The ability to \emph{move} the internal data structure of an allocating
type from one object to another in C++11 --- rather than always having
to \emph{copy} it, in the C++03 sense --- can, under appropriate
circumstances lead to profoundly superior performance characteristics,
but see \intraref{potential-pitfalls-rvalueref}{Over/Misuse (too much
hype)}.
%
\textbf{{AUs: there is no Pitfalls section called ``Over/Misuse (too much
hype)"; what did you intend?}}
%

Classic C++, i.e., C++98/03, did not provide a systematic syntactic
means for indicating that it was OK to extract the \emph{guts} of an
object and transplant them into another object of like type. The only
time that doing such a thing would have been guaranteed to be safe in
C++03 was when the object was a \emph{temporary}, but there was no way
to overload the copy constructor or assignment operator so that they
would behave differently (and more optimally) when passed a
\emph{temporary}.

Classic C++ did, however, provide one Standard Library type,
\lstinline!std::auto_ptr!, that attempted to implement move semantics.
This ill-fated, smart pointer type had a non\lstinline!const!
\emcppsgloss[lvalue reference]{\romeovalue{lvalue} reference} copy constructor that would take
ownership from and reset its source object when ``copied.'' While
\lstinline!std::auto_ptr! functioned as a pioneer for move semantics in
C++03, it also helped to identify the dangers of attempting to implement
move semantics without the more fundamental changes that came with
\emcppsgloss[rvalue reference]{\romeovalue{rvalue} references}. Many attempts to work with containers
of \lstinline!std::auto_ptr! or to leverage standard algorithms with
\lstinline!std::auto_ptr! showed how easy it was for generic code to
assume that copies were safe to make and promptly destroy the data on
which they were attempting to operate. Move semantics enabled the
introduction of \lstinline!std::unique_ptr! as a true move-only type
without the pitfalls of \lstinline!std::auto_ptr!, and at the same time,
\lstinline!std::auto_ptr! was deprecated\footnote{\cite{hinnant05}} and then finally
removed in C++17.\footnote{\cite{baker14}}

The introduction of \emcppsgloss[rvalue reference]{\romeovalue{rvalue} references}, using a syntax of
\lstinline!&&! instead of the single \lstinline!&! used for
\emcppsgloss[lvalue reference]{\romeovalue{lvalue} references}, provided the key way in which
implementations that take advantage of objects being in a movable state
can be written in a safe and robust manner. \lstinline!std::auto_ptr!
showed that modifiable \emcppsgloss[lvalue reference]{\romeovalue{lvalue} references} were not
sufficient for this task, and thus a new reference type was introduced
to enable move operations. A new reference type facilitated new rules
for what it could bind to and how it integrated with overload resolution
and template argument deduction and provided a distinct format to
identify implementations of move operations that would have minimal risk
of changing the meaning of existing types.

\paragraph[Why do we need a new value category?]{Why do we need a new value category?}\label{why-do-we-need-a-new-value-category?}

Simply put, the challenge for the designers of this C++11 feature was to
enable move operations to occur when either (1) the compiler knows for
certain that it is safe to do so or (2) the programmer takes
responsibility for explicitly authorizing the compiler to enable a
\emcppsgloss[move operations]{move operation} that the compiler would not otherwise consider
safe on its own. Their solution was two-fold: 1. Invent the notion of an
\emcppsgloss[rvalue reference]{\romeovalue{rvalue} reference} as a means for binding more aggressively than
a \lstinline!const! \emcppsgloss[lvalue reference]{\romeovalue{lvalue} reference} to expressions that
are eligible to be moved from during overload resolution. 2. Invent a
new \emcppsgloss{value category}, known as an \romeovalue{xvalue}, that could
distinguish when an expression identifies an object that is eligible to
be moved from, including temporary objects that are about to be
implicitly destroyed and will no longer be reachable as well as objects
manually identified, through an explicit cast to \emcppsgloss[rvalue reference]{\romeovalue{rvalue}
reference}, as being eligible.

After a great deal of effort during the C++11 standardization process,
the set of value categories that we have come to know today evolved and
is represented in the Standard\footnote{\textbf{[AUs: Where in the standard? cite.]}} with the following
chart{\cprotect\footnote{The motivation for what would become the
terminology for the new value categories is explained by Bjarne
  Stroustrup himself (\cite{stroustrup}).}}:

\begin{emcppslisting}
                                   expression
                                    /      \
                                glvalue   rvalue
                                 /   \     /  \
                             lvalue   xvalue  prvalue
\end{emcppslisting}
    
    
\noindent This taxonomy helped greatly in formalizing the mechanics of
\emcppsgloss{move operations} in the language, culminating in the final form
of \emcppsgloss[value category]{value categories} in C++11.{\cprotect\footnote{\cite{miller10}}}
A fundamental property that led to this categorization was identifying
two primary, independent properties that could apply to a
\emcppsgloss{value}.

\begin{enumerate}
\item{A value can \emcppsgloss{have identity} or be \emcppsgloss{reachable} if it has an address and exists independently of the current expression.}
\item{A value can be \emcppsgloss{movable} if it is OK to cannibalize the internal representation of the object representing the value. Distinguishing values such as this was the primary goal of seeking to introduce \emcppsgloss{move semantics} into the language in the first place.}
\end{enumerate}

The two classical value categories, \romeovalue{lvalues} and
non\romeovalue{lvalues}, both had opposite orientations for these two
properties. An \romeovalue{lvalue} was \emcppsgloss{reachable} and not
\emcppsgloss{movable}, whereas a non\romeovalue{lvalue} was not \emcppsgloss{reachable}
and was \emcppsgloss{movable}. As the realization emerged that the goal was
to treat these two properties orthogonally, it became apparent that the
other pairings of these properties needed to be considered. A
non\emcppsgloss{movable}, non\emcppsgloss{reachable} value was deemed essentially
not useful or worth considering, as nothing could fundamentally be done
with such a value. A \emcppsgloss{movable} and \emcppsgloss{reachable} object,
however, was the missing piece of the puzzle needed to manually identify
that an object was ready to be moved from.

Given this understanding, the task then became to identify reasonable
names for values with these sets of properties.

\begin{itemize}
\item{The category of \romeovalue{lvalue} was already formalized in the Standard and clearly embodied values that were \emcppsgloss{reachable} and not \emcppsgloss{movable}.}
\item{At a fundamental level, historical work in computer science had trained people to intuitively conclude that \romeovalue{lvalues} and \romeovalue{rvalues} were a partitioning of the set of all values; i.e., every value was either an \romeovalue{lvalue} or an \romeovalue{rvalue}, and no value was both. This led to the \romeovalue{rvalue} category implicitly becoming all \emcppsgloss{movable} values, both \emcppsgloss{reachable} and not \emcppsgloss{reachable}.}
\item{The set of values that are \emcppsgloss{movable} and not \emcppsgloss{reachable} matched well with many of the classical notions of \romeovalue{rvalue}, as it included \emph{pure} values that had no object representation yet, such as integer literals and enumerators. Thus, this category was called \emcppsgloss[prvalue]{prvalues}, or \emph{pure} \romeovalue{rvalues}.}
\item{The set of all values that are \emcppsgloss{reachable} was also something that would need a name, as this category would come into play in the language in a number of places as a generalization of what was previously workable only with \romeovalue{lvalues}. Many fundamental operations that apply to an object in memory are worded in terms of the new \emph{glvalue} category, or \emph{generalized} \romeovalue{lvalues}.}
\item{Finally, the category of \emcppsgloss{movable} objects that were \emcppsgloss{reachable} needed a name. As this was a functionally new invention, a suitable name was not evident, and, perhaps serendipitously, the noncommittal letter ``x'' was chosen for the new \romeovalue{xvalue} category. Originally, this was chosen to represent ``the unknown, the strange, the xpert only, or even the x-rated.''\cprotect\footnote{\cite{stroustrup}} Over time, the ``x'' evolved to capture the \emcppsgloss[movable]{movability} of the values in this category, and it now stands for ``expiring.''}
\end{itemize}

It is worth noting that \romeovalue{rvalue} changed meaning in C++11 by
expanding to include \romeovalue{xvalues} that are reachable. This coincides
well with \emcppsgloss[rvalue reference]{\romeovalue{rvalue} references} being able to functionally
bind to any \romeovalue{rvalue} but was a shift from classical C++ where
\romeovalue{rvalues} were never \emcppsgloss{reachable}. This change was deemed
worth the potential confusion as it had much less impact than a similar
change to \romeovalue{lvalue} would have had, and it kept \romeovalue{lvalue} and
\romeovalue{rvalue} as a disjoint partition of the set of all values.

In C++11 as originally specified, the only way to arrive at an
\romeovalue{xvalue} was via an explicit cast to an \emcppsgloss[rvalue reference]{\romeovalue{rvalue}
reference} or by calling a function that returns an
\emcppsgloss[rvalue reference]{\romeovalue{rvalue} reference}; hence, \romeovalue{xvalues} referencing
unreachable temporaries were significantly harder to acquire. The
original understanding many had was that an \romeovalue{xvalue} was
essentially a \emph{movable} nontemporary. Even as originally
formulated, though, member functions invoked on temporaries were able to
access and distribute \romeovalue{lvalue}, and thus \romeovalue{xvalue}, references
to the temporaries through the \lstinline!this! pointer. Two major core
issues that impacted
\romeovalue{xvalues}\/{\cprotect\footnote{CWG issue 616; \cite{stroustrup07}}}{\cprotect\footnote{CWG issue 1213; \cite{merrill10}}}
were addressed in C++14 and applied retroactively as \emcppsgloss[defect report]{defect
reports} to C++11. These rule changes led to the treatment of subobjects
of both \romeovalue{prvalues} and \romeovalue{xvalues} as \romeovalue{xvalues}, such as
when doing data member access, pointer to data member dereferencing, and
array subscripting.

As the understanding of where the differing value categories can have an
impact has evolved, it has become clear that \romeovalue{xvalue} expressions
identify \emcppsgloss{movable} objects that exist in memory, i.e., their
lifetime has begun, but places no restrictions on whether the objects in
question will continue their lifetimes beyond the end of the current
statement.{\cprotect\footnote{This same refinement of what is an
\romeovalue{xvalue} and what is a \romeovalue{prvalue} inspired the formalization
of \emcppsgloss{guaranteed copy elision} in C++17. The cases where no extra
temporary needs to be created from the return value from a function
are exactly the cases where a function call expression is a
\romeovalue{prvalue} of the appropriate type, enabling the choice to simply
materialize that \romeovalue{prvalue} in the location of the variable being
initialized. This restructuring avoids the need to define intermediate
temporaries and renders unnecessary the ability to optimize away those
temporaries, making object lifetime more deterministic as well as
  enabling \emcppsgloss[return value optimization (RVO)]{RVO} for types that can neither be copied nor moved.}}
In normal use, all \romeovalue{rvalues} --- both \romeovalue{xvalues} and
\romeovalue{prvalues} --- bind equally well to \emcppsgloss[rvalue reference]{\romeovalue{rvalue}
references} and are, for the most part, indistinguishable
programmatically. One of the few places where they are treated
differently is as a parenthesized expression used with the
\lstinline!decltype! operator (see \featureref{\locationa}{decltype}), which can be leveraged to identify value categories (see
\intraref{use-cases-rvalueref}{identifying-value-categories}).

With this new set of value categories in hand, the only remaining pieces
needed to integrate \emcppsgloss{move semantics} into the language were
mechanisms to produce \romeovalue{xvalues} in code to which
\emcppsgloss[rvalue reference]{\romeovalue{rvalue} references} may be bound.Given a \romeovalue{prvalue},
this mechanism could obviously be an implicit conversion, and thus many
automatic benefits of \emcppsgloss{move semantics} could be enabled."
Supporting only such implicit conversions and moving from only
temporaries, however, was not going to solve strong motivational cases,
like our \linebreak%%%%%
\lstinline!std::vector<std::vector<std::string>>! example
described above; see \intrarefsimple{rationale:-why-do-we-want-move-semantics}. \textbf{[AUs: where is the example? Do you mean it is in the Rationale section? If so, just say that. ``Above" is too vague to be really helpful.]} To enable such cases, \romeovalue{xvalues} also needed to
include \romeovalue{lvalues} that had been explicitly cast to
\emcppsgloss[rvalue reference]{\romeovalue{rvalue} references}, enabling the moving of objects
already stored in a data structure. To further enable the use of
\emcppsgloss[rvalue reference]{\romeovalue{rvalue} references}, functions that return an
\emcppsgloss[rvalue reference]{\romeovalue{rvalue} reference} also create \romeovalue{xvalues} when
invoked, enabling Standard Library functions like \lstinline!std::move! and
other cases where encapsulating the ability to enable moving from a
preexisting object is desired.



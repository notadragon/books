
\chapter[Safe Features]{Safe Features}\label{ch-safe}

Intro text should be here.

% to add to the TOC at the section level


\newpage
\section[Attributes]{Attributes}\label{attributes}



An \emph{attribute} is an annotation (e.g., of a statement or named
\textbf{entity}) used to provide supplementary information.

\subsection[Description]{Description}\label{description}

Developers are often aware of information that is not deducible directly
from the source code within a given translation unit. Some of this
information might be useful to certain compilers, say, to inform
diagnostics or optimizations; typical attributes, however, are designed
to avoid affecting the semantics{\cprotect\footnote{By \emph{semantics}, here
we typically mean any observable behavior apart from runtime
performance. Generally, ignoring an attribute is a valid (and safe)
choice for a compiler to make. Sometimes, however, an
attribute will not affect the behavior of a \emph{correct} program but might affect the behavior of a well-formed yet incorrect one (see
{\it\titleref{attribute-use-cases}:} {\it\titleref{delineating-explicit-assumptions-in-code-to-achieve-better-optimizations}} on page~\pageref{delineating-explicit-assumptions-in-code-to-achieve-better-optimizations}).}} of a
well-written program. Customized annotations targeted at external (e.g.,
static-analysis) tools{\cprotect\footnote{Such static-analysis tools include Clang sanitizers, Coverity, and other
proprietary, open-source, and commercial products.}} might be
beneficial as well.

\subsubsection[C++ attribute syntax]{C++ attribute syntax}\label{c++-attribute-syntax}

C++ supports a standard syntax for attributes, introduced via a matching
pair of \texttt{[[} and \texttt{]]}, the simplest of which is a single
attribute represented using a simple identifier, e.g.,
\texttt{attribute\_name}:

\begin{lstlisting}[language=C++]
[[attribute_name]]
\end{lstlisting}

\noindent A single annotation can consist of zero or more attributes:

\begin{lstlisting}[language=C++]
[[]]           // permitted in every position where any attribute is allowed
[[foo, bar]]   // equivalent to (ù{\codeincomments{[[foo]] [[bar]]}}ù)
\end{lstlisting}

\noindent An attribute may have an (optional) argument list consisting of an
arbitrary sequence of tokens:

\begin{lstlisting}[language=C++]
[[attribute_name()]]            // same as (ù{\codeincomments{attribute\_name}}ù)
[[deprecated("too ugly")]]      // single-argument attribute
[[theoretical(1, "two", 3.0)]]  // multiple-argument attributes
[[complicated({1, 2, 3} + 5)]]  // arbitrary tokens (fails on GCC <= 9.2)
\end{lstlisting}

\noindent Note that having an incorrect number of arguments or an incompatible
argument type is a compile-time error for all standard attributes; the
behavior for all other attributes, however, is
\textbf{implementation-defined} (see {\it\titleref{attribute-potential-pitfalls}:} {\it\titleref{unrecognized-attributes-have-implementation-defined-behavior}} on page~\pageref{unrecognized-attributes-have-implementation-defined-behavior}).

Any attribute may be namespace qualified{\cprotect\footnote{Attributes
having a namespace-qualified name (e.g., \texttt{[[gnu::const]]}) were
only \textbf{conditionally supported} in C++11 and C++14, but
historically they were supported by all major compilers, including both
Clang and GCC; all C++17-conforming compilers \textit{must} support namespace-qualified names.}} (using any arbitrary identifier):

\begin{lstlisting}[language=C++]
[[gnu::const]]  // (GCC-specific) namespace-(ù{\codeincomments{gnu}}ù)-qualified (ù{\codeincomments{const}}ù) attribute
[[my::own]]     // (user-specified) namespace-(ù{\codeincomments{my}}ù)-qualified (ù{\codeincomments{own}}ù) attribute
\end{lstlisting}


\subsubsection[C++ attribute placement]{C++ attribute placement}\label{c++-attribute-placement}

Attributes can, in principle, be introduced almost anywhere within the
C++ syntax to annotate almost anything, including an entity,
statement, code block, and even entire translation
unit; however, most contemporary compilers do not support arbitrary
placement of attributes (see {\it\titleref{attribute-use-cases}:} {\it\titleref{probing-where-attributes-are-permitted-in-the-compiler’s-c++-grammar}} on page~\pageref{probing-where-attributes-are-permitted-in-the-compiler’s-c++-grammar}) outside of a
declaration statement. Furthermore, in some cases, the entity to
which an unrecognized attribute pertains might not be clear from its
syntactic placement alone.

In the case of a declaration statement, however, the intended entity is
well specified; an attribute placed in front of the statement applies to
every entity being declared, whereas an attribute placed immediately
after the named entity applies to just that one entity:

\begin{lstlisting}[language=C++]
[[noreturn]] void f(), g();  // Both (ù{\codeincomments{f()}}ù) and (ù{\codeincomments{g()}}ù) are (ù{\codeincomments{noreturn}}ù).
void u(), v() [[noreturn]];  // Only (ù{\codeincomments{v()}}ù) is (ù{\codeincomments{noreturn}}ù).
\end{lstlisting}

\noindent Attributes placed in front of a declaration statement and immediately
behind the name{\cprotect\footnote{There are rare edge cases in which an
entity (e.g., an anonymous \texttt{union} or \texttt{enum}) is
declared without a name:

\begin{lstlisting}[language=C++, basicstyle={\ttfamily\footnotesize}]
struct S { union [[attribute_name]] { int a; float b }; };
enum [[attribute_name]] { SUCCESS, FAIL } result;
\end{lstlisting} \vspace*{-1ex}
}} of an individual entity in the same statement are additive (for
that entity). The behavior of attributes associated with an entity
across multiple declaration statements, however, depends on the
attributes themselves. As an example, \texttt{[[noreturn]]} is required
to be present on the \emph{first} declaration of a function. Other
attributes might be additive, such as the hypothetical \texttt{foo} and
\texttt{bar} shown here:

\begin{lstlisting}[language=C++]
[[foo]] void f(), g();  // declares both (ù{\codeincomments{f()}}ù) and (ù{\codeincomments{g()}}ù) to be (ù{\codeincomments{foo}}ù)
void f [[bar]](), g();  // Now (ù{\codeincomments{f()}}ù) is both (ù{\codeincomments{foo}}ù) and (ù{\codeincomments{bar}}ù) while
//     (ù{\codeincomments{g()}}ù) is still just (ù{\codeincomments{foo}}ù).
\end{lstlisting}

\noindent Redundant attributes are not themselves necessarily considered an error;
however, most standard attributes do consider redundancy an
error{\cprotect\footnote{Redundancy of standard
attributes might no longer be an error in future revisions of the
C++ Standard; see \textbf{{iso20a}}.}}:

\begin{lstlisting}[language=C++]
[[attr1]] void f [[attr2]](), f [[attr3]](int);
// (ù{\codeincomments{f()}}ù)    is (ù{\codeincomments{attr1}}ù) and (ù{\codeincomments{attr2}}ù).
// (ù{\codeincomments{f(int)}}ù) is (ù{\codeincomments{attr1}}ù) and (ù{\codeincomments{attr3}}ù).

[[a1]][[a1]] int [[a1]][[a1]] & x;    // (ù{\codeincomments{x}}ù) (the reference itself) is (ù{\codeincomments{a1}}ù).

void g [[noreturn]] [[noreturn]]();   // (ù{\codeincomments{g()}}ù) is (ù{\codeincomments{noreturn}}ù).

void h [[noreturn, noreturn]]();      // error: repeated (standard) attribute
\end{lstlisting}

\noindent In most other cases, an attribute will typically apply to the statement
(including a block statement) that immediately (apart from other
attributes) follows it:

\begin{lstlisting}[language=C++]
[[attr1]];                                // null statement
[[attr2]] return 0;                       // return statement
[[attr3]] for (int i = 0; i < 10; ++i);   // for statement
[[attr4]] [[attr5]] { /* ... */ }         // block statement
\end{lstlisting}

\noindent The valid positions of any particular attribute, however, will be
constrained by whatever entities to which it applies. That is, an
attribute such as \texttt{noreturn}, which pertains only to functions,
would be valid syntactically but not semantically were it placed so as
to annotate any other kind of entity or syntactic element. Misplacement of
standard attributes results in an ill-formed
program{\cprotect\footnote{As of this writing, GCC is lax and merely
warns when it sees the standard \texttt{noreturn} attribute in an
unauthorized syntactic position, whereas Clang (correctly) fails to
compile. Hence creative use of even a standard attribute might
lead to different behavior on different compilers.}}:

\begin{lstlisting}[language=C++]
void [[noreturn]] g() { throw; }  // error: appertains to type specifier
void i() [[noreturn]] { throw; }  // error: appertains to type specifier
\end{lstlisting}


\subsubsection[Common compiler-dependent attributes]{Common compiler-dependent attributes}\label{common-compiler-dependent-attributes}

Prior to C++11, no standardized syntax was available to support conveying
externally sourced information, and nonportable compiler intrinsics
(such as\linebreak[4] \mbox{\texttt{\_\_attribute\_\_((fallthrough))}}, which is
GCC-specific syntax) had to be used instead. Given the new standard
syntax, vendors are now able to express these extensions in a more
(syntactically) consistent manner. If an unknown attribute is
encountered during compilation, it is ignored, emitting a (likely{\cprotect\footnote{Prior to C++17, a conforming implementation was
permitted to treat an unknown attribute as ill formed and terminate
translation; to the authors' knowledge, however, none of them did.}}) nonfatal
diagnostic.

Table \ref{attribute-table1} provides a brief survey of popular compiler-specific attributes
that have been standardized or have migrated to the standard syntax. (For
additional compiler-specific attributes, see {\it\titleref{attribute-further-reading}} on page~\pageref{attribute-further-reading}.)

\begin{table}[h!]
\begin{center}
\begin{threeparttable}
\caption{Some standardized compiler-specific attributes}\label{attribute-table1}\vspace{1.5ex}
{\small \begin{tabular}{c|c|c}\thickhline
\rowcolor[gray]{.9}   {\sffamily\bfseries Compiler} & {\sffamily\bfseries Compiler-Specific} &
{\sffamily\bfseries Standard-Conforming} \\ \hline
GCC &\texttt{\_\_attribute\_\_((pure))} & \texttt{[[gnu::pure]]} \\ \hline
Clang & \texttt{\_\_attribute\_\_((no\_sanitize))} &\texttt{[[clang::no\_sanitize]]} \\ \hline
MSVC & \texttt{declspec(deprecated)} & \texttt{[[deprecated]]} \\ \thickhline
\end{tabular}
}
\end{threeparttable}
\end{center}
\end{table}

The requirement (as of C++17) to ignore unknown attributes helps to
ensure portability of useful compiler-specific and external-tool
annotations without necessarily having to employ conditional compilation
so long as that attribute is permitted at that specific syntactic
location by all relevant compilers (with some caveats;
see {\it\titleref{attribute-potential-pitfalls}:} {\it\titleref{not-every-syntactic-location-is-viable-for-an-attribute}} on page~\pageref{not-every-syntactic-location-is-viable-for-an-attribute}).

\subsection[Use Cases]{Use Cases}\label{attribute-use-cases}

\subsubsection[Eliciting useful compiler diagnostics]{Eliciting useful compiler diagnostics}\label{eliciting-useful-compiler-diagnostics}

Decorating entities with certain attributes can give compilers enough
additional context to provide more detailed diagnostics. For example,
the GCC-specific\linebreak[4] \texttt{[[gnu::warn\_unused\_result]]}
attribute{\cprotect\footnote{For compatibility with GCC,
Clang supports \texttt{[[gnu::warn\_unused\_result]]} as
well.}} can be used to inform the compiler (and developers) that a
function's return value should not be ignored{\cprotect\footnote{The
C++17 Standard \texttt{[[nodiscard]]} attribute serves the same
purpose and is portable.}}:

\begin{lstlisting}[language=C++]
struct UDPListener
{
[[gnu::warn_unused_result]] int start();
// Start the UDP listener's background thread (which can fail for a
// variety of reasons). Return 0 on success and a nonzero value
// otherwise.

void bind(int port);
// The behavior is undefined unless (ù{\codeincomments{start}}ù) was called successfully.
};
\end{lstlisting}

\noindent Such annotation of the client-facing declaration can prevent defects
caused by a client's forgetting to inspect the result of a
function{\cprotect\footnote{Because the
\texttt{[[gnu::warn\_unused\_result]]} attribute does not affect code
generation, it is explicitly \emph{not} ill formed for a client to
make use of an unannotated declaration and yet compile its
corresponding definition in the context of an annotated one (or vice
versa); such is not always the case for other attributes, however, and
best practice might argue in favor of consistency regardless.}}:

\begin{lstlisting}[language=C++]
void init()
{
UDPListener listener;
listener.start();      // Might fail; return value must be checked!
listener.bind(27015);  // Possible undefined behavior; BAD IDEA!
}
\end{lstlisting}

\noindent For the code above, GCC produces a useful warning:

\begin{lstlisting}[language=C++]
warning: ignoring return value of 'bool HttpClient::start()' declared
with attribute 'warn_unused_result' [-Wunused-result]
\end{lstlisting}


\subsubsection[Hinting at additional optimization opportunities]{Hinting at additional optimization opportunities}\label{hinting-at-additional-optimization-opportunities}

Some annotations can affect compiler optimizations leading to more
efficient or smaller binaries. For example, decorating the function
\texttt{reportError} (below) with the GCC-specific
\texttt{[[gnu::cold]]} attribute (also available on Clang) tells the
compiler that the developer believes the function is unlikely to be
called often:

\begin{lstlisting}[language=C++]
[[gnu::cold]] void reportError(const char* message) { /* ... */ }
\end{lstlisting}

\noindent Not only might the definition of \texttt{reportError} itself be
optimized differently (e.g., for space over speed), any use of this
function will likely be given lower priority during branch \mbox{prediction}:

\begin{lstlisting}[language=C++]
void checkBalance(int balance)
{
if (balance >= 0)  // likely branch
{
// ...
}
else  // unlikely branch
{
reportError("Negative balance.");
}
}
\end{lstlisting}

\noindent Because the (annotated) \texttt{reportError(const}~\texttt{char*)}
appears on the else branch of the if statement (above), the compiler
knows to expect that \texttt{balance} is likely \emph{not} to be
negative and therefore optimizes its predictive branching accordingly.
Note that even if our hint to the compiler turns out to be misleading at
run time, the semantics of every well-formed program remain the same.

\subsubsection[Delineating explicit assumptions in code to achieve better optimizations]{Delineating explicit assumptions in code to achieve better optimizations}\label{delineating-explicit-assumptions-in-code-to-achieve-better-optimizations}

Although the presence (or absence) of an attribute usually has no effect
on the behavior of any well-formed program (besides runtime performance),
an attribute sometimes imparts knowledge to the compiler
which, if incorrect, could alter the intended behavior of the program
(or perhaps mask the defective behavior of an incorrect one). As an
example of this more forceful form of attribute, consider the
GCC-specific \texttt{[[gnu::const]]} attribute (also available on
Clang). When applied to a function, this (atypically) powerful (and
dangerous, see {\it\titleref{attribute-potential-pitfalls}:} {\it\titleref{some-attributes,-if-misused,-can-affect-program-correctness}} on page~\pageref{some-attributes,-if-misused,-can-affect-program-correctness}) attribute instructs the compiler to \emph{assume}
that the function is a \textbf{pure function} (i.e., that it always
returns the same value for any given set of arguments) and has no
\textbf{side effects} (i.e., the globally reachable
state{\cprotect\footnote{Absolutely no external state changes are
allowed in a function decorated with \texttt{[[gnu::const]]},
including global state changes or mutation via any of the function's
arguments. (The arguments themselves are considered local state and
hence can be modified.) The (more lenient) \texttt{[[gnu::pure]]}
attribute allows changes to the state of the function's arguments but still
forbids any global state mutation. For example, any sort of (even
temporary) global memory allocation would render a function ineligible
for \texttt{[[gnu::const]]} or \texttt{[[gnu::pure]]}.}} of the
program is unaltered by calling this function):

\begin{lstlisting}[language=C++]
[[gnu::const]]
double linearInterpolation(double start, double end, double factor)
{
return (start * (1.0 - factor)) + (end * factor);
}
\end{lstlisting}

\noindent The \texttt{vectorLerp} function (below) performs linear
interpolation (referred to as LERP) between two bidimen\-sional vectors. The body
of this function comprises two invocations to the
\mbox{\texttt{linearInterpolation}} function (above) --- one per vector
component:

\begin{lstlisting}[language=C++]
Vector2D vectorLerp(const Vector2D& start, const Vector2D& end, double factor)
{
return Vector2D(linearInterpolation(start.x, end.x, factor),
linearInterpolation(start.y, end.y, factor));
}
\end{lstlisting}

\noindent In the (possibly frequent) case where the values of the two components
are the same, the compiler is allowed to invoke
\texttt{linearInterpolation} only once --- even if its body is not
visible in \texttt{vectorLerp}'s translation unit:

\begin{lstlisting}[language=C++]
// pseudocode (hypothetical compiler transformation)
Vector2D vectorLerp(const Vector2D& start, const Vector2D& end, double factor)
{
if (start.x == start.y && end.x == end.y)
{
const double cache = linearInterpolation(start.x, end.x, factor);
return Vector2D(cache, cache);
}

return Vector2D(linearInterpolation(start.x, end.x, factor),
linearInterpolation(start.y, end.y, factor));
}
\end{lstlisting}

\noindent If the implementation of a function tagged with the
\texttt{[[gnu::pure]]} attribute does not satisfy limitations imposed by
the attribute, however, the compiler will not be able to detect this and a runtime
defect will be the likely result{\cprotect\footnote{The briefly adopted
--- and then \emph{unadopted} --- contract-checking facility proposed
for C++20 contemplated incorporating a feature similar in spirit to
\texttt{[[gnu::const]]} in which preconditions (in addition to being
runtime checked or ignored) could be \emph{assumed} to be true by the
compiler for the purposes of optimization; this unique use of
attribute-like syntax also required that a conforming implementation
could not unilaterally ignore these precondition-checking attributes
since that would make attempting to test them result in hard
(\emph{language}) \textbf{undefined behavior}.}}; see
{\it\titleref{attribute-potential-pitfalls}:} {\it\titleref{some-attributes,-if-misused,-can-affect-program-correctness}} on page~\pageref{some-attributes,-if-misused,-can-affect-program-correctness}.

\subsubsection[Using attributes to control external static analysis]{Using attributes to control external static analysis}\label{using-attributes-to-control-external-static-analysis}

Since unknown attributes are ignored by the compiler, external
static-analysis tools can define their own custom attributes that can be
used to embed detailed information to influence or control those tools
without affecting program semantics. For example, the Microsoft-specific
\texttt{[[gsl::suppress(/*}~\texttt{rules}~\texttt{*/)]]} attribute can
be used to suppress unwanted warnings from static-analysis tools that
verify \emph{Guidelines Support Library}{\cprotect\footnote{\emph{Guidelines
Support Library} (see \textbf{microsoft}) is an open-source library, developed by Microsoft,
that implements functions and types suggested for use by the ``C++
Core Guidelines'' (see \textbf{{stroustrup20}}).}}
rules. In particular, consider GSL C26481 (Bounds rule \#1),\footnote{\textbf{microsoftC26481}} which forbids any pointer arithmetic, instead
suggesting that users rely on the \texttt{gsl::span}
type{\cprotect\footnote{\texttt{gsl::span} is a lightweight reference
type that observes a contiguous sequence (or subsequence) of objects
of homogeneous type. \texttt{gsl::span} can be used in interfaces as
an alternative to both pointer/size or iterator-pair arguments and in
implementations as an alternative to (raw) pointer arithmetic. Since
C++20, the standard \texttt{std::span} template can be used instead.}}:

\begin{lstlisting}[language=C++]
void hereticalFunction()
{
int array[] = {0, 1, 2, 3, 4, 5};

printElements(array, array + 6);  // elicits warning C26481
}
\end{lstlisting}

\noindent Any block of code for which validating rule C26481 is considered
undesirable can be decorated with the
\texttt{[[gsl::suppress(bounds.1)]]} attribute:

\begin{lstlisting}[language=C++]
void hereticalFunction()
{
int array[] = {0, 1, 2, 3, 4, 5};

[[gsl::suppress(bounds.1)]]           // Suppress GSL C26481.
{
printElements(array, array + 6);  // Silence!
}
}
\end{lstlisting}


\subsubsection[Creating new attributes to express semantic properties]{Creating new attributes to express semantic properties}\label{creating-new-attributes-to-express-semantic-properties}

Other uses of attributes for static analysis include statements of
properties that cannot otherwise be deduced within a single translation
unit. Consider a function, \texttt{f}, that takes two pointers,
\texttt{p1} and \texttt{p2}, and has a \textbf{precondition} that both
pointers must refer to the same contiguous block of memory (as the two
addresses are compared internally). Accordingly, we might annotate the
function \texttt{f} with our own attribute
\texttt{home\_grown::in\_same\_block(p1,}~\texttt{p2)}:

\begin{lstlisting}[language=C++]
// lib.h

[[home_grown::in_same_block(p1, p2)]]
int f(double* p1, double* p2);
\end{lstlisting}

\noindent Now imagine that some client calls this function from some other
translation unit but passes in two unrelated pointers:

\begin{lstlisting}[language=C++]
// client.cpp
#include <lib.h>

void client()
{
double a[10], b[10];
f(a, b);  // Oops, this is UB.
}
\end{lstlisting}

\noindent Because our static-analysis tool knows from the
\texttt{home\_grown::in\_same\_block} attribute that \texttt{a} and
\texttt{b} must point into the same contiguous block, however, it has
enough information to report, at compile time, what might otherwise have
resulted in \textbf{undefined behavior} at run time.

\subsubsection[Probing where attributes are permitted in the compiler’s C++ grammar]{Probing where attributes are permitted in the compiler’s C++ grammar}\label{probing-where-attributes-are-permitted-in-the-compiler’s-c++-grammar}

An attribute can generally appear syntactically at the beginning of any
statement --- e.g.,
\texttt{[[attr]]}~\texttt{x}~\texttt{=}~\texttt{5;} --- or in almost any
position relative to a type or expression (e.g.,
\texttt{const}~\texttt{int\&}) but typically cannot be associated
within named objects outside of a declaration statement:

\begin{lstlisting}[language=C++]
[[]] static [[]] int [[]] a [[]], /*[[]]*/ b [[]];  // declaration statement
\end{lstlisting}

\noindent Notice how we have used the empty attribute syntax \texttt{[[]]} above
to probe for positions allowed for arbitrary attributes by the compiler
(in this case, GCC) --- the only invalid one being immediately following
the comma, shown above as \texttt{/*[[]]*/}. Outside of a declaration
statement, however, viable attribute locations are typically far more
limited:

\begin{lstlisting}[language=C++,label=attribute-gcc-example]
[[]] void [[]] f [[]] ( [[]] int [[]] n [[]] )
[[]] {
[[]] n /**/ *= /**/ sizeof /**/ ( [[]] const [[]] int [[]] & [[]] ) /**/;
[[]] for ([[]] int [[]] i [[]] = /**/ 0 /**/ ;
/**/ i  /**/ < /**/ n /**/ ;
/**/ ++ /**/ i /**/ )
[[]] {
[[]] ;             // (ù{\codeincomments{[[]]}}ù) denotes viable attribute location (on GCC)
/**/ }
/**/ }                     // (ù{\codeincomments{/**/}}ù) denotes no attribute allowed (on GCC)
\end{lstlisting}

\noindent Type expressions --- e.g., the argument to \texttt{sizeof} (above) ---
are a notable exception; see {\it\titleref{attribute-potential-pitfalls}:} {\it\titleref{not-every-syntactic-location-is-viable-for-an-attribute}} on page~\pageref{not-every-syntactic-location-is-viable-for-an-attribute}.

\subsection[Potential Pitfalls]{Potential Pitfalls}\label{attribute-potential-pitfalls}

\subsubsection[Unrecognized attributes have implementation-defined behavior]{Unrecognized attributes have implementation-defined behavior}\label{unrecognized-attributes-have-implementation-defined-behavior}

Although standard attributes work well and are portable across all
platforms, the behavior of compiler-specific and user-specified
attributes is entirely implementation defined, with unrecognized
attributes typically resulting in compiler warnings. Such warnings can typically be disabled (e.g., on GCC using
\texttt{-Wno-attributes}), but, if they are, misspellings in even standard
attributes will go unreported.{\cprotect\footnote{Ideally, every relevant platform would offer a way to silently ignore a specific
attribute on a case-by-case basis.}}

\subsubsection[Some attributes, if misused, can affect program correctness]{Some attributes, if misused, can affect program correctness}\label{some-attributes,-if-misused,-can-affect-program-correctness}

Many attributes are benign in that they might improve diagnostics or
performance but cannot themselves cause a program to behave incorrectly.
Some, however, if misused, can lead to incorrect
results and/or \textbf{undefined behavior}.

For example, consider the \texttt{myRandom} function that is intended to
return a new random number between $[0.0$ and $0.1]$ on each successive
call:

\begin{lstlisting}[language=C++]
double myRandom()
{
static std::random_device randomDevice;
static std::mt19937 generator(randomDevice());

std::uniform_real_distribution<double> distribution(0, 1);
return distribution(generator);
}
\end{lstlisting}

\noindent Suppose that we somehow observed that decorating \texttt{myRandom} with
the \texttt{[[gnu::const]]} attribute occasionally improved runtime
performance and innocently but naively decided to use it in production. This
is clearly a misuse of the \texttt{[[gnu::const]]} attribute because the
function doesn't inherently satisfy the requirement of producing the
same result when invoked with the same arguments (in this case, none).
Adding this attribute tells the compiler that it need not call this
function repeatedly and is free to treat the first value returned as a
constant for all time.

\subsubsection[Not every syntactic location is viable for an attribute]{Not every syntactic location is viable for an attribute}\label{not-every-syntactic-location-is-viable-for-an-attribute}

For a fairly limited subset of syntactic locations, most
conforming implementations are likely to tolerate the double-bracketed
attribute-list syntax. The ubiquitously available locations include the
beginning of any statement, immediately following a named entity in a
declaration statement, and (typically) arbitrary positions relative to a
\textbf{type expression} but, beyond that, caveat emptor. For example, GCC
allowed all of the positions indicated in the example shown in
{\it\titleref{attribute-use-cases}:} {\it\titleref{probing-where-attributes-are-permitted-in-the-compiler’s-c++-grammar}} on pages~\pageref{probing-where-attributes-are-permitted-in-the-compiler’s-c++-grammar}--\pageref{attribute-gcc-example}, yet Clang had
issues with the third line in two places:

\begin{lstlisting}[language=C++]
<source>:3:39: error: expected variable name or 'this' in lambda capture list
[[]] n /**/ *= /**/ sizeof /**/ ([[]] const [[]] int [[]] & [[]] ) /**/;
^

<source>:3:48: error: an attribute list cannot appear here
[[]] n /**/ *= /**/ sizeof /**/ (/**/ const [[]] int [[]] & [[]] ) /**/;
^~~~
\end{lstlisting}

\noindent Hence, just because an arbitrary syntactic location is valid for an
attribute on one compiler doesn't mean that it is necessarily valid on
another.a

\subsection[Annoyances]{Annoyances}\label{annoyances}

None so far

\subsection[See Also]{See Also}\label{see-also}

\begin{itemize}
\item{``\titleref{the-noreturn-attribute}" on page~\pageref{the-noreturn-attribute} — Safe C++11 standard attribute for functions that never return control flow to the caller}
\item{``\titleref{carriesdependency}" on page~\pageref{carriesdependency} — Unsafe C++11 standard attribute used to communicate release-consume dependency-chain information to the compiler to avoid unnecessary memory-fence instructions}
\item{``\titleref{alignas}" on page~\pageref{alignas} --- Safe C++11 attribute (with a keyword-like syntax) used to widen the alignment of a type or an object}
\item{``\titleref{deprecated}" on page~\pageref{deprecated} — Safe C++14 standard attribute that discourages the use of an entity via compiler diagnostics}
\end{itemize}

\subsection[Further Reading]{Further Reading}\label{attribute-further-reading}

For more information on commonly supported function attributes, see
section~6.33.1, ``Common Function Attributes," \textbf{{freesoftwarefdn20}}.




\newpage
\section[Binary Literals]{Binary Literals}\label{binary-literals}


\textit{Binary literals} are \textbf{integer literals}\glossary{integer literals} representing their values in base 2.

\subsection[Description]{Description}\label{description}

A \emph{binary literal} (e.g., \texttt{0b1110}) --- much like a
hexadecimal literal (e.g., \texttt{0xE}) or an octal literal (e.g.,
\texttt{016}) --- is a kind of \emph{integer literal} (in this case,
having the \emph{decimal} value \texttt{14}). A binary literal consists
of a \texttt{0b} (or \texttt{0B}) prefix followed by a nonempty
sequence of binary digits (\texttt{0} or \texttt{1}){\cprotect\footnote{Prior to being introduced in C++14, GCC supported binary literals (with the same syntax as the standard feature) as a nonconforming extension since version 4.3 (released between March 2008 and
May 2010); for more details, see [CITATION TBD].}}:

\begin{lstlisting}[language=C++]
int i = 0b11110000;  // equivalent to (ù{\codeincomments{240}}ù), (ù{\codeincomments{0360}}ù), or (ù{\codeincomments{0xF0}}ù)
int j = 0B11110000;  // same value as above
\end{lstlisting}


\noindent The first digit after the \texttt{0b} prefix is the most significant
one:

\begin{lstlisting}[language=C++]
static_assert(0b0     ==  0, "");  // 0*2^0
static_assert(0b1     ==  1, "");  // 1*2^0
static_assert(0b10    ==  2, "");  // 1*2^1 + 0*2^0
static_assert(0b11    ==  3, "");  // 1*2^1 + 1*2^0
static_assert(0b100   ==  4, "");  // 1*2^2 + 0*2^1 + 0*2^0
static_assert(0b101   ==  5, "");  // 1*2^2 + 0*2^1 + 1*2^0
// ...
static_assert(0b11010 == 26, "");  // 1*2^4 + 1*2^3 + 0*2^2 + 1*2^1 + 0*2^0
\end{lstlisting}


\noindent Leading zeros --- as with octal and hexadecimal (but not decimal)
literals --- are ignored but can be added for readability:

\begin{lstlisting}[language=C++]
static_assert(0b00000000 ==   0, "");
static_assert(0b00000001 ==   1, "");
static_assert(0b00000010 ==   2, "");
static_assert(0b00000100 ==   4, "");
static_assert(0b00001000 ==   8, "");
static_assert(0b10000000 == 128, "");
\end{lstlisting}


\noindent The type of a binary literal{\cprotect\footnote{Its \emph{value
category} is \emph{prvalue} like every other integer literal.}} is by
default a (non-negative) \texttt{int} unless that value cannot fit in an
\texttt{int}. In that case, its type is the first type in the sequence
\{\texttt{unsigned}~\texttt{int}, \texttt{long},
\texttt{unsigned}~\texttt{long}, \texttt{long}~\texttt{long},
\texttt{unsigned}~\texttt{long}~\texttt{long}\}{\cprotect\footnote{This
same type list applies for both \texttt{octal} and \texttt{hex}
literals but not for decimal literals, which, if initially
\texttt{signed}, skip over any \texttt{unsigned} types, and vice versa
(see the \textit{Description} section).}} in which it will fit. If neither of those is applicable, then the program is
\emph{ill-formed}{\cprotect\footnote{Purely for convenience of
exposition, we have employed the C++11 \texttt{auto} feature to
conveniently capture the type implied by the literal itself; for more
information, see Section \ref{auto-feature}, ``\titleref{auto-feature}."}}:

\begin{lstlisting}[language=C++]
// example platform 1:
// ((ù{\codeincomments{sizeof(int)}}ù): 4; (ù{\codeincomments{sizeof(long)}}ù): 4; (ù{\codeincomments{sizeof(long long)}}ù): 8)
auto i32  = 0b0111...[ 24 1-bits]...1111;  // (ù{\codeincomments{i32}}ù) is (ù{\codeincomments{int}}ù).
auto u32  = 0b1000...[ 24 0-bits]...0000;  // (ù{\codeincomments{u32}}ù) is (ù{\codeincomments{unsigned int}}ù).
auto i64  = 0b0111...[ 56 1-bits]...1111;  // (ù{\codeincomments{i64}}ù) is (ù{\codeincomments{long long}}ù).
auto u64  = 0b1000...[ 56 0-bits]...0000;  // (ù{\codeincomments{u64}}ù) is (ù{\codeincomments{unsigned long long}}ù).
auto i128 = 0b0111...[120 1-bits]...1111;  // error: integer literal too large
auto u128 = 0b1000...[120 0-bits]...0000;  // error: integer literal too large

// example platform 2:
// ((ù{\codeincomments{sizeof(int)}}ù): 4; (ù{\codeincomments{sizeof(long)}}ù): 8; (ù{\codeincomments{sizeof(long long)}}ù): 16)
auto i32  = 0b0111...[ 24 1-bits]...1111;  // (ù{\codeincomments{i32}}ù)  is (ù{\codeincomments{int}}ù).
auto u32  = 0b1000...[ 24 0-bits]...0000;  // (ù{\codeincomments{u32}}ù)  is (ù{\codeincomments{unsigned int}}ù).
auto i64  = 0b0111...[ 56 1-bits]...1111;  // (ù{\codeincomments{i64}}ù)  is (ù{\codeincomments{long}}ù).
auto u64  = 0b1000...[ 56 0-bits]...0000;  // (ù{\codeincomments{u64}}ù)  is (ù{\codeincomments{unsigned long}}ù).
auto i128 = 0b0111...[120 1-bits]...1111;  // (ù{\codeincomments{i128}}ù) is (ù{\codeincomments{long long}}ù).
auto u128 = 0b1000...[120 0-bits]...0000;  // (ù{\codeincomments{u128}}ù) is (ù{\codeincomments{unsigned long long}}ù).
\end{lstlisting}


\noindent Separately, the precise initial type of a binary literal, like any other
literal, can be controlled explicitly using the common integer-literal
suffixes \{\texttt{u}, \texttt{l}, \texttt{ul}, \texttt{ll},
\texttt{ull}\} in either lower- or uppercase:

\begin{lstlisting}[language=C++]
auto i   = 0b101;        // type: (ù{\codeincomments{int}}ù);                 value: 5
auto u   = 0b1010U;      // type: (ù{\codeincomments{unsigned int}}ù);        value: 10
auto l   = 0b1111L;      // type: (ù{\codeincomments{long}}ù);                value: 15
auto ul  = 0b10100UL;    // type: (ù{\codeincomments{unsigned long}}ù);       value: 20
auto ll  = 0b11000LL;    // type: (ù{\codeincomments{long long}}ù);           value: 24
auto ull = 0b110101ULL;  // type: (ù{\codeincomments{unsigned long long}}ù);  value: 53
\end{lstlisting}


\noindent Finally, note that affixing a minus sign (\texttt{-}) to a binary
literal (e.g., \texttt{-b1010}) --- just like any other integer literal
(e.g., \texttt{-10}, \texttt{-012}, or \texttt{-0xa}) --- is parsed as a
non-negative value first, after which a unary minus is applied:

\begin{lstlisting}[language=C++]
static_assert(sizeof(int) == 4, "");  // true on virtually all machines today
static_assert(-0b1010 == -10, "");    // as if: (ù{\codeincomments{0 - 0b1010 == 0 - 10}}ù)
static_assert(0x7fffffff != -0x7fffffff, "");  // Both values are (ù{\codeincomments{signed int}}ù).
static_assert(0x80000000 == -0x80000000, "");  // Both values are (ù{\codeincomments{unsigned int}}ù).
\end{lstlisting}


\subsection[Use Cases]{Use Cases}\label{use-cases}

\subsubsection[Bit masking and bitwise operations]{Bit masking and bitwise operations}\label{bit-masking-and-bitwise-operations}

Prior to the introduction of binary literals, hexadecimal (and before
that octal) literals were commonly used to represent bit masks (or
specific bit constants) in source code. As an example, consider a
function that returns the least significant four bits of a given
\texttt{unsigned}~\texttt{int} value:

\begin{lstlisting}[language=C++]
unsigned int lastFourBits(unsigned int value)
{
return value & 0xFu;
}
\end{lstlisting}


\noindent The correctness of the ``bitwise and'' operation above might not be
immediately obvious to a developer inexperienced with
hexadecimal literals. In contrast, use of a binary literal more directly
states our intent to mask all but the four least-significant bits of the
input:

\begin{lstlisting}[language=C++]
unsigned int lastFourBits(unsigned int value)
{
return value & 0b1111u;  // The (ù{\codeincomments{u}}ù) literal suffix here is entirely optional.
}
\end{lstlisting}


Similarly, other bitwise operations, such as setting or getting
individual bits, might benefit from the use of binary literals. For
instance, consider a set of flags used to represent the state of an
avatar in a game:

\begin{lstlisting}[language=C++]
struct AvatarStateFlags
{
enum Enum
{
e_ON_GROUND    = 0b0001,
e_INVULNERABLE = 0b0010,
e_INVISIBLE    = 0b0100,
e_SWIMMING     = 0b1000,
};
};

class Avatar
{
unsigned char d_state;  // power set of possible state flags

public:
bool isOnGround() const
{
return d_flags & AvatarStateFlags::e_ON_GROUND;
}

// ...
};
\end{lstlisting}


\subsubsection[Replicating constant binary data]{Replicating constant binary data}\label{replicating-constant-binary-data}

Especially in the context of \emph{embedded development} or emulation,
a programmer will commonly write code that needs to deal
with specific ``magic'' constants (e.g., provided as part of the
specification of a CPU or virtual machine) that must be incorporated in
the program's source code. Depending on the original format of such
constants, a binary representation can be the most convenient or most
easily understandable one.

As an example, consider a function decoding instructions of a virtual
machine whose opcodes are specified in binary format:

\begin{lstlisting}[language=C++]
#include <cstdint>  // (ù{\codeincomments{std::uint8\_t}}ù)

void VirtualMachine::decodeInstruction(std::uint8_t instruction)
{
switch(instruction)
{
case 0b00000000u:  // no-op
break;

case 0b00000001u:  // (ù{\codeincomments{add(register0, register1)}}ù)
d_register0 += d_register1;
break;

case 0b00000010u:  // (ù{\codeincomments{jmp(register0)}}ù)
jumpTo(d_register0);
break;

// ...
}
}
\end{lstlisting}


\noindent Replicating the same binary constant specified as part of the CPU's (or
virtual machine's) manual or documentation directly in the source avoids the need to
mentally convert such constant data to and from, say, a hexadecimal
number.

Binary literals are also suitable for capturing bitmaps. For instance,
consider a bitmap representing the uppercase letter ``C'':

\begin{lstlisting}[language=C++]
const unsigned char letterBitmap_C[] =
{
0b00011111,
0b01100000,
0b10000000,
0b10000000,
0b10000000,
0b01100000,
0b00011111
};
\end{lstlisting}


\noindent Use of \emph{binary} literals makes the shape of the image that the
bitmap represents apparent directly in the source code.

\subsection[Potential Pitfalls]{Potential Pitfalls}\label{potential-pitfalls}

None so far

\subsection[Annoyances]{Annoyances}\label{annoyances}

None so far

\subsection[See Also]{See Also}\label{see-also}

\begin{itemize}
\item{Section \ref{digitseparator}, ``\titleref{digitseparator}" — Safe C++14 feature that allows a developer to (visually) group together digits in a numerical literal to help readability. Often used in conjunction with binary literals.}
\end{itemize}

\subsection[Further Reading]{Further Reading}\label{further-reading}

None so far



\newpage
\section[Consecutive Right Angle Brackets]{Consecutive Right Angle Brackets}\label{consecutive-right-angle-brackets}
In the context of template argument lists, \texttt{>>} is parsed as two
(separate) closing angle brackets.

\subsection[Description]{Description}\label{description}

Prior to C++11, a pair of consecutive right-pointing angle brackets anywhere in
the source code was always interpreted as a bitwise right-shift
operator, making an intervening space mandatory for them to be treated
as separate closing-angle-bracket tokens:

\begin{lstlisting}[language=C++]
// C++03
std::vector<std::vector<int>> v0;   // annoying compile-time error in C++03
std::vector<std::vector<int> > v1;  // OK
\end{lstlisting}

\noindent To facilitate the common use case above, a special rule was added
whereby, when parsing a template-argument expression, \emph{non-nested}
(i.e., within parentheses) appearances of \texttt{>}, \texttt{>>},
\texttt{>>>}, and so on are to be treated as separate closing angle brackets:

\begin{lstlisting}[language=C++]
// C++11
std::vector<std::vector<int>> v0;               // OK
std::vector<std::vector<std::vector<int>>> v1;  // OK
\end{lstlisting}

\subsubsection[Using the greater-than or right-shift operators within template-argument expressions]{Using the greater-than or right-shift operators within template-argument expressions}\label{using-the-greater-than-or-right-shift-operators-within-template-argument-expressions}

For templates that take only type parameters, there's no issue. When the
template parameter is a non-type, however, the greater-than or right-shift operators might possibly be
useful. In the unlikely event that we need either the greater-than
operator (\texttt{>}) or the right-shift operator (\texttt{>>}) within a
(non-type) template-argument expression, we can achieve our goal by
nesting that expression within parentheses:

\begin{lstlisting}[language=C++]
const int i = 1, j = 2;  // arbitrary integer values (used below)

template <int I> class C { /*...*/ };
// class (ù{\codeincomments{C}}ù) taking non-type template parameter (ù{\codeincomments{I}}ù) of type (ù{\codeincomments{int}}ù)

C<i > j>    a1;  // compile-time error (always has been)
C<i >> j>   b1;  // compile-time error in C++11 (OK in C++03)
C<(i > j)>  a2;  // OK
C<(i >> j)> b2;  // OK
\end{lstlisting}


\noindent In the definition of \texttt{a1} above, the first \texttt{>} is
interpreted as a closing angle bracket and the subsequent \texttt{j} is
(and always has been) a syntax error. In the case of \texttt{b1}, the
\texttt{>>} is, as of C++11, parsed as a pair of separate tokens in this
context, so the second \texttt{>} is now considered an error. For
both \texttt{a2} and \texttt{b2}, however, the would-be operators appear
nested (within parentheses) and thus are blocked from matching any
active open angle bracket to the left of the parenthesized expression.

\subsection[Use Cases]{Use Cases}\label{use-cases}

\subsubsection[Avoiding annoying whitespace when composing template types]{Avoiding annoying whitespace when composing template types}\label{avoiding-annoying-whitespace-when-composing-template-types}

When using nested templated types (e.g.,~nested containers) in C++03,
having to remember to insert an intervening space between trailing angle
brackets added no value. What made it even more galling was that every
popular compiler was able to tell you straight-up that you had forgotten
to leave the space. With this new
feature (rather, this repaired defect), we can now render closing angle
brackets --- just like parentheses and square brackets --- contiguously:

\begin{lstlisting}[language=C++]
// OK in both C++03 and C++11
std::list<std::map<int, std::vector<std::string> > > idToNameMappingList;

// OK in C++11, compile-time error in C++03
std::list<std::map<int, std::vector<std::string>>> idToNameMappingList;
\end{lstlisting}


\subsection[Potential pitfalls]{Potential pitfalls}\label{potential-pitfalls}

\subsubsection[Some C++03 programs may stop compiling in C++11]{Some C++03 programs may stop compiling in C++11}\label{some-c++03-programs-may-stop-working-in-c++11}

If a right-shift operator is used in a template expression, the newer
parsing rules may result in a compile-time error where before there was
none:

\begin{lstlisting}[language=C++]
T<1 >> 5>;  // worked in C++03, compile-time error in C++11
\end{lstlisting}

\noindent The easy fix is simply to parenthesize the expression:

\begin{lstlisting}[language=C++]
T<(1 >> 5)>;  // OK
\end{lstlisting}

\noindent This rare syntax error is invariably caught at compile-time, avoiding undetected surprises at runtime.

\subsubsection[The meaning of a C++03 program can (in theory) silently change in C++11]{The meaning of a C++03 program can (in theory) silently change in C++11}\label{the-meaning-of-a-c++03-program-can-(in-theory)-silently-change-in-c++11}

Though pathologically rare, the same valid expression can (in theory) have a different interpretation in C++11 than it had when compiled for C++03.
Consider the case{\cprotect\footnote{Adaptation of an example from \textbf{{gustedt13}}}} where the
\texttt{>>} token is embedded as part of an expression involving
templates:

\begin{lstlisting}[language=C++]
S<G< 0 >>::c>::b>::a
//   ^~~~~~~
\end{lstlisting}

\noindent In the expression above, \texttt{0}~\texttt{>>::c} will be interpreted
as a \emph{bitwise right-shift operator} in C++03 but not in C++11. Writing a program that (1) compiles under both C++03 and
C++11 and (2) exposes the difference in parsing rules, is possible:

\begin{lstlisting}[language=C++]
enum Outer { a = 1, b = 2, c = 3 };

template <typename> struct S
{
enum Inner { a = 100, c = 102 };
};

template <int> struct G
{
typedef int b;
};

int main()
{
std::cout << (S<G< 0 >>::c>::b>::a) << '\n';
}
\end{lstlisting}

\noindent The program above will print \texttt{100} when compiled for C++03 and
\texttt{0} for C++11:

\begin{lstlisting}[language=C++]
// C++03

//     (2) instantiation of (ù{\codeincomments{G<0>}}ù)
//    (ù{\codeincomments{$\|$}}ù)~~~~~~~~~~~~
//    (ù{\codeincomments{$\|\:\,|\:\,\|$}}ù)   (4) instantiation of (ù{\codeincomments{S<int>}}ù)
//  ~~(ù{\codeincomments{$\|\downarrow\|$}}ù)~~~~~~~~~~~~~~(ù{\codeincomments{$\downarrow$}}ù)
S< G< 0 >>::c > ::b >::a
//    ~~(ù{\codeincomments{$\|\,\,\uparrow\,\,\|$}}ù)~~~~~~~~~(ù{\codeincomments{$\uparrow$}}ù)
//      (ù{\codeincomments{$\|\:\,\,\,|\:\,\,\,\|$}}ù) (3) type alias for (ù{\codeincomments{int}}ù)
//      (ù{\codeincomments{$\|$}}ù)~~~~~~~
// (1) bitwise right-shift ((ù{\codeincomments{0 >> 3}}ù))
\end{lstlisting}


\begin{lstlisting}[language=C++]
// C++11

//
//
//  (2) compare ((ù{\codeincomments{>}}ù)) (ù{\codeincomments{Inner::c}}ù) and (ù{\codeincomments{Outer::b}}ù)
//  (ù{\codeincomments{$\downarrow$}}ù) ~~~~~~~~~~~~~~~~~~
S< G< 0 >>::c > ::b >::a
//  (ù{\codeincomments{$\uparrow$}}ù) ~~~~~~~~~
//  (1) instantiation of (ù{\codeincomments{S<G<0>>}}ù)
//
//
\end{lstlisting}

\noindent Though theoretically possible, programs that are (1) syntactically valid
in both C++03 and C++11 and (2) have distinct semantics have not
emerged in practice anywhere that we are aware of.

\subsection[Annoyances]{Annoyances}\label{annoyances}

None so far

\subsection[See Also]{See Also}\label{see-also}

None so far

\subsection[Further Reading]{Further Reading}\label{further-reading}

\begin{itemize}
\item{Daveed Vandevoorde, \textit{Right Angle Brackets,} \textbf{vandevoorde05}}
\end{itemize}



\newpage
\section[\tt{decltype}]{{\SecCode decltype}}\label{decltype}


The keyword \texttt{decltype} enables the compile-time inspection of the \textbf{declared type}\glossary{declared type} of an \textbf{entity}\glossary{entity} \textit{or} the type and
\textbf{value category}\glossary{value category} of an expression.

\subsection[Description]{Description}\label{description}

What results from the use of \texttt{decltype} depends on the nature of
its operand.

\subsubsection[Use with (typically named) entities]{Use with (typically named) entities}\label{use-with-(typically-named)-entities}

If an unparenthesized operand is either an \textbf{id-expression} that names an entity (or a non-type template parameter) or a \textbf{class member access expression}\glossary{class member access expression} (that identifies a class member), \texttt{decltype} yields the \emph{declared type} (the type of the \emph{entity} indicated by the operand):

\begin{lstlisting}[language=C++]
int i;                // (ù{\codeincomments{decltype(i)}}ù)   -> (ù{\codeincomments{int}}ù)
std::string s;        // (ù{\codeincomments{decltype(s)}}ù)   -> (ù{\codeincomments{std::string}}ù)
int* p;               // (ù{\codeincomments{decltype(p)}}ù)   -> (ù{\codeincomments{int}}ù)*
const int& r = *p;    // (ù{\codeincomments{decltype(r)}}ù)   -> (ù{\codeincomments{const int\&}}ù)
struct { char c; } x; // (ù{\codeincomments{decltype(x.c)}}ù) -> (ù{\codeincomments{char}}ù)
double f();           // (ù{\codeincomments{decltype(f)}}ù)   -> (ù{\codeincomments{double()}}ù)
double g(int);        // (ù{\codeincomments{decltype(g)}}ù)   -> (ù{\codeincomments{double(int)}}ù)
\end{lstlisting}


\subsubsection[Use with (unnamed) expressions]{Use with (unnamed) expressions}\label{use-with-(unnamed)-expressions}

When \texttt{decltype} is used with any other expression \texttt{E} of
type \texttt{T}, the result incorporates both the expression's type and
its \textbf{value category}\glossary{value category}:
%\mclhead{Value category of \texttt{E}} & \mclhead{Result of
%\texttt{decltype(E)}} \\
%\emph{prvalue} & \texttt{T} \\
%\emph{lvalue} & \texttt{T\&} \\
%\emph{xvalue} & \texttt{T\&\&} \\
%%%%%%%%%%% changing this per Greg & design discussion
\begin{center}
{\small \begin{tabular}{c|c}\thickhline
\rowcolor[gray]{.9}   {\sffamily\bfseries Value category of {\ttfamily\bfseries E}}
& {\sffamily\bfseries Result of {\ttfamily\bfseries decltype(E)}} \\ \hline
{\it prvalue} &\texttt{T} \\ \hline
{\it lvalue} & \texttt{T\&} \\ \hline
{\it xvalue} & \texttt{T\&\&} \\ \thickhline
\end{tabular}
}
\end{center}
\noindent The three integer expressions below illustrate the various value
categories:

\begin{lstlisting}[language=C++]
decltype(0)   // -> (ù{\codeincomments{int}}ù)   (*prvalue* category)

int i;
decltype((i)) // -> (ù{\codeincomments{int\&}}ù)  (*lvalue* category)

int&& g();
decltype(g()) // -> (ù{\codeincomments{int\&\&}}ù) (*xvalue* category)
\end{lstlisting}

\noindent Much like the \texttt{sizeof}
operator (which too is resolved at compile time), the expression operand to \texttt{decltype} is not evaluated:

\begin{lstlisting}[language=C++]
int i = 0;
decltype(i++) j;  // equivalent to (ù{\codeincomments{int j;}}ù)
assert(i == 0);   // The function (ù{\codeincomments{next}}ù) is never invoked.
\end{lstlisting}


\subsection[Use Cases]{Use Cases}\label{use-cases}

\subsubsection[Avoiding unnecessary use of explicit typenames]{Avoiding unnecessary use of explicit typenames}\label{avoiding-unnecessary-use-of-explicit-typenames}

Consider two logically equivalent ways of declaring a vector of
iterators into a list of \texttt{Widgets}:

\begin{lstlisting}[language=C++]
std::list<Widget> widgets;
std::vector<std::list<Widget>::iterator> widgetIterators;
// (1) The full type of (ù{\codeincomments{widgets}}ù) needs to be restated, and (ù{\codeincomments{iterator}}ù)
// needs to be explicitly named.

std::list<Widget> widgets;
std::vector<decltype(widgets.begin())> widgetIterators;
// (2) Neither (ù{\codeincomments{std::list}}ù) nor (ù{\codeincomments{Widget}}ù) nor (ù{\codeincomments{iterator}}ù) need be named
// explicitly.
\end{lstlisting}

\noindent Notice that, when using \texttt{decltype}, if the C++ type representing
the widget changes (e.g., from \texttt{Widget} to, say,
\texttt{ManagedWidget}) or the container used changes (e.g., from
\texttt{std::list} to \texttt{std::vector}), the declaration of
\texttt{widgetIterators} need not necessarily change.

\subsubsection[Expressing type-consistency explicitly]{Expressing type-consistency explicitly}\label{expressing-type-consistency-explicitly}

In some situations, repetition of explicit type names might
inadvertently result in latent defects caused by mismatched types during
maintenance. For example, consider a \texttt{Packet} class exposing a
\texttt{const} member function that returns a \texttt{std::uint8\_t}
representing the length of the packet's checksum:

\begin{lstlisting}[language=C++]
class Packet
{
// ...
public:
std::uint8_t checksumLength() const;
};
\end{lstlisting}

\noindent This (tiny) unsigned 8-bit type was selected to minimize bandwidth usage
as the checksum length is sent over the network. Next, picture a loop
that computes the checksum of a \texttt{Packet}, using the same (i.e.,
\texttt{std::uint8\_t}) type for its iteration variable (to match the
type returned by \texttt{Packet::checksumLength}):

\begin{lstlisting}[language=C++]
void f()
{
Checksum sum;
Packet data;

for (std::uint8_t i = 0; i < data.checksumLength(); ++i)  // brittle
{
sum.appendByte(data.nthByte(i));
}
}
\end{lstlisting}


Now suppose that, over time, the data transmitted by the \texttt{Packet}
type grows to the point where the range of a \texttt{std::uint8\_t}
value might not be enough to ensure a sufficiently reliable checksum. If
the type returned by \texttt{checksumLength()} is changed to, say,
\texttt{std::uint16\_t} without updating the type of the iteration
variable \texttt{i} in lockstep, the loop might
silently{\cprotect\footnote{As of this writing, neither
GCC~9.3 nor Clang~10.0.0 provide
a warning (using \texttt{-Wall}, \texttt{-Wextra}, and
\texttt{-Wpedantic}) for the comparison between \texttt{std::uint8\_t}
and \texttt{std::uint16\_t} --- even if both (1) the value returned by
\texttt{checksumLength} does not fit in a 8-bit integer and (2) the
body of the function is visible to the compiler. Decorating
\texttt{checksumLength} with \texttt{constexpr} causes
\texttt{clang++} to issue a warning, but this is clearly not a general
solution.}} become infinite.{\cprotect\footnote{The (tiny) loop
variable is promoted to an \texttt{unsigned} \texttt{int} for
comparison purposes but wraps (to 0) whenever its value prior to
being incremented is 255.}}

Had \texttt{decltype(packet.checksumLength())} been used to express the
type of \texttt{i}, the types would have remained consistent and the
ensuing (``truncation'') defect would naturally have been avoided:

\begin{lstlisting}[language=C++]
// ...
for (decltype(data.checksumLength()) i = 0; i < data.checksumLength(); ++i)
// ...
\end{lstlisting}


\subsubsection[Creating an auxiliary variable of generic type]{Creating an auxiliary variable of generic type}\label{creating-an-auxiliary-variable-of-generic-type}

Consider the task of implementing a generic \texttt{loggedSum} function
(template) that returns the sum of two arbitrary objects \texttt{a} and
\texttt{b} after logging both the operands and the result value (e.g.,
for debugging or monitoring purposes). To avoid computing the (possibly
expensive) sum twice, we decide to create an auxiliary function-scope
variable, \texttt{result}. Since the type of the sum depends on both
\texttt{a} and \texttt{b}, we can use
\texttt{decltype(a}~\texttt{+}~\texttt{b)} to infer the type for both
(1) the (trailing) return type{\cprotect\footnote{Using
\texttt{decltype(a}~\texttt{+}~\texttt{b)} as a return type is
significantly different from relying on \emph{automatic return type
deduction}. See Section~\ref{auto-feature}, ``\titleref{auto-feature}," for more information.}} of the
function (see Section~\ref{trailing-function-return-types}, ``\titleref{trailing-function-return-types}") and (2) the auxiliary variable:

\begin{lstlisting}[language=C++]
template <typename A, typename B>
auto loggedSum(const A& a, const B& b)
-> decltype(a + b)                 // (1) exploiting trailing return types
{
decltype(a + b) result = a + b;    // (2) auxiliary generic variable
LOG_TRACE << a << " + " << b << " = " << result;
return result;
}
\end{lstlisting}


\subsubsection[Determining the validity of a generic expression]{Determining the validity of a generic expression}\label{determining-the-validity-of-a-generic-expression}

In the context of generic-library development, \texttt{decltype} can be
used in conjunction with \textbf{SFINAE}\footnote{``Substitution Failure Is Not An Error"} to validate an expression involving a
template parameter.

For example, consider the task of writing a generic \texttt{sortRange}
function template that, given a \textbf{range}\glossary{range}, invokes either the
\texttt{sort} member function of the argument (the one specifically
optimized for that type) if available, or else falls back to the more
general \texttt{std::sort}:

\begin{lstlisting}[language=C++]
template <typename Range>
void sortRange(Range& range)
{
sortRangeImpl(range, 0);
}
\end{lstlisting}

\noindent The client-facing \texttt{sortRange} function (above) delegates its
behavior to an (overloaded) \texttt{sortRangeImpl} function (below),
invoking the latter with the \texttt{range} and a \emph{disambiguator}
of type \texttt{int}. The type of this additional parameter (its value
is arbitrary) is used to give priority to the \texttt{sort} member
function (at compile time) by exploiting overload resolution rules in
the presence of an implicit (\emph{standard}) conversion (from
\texttt{int} to \texttt{long}):

\begin{lstlisting}[language=C++]
template <typename Range>
void sortRangeImpl(Range& range,
long)                  // low priority: standard conversion
{
// fallback implementation
std::sort(std::begin(range), std::end(range));
}
\end{lstlisting}

\noindent The fallback overload of \texttt{sortRangeImpl} (above) will accept a
\texttt{long} \emph{disambiguator} (requiring a standard conversion from
\texttt{int}) and will simply invoke \texttt{std::sort}. The more
specialized overload of \texttt{sortRangeImpl} (below) will accept an
\texttt{int} \emph{disambiguator} (requiring no conversions) and thus
will be a better match, provided a range-specific sort is available:

\begin{lstlisting}[language=C++]
template <typename Range>
void sortRangeImpl(Range& range,
int,                          // high priority: exact match
decltype(range.sort())* = 0)  // check expression validity
{
// optimized implementation
range.sort();
}
\end{lstlisting}

\noindent Note that, by exposing{\cprotect\footnote{The relative position of
\texttt{decltype(range.sort())} in the signature of
\texttt{sortRangeImpl} is not significant, as long as it is visible to
the compiler (as part of the function's \emph{logical interface})
during template substitution. This particular example (shown in the
main text) makes use of a function parameter that is defaulted to
\texttt{nullptr}. Alternatives involving a trailing return type or a
default template argument are also viable:

\begin{lstlisting}[language=C++, basicstyle={\ttfamily\footnotesize}]
template <typename Range>
auto sortRangeImpl(Range& range, int) -> decltype(range.sort(), void());
// The comma operator is used to force the return type to (ù{\codeincomments{void}}ù),
// regardless of the return type of (ù{\codeincomments{range.sort()}}ù).

template <typename Range, typename = decltype(std::declval<Range&>().sort()>
auto sortRangeImpl(Range& range, int);
// (ù{\codeincomments{std::declval}}ù) is used to generate a reference to (ù{\codeincomments{Range}}ù) that can
// be used in an unevaluated expression.
\end{lstlisting}
}} \texttt{decltype(range.sort())} as part of
\texttt{sortRangeImpl}'s declaration, the more specialized overload will
be discarded during template substitution if \texttt{range.sort()} is
not a valid expression for the deduced \texttt{Range}
type.{\cprotect\footnote{The technique of exposing a (possibly unused)
unevaluated expression (e.g., using \texttt{decltype}) in a function's
declaration for the purpose of expression-validity detection prior to
template instantiation is commonly known as \textbf{expression SFINAE}\glossary{expression SFINAE}
and is a restricted form of the more general (classical) SFINAE that acts exclusively on
expressions visible in a function's signature rather than on (obscure)
template-based type computations.}}

Putting it all together, we see that exactly two possible
outcomes exist for the original client-facing \texttt{sortRange} function
invoked with a range argument of type \texttt{R}:

\begin{itemize}
\item{If \texttt{R} does have a \texttt{sort} member function, the more specialized overload (of\linebreak[4] \texttt{sortRangeImpl}) will be viable (as \texttt{range.sort()} is a well-formed expression) and preferred because the \emph{disambiguator} \texttt{0} (of type \texttt{int}) requires no conversion.}
\item{Otherwise, the more specialized overload will be discarded during template substitution (as \texttt{range.sort()} is not a well-formed expression) and the only remaining (more general) \texttt{sortRangeImpl} overload will be chosen instead.}
\end{itemize}

\subsection[Potential pitfalls]{Potential pitfalls}\label{potential-pitfalls}

Perhaps surprisingly, \texttt{decltype(x)} and \texttt{decltype((x))}
will sometimes yield different results for the same expression
\texttt{x}:

\begin{lstlisting}[language=C++]
int i = 0; // (ù{\codeincomments{decltype(i)}}ù) yields (ù{\codeincomments{int}}ù).
// (ù{\codeincomments{decltype((i))}}ù) yields (ù{\codeincomments{int\&}}ù).
\end{lstlisting}

\noindent In the case where the unparenthesized operand is an entity having a
declared type \texttt{T} and the parenthesized operand is an expression
whose value category is represented (by \texttt{decltype}) as the same
type \texttt{T}, the results will coincidentally be the same:

\begin{lstlisting}[language=C++]
int& ref = i;  // (ù{\codeincomments{decltype(ref)}}ù) yields (ù{\codeincomments{int\&}}ù).
// (ù{\codeincomments{decltype((ref))}}ù) yields (ù{\codeincomments{int\&}}ù).
\end{lstlisting}

\noindent Wrapping its operand with parentheses ensures \texttt{decltype} yields
the \textbf{value category}\glossary{value category} of a given expression. This technique can be
useful in the context of metaprogramming --- particularly in the case of
\textbf{value category}\glossary{value category} propagation.

\subsection[Annoyances]{Annoyances}\label{annoyances}

None so far

\subsection[See Also]{See Also}\label{see-also}

None so far

\subsection[Further reading]{Further reading}\label{further-reading}

None so far



\newpage
\section[Deleted Functions]{Deleted Functions}\label{deleted-functions}


Use of \texttt{=}~\texttt{delete} in a function's (first) declaration
forces a compilation error upon any attempt to use or access it.

\subsection[Description]{Description}\label{description}

Declaring a particular function (or function overload) to result in a
fatal diagnostic upon invocation can be useful --- e.g., to suppress the
generation of a \emph{special function} or to limit the types of
arguments a particular function is able to accept. In such cases,
\texttt{=}~\texttt{delete;} can be used in place of the body of any
function (on first declaration only) to force a compile-time error if
any attempt is made to invoke it or take its address.

\begin{lstlisting}[language=C++]
void g(double) { }
void g(int) = delete;

void f()
{
g(3.14);  // OK, (ù{\codeincomments{f(double)}}ù) is invoked.
g(0);     // Error: (ù{\codeincomments{f(int)}}ù) is deleted.
}
\end{lstlisting}

\noindent Notice that deleted functions participate in \emph{overload resolution}
and produce a compile-time error when selected as the best candidate.

\subsection[Use Cases]{Use Cases}\label{use-cases}

\subsubsection[Suppressing special member function generation]{Suppressing special member function generation}\label{suppressing-special-member-function-generation}

When instantiating an object of user-defined type, \textbf{special
member functions}\glossary{special
member functions} that have not been declared explicitly are
often{\cprotect\footnote{The generation of individual special member
functions can be affected by the existence of other user-defined special
member functions or by limitations imposed by the specific types of
any data members or base types. For more information, see Section~\ref{Defaulted-Special-Member-Functions}, ``\titleref{Defaulted-Special-Member-Functions}."}} generated automatically by the compiler.
For certain kinds of types, the notion of \textbf{copy semantics}\glossary{copy semantics}
(including \textbf{move semantics}\glossary{move semantics}{\cprotect\footnote{The two
\textbf{special member functions}\glossary{special member functions} controlling \emph{move} operations
(introduced in C++11) are sometimes implemented as effective
optimizations of copy operations and (rarely) with copy operations
explicitly deleted; see Section~\ref{Rvalue-References}, ``\titleref{Rvalue-References}."}}) is not meaningful and
hence permitting the generation of copy operations is contraindicated.

Consider a class, \texttt{FileHandle}, that uses the \textbf{RAII}\glossary{RAII} idiom
to safely acquire and release an I/O stream. As \emph{copy semantics}
are typically not meaningful for such resources, we will want to
suppress generation of both the \emph{copy constructor} and \emph{copy
assignment operator}. Prior to C++11, there was no direct way to express
suppression of \emph{special functions} in C++. The commonly
recommended workaround was to declare the two methods \texttt{private}
and leave them unimplemented, typically resulting in a compile-time (or
link-time) error when accessed{\cprotect\footnote{Leaving unimplemented a special
member function that is declared to be private ensures
that there will be at least a link-time error in case that function is
inadvertently accessed from within the implementation of the class
itself.}}:

\begin{lstlisting}[language=C++]
class FileHandle
{
private:
// ...

FileHandle(const FileHandle&);             // not implemented
FileHandle& operator=(const FileHandle&);  // not implemented

public:
explicit FileHandle(FILE* filePtr);
~FileHandle();

// ...
};
\end{lstlisting}

\noindent With the \texttt{=}~\texttt{delete} syntax, we are able to (1)
explicitly express our intention to make these special member
functions unavailable, (2) do so directly in the \texttt{public} region
of the class, and (3) enable more precise compiler diagnostics:

\begin{lstlisting}[language=C++]
class FileHandle
{
private:
// ...

public:
explicit FileHandle(FILE* filePtr);
~FileHandle();

FileHandle(const FileHandle&) = delete;             // make unavailable
FileHandle& operator=(const FileHandle&) = delete;  // make unavailable

// ...
};
\end{lstlisting}


\subsubsection[Preventing a particular implicit conversion]{Preventing a particular implicit conversion}\label{preventing-a-particular-implicit-conversion}

Certain functions --- especially those that take a \texttt{char} as an
argument --- are prone to inadvertent misuse. As a truly classic
example, consider the C library function \texttt{memset}, which may be used
to write the character \texttt{*} five times in a row, starting at a
specified memory address, \texttt{buf}:

\begin{lstlisting}[language=C++]
#include <cstring>
#include <cstdio>

void f()
{
char buf[] = "Hello World!";
memset(buf, 5, '*');  // undefined behavior
puts(buf);            // expected output: "***** World!"
}
\end{lstlisting}

\noindent Sadly, inadvertently reversing the final two arguments is a commonly
recurring error, and the C language provides no help. In C++, we
can target such observed misuse using an extra deleted overload:

\begin{lstlisting}[language=C++]
#include <cstring>  // memset()
void* memset(void* str, int ch, size_t n);      // standard library function
void* memset(void* str, int n, char) = delete;  // defensive against misuse
\end{lstlisting}

\noindent Pernicious user errors can now be reported during compilation:

\begin{lstlisting}[language=C++]
// ...
memset(buf, 5, '*');  // Error: (ù{\codeincomments{memset(void\*, int, char)}}ù) is deleted.
// ...
\end{lstlisting}


\subsubsection[Preventing all implicit conversions]{Preventing all implicit conversions}\label{preventing-all-implicit-conversions}

The \texttt{ByteStream::send} member function below is designed to work
with 8-bit unsigned integers only. Providing a deleted overload
accepting an \texttt{int} forces a caller to ensure that the argument is
always of the appropriate type:

\begin{lstlisting}[language=C++]
class ByteStream
{
public:
void send(unsigned char byte) { /* ... */ }
void send(int) = delete;

// ...
};

void f()
{
ByteStream stream;
stream.send(0);   // Error: (ù{\codeincomments{send(int)}}ù) is deleted.     (1)
stream.send('a'); // Error: (ù{\codeincomments{send(int)}}ù) is deleted.     (2)
stream.send(0L);  // Error: ambiguous                 (3)
stream.send(0U);  // Error: ambiguous                 (4)
stream.send(0.0); // Error: ambiguous                 (5)
stream.send(
static_cast<unsigned char>(100));  // OK          (6)
}
\end{lstlisting}

\noindent Invoking \texttt{send} with an \texttt{int} (noted with (1) in the code above) or any integral type
(other than \texttt{unsigned}~\texttt{char}{\cprotect\footnote{Note that
implicitly converting from \texttt{unsigned}~\texttt{char} to either a
\texttt{long} or \texttt{unsigned} integer involves a \textbf{standard
conversion}\glossary{standard
conversion} (not just an \textbf{integral promotion}\glossary{integral promotion}), the same as
converting to a \texttt{double}.}}) that promotes to \texttt{int} (2)
will map exclusively to the deleted \texttt{send(int)} overload; all
other integral (3 \& 4) and floating-point types (5) are convertible to
both (via a \textbf{standard conversion}\glossary{standard conversion}) and hence will be ambiguous.
An explicit cast to \texttt{unsigned}~\texttt{char} (6) can always be
pressed into service if needed.

\subsubsection[Hiding a structural (nonpolymorphic) base class's member function]{Hiding a structural (nonpolymorphic) base class’s member function}\label{hiding-a-structural-(nonpolymorphic)-base-class's-member-function}

Best practices notwithstanding,{\cprotect\footnote{By publicly deriving
from a concrete class, we do not hide the underlying capabilities,
which can easily be accessed (perhaps accidentally) via assignment to
a pointer or reference to a base class (no casting required). What's
more, inadvertently passing such a class to a function taking the base
class by value will result in \emph{slicing}, which can be especially
problematic when the derived class holds data. Finally, if the derived
class purports to maintain \emph{class invariants} that the base class
does not preserve, this design technique is beyond dubious; a more
robust approach would be to use layering or at least private
inheritance. For more on improving compositional designs at scale, see
\textbf{{lakos20}}, sections 3.5.10.5 and 3.7.3, pp.~687--703 and
726--727, respectively.}} it can be cost-effective (in the short
term) to provide an elided ``view'' on a concrete class for (trusted)
clients. Imagine a class \texttt{AudioStream} designed to play sounds
and music that --- in addition to providing basic ``play'' and
``rewind'' operations --- sports a large, robust interface:

\begin{lstlisting}[language=C++]
struct AudioStream
{
void play();
void rewind();
// ...
// ... (large, robust interface)
// ...
};
\end{lstlisting}


Now suppose that, on short notice, we need to whip up a very similar
class,\linebreak[4] \texttt{ForwardAudioStream}, to use with audio samples that
cannot be rewound (e.g., coming directly from a live feed). Realizing
that we can readily reuse most of \texttt{AudioStream}'s interface, we
pragmatically decide to prototype the new class simply by exploiting
public \textbf{structural inheritance}\glossary{structural inheritance} and then deleting just the lone
unwanted \texttt{rewind} member function:

\begin{lstlisting}[language=C++]
struct ForwardAudioStream : AudioStream
{
void rewind() = delete; // make just this one function unavailable
};

void f()
{
ForwardAudioStream stream = FMRadio::getStream();
stream.play();   // fine
stream.rewind(); // Error: (ù{\codeincomments{rewind()}}ù) is deleted.
}
\end{lstlisting}

\noindent If the need for a \texttt{ForwardAudioStream} type persists, we can always
consider reimplementing it more carefully later.{\cprotect\footnote{\textbf{{lakos20}}, sections 3.5.10.5 and 3.7.3, pp.~687--703 and 726--727}}

\subsection[Potential Pitfalls]{Potential Pitfalls}\label{potential-pitfalls}

None so far

\subsection[Annoyances]{Annoyances}\label{annoyances}

None so far

\subsection[See Also]{See Also}\label{see-also}

\begin{itemize}
\item{Section~\ref{Defaulted-Special-Member-Functions}, ``\titleref{Defaulted-Special-Member-Functions}" — Companion safe C++11 feature that enables \emph{defaulting} (as opposed to \emph{deleting}) special member functions}
\item{Section~\ref{Rvalue-References}, ``\titleref{Rvalue-References}" — Conditionally safe C++11 feature that introduces the two \emph{move} variants to \emph{copy} special member functions}
\end{itemize}

\subsection[Further Reading]{Further Reading}\label{further-reading}

None so far



\newpage
\section[\tt{override}]{{\SecCode override}}\label{override}


The \texttt{override} keyword ensures that a member function overrides a corresponding \texttt{virtual} member function in a base class.

\subsection[Description]{Description}\label{description}

The \textbf{contextual keyword}\glossary{contextual keyword} \texttt{override} can be provided at the
end of a member-function declaration to ensure that the decorated
function is indeed \textbf{overriding}\glossary{overriding} a corresponding \texttt{virtual}
member function in a base class (i.e., not \textbf{hiding}\glossary{hiding} it or
otherwise inadvertently introducing a distinct function declaration):

\begin{lstlisting}[language=C++]
struct Base
{
virtual void f(int);
void g(int);
};

struct Derived : Base
{
void f();              // hides (ù{\codeincomments{Base::f(int)}}ù) (likely mistake)
void f() override;     // error: (ù{\codeincomments{Base::f()}}ù) not found

void f(int);           // implicitly overrides (ù{\codeincomments{Base::f(int)}}ù)
void f(int) override;  // explicitly overrides (ù{\codeincomments{Base::f(int)}}ù)

void g();              // hides (ù{\codeincomments{Base::g(int)}}ù) (likely mistake)
void g() override;     // error: (ù{\codeincomments{Base::g()}}ù) not found

void g(int);           // hides (ù{\codeincomments{Base::g(int)}}ù) (likely mistake)
void g(int) override;  // Error: (ù{\codeincomments{Base::g()}}ù) is not (ù{\codeincomments{virtual}}ù).
};
\end{lstlisting}

\noindent Use of this feature expresses design intent so that (1) human readers
are aware of it and (2) compilers can validate it.

\subsection[Use Cases]{Use Cases}\label{use-cases}

\subsubsection[Ensuring that a member function of a base class is being overridden]{Ensuring that a member function of a base class is being overridden}\label{ensuring-that-a-member-function-of-a-base-class-is-being-overridden}

Consider the following polymorphic hierarchy of error-category classes
(as we might have defined them using C++03):

\begin{lstlisting}[language=C++]
struct ErrorCategory
{
virtual bool equivalent(const ErrorCode& code, int condition);
virtual bool equivalent(int code, const ErrorCondition& condition);
};

struct AutomotiveErrorCategory : ErrorCategory
{
virtual bool equivalent(const ErrorCode& code, int condition);
virtual bool equivolent(int code, const ErrorCondition& condition);
};
\end{lstlisting}

\noindent Notice that there is a defect in the last line of the example above:
\texttt{equivalent} has been misspelled. Moreover, the compiler did not
catch that error. Clients calling \texttt{equivalent} on
\texttt{AutomotiveErrorCategory} will incorrectly invoke the base-class
function. If the function in the base class happens to be defined, the
code might compile and behave unexpectedly at runtime. Now, suppose
that over time the interface is changed by marking the
equivalence-checking function \texttt{const} to bring the interface
closer to that of \texttt{std::error\_category}:

\begin{lstlisting}[language=C++]
struct ErrorCategory
{
virtual bool equivalent(const ErrorCode& code, int condition) const;
virtual bool equivalent(int code, const ErrorCondition& condition) const;
};
\end{lstlisting}

Without applying the corresponding modification to all classes deriving
from\linebreak[4] \texttt{ErrorCategory}, the semantics of the program change due to
the derived classes now hiding (instead of overriding) the base class's
\texttt{virtual} member function. Both of the errors discussed above
would be detected automatically by decorating the \texttt{virtual}
functions in all derived classes with \texttt{override}:

\begin{lstlisting}[language=C++]
struct AutomotiveErrorCategory : ErrorCategory
{
bool equivalent(const ErrorCode& code, int condition) override;
// compile-time error when base class changed

bool equivolent(int code, const ErrorCondition& code) override;
// compile-time error when first written
};
\end{lstlisting}

\noindent What's more, \texttt{override} serves as a clear indication to the human
reader of the derived class's author's intent to customize the
behavior of \texttt{ErrorCategory}. For any given member function, use
of \texttt{override} necessarily renders any use of \texttt{virtual} for
that function syntactically and semantically redundant. The only
(cosmetic) reason for retaining \texttt{virtual} in the presence of
\texttt{override} would be that \texttt{virtual} appears to the left of
the function declaration (as it always has) instead of all the way to
the right (as \texttt{override} does now).

\subsection[Potential Pitfalls]{Potential Pitfalls}\label{potential-pitfalls}

\subsubsection[Lack of consistency across a code base]{Lack of consistency across a code base}\label{lack-of-consistency-across-a-codebase}

Relying on \texttt{override} as a means of ensuring that changes to
base-class interfaces are propagated across a codebase can prove
unreliable if this feature is used inconsistently --- i.e., statically
verified in every circumstance where its use would be appropriate. In
particular, altering the signature of a \texttt{virtual} member function
in a base class and then compiling ``the world'' will always flag (as an
error) any nonmatching derived-class function where \texttt{override}
was used but might fail (even to warn) where it is not.

\subsection[Annoyances]{Annoyances}\label{annoyances}

None so far

\subsection[See Also]{See Also}\label{see-also}

None so far

\subsection[Further Reading]{Further Reading}\label{further-reading}

None so far



\newpage
\section[Compile-Time Assertions ({\tt{static\_assert}})]{Compile-Time Assertions ({\SecCode static\_assert})}\label{compile-time-assertions-(static_assert)}


The \texttt{static\_assert} keyword allows programmers to intentionally terminate compilation whenever a given compile-time predicate
evaluates to \texttt{false}.

\subsection[Description]{Description}\label{description}

Assumptions are
inherent in every program, whether we explicitly document them or not. A common way of validating certain
assumptions at runtime is to use the classic \texttt{assert} macro found
in \texttt{<cassert>}. Such runtime assertions are not always ideal
because (1) the program must already be built and running for them to
even have a chance of being triggered and (2) executing a
\textbf{redundant check}\glossary{redundant check} at runtime typically{\cprotect\footnote{It is
not unheard of for a program having assertions to run faster with them
enabled than disabled --- e.g., when asserting that a pointer is not
null, thereby enabling the optimizer to elide all code branches that
can be reached only if that pointer were null.}} results in a slower
program. Being able to validate an assertion at compile time avoids
several drawbacks:

\begin{enumerate}
\item{Validation occurs at compile time within a single translation unit, and therefore doesn’t need to wait until a complete program is linked and executed.}
\item{Compile-time assertions can exist in many more places than runtime assertions and are unrelated to program control flow.}
\item{No runtime code will be generated due to a \texttt{static\_assert}, so program performance will not be impacted.}
\end{enumerate}

\subsubsection[Syntax and semantics]{Syntax and semantics}\label{syntax-and-semantics}

We can use \emph{static assertion declarations} to conditionally trigger
controlled compilation failures depending on the truthiness of a
\textbf{constant expression}\glossary{constant expression}. Such declarations are introduced by the
\texttt{static\_assert} keyword, followed by a parenthesized list
consisting of (1) a constant Boolean expression and (2) a mandatory (see
{\it\titleref{static-annoyances}: \titleref{mandatory-string-literal}} on page~\pageref{mandatory-string-literal}) \textbf{string literal}\glossary{string literal}, which will be
part of the compiler diagnostics if the compiler determines that the
assertion fails to hold:

\begin{lstlisting}[language=C++]
static_assert(true, "Never fires.");
static_assert(false, "Always fires.");
\end{lstlisting}

\noindent Static assertions can be placed anywhere in the scope of a namespace,
block, or class:

\begin{lstlisting}[language=C++]
static_assert(1 + 1 == 2, "Never fires.");  // (global) namespace scope

template <typename T>
struct S
{
void f0()
{
static_assert(1 + 1 == 3, "Always fires.");  // block scope
}

static_assert(!Predicate<T>::value, "Might fire.");  // class scope
};
\end{lstlisting}

\noindent Providing a non-constant expression to a \texttt{static\_assert} is
itself a compile-time error:

\begin{lstlisting}[language=C++]
extern bool x;
static_assert(x, "Nice try.");  // Error: (ù{\codeincomments{x}}ù) is not a compile-time constant.
\end{lstlisting}


\subsubsection[Evaluation of static assertions in templates]{Evaluation of static assertions in templates}\label{evaluation-of-static-assertions-in-templates}

The C++ Standard does not explicitly specify at precisely what point (during
the compilation process) static assertion declarations are
evaluated.{\cprotect\footnote{By ``evaluated'' here, we mean that the
asserted expression is processed and its semantic truth\linebreak[4] determined.}}
In particular, when used within the body of a template, a
\texttt{static\_assert} declaration might not be evaluated until
\textbf{template instantiation time}\glossary{template instantiation time}. In practice, however, a
\texttt{static\_assert} that does not depend on any template parameters
is essentially always{\cprotect\footnote{E.g.,
GCC~10.1, Clang~10.0, and MSVC~19.24}} evaluated immediately --- i.e., as
soon as it is parsed and irrespective of whether any subsequent template
instantiations occur:

\begin{lstlisting}[language=C++]
void f1()
{
static_assert(false, "Impossible!");  // always evaluated immediately...
}                                         // even if (ù{\codeincomments{f1()}}ù) is never invoked

template <typename T>
void f2()
{
static_assert(false, "Impossible!");  // always evaluated immediately...
}                                         // even if (ù{\codeincomments{f2()}}ù) is never instantiated
\end{lstlisting}

\noindent The evaluation of a static assertion that is (1) located within the
body of a class or function template and (2) depends on at least one
template parameter is almost always bypassed during its initial parse since
the value --- true or false --- of the assertion will (in general) depend on the nature
of the template argument:

\begin{lstlisting}[language=C++]
template <typename T>
void f3()
{
static_assert(sizeof(T) >= 8, "Size < 8.");  // depends on (ù{\codeincomments{T}}ù)
}
\end{lstlisting}

\noindent (However, see {\it\titleref{static-potential-pitfalls}: \titleref{static-assertions-in-templates-can-trigger-unintended-compilation-failures}} on page~\pageref{static-potential-pitfalls}.) In the example above, the compiler has no choice but to wait until each
time \texttt{f3} is instantiated because the truth of the predicate will
vary depending on the type provided:

\begin{lstlisting}[language=C++]
void g()
{
f3<double>();               // OK
f3<long double>();          // OK
f3<std::complex<float>>();  // OK
f3<char>();                 // Error: static assertion failed: Size < 8.
}
\end{lstlisting}

\noindent The standard does, however, specify that a program containing any
template definition for which no valid specialization exists is
\textbf{ill formed}\glossary{ill formed} (no diagnostic required), which was the case for
\texttt{f2} but not \texttt{f3}, above. Contrast each of the
\texttt{h*n*} definitions (below) with its correspondingly numbered
\texttt{f*n*} definition (above):

\begin{lstlisting}[language=C++]
void h1()
{
int a[!sizeof(int) - 1];  // same as (ù{\codeincomments{int a[-1];}}ù) and is ill formed
}

template <typename T>
void h2()
{
int a[!sizeof(int) - 1];  // always reported as a compile-time error
}

template <typename T>
void h3()
{
int a[!sizeof(T) - 1];    // typically reported only if instantiated
}
\end{lstlisting}

\noindent Both \texttt{f1} and \texttt{h1} are ill-formed, non-template functions,
and both will always be reported at compile time, albeit typically with
decidedly different error messages as demonstrated by GCC 10.x's output:

\begin{lstlisting}[language=C++]
f1: error: static assertion failed: Impossible!
h1: error: size (ù{\codeincomments{-1}}ù) of array (ù{\codeincomments{a}}ù) is negative
\end{lstlisting}

\noindent Both \texttt{f2} and \texttt{h2} are ill-formed template functions; the cause of their being ill formed has nothing to do with the
template type and hence will always be reported as a compile-time error
in practice. Finally, \texttt{f3} can be only contextually ill formed
whereas \texttt{h3} is always necessarily ill formed, and yet neither is
reported by typical compilers as such unless and until it has been
instantiated. Reliance on a compiler not to notice that a program is
ill formed is dubious; see {\it\titleref{static-potential-pitfalls}: \titleref{static-assertions-in-templates-can-trigger-unintended-compilation-failures}} on page~\pageref{static-assertions-in-templates-can-trigger-unintended-compilation-failures}.

\subsection[Use Cases]{Use Cases}\label{use-cases}

\subsubsection[Verifying assumptions about the target platform]{Verifying assumptions about the target platform}\label{verifying-assumptions-about-the-target-platform}

Some programs rely on specific properties of the native types provided
by their target platform. Static assertions can help ensure portability
and prevent such programs from being compiled (into a malfunctioning
binary) on, say, an unsupported platform. As an example, consider a
program that relies on the size of an \texttt{int} to be exactly 32
bits (e.g., due to the use of inline \texttt{asm} blocks). Placing a
\texttt{static\_assert} in namespace scope in any of the program's
translation units will (1) ensure that the assumption regarding the size
of \texttt{int} is valid and (2) serve as documentation for readers:

\begin{lstlisting}[language=C++]
#include <ctype>  // (ù{\codeincomments{CHAR\_BIT}}ù)

static_assert(sizeof(int) * CHAR_BIT == 32,
"An (ù{\codeincomments{int}}ù) must have exactly 32 bits for this program to work correctly.");
\end{lstlisting}

\noindent More typically, statically asserting the \emph{size} of an \texttt{int}
avoids having to write code to handle an \texttt{int} type's having
greater or fewer bytes when no such platforms are likely ever to
materialize:

\begin{lstlisting}[language=C++]
static_assert(sizeof(int) == 4, "An (ù{\codeincomments{int}}ù) must have exactly 4 bytes.");
\end{lstlisting}


\subsubsection[Preventing misuse of class and function templates]{Preventing misuse of class and function templates}\label{preventing-misuse-of-class-and-function-templates}

Static assertions are often used in practice to constrain class or
function templates to prevent their being instantiated with unsupported
types by either (1) substantially improving compile-time
diagnostics{\cprotect\footnote{Syntactically incompatible types often
lead to absurdly long and notoriously hard-to-read diagnostic messages, especially when deeply nested template expressions are involved.}} or, more critically, (2) actively avoiding
erroneous runtime behavior.
%%%  VR WANTS TO COME BACK TO THIS FOOTNOTE AND ADD A SEE ALSO.

As an example, consider the \texttt{SmallObjectBuffer<N>} class
templates, which provide storage for arbitrary objects whose size does
not exceed \texttt{N}{\cprotect\footnote{A \texttt{SmallObjectBuffer} is
similar to C++17's \texttt{std::any} (\textbf{{cppref\_stdany}}) in
that it can store any object of any type. Instead of performing
dynamic allocation to support arbitrarily sized objects, however,
\texttt{SmallObjectBuffer} uses an internal fixed-size buffer, which
can lead to better performance and cache locality provided (the
maximum size of) all of the types involved is known.}}:

\begin{lstlisting}[language=C++]
template <std::size_t N>
class SmallObjectBuffer
{
private:
char d_buffer[N];

public:
template <typename T>
void set(const T& object);

// ...
};
\end{lstlisting}

\noindent To prevent buffer overruns, it is important that \texttt{set} accepts
only those objects that will fit in \texttt{d\_buffer}. The use of a
static assertion in the \texttt{set} member function template catches
--- at compile time --- any such misuse:

\begin{lstlisting}[language=C++]
template <std::size_t N>
template <typename T>
void SmallObjectBuffer<N>::set(const T& object)
{
static_assert(sizeof(T) <= N, "(ù{\codeincomments{object}}ù) does not fit in the small buffer.");
new (&d_buffer) T(object);
}
\end{lstlisting}


The principle of constraining inputs can be applied to most class and
function templates. \texttt{static\_assert} is particularly useful in
conjunction with standard \textbf{type traits}\glossary{type traits} provided in
\texttt{<type\_traits>}. In the \texttt{rotateLeft} function template
(below), we have used two static assertions to ensure that only unsigned
integral types will be accepted:

\begin{lstlisting}[language=C++]
#include <ctype>  // (ù{\codeincomments{CHAR\_BIT}}ù)

template <typename T>
T rotateLeft(T x)
{
static_assert(std::is_integral<T>::value, "(ù{\codeincomments{T}}ù) must be an integral type.");
static_assert(std::is_unsigned<T>::value, "(ù{\codeincomments{T}}ù) must be an unsigned type.");

return (x << 1) | (x >> (sizeof(T) * CHAR_BIT - 1));
}
\end{lstlisting}


\subsection[Potential Pitfalls]{Potential Pitfalls}\label{static-potential-pitfalls}

\subsubsection[Static assertions in templates can trigger unintended compilation failures]{Static assertions in templates can trigger unintended compilation failures}\label{static-assertions-in-templates-can-trigger-unintended-compilation-failures}

As mentioned in the description, any program containing a template for
which no valid specialization can be generated is (by definition)
\textbf{ill formed}\glossary{ill formed} (no diagnostic required). Attempting to prevent the
use of, say, a particular function template overload by using a static
assertion that never holds produces such a program:

\begin{lstlisting}[language=C++]
template <bool>
struct SerializableTag { };

template <typename T>
void serialize(char* buffer, const T& object, SerializableTag<true>);  // (1)

template <typename T>
void serialize(char* buffer, const T& object, SerializableTag<false>)  // (2)
{
static_assert(false, "T must be serializable.");  // independent of (ù{\codeincomments{T}}ù)
// too obviously ill formed: always a compile-time error
}
\end{lstlisting}

\noindent In the example above, the second overload (2) of \texttt{serialize} is
provided with the intent of eliciting a meaningful compile-time error
message in the event that an attempt is made to serialize a
nonserializable type. The program, however, is technically
\emph{ill-formed} and, in this simple case, will likely result in a
compilation failure --- irrespective of whether either overload of
\texttt{serialize} is ever instantiated.

A commonly attempted workaround
is to make the predicate of the assertion somehow dependent on a
template parameter, ostensibly forcing the compiler to withhold
evaluation of the \texttt{static\_assert} unless and until the template
is actually instantiated (a.k.a. \textbf{instantiation time}\glossary{instantiation time}):

\begin{lstlisting}[language=C++]
template <typename>  // N.B., we make no use of the (nameless) type parameter:
struct AlwaysFalse   // This class exists only to "outwit" the compiler.
{
enum { value = false };
};

template <typename T>
void serialize(char* buffer, const T& object, SerializableTag<false>)  // (2)
{
static_assert(AlwaysFalse<T>::value, "T must be serializable.");  // OK
// less obviously ill formed: compile-time error when instantiated
}
\end{lstlisting}

\noindent To implement this version of the second overload, we have provided an
intermediary class template \texttt{AlwaysFalse} that, when instantiated
on any type, contains an enumerator named \texttt{value}, whose value is
\texttt{false}. Although this second implementation is more likely to
produce the desired result (i.e., a controlled compilation failure
only when \texttt{serialize} is invoked with unsuitable arguments),
sufficiently ``smart'' compilers looking at just the current translation
unit would still be able to know that no valid instantiation of
\texttt{serialize} exists and would therefore be well within their
rights to refuse to compile this still technically \emph{ill-formed}
program.

Equivalent workarounds achieving the same result without a
helper class are possible.

\begin{lstlisting}[language=C++]
template <typename T>
void serialize(char* buffer, const T& object, SerializableTag<false>)  // (2)
{
static_assert(0 == sizeof(T), "T must be serializable.");  // OK
// not too obviously ill formed: compile-time error when instantiated
}
\end{lstlisting}

\noindent Know that use of this sort of obfuscation is not guaranteed to be either
portable or future-proof: \emph{caveat emptor}.

\subsubsection[Misuse of static assertions to restrict overload sets]{Misuse of static assertions to restrict overload sets}\label{misuse-of-static-assertions-to-restrict-overload-sets}

Even if we are careful to \emph{fool} the compiler into thinking that a
specialization is wrong \emph{only} if instantiated, we still cannot use
this approach to remove a candidate from an overload set because translation
will terminate if the static assertion is triggered. Consider this
(flawed) attempt at writing a \texttt{process} function that will behave
differently depending on the size of the given argument:

\begin{lstlisting}[language=C++]
template <typename T>
void process(const T& x)  // (1) first definition of (ù{\codeincomments{process}}ù) function
{
static_assert(sizeof(T) <= 32, "Overload for small types");  // BAD IDEA
// ... (process small types)
}

template <typename T>
void process(const T& x)  // (2) compile-time error: redefinition of function
{
static_assert(sizeof(T) > 32, "Overload for big types");     // BAD IDEA
// ... (process big types)
}
\end{lstlisting}

\noindent While the intention of the developer might have been to statically
dispatch to one of the two mutually exclusive overloads, the ill-fated
implementation above will not compile because the signatures of the two
overloads are identical, leading to a redefinition error. The semantics
of \texttt{static\_assert} are not suitable for the purposes of
\textbf{compile-time dispatch}\glossary{compile-time dispatch}.

To achieve the goal of removing (up
front) a specialization from consideration, we will need to employ
\textbf{SFINAE}\glossary{SFINAE}. To do that, we must instead find a way to get the
failing compile-time expression to be part of the function's
\textbf{declaration}\glossary{declaration}{\cprotect\footnote{\textbf{Concepts}\glossary{Concepts} --- a
language feature introduced in C++20 --- provides a far less baroque
alternative to SFINAE that allows for overload sets to be governed by
the syntactic properties of their (compile-time) template arguments.}}:

\begin{lstlisting}[language=C++]
template <bool> struct Check { };
// helper class template having a (non-type) boolean template parameter
// representing a compile-time predicate

template <> struct Check<true> { typedef int Ok; };
// specialization of (ù{\codeincomments{Check}}ù) that makes the type (ù{\codeincomments{Ok}}ù) manifest *only* if
// the supplied predicate (boolean template argument) evaluates to (ù{\codeincomments{true}}ù)

template <typename T,
typename Check<(sizeof(T) <= 32)>::Ok = 0>  // SFINAE
void process(const T& x)  // (1)
{
// ... (process small types)
}

template <typename T,
typename Check<(sizeof(T) > 32)>::Ok = 0>  // SFINAE
void process(const T& x)  // (2)
{
// ... (process big types)
}
\end{lstlisting}

\noindent The (empty) \texttt{Check} helper class template in conjunction with
just one of its two possible specializations (above) conditionally
exposes the \texttt{Ok} type alias \emph{only} if the provided boolean
template parameter evaluates to \texttt{true}. (Otherwise, by default, it
does not.)

During the substitution phase of template instantiation,
exactly one of the two overloads of the \texttt{process} function will
attempt to access a nonexisting \texttt{Ok} type alias via the
\texttt{Check<false>} instantiation, which again, by default, is
nonexistent. Although such an error would typically result in a
compilation failure, in the context of template argument substitution it
will instead result in only the offending overload's being discarded,
giving other (valid) overloads a chance to be selected:

\begin{lstlisting}[language=C++]
void client()
{
process(SmallType());  // discards (2), selects (1)
process(BigType());    // discards (1), selects (2)
}
\end{lstlisting}

\noindent This general technique of pairing template specializations is used widely
in modern C++ programming. For another, often more convenient way of
constraining overloads using \textbf{expression SFINAE}\glossary{expression SFINAE}, see Section~\ref{trailing-function-return-types}, ``\titleref{trailing-function-return-types}."

\subsection[Annoyances]{Annoyances}\label{static-annoyances}

\subsubsection[Mandatory string literal]{Mandatory string literal}\label{mandatory-string-literal}

Many compilation failures caused by static assertions are
self-explanatory since the offending line (which necessarily contains the
predicate code) is displayed as part of the compiler diagnostic. In
those situations, the message required{\cprotect\footnote{As of C++17,
the message argument of a static assertion is optional.}} as part of
\texttt{static\_assert}'s grammar is redundant:

\begin{lstlisting}[language=C++]
static_assert(std::is_integral<T>::value, "(ù{\codeincomments{T}}ù) must be an integral type.");
\end{lstlisting}

\noindent Developers commonly provide an empty string literal in these
cases:

\begin{lstlisting}[language=C++]
static_assert(std::is_integral<T>::value, "");
\end{lstlisting}


\subsection[See Also]{See Also}\label{see-also}

\begin{itemize}
\item{Section~\ref{trailing-function-return-types}, ``\titleref{trailing-function-return-types}" — Safe C++11 feature that allows fine-grained control over overload resolution by enabling \textbf{expression SFINAE}\glossary{expression SFINAE} as part of a function’s \textbf{declaration}\glossary{declaration}}
\end{itemize}

\subsection[Further reading]{Further reading}\label{further-reading}

None so far



\newpage
\section[Trailing Function Return Types]{Trailing Function Return Types}\label{trailing-function-return-types}


Trailing return types provide a new alternate syntax in which the return type of a function is specified at
the end of a function declaration (as opposed to at the beginning),
thereby allowing it to reference function parameters by name and to reference class
or namespace members without explicit qualification.

\subsection[Description]{Description}\label{description}

C++ offers an alternative function-declaration syntax in which the
return type of a function is located to the right of its
\textbf{signature}\glossary{signature} (name, parameters, and qualifiers), offset by the
arrow token (\texttt{->}); the function itself is introduced by the
keyword {\texttt{auto}}, which acts as a type placeholder\cprotect\footnote{Note that, when using the alternative trailing return syntax for a function (e.g., one returning a \texttt{double}), the override keyword would be inserted after call qualifiers and before the arrow:

\begin{lstlisting}[language=C++,basicstyle=\ttfamily\footnotesize]
virtual f(int value) const override -> double;
\end{lstlisting}\vspace*{-1ex}}:

\begin{lstlisting}[language=C++]
auto f() -> void;  // equivalent to (ù{\codeincomments{void f();}}ù)
\end{lstlisting}

\noindent Using a trailing return type allows the parameters of a function to be
named as part of the specification of the return type, which can be
useful in conjunction with {\texttt{decltype}}:

\begin{lstlisting}[language=C++]
auto g(int x) -> decltype(x);  // equivalent to (ù{\codeincomments{int g(int x);}}ù)
\end{lstlisting}

\noindent When using the trailing-return-type syntax in a member function
definition outside the class definition, names appearing in the return
type, unlike with the classic notation, will be looked up in class scope
by default:

\begin{lstlisting}[language=C++]
struct S
{
typedef int T;
auto h1() -> T;  // trailing syntax for member function
T h2();          // classical syntax for member function
};

auto S::h1() -> T { /*...*/ }  // equivalent to (ù{\codeincomments{S::T S::h1() \{ /\*...\*/ \}}}ù)
T    S::h2()      { /*...*/ }  // Error: (ù{\codeincomments{T}}ù) is unknown in this context.
\end{lstlisting}

\noindent The same advantage would apply to a nonmember
function{\cprotect\footnote{A \texttt{static} member function of a
\texttt{struct} can be a viable alternative implementation to a free
function declared within a namespace; see \textbf{lakos20}, section~1.4,
pp.~190--201, especially Figure~1-37c (p.~199), and section~2.4.9, pp.~312--321, especially Figure~2-23 (p.~316).}} defined outside of the namespace in
which it is declared:

\begin{lstlisting}[language=C++]
namespace N
{
typedef int T;
auto h3() -> T;  // trailing syntax for free function
T h4();          // classical syntax for free function
};

auto N::h3() -> T { /*...*/ }  // equivalent to (ù{\codeincomments{N::T N::h3() \{ /\*...\*/ \}}}ù)
T    N::h4()      { /*...*/ }  // Error: (ù{\codeincomments{T}}ù) is unknown in this context.
\end{lstlisting}


Finally, since the syntactic element to be provided after the arrow
token is a separate type unto itself, return types involving pointers to
functions are (somewhat) simplified. Suppose, for example, we want to
describe a \textbf{higher-order function}\glossary{higher-order function}, \texttt{f}, that takes as its
argument a \texttt{long}~\texttt{long} and returns a pointer to a
function that takes an \texttt{int} and returns a
\texttt{double}{\cprotect\footnote{Co-author John Lakos first used the shown verbose declaration notation
while teaching Advanced Design and Programming using C++ at Columbia
University (1991-1997).}}:

\begin{lstlisting}[language=C++]
// [function(long long) returning]
//     [pointer to] [function(int x) returning] double   f;
//     [pointer to] [function(int x) returning] double   f(long long);
//                  [function(int x) returning] double  *f(long long);
//                                              double (*f(long long))(int x);
\end{lstlisting}

\noindent Using the alternate trailing syntax, we can conveniently break the
declaration of \texttt{f} into two parts: (1) the declaration of the
function's signature, \texttt{auto}~\texttt{f(long}~\texttt{long)}, and (2) that of the return type, say, \texttt{R} for now:

\begin{lstlisting}[language=C++]
// [pointer to] [function (int) returning] double   R;
//              [function (int) returning] double  *R;
//                                         double (*R)(int);
\end{lstlisting}

\noindent The two equivalent forms of the same declaration are shown below:

\begin{lstlisting}[language=C++]
double (*f(long long))(int x);         // classic return-type syntax
auto f(long long) -> double (*)(int);  // trailing return-type syntax
\end{lstlisting}

\noindent Note that both syntactic forms of the same declaration may appear
together within the same scope. Note also that not all functions that
can be represented in terms of the trailing syntax have a convenient
equivalent representation in the classic one:

\begin{lstlisting}[language=C++]
template <typename A, typename B>
auto foo(A a, B b) -> decltype(a.foo(b));
// trailing return-type syntax

template <typename A, typename B>
decltype(std::declval<A&>().foo(std::declval<B&>())) foo(A a, B b);
// classic return-type syntax (using C++11's (ù{\codeincomments{std::declval}}ù))
\end{lstlisting}

\noindent In the example above, we were essentially forced to use the (C++11)
standard library template \texttt{std::declval}
(\textbf{{cppref\_declval}}) to express our intent with the classic
return-type syntax.

\subsection[Use Cases]{Use Cases}\label{use-cases}

\subsubsection[Function template whose return type depends on a parameter type]{Function template whose return type depends on a parameter type}\label{function-template-whose-return-type-depends-on-a-parameter-type}

Declaring a function template whose return type depends on the types of
one or more of its parameters is not uncommon in generic programming.
For example, consider a mathematical function that linearly interpolates
between two values of (possibly) different type:

\begin{lstlisting}[language=C++]
template <typename A, typename B, typename F>
auto linearInterpolation(const A& a, const B& b, const F& factor)
-> decltype(a + factor * (b - a))
{
return a + factor * (b - a);
}
\end{lstlisting}

\noindent The return type of \texttt{linearInterpolation} is the type of
expression inside the \emph{\texttt{decltype} specifier}, which is
identical to the expression returned in the body of the function. Hence,
this interface necessarily supports any set of input types for which
\texttt{a}~\texttt{+}~\texttt{factor}~\texttt{*}~\texttt{(b}~\texttt{-}~\texttt{a)}
is valid, including types such as mathematical vectors, matrices, or
expression templates. As an added benefit, the presence of the
expression in the function's declaration enables \textbf{expression
SFINAE}\glossary{expression
SFINAE}, which is typically desirable for generic template functions
(see Section~\ref{decltype}, ``\titleref{decltype}").

\subsubsection[Avoiding having to qualify names redundantly in return types]{Avoiding having to qualify names redundantly in return types}\label{avoiding-having-to-qualify-names-redundantly-in-return-types}

When defining a function outside the \texttt{class}, \texttt{struct}, or
\texttt{namespace} in which it is first declared, any unqualified names
present in the return type might be looked up differently depending on
the particular choice of function-declaration syntax used. When the
return type precedes the qualified name of the function definition (as
is the case with classic syntax), all references to types declared in
the same scope where the function itself is declared must also be
(redundantly) qualified. By contrast, when the return type follows the
qualified name of the function (as is the case when using the
trailing-return-type syntax), the return type (just like any parameter
types) is --- by default --- looked up in the same scope in which the
function was first declared. Avoiding such redundancy can be beneficial, especially when the (redundant) qualifying name is not short.

As an illustration, consider a class (representing an abstract syntax
tree node) that exposes a type alias:

\begin{lstlisting}[language=C++]
struct NumericalASTNode
{
using ElementType = double;
auto getElement() -> ElementType;
};
\end{lstlisting}

\noindent Defining the \texttt{getElement} member function using traditional
function-declaration syntax would require repetition of the
\texttt{NumericalASTNode} name:

\begin{lstlisting}[language=C++]
NumericalASTNode::ElementType NumericalASTNode::getElement() { /*...*/ }
\end{lstlisting}

\noindent Using the trailing-return-type syntax handily avoids the repetition:

\begin{lstlisting}[language=C++]
auto NumericalASTNode::getElement() -> ElementType { /*...*/ }
\end{lstlisting}

\noindent By ensuring that name lookup within the return type is the same as for
the parameter types, we avoid needlessly having to qualify names that
should be found correctly by default.

\subsubsection[Improving readability of declarations involving function pointers]{Improving readability of declarations involving function pointers}\label{improving-readability-of-declarations-involving-function-pointers}

Declarations of functions returning a pointer to either (1) a function, (2) a member function, or (3) a data member are notoriously hard to parse --- even for seasoned programmers. As an example, consider a function called
\texttt{getOperation} that takes, as its argument, a \texttt{kind} of
(enumerated) \texttt{Operation} and returns a pointer to a member
function of \texttt{Calculator} that takes a \texttt{double} and
returns a \texttt{double}:

\begin{lstlisting}[language=C++]
double (Calculator::*getOperation(Operation kind))(double);
\end{lstlisting}

\noindent As we saw in the description, such declarations can be constructed
systematically but do not exactly roll off the fingers. On the other
hand, by partitioning the problem into (1) the declaration of the
function itself and (2) the type it returns, each individual problem
becomes far simpler than the original:

\begin{lstlisting}[language=C++]
auto getOperation(Operation kind)  // (1) function taking a kind of (ù{\codeincomments{Operation}}ù)
-> double (Calculator::*)(double);
// (2) returning a pointer to a (ù{\codeincomments{Calculator}}ù) member function taking a
//     (ù{\codeincomments{double}}ù) and returning a (ù{\codeincomments{double}}ù)
\end{lstlisting}

\noindent Using this divide-and-conquer approach, writing a \textbf{higher-order function}\glossary{higher-order function} that returns a
pointer to a function, member function, or data member as its return
type{\cprotect\footnote{Declaring a \textbf{higher-order function}\glossary{higher-order function} that
takes a function pointer as an argument might be even easier to read
if a type alias is used (e.g., via \texttt{typedef}\glossary{typedef} or, as of C++11,
\texttt{using}).}} becomes fairly straightforward.

\subsection[Potential Pitfalls]{Potential Pitfalls}\label{potential-pitfalls}

None so far

\subsection[Annoyances]{Annoyances}\label{annoyances}

None so far

\subsection[See Also]{See Also}\label{see-also}

\begin{itemize}
\item{Section~\ref{decltype}, ``\titleref{decltype}" — Safe C++11 type inference feature that is often used in conjunction with (or in place of) trailing return types}
\item{Section~\ref{Function-Return-Type-Deduction}, ``\titleref{Function-Return-Type-Deduction}" — Unsafe C++14 type inference feature that shares syntactical similarities with trailing return types, leading to potential pitfalls when migrating from C++11 to C++14}
\end{itemize}

\subsection[Further Reading]{Further Reading}\label{further-reading}

None so far



\newpage
\section[Unrestricted Unions]{Unrestricted Unions}\label{unrestricted-unions}


Any nonreference type is permitted to be a member of a \texttt{union}.

\subsection[Description]{Description}\label{unrestrictedunion-description}

Prior to C++11, only \textbf{trivial types}\glossary{trivial types} --- e.g.,
\textbf{fundamental types}, such as \texttt{int} and \texttt{double},
enumerated or pointer types, or a C-style array or \texttt{struct}
(a.k.a. a \textbf{POD}\glossary{POD}) --- were allowed to be members of a
\texttt{union}. This limitation prevented any (user-defined) type having
a \textbf{non-trivial special member function}\glossary{non-trivial special member function} from being a member of a
\texttt{union}:

\begin{lstlisting}[language=C++]
union U0
{
int         d_i;  // OK
std::string d_s;  // compile-time error in C++03 (OK as of C++11)
};
\end{lstlisting}

\noindent C++11 relaxes such restrictions on \texttt{union} members, such as
\texttt{d\_s} above, allowing any type other than a \textbf{reference
type}\glossary{reference
type} to be a member of a \texttt{union}.

A \texttt{union} type is permitted to have user-defined special member
functions but --- by design --- does not initialize any of its members
automatically. Any member of a \texttt{union} having a
\textbf{non-trivial constructor}\glossary{non-trivial constructor}, such as \texttt{struct}~\texttt{Nt}
(below), must be constructed manually (e.g., via \textbf{placement
\texttt{new}}\glossary{placement
\texttt{new}} implemented within the body of a constructor of the union
itself) before it can be used:

\begin{lstlisting}[language=C++]
struct Nt  // used as part of a (ù{\codeincomments{union}}ù) (below)
{
Nt();   // non-trivial default constructor
~Nt();  // non-trivial destructor

// Copy construction and assignment are implicitly defaulted.
// Move construction and assignment are implicitly deleted.
};
\end{lstlisting}

\noindent As an added safety measure, any non-trivial \textbf{special member
function}\glossary{special member
function} defined --- either implicitly or explicitly --- for any
\emph{member} of a \texttt{union} results in the compiler implicitly
deleting (see Section~\ref{deleted-functions}, ``\titleref{deleted-functions}") the corresponding \textbf{special
member function}\glossary{special
member function} of the \texttt{union} itself:

\begin{lstlisting}[language=C++]
union U1
{
int d_i;   // fundamental type having all trivial special member functions
Nt  d_nt;  // user-defined type having non-trivial special member functions

// Implicitly deleted special member functions of (ù{\codeincomments{U1}}ù):
/*
U1()                     = delete; // due to explicit (ù{\codeincomments{Nt::Nt()}}ù)
U1(const U1&)            = delete; // due to implicit (ù{\codeincomments{Nt::Nt(const Nt\&)}}ù)
~U1()                    = delete; // due to explicit (ù{\codeincomments{Nt::}}ù)~(ù{\codeincomments{Nt()}}ù)
U1& operator=(const U1&) = delete; // due to implicit
// (ù{\codeincomments{Nt::operator=(const Nt\&)}}ù)
*/
};
\end{lstlisting}

\noindent This same sort of precautionary deletion also occurs for any class
containing such a union as a data member (see {\it\titleref{unrestrictedunion-use-cases}: \titleref{implementing-a-sum-type-as-a-discriminating-(or-tagged)-union}} on page~\pageref{implementing-a-sum-type-as-a-discriminating-(or-tagged)-union}).

A special member function of a \texttt{union} that is implicitly deleted
can be restored via explicit declaration, thereby forcing a programmer
to think about how non-trivial members should be managed. For example,
we can start providing a \emph{value constructor} and corresponding
\emph{destructor}:

\begin{lstlisting}[language=C++]
struct U2
{
union
{
int  d_i;   // fundamental type (trivial)
Nt   d_nt;  // non-trivial user-defined type
};

bool d_useInt;  // discriminator

U2(bool useInt) : d_useInt(useInt)       // value constructor
{
if (d_useInt) { new (&d_i) int(); }  // value initialized (to (ù{\codeincomments{0}}ù))
else          { new (&d_nt) Nt(); }  // default constructed in place
}

~U2()  // destructor
{
if (!d_useInt) { d_nt.~Nt(); }
}
};
\end{lstlisting}

\noindent Notice that we have employed \textbf{placement \texttt{new}}\glossary{placement \texttt{new}} syntax to
control the lifetime of both member objects. Although assignment would
be permitted for the (trivial) \texttt{int} type, it would be
\textbf{undefined behavior}\glossary{undefined behavior} for the (non-trivial) \texttt{Nt} type:

\begin{lstlisting}[language=C++]
U2(bool useInt) : d_useInt(useInt)  // value constructor
{
if (d_useInt) { d_i = int(); }  // value initialized (to (ù{\codeincomments{0}}ù))
else          { d_nt = Nt(); }  // undefined behavior
}
\end{lstlisting}

\noindent Now if we were to try to copy-construct or assign an object of type
\texttt{U2} to another, the operation would fail because we have not
(yet) specifically addressed those \textbf{special member functions}\glossary{special member functions}:

\begin{lstlisting}[language=C++]
void f()
{
U2 a(false), b(true);  // OK (construct both instances of (ù{\codeincomments{U2}}ù))
U2 c(a);               // compile-time error: no (ù{\codeincomments{U2(const U2\&)}}ù)
a = b;                 // compile-time error: no (ù{\codeincomments{U2\& operator=(const U2\&)}}ù)
}
\end{lstlisting}

\noindent We can restore these implicitly deleted special member functions too,
simply by adding appropriate copy-constructor and assignment-operator
definitions for \texttt{U2} explicitly{\cprotect\footnote{Attempting to
restore a \texttt{union}'s implicitly deleted special member
functions by using the \texttt{=}~\texttt{default} syntax (see
Section~\ref{Defaulted-Special-Member-Functions}, ``\titleref{Defaulted-Special-Member-Functions}") will still result in their being deleted because
the compiler cannot know which member of the union is active without a
discriminator.}}:

\begin{lstlisting}[language=C++]
union U2
{
// ... (everything in (ù{\codeincomments{U2}}ù) above)

U2(const U2& original) : d_useInt(original.d_useInt)
{
if (d_useInt) { new (&d_i) int(original.d_i);  }
else          { new (&d_nt) Nt(original.d_nt); }
}

U2& operator=(const U2& rhs)
{
if (this == &rhs) // Prevent self-assignment.
{
return *this;
}

// Resolve all possible combinations of active types between the
// left-hand side and right-hand side of the assignment:

if (d_useInt)
{
if (rhs.d_useInt) { d_i = rhs.d_i; }
else              { new (&d_nt) Nt(rhs.d_nt); }
}
else
{
if (rhs.d_useInt) { d_nt.~Nt(); new (&d_i) int(rhs.d_i); }
else              { d_nt = rhs.d_nt; }
}

return *this;
}
};
\end{lstlisting}


\subsection[Use Cases]{Use Cases}\label{unrestrictedunion-use-cases}

\subsubsection[Implementing a \textbf{sum type}\glossary{sum type} as a discriminating (or tagged) \tt{union}]{Implementing a \textbf{sum type}\glossary{sum type} as a discriminating (or tagged) {\ParaCode union}}\label{implementing-a-sum-type-as-a-discriminating-(or-tagged)-union}

A \textbf{sum type}\glossary{sum type} is an abstract data type that provides a choice
among a fixed set of specific types. Although other implementations are
possible, using the storage of a single object to accommodate one out of
a set of types along with a (typically integral) discriminator enables
programmers to implement a \textbf{sum type}\glossary{sum type} (a.k.a.
\emph{discriminating} or \emph{tagged} union) efficiently (e.g., without
necessarily involving memory allocation or virtual dispatch) and
nonintrusively (i.e., the individual types comprised need not be related
in any way). A C++ \texttt{union} can serve as a convenient and
efficient way to define storage for a \textbf{sum type}\glossary{sum type} as alignment and
size calculations are performed (by the compiler) automatically.

As an example, consider writing a parsing function \texttt{parseInteger}
that, given a\linebreak[4] \texttt{std::string} \texttt{input}, will return, as a
\textbf{sum type}\glossary{sum type} \texttt{ParseResult} (see below), either an
\texttt{int} result (on success) or an informative error message
(on failure):

\begin{lstlisting}[language=C++]
ParseResult parseInteger(const std::string& input)  // Return a sum type.
{
int result;     // accumulate (ù{\codeincomments{result}}ù) as we go
std::size_t i;  // current character index

// ...

if (/* Failure case (1). */)
{
std::ostringstream oss;
oss << "Found non-numerical character '" << input[i]
<< "' at index '" << i << "'.";

return ParseResult(oss.str());
}

if (/* Failure case (2). */)
{
std::ostringstream oss;
oss << "Accumulating '" << input[i]
<< "' at index '" << i
<< "' into the current running total '" << result
<< "' would result in integer overflow.";

return ParseResult(oss.str());
}

// ...

return ParseResult(result);  // Success!
}
\end{lstlisting}

\noindent The implementation above relies on \texttt{ParseResult} being able to
hold a value of type either \texttt{int} or \texttt{std::string}. By
encapsulating a C++ \texttt{union} and a Boolean{\cprotect\footnote{For
\textbf{sum types}\glossary{sum types} comprising more than two types, a larger integral
or enumerated type may be used instead.}} \emph{discriminator} as part
of the \texttt{ParseResult} \textbf{sum type}\glossary{sum type}, we can achieve the
desired semantics:

\begin{lstlisting}[language=C++]
class ParseResult
{
union  // storage for either the result or the error
{
int         d_value;  // trivial result type
std::string d_error;  // non-trivial error type
};

bool d_isError;  // discriminator

public:
explicit ParseResult(int value);                 // value constructor (1)
explicit ParseResult(const std::string& error);  // value constructor (2)

ParseResult(const ParseResult& rhs);             // copy constructor
ParseResult& operator=(const ParseResult& rhs);  // copy assignment

~ParseResult();                                  // destructor
};
\end{lstlisting}

\noindent As discussed in {\it\titleref{unrestrictedunion-description}} on page~\pageref{unrestrictedunion-description}, having a non-trivial
type within a \texttt{union} forces the programmer to provide each
desired special member function and define it manually; note, although,
that the use of placement \texttt{new} is not required for either of the
two \emph{value constructors} (above) because the initializer syntax
(below) is sufficient to begin the lifetime of even a non-trivial
object:

\begin{lstlisting}[language=C++]
ParseResult::ParseResult(double value) : d_value(value), d_isError(false)
{
}

ParseResult::ParseResult(const std::string& error)
: d_error(error), d_isError(true)
// Note that placement (ù{\codeincomments{new}}ù) was not necessary here because a new
// (ù{\codeincomments{std::string}}ù) object will be created as part of the initialization of
// (ù{\codeincomments{d\_error}}ù).
{
}
\end{lstlisting}

\noindent Placement \texttt{new} and explicit destructor calls are, however,
required for destruction and both copy operations{\cprotect\footnote{For
more information on initiating the lifetime of an object, see \textbf{iso14}, section 3.8, ``Object Lifetime," pp. 66--69.}}:

\begin{lstlisting}[language=C++]
ParseResult::~ParseResult()
{
if(d_isError)
{
d_error.std::string::~string();
// An explicit destructor call is required for (ù{\codeincomments{d\_error}}ù) because its
// destructor is non-trivial.
}
}

ParseResult::ParseResult(const ParseResult& rhs) : d_isError(rhs.d_isError)
{
if (d_isError)
{
new (&d_error) std::string(rhs.d_error);
// Placement (ù{\codeincomments{new}}ù) is necessary here to begin the lifetime of a
// (ù{\codeincomments{std::string}}ù) object at the address of (ù{\codeincomments{d\_error}}ù).
}
else
{
d_value = rhs.d_value;
// Placement (ù{\codeincomments{new}}ù) is not necessary here as (ù{\codeincomments{int}}ù) is a trivial type.
}
}

ParseResult& ParseResult::operator=(const ParseResult& rhs)
{
// Destroy (ù{\codeincomments{lhs}}ù)'s error string if existent:
if (d_isError) { d_error.std::string::~string(); }

// Copy (ù{\codeincomments{rhs}}ù)'s object:
if (rhs.d_isError) { new (&d_error) std::string(rhs.d_error); }
else               { d_value = rhs.d_value; }

d_isError = rhs.d_isError;
return *this;
}
\end{lstlisting}

\noindent In practice, \texttt{ParseResult} would typically be defined as a
template and renamed to allow any arbitrary result type \texttt{T} to be
returned or else implemented in terms of a more general \textbf{sum
type}\glossary{sum type} abstraction.{\cprotect\footnote{\texttt{std::variant}, introduced
in C++17, is the standard construct used to represent a \textbf{sum
type}\glossary{sum type} as a \emph{discriminating union}. Prior to C++17,
\texttt{boost::variant} was the most widely used \emph{tagged} union
implementation of a \textbf{sum type}\glossary{sum type}.}}

\subsection[Potential Pitfalls]{Potential Pitfalls}\label{potential-pitfalls}

\subsubsection[Inadvertent misuse can lead to latent \textbf{undefined behavior}\glossary{undefined behavior} at runtime]{Inadvertent misuse can lead to latent \textbf{undefined behavior}\glossary{undefined behavior} at runtime}\label{inadvertent-misuse-can-lead-to-latent-undefined-behavior-at-runtime}

When implementing a type that makes use of an unrestricted union,
forgetting to initialize a non-trivial object (using either a
\emph{member initialization list} or \textbf{placement \texttt{new}}\glossary{placement \texttt{new}}) or
accessing a different object than the one that was actually initialized
can result in tacit \textbf{undefined behavior}\glossary{undefined behavior}. Although forgetting to
destroy an object does not necessarily result in \textbf{undefined
behavior}\glossary{undefined behavior}, failing to do so for any object that manages a resource (such
as dynamic memory) will result in a \emph{resource leak} and/or lead to
unintended behavior. Note that destroying an
object having a trivial destructor is never necessary; there are, however, rare cases where
we may choose not to destroy an object having a non-trivial
one.{\cprotect\footnote{A specific example of where one might
deliberately choose \emph{not} to destroy an object occurs when a
collection of related objects are allocated from the same local memory
resource and then deallocated unilaterally by releasing the memory
back to the resource. No issue arises if the only resource that is ``leaked''
by not invoking each individual destructor is the memory allocated
from that memory resource, and that memory can be
reused without resulting in \textbf{undefined behavior}\glossary{undefined behavior} if it
is not subsequently referenced in the context of the deallocated
objects.}}

\subsection[Annoyances]{Annoyances}\label{annoyances}

None so far

\subsection[See Also]{See Also}\label{see-also}

\begin{itemize}
\item{Section~\ref{deleted-functions}, ``\titleref{deleted-functions}" — Safe C++11 feature that forbids the invocation of a particular function. Similar effects to deleting a function happen when we specify a special function within a subobject of a union or when a class has such a union as a data member.}
\end{itemize}

\subsection[Further Reading]{Further Reading}\label{further-reading}

None so far



\newpage
\section[The {\tt [[noreturn]]} Attribute]{The {\SecCode [[noreturn]]} Attribute}\label{the-noreturn-attribute}



The \texttt{[[noreturn]]} attribute promises that the function to which
it pertains never \nobreak{returns}.

\subsection[Description]{Description}\label{description}

The presence of the standard \texttt{[[noreturn]]} attribute as part of
a function declaration informs both the compiler and human readers that
such a function never returns control flow to the caller:

\begin{lstlisting}[language=C++]
[[noreturn]] void f()
{
throw;
}
\end{lstlisting}

\noindent The \texttt{[[noreturn]]} attribute is not part of a function's type
and is also, therefore, not part of the type of a function pointer. Applying \texttt{[[noreturn]]} to a function
pointer is not an error, though doing so has no actual effect in standard C++; see
{\it\titleref{noreturn-potential-pitfalls}: \titleref{misuse-of-[[noreturn]]-on-function-pointers}} on page~\pageref{misuse-of-[[noreturn]]-on-function-pointers}. Use on a pointer might have
benefits for external tooling, code expressiveness, and future language
evolution:

\begin{lstlisting}[language=C++]
void (*fp [[noreturn]])() = f;
\end{lstlisting}


\subsection[Use Cases]{Use Cases}\label{use-cases}

\subsubsection[Better compiler diagnostics]{Better compiler diagnostics}\label{better-compiler-diagnostics}

Consider the task of creating an assertion handler that, when invoked,
always aborts execution of the program after printing some useful
information about the source of the assertion. Since this specific
handler will never return, it is a viable candidate for
\texttt{[[noreturn]]}:

\begin{lstlisting}[language=C++]
[[noreturn]] void abortingAssertionHandler(const char* filename, int line)
{
LOG_ERROR << "Assertion fired at " << filename << ':' << line;
std::abort();
}
\end{lstlisting}


\noindent The additional information provided by the attribute will allow a
compiler to warn if it determines that a code path in the
function would allow it to return:

\begin{lstlisting}[language=C++]
[[noreturn]] void abortingAssertionHandler(const char* filename, int line)
{
if (filename)  // just being safe, but see "Further Reading," below
{
LOG_ERROR << "Assertion fired at " << filename << ':' << line;
std::abort();
}
}  // compile-time warning made possible
\end{lstlisting}


\noindent This information can also be used to warn in case unreachable code is
present after\linebreak[4] \texttt{abortingAssertionHandler} is invoked:

\begin{lstlisting}[language=C++]
int main()
{
// ...
abortingAssertionHandler("main.cpp", __LINE__);
std::cout << "We got here.\n";  // compile-time warning made possible
// ...
}
\end{lstlisting}


\noindent Note that this warning is made possible by decorating just the
declaration of the handler function --- i.e., even if the definition of
the function is not visible in the current translation unit.

\subsubsection[Improved runtime performance]{Improved runtime performance}\label{improved-runtime-performance}

If the compiler knows that it is going to invoke a function
that is guaranteed not to return, the compiler is within its rights to optimize
that function by removing what it can now determine to be dead code. As
an example, consider a utility component, \texttt{util}, that defines a
function, \texttt{throwBadAlloc}, that is used to \textbf{insulate} the
throwing of an \texttt{std::bad\_alloc} exception in what would
otherwise be template code fully exposed to clients:

\begin{lstlisting}[language=C++]
// util.h:
[[noreturn]] void throwBadAlloc();

// util.cpp:
#include <util.h>  // (ù{\codeincomments{[[noreturn]] void throwBadAlloc()}}ù)

void throwBadAlloc()  // This redeclaration is also (ù{\codeincomments{[[noreturn]]}}ù).
{
throw std::bad_alloc();
}
\end{lstlisting}


\noindent Irrespective of whether the client compiler warns, the compiler is within its
rights to elide code that is rendered unreachable by the call to the
\texttt{throwBadAlloc} function due to the function being decorated with the
\texttt{[[noreturn]]} attribute on its declaration:

\begin{lstlisting}[language=C++]
#include <util.h>  // [[noreturn]] void throwBadAlloc()

void client()
{
// ...
throwBadAlloc();
// ... (Everything below here can be optimized away.)
}
\end{lstlisting}


\noindent Notice that even though \texttt{[[noreturn]]} appeared only on the first
declaration (in the \texttt{util.h} header), the \texttt{[[noreturn]]}
attribute carries over to the redeclaration used in the\linebreak[4] \texttt{throwBadAlloc}
function's definition because the header was included in the
corresponding \texttt{.cpp} file.

\subsection[Potential Pitfalls]{Potential Pitfalls}\label{noreturn-potential-pitfalls}

\subsubsection[\tt{[[noreturn]]} can inadvertently break an otherwise working program]{{\ParaCode [[noreturn]]} can inadvertently break an otherwise working program}\label{[[noreturn]]-can-inadvertently-break-an-otherwise-working-program}

Unlike many attributes, use of \texttt{[[noreturn]]} \emph{can} alter
the semantics of a well-formed program, potentially introducing a
runtime defect and/or making the program ill-formed. If a function that
can potentially return is decorated with \texttt{[[noreturn]]} and then,
in the course of executing a program, it ever does return, that behavior
is \textbf{undefined}.

Consider a \texttt{printAndExit} function whose role is to print a fatal
error message before aborting the program:

\begin{lstlisting}[language=C++]
[[noreturn]] void printAndExit()
{
std::cout << "Fatal error. Exiting the program.\n";
assert(false);
}
\end{lstlisting}

\noindent The programmer chose to (sloppily) implement termination by using an
assertion, which would not be incorporated into a program compiled with
the preprocessor definition \texttt{NDEBUG} active, and thus
\texttt{printAndExit} would (in that build mode) return normally. If the
compiler of the client is informed that function will not return, the compiler is
free to optimize accordingly. If the function then does return, any
number of hard-to-diagnose defects (e.g., due to incorrectly elided
code) might materialize as a consequence of the ensuing
\textbf{undefined behavior}. Furthermore, within a program, if a function is declared \texttt{[[noreturn]]} in some
translation units but not in others, that program is (inherently)
\textbf{ill-formed, no diagnostic required}.

\subsubsection[Misuse of {\tt[[noreturn]]} on function pointers]{Misuse of {\ParaCode [[noreturn]]} on function pointers}\label{misuse-of-[[noreturn]]-on-function-pointers}

Although the \texttt{[[noreturn]]} attribute is permitted to appertain
to a function pointer (syntactically) for the benefit of external tools,
it has no effect in standard C++; fortunately, most compilers will warn:

\begin{lstlisting}[language=C++]
void (*fp [[noreturn]])();  // not supported by standard C++ (will likely warn)
\end{lstlisting}

\noindent What's more, assigning (the address of) a function
that is not decorated with \texttt{[[noreturn]]} to an otherwise
suitable function pointer that is so decorated is perfectly fine:

\begin{lstlisting}[language=C++]
void f() { return; };  // function that always returns

void g()
{
fp = f;  // "OK" -- that (ù{\codeincomments{fp}}ù) is (ù{\codeincomments{[[noreturn]]}}ù) is silently ignored
}
\end{lstlisting}

\noindent Any reliance on \texttt{[[noreturn]]} to have any effect in standard C++
when applied to other than a function's declaration is misguided.

\subsection[Annoyances]{Annoyances}\label{annoyances}

None so far

\subsection[See Also]{See Also}\label{see-also}

\begin{itemize}
\item{Section~\ref{attributes}, ``\titleref{attributes}" — To learn more about allowed attribute placement in general}
\end{itemize}

\subsection[Further Reading]{Further Reading}\label{further-reading}

None so far




\newpage
\section[Null Pointer Literal (\tt{nullptr})]{Null Pointer Literal ({\SecCode nullptr})}\label{null-pointer-literal-(nullptr)}


The keyword \texttt{nullptr} (unambiguously) denotes the
null-pointer-value literal.

\subsection[Description]{Description}\label{description}

The \texttt{nullptr} keyword is a \textbf{prvalue} (pure rvalue) of type
\texttt{std::nullptr\_t} representing the (implementation-defined)
bit pattern corresponding to a \textbf{null address} on the host platform;
\texttt{nullptr} and other values of type \texttt{std::nullptr\_t}
(along with the integer literal \texttt{0} and the macro \texttt{NULL})
can be converted implicitly to any pointer (or pointer-to-member) type:

\begin{lstlisting}[language=C++]
int data;  // non-member data

int *pi0 = &data;    // Initialize with non-null address.
int *pi1 = nullptr;  // Initialize with null address.
int *pi2 = NULL;     //  "          "    "    "
int *pi3 = 0;        //  "          "    "    "

double f(int x);  // non-member function

double (*pf0)(int) = &f;       // Initialize with non-null address.
double (*pf1)(int) = nullptr;  // Initialize with null address.

struct S
{
short d_data;    // member data
float g(int y);  // member function
};

short S::*pmd0 = &S::d_data;  // Initialize with non-null address.
short S::*pmd1 = nullptr;     // Initialize with null address.

float (S::*pmf0)(int) = &S::g;    // Initialize with non-null address.
float (S::*pmf1)(int) = nullptr;  // Initialize with null address.
\end{lstlisting}


\noindent Because \texttt{std::nullptr\_t} is its own distinct type, overloading on
it is possible:

\begin{lstlisting}[language=C++]
#include <cstddef>  // (ù{\codeincomments{std::nullptr\_t}}ù)

void g(void*);           // (1)
void g(int);             // (2)
void g(std::nullptr_t);  // (3)

void f()
{
g("hello");  // OK --- (1) (ù{\codeincomments{void g(void}}ù)*(ù{\codeincomments{)}}ù)
g(0);        // OK --- (2) (ù{\codeincomments{void g(int)}}ù)
g(nullptr);  // OK --- (3) (ù{\codeincomments{void g(std::nullptr\_t)}}ù)
g(NULL);     // Error: ambiguous --- (1), (2), or (3)
}
\end{lstlisting}


\subsection[Use Cases]{Use Cases}\label{use-cases}

\subsubsection[Improve type safety]{Improve type safety}\label{improve-type-safety}

In pre-C++11 code bases, use of the \texttt{NULL}
macro{\cprotect\footnote{In the C Standard, the macro \texttt{NULL} is
defined as an \textbf{implementation-defined} integral or \texttt{void*}
constant. Unlike C, C++ forbids conversions from \texttt{void*} to
arbitrary pointer types and instead, prior to C++11, defined
\texttt{NULL} as an \emph{``integral constant expression rvalue of
integer type that evaluates to zero''}; any integer literal (e.g.,
\texttt{0}, \texttt{0L}, \texttt{0U}, \texttt{0LLU}) satisfies this
criterion.}} was a common way of indicating (mostly to the human
reader) that the literal value it conveys is intended specifically to
represent a \emph{null address} rather than the literal \texttt{int}
value \texttt{0}. From a type-safety perspective, its
implementation-defined (typically integral{\cprotect\footnote{As of
C++11, the definition of \texttt{NULL} has been expanded to --- in
theory --- permit \texttt{nullptr} as a conforming definition; as of
this writing, however, no major compiler vendors do so. Both GCC and
Clang default to \texttt{0L} (\texttt{long}~\texttt{int}) while MSVC
defaults to \texttt{0} (\texttt{int}). Such definitions are unlikely
to change since existing code could cease to compile or (possibly
silently) present altered run-time behavior.}}) definition, however,
makes the use of \texttt{NULL} only marginally better suited than a raw
literal \texttt{0} to represent a null pointer.

As just one specific illustration of the added type safety provided by
\texttt{nullptr}, imagine that you work for a large software company
that has historically required, as one of its coding standards, that
values returned via output parameters (as opposed to a \texttt{return}
statement) are always returned via pointer to a modifiable
object.{\cprotect\footnote{Functions that return via argument typically
do so to reserve the function's return value to communicate status.
See \textbf{{lakos96}}, section~9.1.11, pp.~621--628, specifically the
\emph{Guideline} at the bottom of p.~621: ``Be consistent about
returning values through arguments (e.g., avoid declaring
non-\texttt{const} reference parameters)."}} In the illustrative function below, the output parameter's local pointer
variable is ``zeroed'' (shown here in three different ways) to indicate
(and ensure) that nothing more is to be written:

\begin{lstlisting}[language=C++]
int illustrativeFunction(int* x)   // pointer to modifiable integer
{
// ...
if (/*...*/)
{
x = 0;       // (1) Set pointer (ù{\codeincomments{x}}ù) to null address.
x = NULL;    // (2) Set pointer (ù{\codeincomments{x}}ù) to null address.
x = nullptr; // (3) Set pointer (ù{\codeincomments{x}}ù) to null address.
}
// ...
return 0;    // success
}
\end{lstlisting}


Now suppose that the function signature is changed (e.g., due to a
change in coding standards in the organization) to accept a reference
instead of a pointer:

\begin{lstlisting}[language=C++]
int illustrativeFunction(int& x)  // reference to modifiable integer
{
// ...
if (/*...*/)
{
x = 0;       // (1) always compiles; makes what (ù{\codeincomments{x}}ù) refers to 0
x = NULL;    // (2) implementation-defined (might warn)
x = nullptr; // (3) always a compile-time error
}
// ...
return 0;    // SUCCESS
}
\end{lstlisting}


As the example above demonstrates, how we represent the notion of a
\textbf{null address} matters:
\begin{enumerate}
\item{\texttt{0} — Portable across all implementations but minimal type safety.}
\item{\texttt{NULL} — Implemented as a macro; added type safety (if any) is platform specific.}
\item{\texttt{nullptr} — Portable across all implementations and fully type-safe.}
\end{enumerate}
Use of \texttt{nullptr} instead of \texttt{0} or \texttt{NULL} to denote
a null address maximizes type safety and readability, while avoiding
both macros and implementation-defined behavior.

\subsubsection[Disambiguation of \tt{(int) 0} versus \tt{(T*) 0} during overload resolution]{Disambiguation of {\ParaCode (int) 0} versus {\ParaCode (T*) 0} during overload resolution}\label{disambiguation-of-(int)-0-versus-(t*)-0-during-overload-resolution}

The platform-dependent nature of \texttt{NULL} presents additional
challenges when used to call a function whose overloads differ only in
accepting a pointer or an integral type as the same positional argument
(which might be the case, e.g., in a poorly designed third-party
library):

\begin{lstlisting}[language=C++]
void uglyLibraryFunction(int* p);  // (1)
void uglyLibraryFunction(int  i);  // (2)
\end{lstlisting}


\noindent Calling this function with the literal \texttt{0} will always invoke
overload (2), but that might not always be what casual clients expect:

\begin{lstlisting}[language=C++]
void f()
{
uglyLibraryFunction(0);         // unambiguously invokes (2)
uglyLibraryFunction((int*) 0);  // unambiguously invokes (1)
uglyLibraryFunction(nullptr);   // unambiguously invokes (1)
uglyLibraryFunction(NULL);      // anything! (platform-defined)
uglyLibraryFunction(0L);        // always ambiguous
uglyLibraryFunction(0U);        // always ambiguous
}
\end{lstlisting}


\noindent\texttt{nullptr} is especially useful when such problematic overloads
are unavoidable because it obviates explicit
casts.{\cprotect\footnote{N.B., Explicitly casting \texttt{0} to an
appropriately typed pointer (other than \texttt{void*}) was at one
time considered by some to be a best practice, especially in C.}}

\subsubsection[Overloading for a literal null pointer]{Overloading for a literal null pointer}\label{overloading-for-a-literal-null-pointer}

Being a distinct type, \texttt{std::nullptr\_t} can itself participate
in an overload set:

\begin{lstlisting}[language=C++]
void f(int* v);          // (1)
void f(std::nullptr_t);  // (2)

void g()
{
int* ptr = nullptr;
f(ptr);      // unambiguously invokes (1)
f(nullptr);  // unambiguously invokes (2)
}
\end{lstlisting}


\noindent Given the relative ease with which a \texttt{nullptr} (above) can be
converted to a typed pointer having the same null-address value, such
overloads are, however, dubious when used to control essential behavior.
Nonetheless, one can envision such use to, say, aid in compile-time
diagnostics when passing a \textbf{null address} would otherwise result in
a runtime error\footnote{see also Section~\ref{deleted-functions}, ``\titleref{deleted-functions}"}:

\begin{lstlisting}[language=C++]
std::size_t strlen(const char* s);
// The behavior is undefined unless (ù{\codeincomments{s}}ù) is null-terminated.

std::size_t strlen(std::nullptr_t);
// declared but not defined
\end{lstlisting}


\noindent Another arguably safe use of such an overload for a \texttt{nullptr} is
to avoid a null-pointer check. However, for cases where the client knows the address is null at compile time, better ways typically exist for avoiding the (often
insignificant) overhead to test for a null pointer at runtime.

\subsection[Potential Pitfalls]{Potential Pitfalls}\label{potential-pitfalls}

None so far

\subsection[Annoyances]{Annoyances}\label{annoyances}

None so far

\subsection[See Also]{See Also}\label{see-also}

None so far

\subsection[Further Reading]{Further Reading}\label{further-reading}

None so far


\newpage
\section[\tt{alignas}]{{\SecCode alignas}}\label{alignas}


\texttt{alignas}, a keyword that acts like an attribute, is used to widen (make more strict)
the \textbf{alignment} of a \textbf{variable}, \textbf{user-defined
type}, or \textbf{data member}.

\subsection[Description]{Description}\label{description}

The \texttt{alignas} specifier provides a means of further restricting
the granularity at which (1) a particular object of arbitrary type, (2)
a user-defined type (\texttt{class}, \texttt{struct}, \texttt{union}, or
\texttt{enum}), or (3) an individual data member is permitted to reside
within the virtual-memory-address space.

\subsubsection[Restricting the alignment of a particular object]{Restricting the alignment of a particular object}\label{restricting-the-alignment-of-a-particular-object}

In its most basic form, \texttt{alignas} acts like an
attribute that accepts (as an argument) an
\textbf{integral constant expression} representing an explicitly
supplied minimum alignment value:

\begin{lstlisting}[language=C++]
alignas(64) int i;    // OK, (ù{\codeincomments{i}}ù) is aligned on a 64-byte address boundary.
int j alignas(8), k;  // OK, (ù{\codeincomments{j}}ù) is 8-byte aligned; (ù{\codeincomments{k}}ù) remains naturally aligned.
\end{lstlisting}

\noindent If more than one alignment pertains to a given object, the most
restrictive alignment value is applied:

\begin{lstlisting}[language=C++]
alignas(4) alignas(8) alignas(2) char m;  // OK, (ù{\codeincomments{m}}ù) is 8-byte aligned.
alignas(8) int n alignas(16);             // OK, (ù{\codeincomments{n}}ù) is 16-byte aligned.
\end{lstlisting}

\noindent For a program to be \textbf{well formed}, a specified alignment value
must satisfy several\linebreak[4] \mbox{requirements}:

\begin{enumerate}
\item{Be either zero or a non-negative integral power of two of type \texttt{std::size\_t} (0, 1, 2, 4, 8, 16\dots).}
\item{Be at least the minimum alignment\cprotect\footnote{The minimum alignment of an entity is the least restrictive memory-address boundary at which the entity can be placed and have the program continue to work properly. This value is platform dependent and often subject to compiler controls but, by default, is often well approximated by \textbf{natural alignment}; see \textit{\titleref{alignas-appendix}: \titleref{natural-alignment}} on page \pageref{natural-alignment}.} required by the decorated entity.}
\item{Be no more than the largest alignment\cprotect\footnote{The notion of the largest supported alignment is characterized by both \textbf{maximal alignment} and the maximum \textbf{extended alignment}. \textbf{Maximal alignment} is defined as that most restrictive alignment that is valid in \emph{all} contexts on the current platform. All fundamental and pointer types necessarily have a minimal alignment that is less than or equal to \texttt{alignof(std::max\_align\_t)} — typically 8 or 16. Any alignment value greater than \textbf{maximal alignment} is an \textbf{extended alignment} value. Whether any extended alignment is supported (and in which contexts) is implementation defined. On typical platforms, extended alignment will often be as large as $2^{18}$ or $2^{19}$, however implementations may warn when the alignment of a global object exceeds some maximal hardware threshold (such as the size of a physical memory page, e.g., 4096 or 8192). For \textbf{automatic variables} (defined on the program stack), making alignment more restrictive than what would naturally be employed  is seldom desired because at most one thread is able to access proximately located variables there unless explicitly passed in via address to separate threads; see \textit{\titleref{alignas-use-cases}: \titleref{avoiding-false-sharing-among-distinct-objects-in-a-multi-threaded-program}} on page~\pageref{avoiding-false-sharing-among-distinct-objects-in-a-multi-threaded-program}. Note that, in the case of \texttt{i} in the first code snippet on page~\pageref{restricting-the-alignment-of-a-particular-object}, a conforming platform that did not support an extended alignment of 64 would be required to report an error at compile time.} supported on the platform in the context in which the entity appears.}
\end{enumerate}

\noindent Additionally, if the specified alignment value is zero, the
\texttt{alignas} specifier is ignored:

\begin{lstlisting}[language=C++]
// Static variables declared at namespace scope
alignas(32) int i0;  // OK, aligned on a 32-byte boundary (extended alignment)
alignas(16) int i1;  // OK, aligned on a 16-byte boundary (maximum alignment)
alignas(8)  int i2;  // OK, aligned on an 8-byte boundary
alignas(7)  int i3;  // error: not a power of two
alignas(4)  int i4;  // OK, no change to alignment boundary
alignas(2)  int i5;  // error: less than minimum alignment on this platform
alignas(0)  int i6;  // OK, (ù{\codeincomments{alignas}}ù) specifier ignored

alignas(1024 * 16) int i7;
// OK, might warn: e.g., exceeds (physical) page size on current platform

alignas(1024 * 1024 * 512) int i8;
// (likely) compile-time error: e.g., exceeds maximum size of object file

alignas(8) char buf[128];  // create 8-byte-aligned, 128-byte character buffer

void f()
{
// automatic variables declared at function scope
alignas(4)  double e0;  // error: less than minimum alignment on this platform
alignas(8)  double e1;  // OK, no-change to (8-byte) alignment boundary
alignas(16) double e2;  // OK, aligned to maximum (fundamental) alignment value
alignas(32) double e3;  // OK, maximum alignment value exceeded; might warn
}
\end{lstlisting}

\subsubsection[Restricting the alignment of a user-defined type]{Restricting the alignment of a user-defined type}\label{restricting-the-alignment-of-a-user-defined-type}

The \texttt{alignas} specifier can also be used to specify alignment for
user-defined types (UDTs), such as a \texttt{class}, \texttt{struct},
\texttt{union}, or \texttt{enum}. When specifying the alignment of a UDT,
the \texttt{alignas} keyword is placed \emph{after} the
type specifier (e.g., \texttt{class}) and just before the name of the
type (e.g., \texttt{C}):

\begin{lstlisting}[language=C++]
class alignas(2)  C { };  // OK, aligned on a 2-byte boundary; size = 2
struct alignas(4) S { };  // OK, aligned on a 4-byte boundary; size = 4
union alignas(8)  U { };  // OK, aligned on an 8-byte boundary; size = 8
enum alignas(16)  E { };  // OK, aligned on a 16-byte boundary; size = 4
\end{lstlisting}

\noindent Notice that, for each of \texttt{class}, \texttt{struct}, and
\texttt{union} above, the \texttt{sizeof} objects of that type increased
to match the alignment; in the case of the \texttt{enum}, however, the
size remains that of the default \textbf{underlying type} (e.g., 4
bytes) on the current platform.{\cprotect\footnote{When \texttt{alignas}
is applied to an enumeration \texttt{E}, the Standard does not
indicate whether padding bits are added to \texttt{E}'s object
representation or not, affecting the result of \texttt{sizeof(E)}. The
implementation variance resulting from this lack of clarity in the
Standard was captured in \textbf{miller17}. The outcome of the core
issue was to completely remove permission for \texttt{alignas} to be
applied to enumerations (see \textbf{iso18a}). Therefore, conforming implementations will
eventually stop accepting the \texttt{alignas} specifier on
enumerations in the future.}}

Again, specifying an alignment that is less than what would occur
naturally or else is restricted explicitly is ill formed:

\begin{lstlisting}[language=C++]
struct alignas(2) T0 { int i; };
// Error: Alignment of (ù{\codeincomments{T0}}ù) (2) is less than that of (ù{\codeincomments{int}}ù) (4).
struct alignas(1) T1 { C c; };
// Error: Alignment of (ù{\codeincomments{T1}}ù) (1) is less than that of (ù{\codeincomments{C}}ù) (2).
\end{lstlisting}


\subsubsection[Restricting the alignment of individual data members]{Restricting the alignment of individual data members}\label{restricting-the-alignment-of-individual-data-members}

Within a user-defined type (\texttt{class}, \texttt{struct}, or
\texttt{union}), using the attribute-like syntax of the
\texttt{alignas} keyword to specify the alignments of individual data
members is possible:

\begin{lstlisting}[language=C++]
struct T2
{
alignas(8)  char   x;  // size   1; alignment 8
alignas(16) int    y;  // size   4; alignment 16
alignas(64) double y;  // size   8; alignment 64
};  // size 128; alignment 64
\end{lstlisting}

\noindent The effect here is the same as if we had added the padding explicitly
and then set the alignment of the structure overall:

\begin{lstlisting}[language=C++]
struct alignas(64) T3
{
char   x;      // size   1; alignment 8
char   a[15];  // padding
int    y;      // size   4; alignment 16
char   b[44];  // padding
double z;      // size   8; alignment 64
char   c[56];  // padding (optional)
};  // size 128; alignment 64
\end{lstlisting}

\noindent Again, if more than one attribute pertains to a given data member,
the maximum applicable alignment value is applied:

\begin{lstlisting}[language=C++]
struct T4
{
alignas(2) char
c1 alignas(1),  // size 1; alignment 2
c2 alignas(2),  // size 1; alignment 2
c4 alignas(4);  // size 1; alignment 4
};                      // size 8; alignment 4
\end{lstlisting}


\subsubsection[Matching the alignment of another type]{Matching the alignment of another type}\label{matching-the-alignment-of-another-type}

The \texttt{alignas} specifier also accepts (as an argument) a type
identifier. In its alternate form, \texttt{alignas(T)} is strictly
equivalent to \texttt{alignas(alignof(T))}:

\begin{lstlisting}[language=C++]
alignas(int) char c;  // equivalent to (ù{\codeincomments{alignas(alignof(int)) char c;}}ù)
\end{lstlisting}


\subsection[Use Cases]{Use Cases}\label{alignas-use-cases}

\subsubsection[Creating a sufficiently aligned object buffer]{Creating a sufficiently aligned object buffer}\label{creating-a-sufficiently-aligned-object-buffer}

When writing low-level, system-infrastructure code, constructing an object within a raw buffer is sometimes useful. As a minimal
example, consider a function that uses a local character buffer to
create an object of type \texttt{std::complex<long}~\texttt{double>} on
the program stack using placement \texttt{new}:

\begin{lstlisting}[language=C++]
void f()
{
// ...
char objectBuffer[sizeof(std::complex<long double>)];  // BAD IDEA
// ...
new(objectBuffer) std::complex<long double>(1.0, 0.0);  // Might dump core!
// ...
}
\end{lstlisting}

\noindent The essential problem with the code above is that \texttt{objectBuffer},
being an array of characters (each having an alignment of 1), is itself
byte aligned. The compiler is therefore free to place it on any address
boundary. On the other hand, \texttt{std::complex<long}~\texttt{double>} is an aggregate consisting of two \texttt{long}~\texttt{double} objects
and therefore necessarily requires (at least) the same strict alignment
(typically 16) as the two \texttt{long}~\texttt{double} objects it comprises. Previous
solutions to this problem involved creating a \texttt{union} of the
object buffer and some maximally aligned type (e.g.,
\texttt{std::max\_align\_t}):

\begin{lstlisting}[language=C++]
#include <cstddef>  // (ù{\codeincomments{std::max\_align\_t}}ù)

void f()
{
// ...

union {                                              // awkward workaround
std::max_align_t dummy;  // (ù{\codeincomments{typedef}}ù) to maximally aligned type
char objectBuffer[sizeof(std::complex<long double>)];
} objectBuffer;

// ...

new(&objectBuffer) std::complex<long double>(1.0, 0.0);  // OK

// ...
}
\end{lstlisting}

\noindent Using the alternate syntax for \texttt{alignas}, we can avoid gratuitous
complexity and just state our intentions explicitly:

\begin{lstlisting}[language=C++]
void f()
{
// ...

alignas(std::complex<long double>) char objectBuffer[
sizeof(std::complex<long double>)];  // GOOD IDEA

// ...

new(objectBuffer) std::complex<long double>(1.0, 0.0);  // OK

// ...
}
\end{lstlisting}


\subsubsection[Ensuring proper alignment for architecture-specific instructions]{Ensuring proper alignment for architecture-specific instructions}\label{ensuring-proper-alignment-for-architecture-specific-instructions}

Architecture-specific instructions or compiler intrinsics might require
the data they act on to have a specific alignment. One example of such
intrinsics is the \emph{Streaming SIMD Extensions (SSE)}\footnote{\textbf{inteliig}, ``Technologies: SSE"} instruction set available on the x86
architecture. SSE instructions operate on groups of four 32-bit
single-precision floating-point numbers at a time, which are required to
be 16-byte aligned.{\cprotect\footnote{``Data must be
16-byte aligned when loading to and storing from the 128-bit XMM
registers used by SSE/SSE2/SSE3/SSSE3'': see \textbf{{intel16}},
section 4.4.4, ``Data Alignment for 128-Bit Data," pp. 4-19--4-20.}} The
\texttt{alignas} specifier can be used to create a type satisfying this requirement:

\begin{lstlisting}[language=C++]
struct SSEVector
{
alignas(16) float d_data[4];
};
\end{lstlisting}

\noindent Each object of the \texttt{SSEVector} type above is guaranteed always to
be aligned to a 16-byte boundary and can therefore be safely (and
conveniently) used with SSE intrinsics:

\begin{lstlisting}[language=C++]
#include <xmmintrin.h>  // (ù{\codeincomments{\_\_m128}}ù) and (ù{\codeincomments{\_mm\_XXX}}ù) functions

void f()
{
const SSEVector v0 = {0.0f, 1.0f, 2.0f, 3.0f};
const SSEVector v1 = {10.0f, 10.0f, 10.0f, 10.0f};

__m128 sseV0 = _mm_load_ps(v0.d_data);
__m128 sseV1 = _mm_load_ps(v1.d_data);
// (ù{\codeincomments{\_mm\_load\_ps}}ù) requires the given (ù{\codeincomments{float}}ù) array to be 16-byte aligned.
// The data is loaded into a dedicated 128-bit CPU register.

__m128 sseResult = _mm_add_ps(sseV0, sseV1);
// sum two 128-bit registers; typically generates an (ù{\codeincomments{addps}}ù) instruction

SSEVector vResult;
_mm_store_ps(vResult.d_data, sseResult);
// Store the result of the sum back into a (ù{\codeincomments{float}}ù) array.

assert(vResult.d_data[0] == 10.0f);
assert(vResult.d_data[1] == 11.0f);
assert(vResult.d_data[2] == 12.0f);
assert(vResult.d_data[3] == 13.0f);
}
\end{lstlisting}


\subsubsection[Avoiding \textbf{false sharing} among distinct objects in a multi-threaded program]{Avoiding \textbf{false sharing} among distinct objects in a multi-threaded program}\label{avoiding-false-sharing-among-distinct-objects-in-a-multi-threaded-program}

In the context of an application where multithreading has been employed
to improve performance, seeing
a previously single-threaded workflow become even less performant after
a parallelization attempt can be surprising (and disheartening). One possible insidious cause of such
disappointing results comes from \textbf{false sharing} --- a situation
in which multiple threads unwittingly harm each other's performance
while writing to logically independent variables that happen to reside
on the same \textbf{cache line}; see {\it \titleref{alignas-appendix}:} {\it\titleref{cache-lines,-l1,-l2,-and-l3-cache,-pages,-and-virtual-memory}} on page~\pageref{cache-lines,-l1,-l2,-and-l3-cache,-pages,-and-virtual-memory}.

As a simple (purely pedagogical) illustration of the potential
performance degradation resulting from \textbf{false sharing}, consider
a function that spawns separate threads to repeatedly increment
(concurrently) logically distinct variables that happen to reside in
close proximity on the program stack:

\begin{lstlisting}[language=C++]
#include <thread>  // (ù{\codeincomments{std::thread}}ù)

volatile int target = 0;  // updated asynchronously from multiple threads

void incrementJob(int* p);
// Repeatedly increment (ù{\codeincomments{*p}}ù) a large, fixed number of times;
// periodically write its current value to (ù{\codeincomments{target}}ù).

void f()
{
int i0 = 0;  // Here, (ù{\codeincomments{i0}}ù) and (ù{\codeincomments{i1}}ù) likely share the same cache line,
int i1 = 0;  // i.e., byte-aligned memory block on the program stack.

std::thread t0(&incrementJob, &i0);
std::thread t1(&incrementJob, &i1);
// Spawn two parallel jobs incrementing the respective variables.

t0.join();
t1.join();
// Wait for both jobs to be completed.
}
\end{lstlisting}

\noindent In the simplistic example above, the proximity in memory between
\texttt{i0} and \texttt{i1} can result in their belonging to the same
\textbf{cache line}, thus leading to \textbf{false sharing}. By
prepending \texttt{alignas(64)} to the declaration of both integers, we
ensure that the two variables reside on distinct cache lines:

\begin{lstlisting}[language=C++]
// ...

void f()
{
alignas(64) int i0 = 0;   // Assuming a cache line on this platform is 64
alignas(64) int i1 = 0;   // bytes, (ù{\codeincomments{i0}}ù) and (ù{\codeincomments{i1}}ù) will be on separate ones.

// ...
\end{lstlisting}

\noindent As an empirical demonstration of the effects of \textbf{false sharing},
a benchmark program repeatedly calling \texttt{f} completed its
execution seven times faster on average when compared to the same
program without use of \texttt{alignas}.{\cprotect\footnote{The benchmark
program was compiled using Clang 11.0.0 using \texttt{-Ofast},
\texttt{-march=native}, and \mbox{\texttt{-std=c++11}}. The program was then
executed on a machine running Windows 10 x64, equipped with an Intel
Core i7-9700k CPU (8 cores, 64-byte cache line size). Over the
course of multiple runs, the version of the benchmark without
\texttt{alignas} took 18.5967ms to complete (on average), while the
version with \texttt{alignas} took 2.45333ms to complete (on average).
See \textbf{{[PRODUCTION: CODE PROVIDED WITH BOOK] alignasbenchmark}} for the source code of the program.}}

\subsubsection[Avoiding \textbf{false sharing} within a single thread-aware object]{Avoiding \textbf{false sharing} within a single thread-aware object}\label{avoiding-false-sharing-within-a-single-thread-aware-object}

A real-world scenario where the need for preventing \textbf{false
sharing} is fundamental occurs in the implementation of high-performance
concurrent data structures. As an example, a thread-safe ring buffer
might make use of \texttt{alignas} to ensure that the indices of the
head and tail of the buffer are aligned at the start of a cache line
(typically 64, 128, or 256 bytes), thereby preventing them from
occupying the same one.

\begin{lstlisting}[language=C++]
class ThreadSafeRingBuffer
{
alignas(cpuCacheSize) std::atomic<std::size_t> d_head;
alignas(cpuCacheSize) std::atomic<std::size_t> d_tail;

// ...
};
\end{lstlisting}

\noindent Not aligning \texttt{d\_head} and \texttt{d\_tail} (above) to the CPU
cache size might result in poor performance of the
\texttt{ThreadSafeRingBuffer} because CPU cores that need to access only one
of the variables will inadvertently load the other one as well,
triggering expensive hardware-level coherency mechanisms between the
cores' caches. On the other hand, specifying such substantially stricter
alignment on consecutive data members necessarily increases the size of
the object; see {\it\titleref{potential-pitfalls}:} {\it\titleref{stricter-alignment-might-reduce-cache-utilization}} on page~\pageref{stricter-alignment-might-reduce-cache-utilization}.

\subsection[Potential Pitfalls]{Potential Pitfalls}\label{potential-pitfalls}

\subsubsection[Underspecifying alignment is not universally reported]{Underspecifying alignment is not universally reported}\label{underspecifying-alignment-is-not-universally-reported}

The Standard is clear when it comes to underspecifying
alignment{\cprotect\footnote{\textbf{{cpp11}}, section 7.6.2, ``Alignment Specifier," paragraph~5, pp. 179}}:
\begin{quote}
The combined effect of all \textit{alignment-specifiers} in a declaration
shall not specify an alignment that is less strict than the alignment
that would be required for the entity being declared if all
\textit{alignment-specifiers} were omitted (including those in other
declarations).
\end{quote}
The compiler is required to honor the
specified value if it is a \textbf{fundamental
alignment},{\cprotect\footnote{``If the constant expression evaluates to
a fundamental alignment, the alignment requirement of the declared
entity shall be the specified fundamental alignment'': \textbf{cpp11}, section~7.6.2, ``Alignment Specifier," paragraph~2, item~2, p. 178.}} so
imagining how this would lead to anything other than an ill-formed
program is difficult:

\begin{lstlisting}[language=C++]
alignas(4) void* p;              // (1) Error: (ù{\codeincomments{alignas(4)}}ù) is below minimum, 8.

struct alignas(2) S { int x; };  // (2) Error: (ù{\codeincomments{alignas(2)}}ù) is below minimum, 4.

struct alignas(2) T { };
struct alignas(1) U { T e; };    // (3) Error: (ù{\codeincomments{alignas(1)}}ù) is below minimum, 2.
\end{lstlisting}

\noindent Each of the three errors above are reported by Clang, but GCC
doesn't issue so much as a warning (let alone the required error) ---
even in the most pedantic warning mode. Thus, one could write a program,
involving statements like those above, that happens to work on one
platform (e.g., GCC) but fails to compile on another (e.g.,
Clang).{\cprotect\footnote{Underspecifying alignment is not reported at
all by GCC 10.1, using the
\texttt{-std=c++11} \texttt{-Wall} \texttt{-Wextra} \mbox{\texttt{-Wpedantic}}
flags. With the same set of options, Clang 10.0 produces a compilation
failure. MSVC v19.24 will produce a warning and ignore any alignment
less than the minimum one.}}

\subsubsection[Incompatibly specifying alignment is \textbf{IFNDR}]{Incompatibly specifying alignment is \textbf{IFNDR}}\label{incompatibly-specifying-alignment-is-ifndr}

It is permissible to forward declare a user-defined type (UDT)
without an \texttt{alignas} specifier so long as all defining
declarations of the type have either no \texttt{alignas} specifier or
have the same one. Similarly, if any forward declaration of a
user-defined type has an \texttt{alignas} specifier, then all defining
declarations of the type must have the same specifier and that specifier
must be \emph{equivalent to} (not necessarily \emph{the same as}) that
in the forward declaration:

\begin{lstlisting}[language=C++]
struct Foo;                  // OK, does not specify an alignment
struct alignas(double) Foo;  // OK, must be equivalent to every definition
struct alignas(8) Foo;       // OK, all definitions must be identical.
struct alignas(8) Foo { };   // OK, equivalent to each decl. specifying (ù{\codeincomments{alignas}}ù)
struct Foo;                  // OK, has no effect
struct alignas(8) Foo;       // OK, has no effect; might warn after definition
\end{lstlisting}

\noindent Specifying an alignment in a forward declaration without specifying an
equivalent one in the defining declaration is \textbf{ill formed; no diagnostic
is required (IFNDR)} if the two declarations appear in distinct translation
units:

\begin{lstlisting}[language=C++]
struct alignas(4) Bar;      // OK, forward declaration
struct Bar { };             // error: missing (ù{\codeincomments{alignas}}ù) specifier

struct alignas(4) Baz;      // OK, forward declaration
struct alignas(8) Baz { };  // error: non-equivalent (ù{\codeincomments{alignas}}ù) specifier
\end{lstlisting}

\noindent Both of the errors above are flagged by Clang, but neither of them is
reported by GCC. Note that when the inconsistency occurs across
translation units, no mainstream compiler is likely to diagnose the
problem:

\begin{lstlisting}[language=C++]
// file1.cpp
struct Bam { char ch; } bam, *p = &bam;

// file2.cpp
struct alignas(int) Bam;  // Error: definition of (ù{\codeincomments{Bam}}ù) lacks alignment specifier.
extern Bam* p;            //        (no diagnostic required)
\end{lstlisting}

\noindent Any program incorporating both translation units above is
\textbf{ill formed, no diagnostic required}.

\subsubsection[Stricter alignment might reduce cache utilization]{Stricter alignment might reduce cache utilization}\label{stricter-alignment-might-reduce-cache-utilization}

User-defined types having artificially stricter alignments than would
naturally occur on the host platform means that fewer of them can fit
within any given level of physical cache within the hardware. Types
having data members whose alignment is artificially widened tend to be
larger and thus suffer the same lost cache utilization. As an
alternative to enforcing stricter alignment to avoid \textbf{false
sharing}, consider organizing a multithreaded program such that tight
clusters of repeatedly accessed objects are always acted upon by only a
single thread at a time, e.g., using local (arena) memory allocators;
see {\it\titleref{alignas-appendix}:} {\it\titleref{cache-lines,-l1,-l2,-and-l3-cache,-pages,-and-virtual-memory}} on page~\pageref{cache-lines,-l1,-l2,-and-l3-cache,-pages,-and-virtual-memory}.

\subsection[See Also]{See Also}\label{see-also}

\begin{itemize}
\item{Section~\ref{alignof}, ``\titleref{alignof}" — Safe C++11 feature that inspects the alignment of a given type}
\item{Section~\ref{attributes}, ``\titleref{attributes}" — Safe C++11 feature that shows how other attributes (following the conventional attribute notation) are used to annotate source code, improve error diagnostics, and implicitly code generation} %%% WORDS MISSING!
\end{itemize}

\subsection[Further Reading]{Further Reading}\label{further-reading}

None so far

\subsection[Appendix]{Appendix}\label{alignas-appendix}

\subsubsection[Natural Alignment]{Natural Alignment}\label{natural-alignment}

By default, fundamental, pointer, and enumerated types typically reside
on an address boundary that divides the size of the object; we refer to
such alignment as \textbf{natural alignment}{\cprotect\footnote{Sizes
and alignment shown here are typical but not specifically required by
the standard. On some platforms, one can request that all
types be \textbf{byte aligned}. While such a representation is more
compact, entities that span memory boundaries can require multiple
fetch operations leading to run times that are typically
significantly (sometimes as much as an order of magnitude) slower when
run in this ``packed'' mode.}}:

\begin{lstlisting}[language=C++]
char   c;  // size 1; alignment 1; boundaries: 0x00, 0x01, 0x02, 0x03, ...
short  s;  // size 2; alignment 2: boundaries: 0x00, 0x02, 0x04, 0x06, ...
int    i;  // size 4; alignment 4; boundaries: 0x00, 0x04, 0x08, 0x0c, ...
float  f;  // size 4; alignment 4; boundaries: 0x00, 0x04, 0x08, 0x0c, ...
double d;  // size 8; alignment 8; boundaries: 0x00, 0x08, 0x10, 0x18, ...
\end{lstlisting}

\noindent For aggregates (including arrays) or user-defined types, the alignment
is typically that of the most strictly aligned subelement:

\begin{lstlisting}[language=C++]
struct S0
{
char a;  // size 1; alignment 1
char b;  // size 1; alignment 1
int  c;  // size 4; alignment 4
};           // size 8; alignment 4

struct S1
{
char a;  // size  1; alignment 1
int  b;  // size  4; alignment 4
char c;  // size  1; alignment 1
};           // size 12; alignment 4

struct S2
{
int  a;  // size 4; alignment 4
char b;  // size 1; alignment 1
char c;  // size 1; alignment 1
};           // size 8; alignment 4

struct S3
{
char a;  // size 1; alignment 1
char b;  // size 1; alignment 1
};           // size 2; alignment 1

struct S4
{
char a[2];  // size 2; alignment 1
};              // size 2; alignment 1
\end{lstlisting}

\noindent Size and alignment behave similarly with respect to \textbf{structural
inheritance}:

\begin{lstlisting}[language=C++]
struct D0 : S0
{
double d;  // size  8; alignment 8
};             // size 16; alignment 8

struct D1 : S1
{
double d;  // size  8; alignment 8
};             // size 24; alignment 8

struct D2 : S2
{
int d;  // size  4; alignment 4
};          // size 12; alignment 4

struct D3 : S3
{
int d;  // size 4; alignment 4
};          // size 8; alignment 4

struct D4 : S4
{
char d;  // size 1; alignment 1
};           // size 3; alignment 1
\end{lstlisting}

\noindent Finally, virtual functions invariably introduce an implicit
virtual-table-pointer member having a size and alignment corresponding
to that of a memory address (e.g., 4 or 8) on the host platform:

\begin{lstlisting}[language=C++]
struct S5
{
virtual ~S5();
};                   // size 8; alignment 8

struct D5 : S5
{
char d;  // size  1; alignment 1
};           // size 16; alignment 8
\end{lstlisting}


\subsubsection[Cache lines; L1, L2, and L3 cache; pages; and virtual memory]{Cache lines; L1, L2, and L3 cache; pages; and virtual memory}\label{cache-lines,-l1,-l2,-and-l3-cache,-pages,-and-virtual-memory}

Modern computers are highly complex systems, and a detailed
understanding of their intricacies is unnecessary to achieve most of
the performance benefits. Still, certain general themes and
rough thresholds aid in understanding how to squeeze just a bit
more out of the underlying hardware. In this section, we sketch
fundamental concepts that are common to all modern computer hardware;
although the precise details will vary, the general ideas remain
essentially the same.

In its most basic form, a computer consists of central processing unit
(CPU) having internal registers that access main memory (MM).
Registers in the CPU (on the order of hundreds of bytes) are among the
fastest forms of memory, while main memory (typically many gigabytes) is
orders of magnitude slower. An almost universally observed phenomenon is
that of \textbf{locality of reference}, which suggests that data that
resides in close proximity (in the virtual address space) is more likely
to be accessed together in rapid succession than more distant data.

To exploit the phenomenon of \textbf{locality of reference}, computers
introduce the notion of a cache that, while much faster than main
memory, is also much smaller. Programs that attempt to amplify
\textbf{locality of reference} will, in turn, often be rewarded with
faster run times. The organization of a cache and, in fact, the number of
levels of cache (e.g., L1, L2, L3,$\ldots$) will vary, but the basic
design parameters are, again, more or less the same. A given level of
cache will have a certain total size in bytes (invariably an integral
power of two). The cache will be segmented into what are called
\textbf{cache lines} whose size (a smaller power of two) divides that of
the cache itself. When the CPU accesses main memory, it first looks to
see if that memory is in the cache; if it is, the value is returned
quickly (known as a \textbf{cache hit}). Otherwise, the cache line(s)
containing that data is (are) fetched (from the next higher level of cache
or from main memory) and placed into the cache (known as a \textbf{cache
miss}), possibly ejecting other less recently used
ones.{\cprotect\footnote{Conceptually, the cache is often thought of as
being able to hold any arbitrary subset of the most recently accessed
cache lines. This kind of cache is known as \textbf{fully
associative}. Although it provides the best hit rate, a \textbf{fully
associative} cache requires the most power along with significant
additional chip area to perform the fully parallel lookup. \textbf{Direct-mapped} cache associativity is at the
other extreme. In direct mapped, each memory location has exactly one location
available to it in the cache. If another memory location mapping to
that location is needed, the current cache line must be flushed from
the cache. Although this approach has the lowest hit rate, lookup
times, chip area, and power consumption are all minimized (optimally).
Between these two extremes is a continuum that is referred to as
\textbf{set associative}. A \textbf{set associate} cache has more than
one (typically 2, 4, or 8; see \textbf{solihin15}, section~5.2.1, ``Placement Policy," pp. 136--141, and \textbf{hruska20})
location in which each memory location in main memory can reside.
Note that, even with a relatively small $N$, as $N$ increases, an $N$-way
\textbf{set associative} cache quickly approaches the hit rate of a fully
associative cache at greatly reduced collateral cost; for most
software-design purposes, any loss in hit rate due to set
associativity of a cache can be safely ignored.}}

Data residing in distinct cache lines is physically independent and can
be written concurrently by multiple threads. Logically unrelated data
residing in the same cache line, however, is nonetheless physically
coupled; two threads that write to such logically unrelated data will find
themselves synchronized by the hardware. Such unexpected and typically
undesirable sharing of a cache line by unrelated data acted upon by two
concurrent threads is known as \textbf{false sharing}. One way of
avoiding \textbf{false sharing} is to align such data on a cache-line
boundary, thus rendering accidental collocation of such data on the same
cache line impossible. Another (more broad-based) design approach that
avoids lowering cache utilization is to ensure that data acted upon by a
given thread is kept physically separate --- e.g., through the use of
local (arena) memory allocators.{\cprotect\footnote{\textbf{{lakos17}},
\textbf{{lakos19}}, \textbf{{lakos22}}}}

Finally, even data that is not currently in cache but resides nearby in
MM can benefit from locality. The virtual address space, synonymous with
the size of a \texttt{void*} (typically 64-bits on modern general-purpose hardware), has historically well exceeded the physical memory
available to the CPU. The operating system must therefore maintain a
mapping (in main memory) from what is resident in physical memory and
what resides in secondary storage (e.g., on disc). In addition,
essentially all modern hardware provides a
\textbf{TLB}{\cprotect\footnote{A translation-lookaside buffer (TLB) is
a kind of address-translation cache that is typically part of a chip's
memory management unit (MMU). A TLB holds a recently accessed subset
of the complete mapping (itself maintained in MM) from virtual memory
address to physical ones. A TLB is used to reduce access time when the
requisite pages are already resident in memory; its size (e.g., 4K) is
capped at the number of bytes of physical memory (e.g., 32Gb) divided
by the number of bytes in each physical page (e.g., 8Kb), but could be
smaller. Because it resides on chip, is typically an order of
magnitude faster (SRAM versus DRAM), and requires only a single lookup
(as opposed to two or more when going out to MM), there is an enormous
premium on minimizing TLB misses.}} that caches the addresses of the
most recently accessed physical pages, providing yet another advantage
to having the \textbf{working set} (i.e., the current set of frequently
accessed pages) remain small and densely packed with relevant
data.{\cprotect\footnote{Note that memory for handle-body
types (e.g., \texttt{std::vector} or \texttt{std::deque}) and
especially node-based containers (e.g., \texttt{std::map} and
\texttt{std::unordered\_map}), originally allocated within a single
page, can --- through deallocation and reallocation (or even move
operations) --- become scattered across multiple (perhaps many)
pages, thus causing what was originally a relatively small \textbf{working set}
to no longer fit within physical memory. This phenomenon, known as
\textbf{diffusion} (which is a distinct concept from
\textbf{fragmentation}), is what typically leads to a substantial
runtime performance degradation (due to \textbf{thrashing}) in large,
long-running programs. Such \textbf{diffusion} can be mitigated by
judicious use of local arena memory allocators (and deliberate
avoidance of \textbf{move operations} across disparate localities of
frequent memory usage).}} What's more, dense working sets, in addition
to facilitating hits for repeat access, increase the likelihood that
data that is coresident on a page (or cache line) will be needed soon
(i.e., in effect acting as a prefetch).{\cprotect\footnote{We sometimes
lightheartedly refer to the beneficial prefetch of unrelated data that
is accidentally needed subsequently (e.g., within a single thread) due
to high locality within a cache line (or a physical page) as
\textbf{true sharing}.}} Table~\ref{table-alignas-appendix} provides a summary of typical physical parameters found in modern computers today.

%%%%%%TODO: TBD: @Lori: Format this as a figure with a caption. @jslakos: Double-check accuracy of values.

\begin{table}[h!]
\begin{center}
\begin{threeparttable}
\caption{Various sizes and access speeds of typical memory for modern \mbox{computers}}\label{table-alignas-appendix} \vspace{1.5ex}
{\small \begin{tabular}{c|c|c}\thickhline
\rowcolor[gray]{.9}    {\sffamily\bfseries Memory Type} & {\sffamily\bfseries Typical Memory Size (Bytes)} & {\sffamily\bfseries Typical Access Times}\\\hline
CPU Registers & 512 \ldots~2048 & $\sim$250ps\\ \hline
Cache Line  & 64 \ldots~256 & NA\\ \hline
L1 Cache & 16Kb \ldots~64Kb & $\sim$1ns\\ \hline
L2 Cache & 1Mb \ldots~2Mb & $\sim$10ns\\ \hline
L3 Cache & 8Mb \ldots~32Mb & $\sim$80ns--120ns\\ \hline
L4 Cache & 32Mb \ldots~128Mb & $\sim$100ns--200ns\\ \hline
Set Associativity  &  2 \ldots~64 & NA\\ \hline
TL & 4 words \ldots~65536 & 10ns \ldots~50ns\\ \hline
Physical Memory Page & 512 \ldots~8192 & 100ns \ldots~500ns\\ \hline
\rule{0pt}{3.5mm}Virtual Memory & $2^{32}$ bytes \ldots~$2^{64}$ bytes & $\sim$10$\mu$s--50$\mu$s\\ \hline
Solid-State Disc (SSD) & 256Gb \ldots~16Tb & $\sim$25$\mu$s--100$\mu$s\\ \hline
Mechanical Disc & Huge & $\sim$5ms--10ms\\ \hline
Clock Speed & NA & $\sim$4GHz \\ \thickhline
\end{tabular}
}
\end{threeparttable}
\end{center}
\end{table}


\newpage
\section[Delegating Constructors]{Delegating Constructors}\label{delegating-constructors}


Delegating constructors are constructors of a class that delegate initialization to another
constructor of the same class.

\subsection[Description]{Description}\label{description}

A \textbf{delegating constructor} is a constructor of a
\textbf{user-defined type} (i.e., \texttt{class}, \texttt{struct}, or
\texttt{union}) that invokes another constructor defined for the same
\textbf{UDT} as part of its initialization of an object of that type.
The syntax for invoking another constructor within a type is to specify
the name of the type as the only element in the \textbf{member
initializer list}:

\begin{lstlisting}[language=C++]
struct S0
{
int d_i;

S0(int i) : d_i(i)        { }  // non-delegating constructor
S0()      : S0(0)         { }  // OK, delegates to (ù{\codeincomments{S0(int)}}ù)
S0(bool)  : S0(0), d_i(0) { }  // error: delegation must be on its own
};
\end{lstlisting}

\noindent Multiple delegating constructors can be chained together (one calling
exactly one other) so long as cycles are avoided (see
{\it\titleref{ctordelegrating-potential-pitfalls}:} {\it\titleref{delegation-cycles}} on page~\pageref{delegation-cycles}). Once a \emph{target} (i.e., invoked via delegation) constructor returns,
the body of the delegator is invoked:

\begin{lstlisting}[language=C++]
#include <iostream>  // (ù{\codeincomments{std::cout}}ù)

struct S1
{
S1(int, int)            { std::cout << 'a'; }
S1(int)      : S1(0, 0) { std::cout << 'b'; }
S1()         : S1(0)    { std::cout << 'c'; }
};

void f()
{
S1 s;  // OK, prints (ù{\codeincomments{"abc"}}ù) to (ù{\codeincomments{stdout}}ù)
}
\end{lstlisting}

\noindent If an exception is thrown while executing a nondelegating constructor,
the object being initialized is considered only \textbf{partially
constructed} (i.e., the object is not yet known to be in a valid state)
and hence its destructor will \emph{not} be
invoked{\cprotect\footnote{The destructor of a \textbf{partially
constructed} object will not be invoked. However, the destructors of
each successfully constructed base and of data members will still be
invoked:

\begin{lstlisting}[language=C++, basicstyle={\ttfamily\footnotesize}]
#include <iostream>

using std::cout;
struct A { A() { cout << "A() "; } ~A() { cout << "~A() "; } };
struct B { B() { cout << "B() "; } ~B() { cout << "~B() "; } };

struct C : B
{
A d;

C()  { cout << "C() "; throw 0; }  // non-delegating constructor that throws
~C() { cout << "~C() ";         }  // destructor that never gets called
};

void f() try { C c; } catch(int) { }
// prints (ù{\codeincomments{"B() A() C() \textasciitilde A() \textasciitilde B()"}}ù) to (ù{\codeincomments{stdout}}ù)
\end{lstlisting}

\noindent Notice that base-class \texttt{B} and member \texttt{d} of type
\texttt{a} were fully constructed, and so their respective destructors
are called, even though the destructor for class \texttt{C} itself is
never executed.}}:

\begin{lstlisting}[language=C++]
#include <iostream>  // (ù{\codeincomments{std::cout}}ù)

struct S2
{
S2()  { std::cout << "S2() ";  throw 0; }
~S2() { std::cout << "~S2() ";          }
};

void f() try { S2 s; } catch(int) { }
// prints only "(ù{\codeincomments{S2() }}ù)" to (ù{\codeincomments{stdout}}ù) (i.e., the destructor of (ù{\codeincomments{S2}}ù) is never
// invoked)
\end{lstlisting}

\noindent However, if an exception is thrown in the body of a delegating
constructor, the object being initialized is considered \textbf{fully
constructed}, as the target constructor must have returned control to
the delegator; hence the overall object's destructor \emph{will} be
invoked:

\begin{lstlisting}[language=C++]
#include <iostream>  // (ù{\codeincomments{std::cout}}ù)

struct S3
{
S3()           { std::cout << "S3() "              }
S3(int) : S3() { std::cout << "S3(int) "; throw 0; }
~S3()          { std::cout << "~S3() "             }
};

void f() try { S3 s(0); } catch(int) { }
// prints "(ù{\codeincomments{S3() S3(int) \texttt{\~{}}S3() }}ù)" to (ù{\codeincomments{stdout}}ù)
\end{lstlisting}


\subsection[Use Cases]{Use Cases}\label{ctordelegating-use-cases}

\subsubsection[Avoiding code duplication among constructors]{Avoiding code duplication among constructors}\label{avoiding-code-duplication-among-constructors}

Avoiding gratuitous code duplication is considered by many to be a best
practice. Having one ordinary member function call another has always
been an option, but having one constructor invoke another constructor
directly has not. Classic workarounds included repeating the code or
else factoring the code into a private member function that would be
called from multiple constructors. The drawback with this workaround is
that the private method, not being a constructor, would be unable to
make use of \textbf{member initialization lists} to construct base-class
and member objects efficiently. As of C++11, \emph{delegating
constructors} can be used to minimize code duplication when some of
the same operations are performed across multiple constructors without
having to forgo efficient initialization.

As an example, consider an \texttt{IPV4Host} class representing a
network endpoint that can either be constructed by (1) a 32-bit address
and a 16-bit port or (2) an IPV4 string with
\texttt{XXX.XXX.XXX.XXX:XXXXX} format{\cprotect\footnote{Note that
this initial design might itself be suboptimal in that the
representation of the IPV4 address and port value might profitably be
factored out into a separate \textbf{value-semantic} class, say,
\texttt{IPV4Host}, that itself might be constructed in multiple ways;
see {\it\titleref{ctordelegrating-potential-pitfalls}:} {\it\titleref{suboptimal-factoring}} on page~\pageref{suboptimal-factoring}.}}:

\begin{lstlisting}[language=C++]
#include <cstdint>  // (ù{\codeincomments{std::uint16\_t}}ù), (ù{\codeincomments{std::uint32\_t}}ù)

class IPV4Host
{
// ...

public:
IPV4Host(std::uint32_t address, std::uint16_t port)
{
if (!connect(address, port))  // code repetition: BAD IDEA
{
throw ConnectionException{address, port};
}
}

IPV4Host(const std::string& ip)
{
std::uint32_t address = extractAddress(ip);
std::uint16_t port = extractPort(ip);

if (!connect(address, port))  // code repetition: BAD IDEA
{
throw ConnectionException{address, port};
}
}
};
\end{lstlisting}

\noindent Prior to C++11, working around such code duplication would require the
introduction of a separate, subordinate (private) helper function, that
would, in turn, be called by each of the constructors:

\begin{lstlisting}[language=C++]
#include <cstdint>  // (ù{\codeincomments{std::uint16\_t}}ù), (ù{\codeincomments{std::uint32\_t}}ù)

class IPV4Host
{
// ...

private:
void validate(std::uint32_t address, std::uint16_t port)  // helper function
{
if (!connect(address, port))  // factored implementation of needed logic
{
throw ConnectionException{address, port};
}
}

public:
IPV4Host(std::uint32_t address, std::uint16_t port)
{
validate(address, port);  // Invoke factored private helper function.
}

IPV4Host(const std::string& ip)
{
std::uint32_t address = extractAddress(ip);
std::uint16_t port = extractPort(ip);

validate(address, port);  // Invoke factored private helper function.
}
};
\end{lstlisting}

\noindent Alternatively, the constructor accepting a string can be rewritten to
delegate to the one accepting \texttt{address} and \texttt{port},
avoiding repetition without having to delegate to a private function:

\begin{lstlisting}[language=C++]
#include <cstdint>  // (ù{\codeincomments{std::uint16\_t}}ù), (ù{\codeincomments{std::uint32\_t}}ù)

class IPV4Host
{
// ...

public:
IPV4Host(std::uint32_t address, std::uint16_t port)
{
if(!connect(address, port))
{
throw ConnectionException{address, port};
}
}

IPV4Host(const std::string& ip)
: IPV4Host{extractAddress(ip), extractPort(ip)}
{
}
};
\end{lstlisting}

\noindent Compared to the pre-C++11 workaround of introducing a private
\texttt{init} function containing the duplicated logic, use of
delegating constructors results in less boilerplate and fewer run-time
operations, as data members (and base classes) can be initialized
directly through the \textbf{member initialization list}, rather than be
\emph{assigned-to} in the body of \texttt{init} (assuming copy
assignment is even supported on that type), but see
{\it\titleref{ctordelegrating-potential-pitfalls}:} {\it\titleref{suboptimal-factoring}} on page~\pageref{suboptimal-factoring}.

\subsection[Potential Pitfalls]{Potential Pitfalls}\label{ctordelegrating-potential-pitfalls}

\subsubsection[Delegation cycles]{Delegation cycles}\label{delegation-cycles}

If a constructor delegates to itself either directly or indirectly, the
program is \textbf{ill-formed, no diagnostic required}. While some
compilers can detect delegation cycles at compile time, they are not
required (nor necessarily able) to do so. For example, consider a simple
delegation cycle comprising two constructors:

\begin{lstlisting}[language=C++]
struct S  // Object
{
S(int)  : S(true) { }  // delegating constructor
S(bool) : S(0)    { }  // delegating constructor
};
\end{lstlisting}

\noindent Not all popular compilers will warn you that the program above is
ill-formed.{\cprotect\footnote{GCC 10.x does not detect this delegation
cycle at compile time and produces a binary that, if run, will
necessarily exhibit \textbf{undefined behavior}. Clang 10.x, on the
other hand, halts compilation with a helpful error message:

\begin{lstlisting}[language=C++, basicstyle={\ttfamily\footnotesize}]
error: constructor for (ù{\codeincomments{S}}ù) creates a delegation cycle
\end{lstlisting}\vspace*{-1ex}
}} Therefore the programmer is responsible for ensuring that
no delegation cycles are present.

\subsubsection[Suboptimal factoring]{Suboptimal factoring}\label{suboptimal-factoring}

The need for delegating constructors might result from initially
suboptimal factoring --- e.g., in the case where the same \textbf{value}
is being presented in different forms to a variety of different
\textbf{mechanisms}. For example, consider the \texttt{IPV4Host} class
in {\it\titleref{ctordelegating-use-cases}} (which starts on page~\pageref{ctordelegating-use-cases}). While having two constructors to
initialize the host might be appropriate, if either (1) the number of
ways of expressing the same value increases or (2) the number of
consumers of that value increases, we might be well advised to create a
separate \textbf{value semantic} type, e.g., \texttt{IPV4Address}, to
represent that value{\cprotect\footnote{The notion that each component
in a subsystem ideally performs one focused function well is sometimes
referred to as separation of (logical) concerns or
fine-grained (physical) factoring; see \textbf{{lakos20}},
sections 0.4, 3.2.7, and 3.5.9, pp.~20--28, 529--530, and 674--676,
respectively.}}:

\begin{lstlisting}[language=C++]
#include <cstdint>  // (ù{\codeincomments{std::uint16\_t}}ù), (ù{\codeincomments{std::uint32\_t}}ù)

struct IPV4Address
{
std::uint32_t d_address;
std::uint16_t d_port;

IPV4Address(std::uint32_t address, std::uint16_t port)
: d_address{address}, d_port{port}
{
}

IPV4Address(const std::string& ip)
: IPV4Address{extractAddress(ip), extractPort(ip)}
{
}
};
\end{lstlisting}

\noindent Note that \texttt{IPV4Address} itself makes use of delegating
constructors but as a purely private, encapsulated implementation
detail. With the introduction of \texttt{IPV4Address} into the codebase,
\texttt{IPV4Host} (and similar components requiring an
\texttt{IPV4Address} value) can be redefined to have a single
constructor (or other previously overloaded member function) accepting
an \texttt{IPV4Address} object as an argument.

\subsection[Annoyances]{Annoyances}\label{annoyances}

None so far

\subsection[See Also]{See Also}\label{see-also}

None so far

\subsection[Further Reading]{Further Reading}\label{further-reading}

None so far




\newpage
\section[Local Types as Template Arguments]{Local Types as Template Arguments}\label{local-types-as-template-arguments}

Local (i.e., function-scope) and unnamed (e.g., \textit{lambda
expression}, a.k.a. ``closure'') types can, as of C++11, be used (like all other
types) as arguments to templates.

\subsection[Description]{Description}\label{description}

Historically, types without \textbf{linkage} (i.e., local and unnamed
types) were forbidden as template arguments due to implementability
concerns using the compiler technology available at that
time.{\cprotect\footnote{TODO: Alisdair}} Modern C++ lifts this
restriction, making use of local or unnamed types consistent with
nonlocal, named ones, thereby obviating the need to gratuitously name
or enlarge the scope of a type.

\begin{lstlisting}[language=C++]
template <typename T>
void f(T) { };            // function template

template <typename T>
class C { };              // class template

struct { } obj;           // object (ù{\codeincomments{obj}}ù) of unnamed C++ type

void g()
{
struct S { };         // local type

f(S());               // OK in C++11; was error in C++03
f(obj);               // OK in C++11; was error in C++03

C<S>             cs;  // OK in C++11; was error in C++03
C<decltype(obj)> co;  // OK in C++11; was error in C++03
}
\end{lstlisting}

\noindent Notice that we have used the (C++11) {\it \texttt{decltype}
keyword} (see Section~\ref{decltype}, ``\titleref{decltype}") to extract the unnamed type of the object \texttt{obj}.

These new relaxed rules for template arguments are essential to the
ergonomics of {\it lambda expressions} (see Section~\ref{lambda}, ``\titleref{lambda}"), as such types are both
unnamed and local in typical usage:

\begin{lstlisting}[language=C++]
#include <algorithm>  // (ù{\codeincomments{std::sort}}ù)

struct Person { std::string d_name; };

void sortByName(std::vector<Person>& people)
{
std::sort(people.begin(), people.end(),
[](const Person& lhs, const Person& rhs)
{
return lhs.d_name < rhs.d_name;
});
}
\end{lstlisting}

\noindent In the example above, the lambda expression passed to the
\texttt{std::sort} algorithm is a local unnamed type, and the algorithm
itself is a function template.

\subsection[Use Cases]{Use Cases}\label{use-cases}

\subsubsection[Encapsulating a type within a function]{Encapsulating a type within a function}\label{encapsulating-a-type-within-a-function}

Limiting the scope and visibility of an \textbf{entity} to the body of a
function actively prevents its direct use, even when the function body
is exposed widely --- say, as an \texttt{inline} function or function
template defined within a header file.

Consider, for instance, an implementation of Dijkstra's algorithm that
uses a local type to keep track of metadata for each vertex in the input
graph (i.e., the distance of a vertex from the source of the search and
whether a vertex is included in the shortest path or not):

\begin{lstlisting}[language=C++]
// dijkstra.h

inline int dijkstra(std::vector<Vertex>* path, const Graph& graph)
{
struct VertexMetadata         // implementation-specific helper class
{
int  d_distanceFromSource;
bool d_inShortestPath;
};

std::vector<VertexMetadata> vertexMetadata(graph.numNodes());
// standard vector of local (ù{\codeincomments{VertexMetadata}}ù) objects -- one per vertex

// ... (body of algorithm)
}
\end{lstlisting}

\noindent Defining \texttt{VertexMetadata} outside of the body of
\texttt{dijkstra} --- e.g., to comply with C++03 restrictions --- would
make that implementation-specific helper class directly accessible to
anyone including the \texttt{dijkstra.h} header file. As Hyrum's
law{\cprotect\footnote{``With a sufficient number
of users of an API, it does not matter what you promise in the
contract: all observable behaviors of your system will be depended on
by somebody'': see \textbf{wight}.}} suggests, if the
imple\-men\-tation-specific \texttt{VertexMetadata} detail is defined
outside the function body, it is to be expected that some user somewhere
will depend on it in its current form, making it problematic, if not
impossible, to change.\footnote{The C++20 \emph{modules} facility enables the
encapsulation of helper types (such as \texttt{metadata} in the \mbox{\texttt{dijkstra.h}} example on this page) used in
the implementation of other locally defined types or functions, even
when the helper types appear at namespace scope within the module.} Conversely, encapsulating
the type within the function body avoids unintended use by clients,
while improving human cognition by colocating the definition of the
type with its sole purpose.{\cprotect\footnote{For a detailed
discussion of malleable  versus stable software, see \textbf{{lakos20}},
section 0.5, pp.~29-43.}}

\subsubsection[Instantiating templates with local function objects as type arguments]{Instantiating templates with local function objects as type arguments}\label{instantiating-templates-with-local-function-objects-as-type-arguments}

Suppose that we have a program that makes wide use of an aggregate data
type, \texttt{City}:

\begin{lstlisting}[language=C++]
struct City
{
int         d_uniqueId;
std::string d_name;
};
\end{lstlisting}

\noindent Consider now the task of writing a function to print unique elements of
an\linebreak[4] \texttt{std::vector<City>}, ordered by name:

\begin{lstlisting}[language=C++]
void printUniqueCitiesOrderedByName(const std::vector<City>& cities)
{
struct OrderByName
{
bool operator()(const City& lhs, const City& rhs) const
{
return lhs.d_name < rhs.d_name;
// increasing order (subject to change)
}
};

const std::set<City, OrderByName> tmp(cities.begin(), cities.end());

std::copy(tmp.begin(), tmp.end(),
std::ostream_iterator<City>(std::cout, '\n'));
}
\end{lstlisting}

\noindent Absent any countervailing reasons to make the \texttt{OrderByName}
function object more generally available, rendering its definition
alongside the one place where it is used --- i.e., directly within
function scope --- again enforces and readily communicates its tightly
encapsulated (and therefore \emph{malleable}) status.

\subsubsection[Configuring algorithms via lambda expressions]{Configuring algorithms via lambda expressions}\label{configuring-algorithms-via-lambda-expressions}

Suppose we are representing a 3D environment using a \emph{scene
graph}{\cprotect\footnote{A \emph{scene graph} data structure, commonly
used in computer games and 3D-modeling software, represents the
logical and spatial hierarchy of objects in a scene.}} and managing
the graph's nodes via an \texttt{std::vector} of \texttt{SceneNode}
objects. Our \texttt{SceneNode} class supports a variety of
\texttt{const} member functions used to query its status (e.g.,
\texttt{isDirty} and \texttt{isNew}). Our task is to implement a
\textbf{predicate function}, \texttt{mustRecalculateGeometry}, that
returns \texttt{true} if and only if at least one of the nodes is either
``dirty'' or ``new.''

These days, we might reasonably elect to implement this functionality
using the (C++11) standard algorithm
\texttt{std::any\_of}{\cprotect\footnote{\textbf{cppreferencea}}}:

\begin{lstlisting}[language=C++]
template <typename InputIterator, typename UnaryPredicate>
bool any_of(InputIterator first, InputIterator last, UnaryPredicate pred);
// Return (ù{\codeincomments{true}}ù) if any of the elements in the range satisfies (ù{\codeincomments{pred}}ù).
\end{lstlisting}

\noindent Prior to C++11, however, use of a function template, such as
\texttt{any\_of}, would have required a separate function or
function object (defined \emph{outside} of the scope of the function):

\begin{lstlisting}[language=C++]
namespace {

struct IsNodeDirtyOrNew
{
bool operator()(const SceneNode& node) const
{
return node.isDirty() || node.isNew();
}
};

}  // close unnamed namespace

bool mustRecalculateGeometry(const std::vector<SceneNode>& nodes)
{
return std::any_of(nodes.begin(), nodes.end(), IsNodeDirtyOrNew());
}
\end{lstlisting}

\noindent In C++11, not only can we embed the function object within the scope of
the function but, by using a lambda expression, we can
remove much of the boilerplate, including the enclosing \texttt{struct}:

\begin{lstlisting}[language=C++]
bool mustRecalculateGeometry(const std::vector<SceneNode>& nodes)
{
return std::any_of(nodes.begin(),             // start of range
nodes.end(),               // end of range
[](const SceneNode& node)  // lambda expression
{
return node.isDirty() || node.isNew();
}
);
}
\end{lstlisting}

\noindent By creating a \textbf{closure} of unnamed type via a lambda
expression, unnecessary boilerplate, excessive scope, and even local
symbol visibility are avoided.

\subsection[Potential Pitfalls]{Potential Pitfalls}\label{potential-pitfalls}

None so far

\subsection[Annoyances]{Annoyances}\label{annoyances}

None so far

\subsection[See Also]{See Also}\label{see-also}

\begin{itemize}
\item{Section~\ref{lambda}, ``\titleref{lambda}" — Conditionally safe C++11 feature providing strong practical motivation for the relaxations discussed here}
\item{Section~\ref{decltype}, ``\titleref{decltype}" — Safe C++11 feature that allows developers to query the type of any expression or entity, including objects with unnamed types}
\end{itemize}

\subsection[Further Reading]{Further Reading}\label{further-reading}

None so far




\newpage
\section[{\tt long}~{\tt long}]{{\SecCode long}~{\SecCode long}}\label{long-long}


\texttt{long long} is a \textbf{fundamental integral type} guaranteed to have (at least) 64 bits on all
platforms.

\subsection[Description]{Description}\label{description}

The \textbf{integral type} \texttt{long}~\texttt{long} and its companion
type \texttt{unsigned}~\texttt{long}~\texttt{long} are the only two
\textbf{fundamental integral types} in C++ that are guaranteed to have
at least 64~bits on all conforming platforms{\cprotect\footnote{\texttt{long}~\texttt{long}
has been available in C since the C99 standard, and many C++ compilers
supported it as an extension prior to C++11.}}:

\begin{lstlisting}[language=C++]
#include <climits>  // (ù{\codeincomments{CHAR\_BIT}}ù) (a.k.a.~8, see below)

long long          a;  // (ù{\codeincomments{sizeof(a) * CHAR\_BIT >= 64}}ù)
unsigned long long b;  // (ù{\codeincomments{sizeof(b) * CHAR\_BIT >= 64}}ù)

static_assert(sizeof(a) == sizeof(b), "");
// I.e., (ù{\codeincomments{a}}ù) and (ù{\codeincomments{b}}ù) necessarily have the same size in every program.
\end{lstlisting}

\noindent On all conforming platforms, \texttt{CHAR\_BIT} --- the number of bits
in a byte --- is at least~8 and, on virtually all commonly available
commercial platforms today, is exactly~8, as is
\texttt{sizeof(long}~\texttt{long)}.

The corresponding integer-literal suffixes indicating type
\texttt{long}~\texttt{long} are \texttt{ll} and \texttt{LL}; for
\texttt{unsigned}~\texttt{long}~\texttt{long}, any of eight alternatives
are accepted: \texttt{ull}, \texttt{ULL}, \texttt{uLL}, \texttt{Ull},
\texttt{llu}, \texttt{LLU}, \texttt{LLu},
\texttt{llU}{\cprotect\footnote{Note that \texttt{long}~\texttt{long}
and \texttt{unsigned}~\texttt{long}~\texttt{long} are also candidates
for the type of an integer literal having a large enough value. As an
example, the type of the literal \texttt{2147483648} (one more than
the upper bound of a 32-bit integer) is likely to be
\texttt{long}~\texttt{long} on a 32-bit platform.}}:

\begin{lstlisting}[language=C++]
auto i = 0LL;  // (ù{\codeincomments{long long}}ù), (ù{\codeincomments{sizeof(i) * CHAR\_BIT >= 64}}ù)
auto u = 0uLL  // (ù{\codeincomments{unsigned long long}}ù), (ù{\codeincomments{sizeof(u) * CHAR\_BIT >= 64}}ù)
\end{lstlisting}

\noindent For a historical perspective on how integral types have evolved (and
continue to evolve) over time, see {\it\titleref{historical-perspective-on-the-evolution-of-use-of-fundamental-integral-types}} on page~\pageref{historical-perspective-on-the-evolution-of-use-of-fundamental-integral-types}.

\subsection[Use Cases]{Use Cases}\label{use-cases}

\subsubsection[When your pedestrian four-byte {\tt int} might not cut it]{When your pedestrian four-byte {\SubsubsecCode int} might not cut it}\label{when-your-pedestrian-four-byte-int-might-not-cut-it}

Deciding when an \texttt{int} (i.e., exactly 32~bits) is big enough is
often a nonissue. For most common things we deal with day to day ---
miles on our car, years of age, bottles of wine --- having more than about a
billion of them just isn't worth thinking about, at least not in the
interface.{\cprotect\footnote{For efficient storage in a \texttt{class}
or \texttt{struct}, however, we may well decide to represent such
quantities more compactly using a \texttt{short} or \texttt{char}; see
also the aliases found in C++11's \texttt{<cstdint>}.}} Sometimes the size of the virtual address space for the
underlying architecture itself dictates how large an integer you will
need. For example, specifying the \emph{distance} between two pointers
into a contiguous array or the size of the array itself could, on a
64-bit platform, well exceed the size of an \texttt{int} or
\texttt{unsigned}~\texttt{int}, respectively. Using either
\texttt{long}~\texttt{long} or
\texttt{unsigned}~\texttt{long}~\texttt{long} here would, however, not
be indicated as the respective platform-dependent integer types
(\texttt{typedef}s) \texttt{std::ptrdiff\_t} and \texttt{std::size\_t}
are provided expressly for such use (and avoid wasting space where it
cannot be used by the underlying hardware).

Occasionally, however, the decision of whether to use an \texttt{int} is
neither platform dependent nor clear cut, in which case using an
\texttt{int} is almost certainly a bad idea. As part of a financial
library, suppose we were asked to provide a function that, given a date,
returns the number of shares of some particular stock, identified by its
security id (\texttt{SecId}) traded on the New York Stock Exchange
(NYSE).\footnote{The NYSE consists of 2400 different (Equity) securities. The average daily trading volume (the number of shares traded on a given day) on the NYSE is typically  between 2? and 6? billion shares per day, with the maximum volume reaching ??? on ???. (TODO, TBD -- will fill this in much later. NOTE: from Harry: ``it looks like the numbers you are referencing are for the NYSE Composite -- i.e., the volume of all shares traded in companies listed at the NYSE. That number is significantly higher than the number of shares traded on the NYSE exchange. That is because NYSE shares can trade on other exchanges. With that proviso, over the past 5 years, NYSE Composite trading volume has averaged 3.8 billion shares per day. The highest volume day was March 20, 2020, when just over 9 billion shares were traded.")} Since the average daily rate
for even the most heavily traded stocks (roughly 70 million) appears to
be well under the maximum value a signed \texttt{int} supports (more
than 2 billion), we might at first think to write the function
returning an \texttt{int}:

\begin{lstlisting}[language=C++]
int volYMD(SecId equity, int year, int month, int day);  // (1) BAD IDEA
\end{lstlisting}

\noindent One obvious problem with this interface is that the daily fluctuations
in turbulent times might exceed the maximum value representable by a
32-bit \texttt{int}, which, unless detected internally, would result in
\textbf{signed integer overflow}, which is both \textbf{undefined
behavior} and a potential security hole.{\cprotect\footnote{\textbf{Signed
integer overflow} is among the most pervasive kinds of defects
enabling avenues of deliberate attack from outside sources. For an overview of integer overflow in C++, see \textbf{ballman}. For a more focused discussion of secure coding in CPP using CERT standards, see \textbf{seacord13}, section x, pp. yy-zz.}} What's more, the growth rate of some companies,
especially technology companies, such as AAPL, GOOG, FB, AMZN, and MSFT, has
been at times seemingly exponential. To gain an extra
insurance factor of two, we might opt to replace the return type
\texttt{int} with an \texttt{unsigned}~\texttt{int}:

\begin{lstlisting}[language=C++]
unsigned volYND(SecId stock, int year, int month, int day);  // (2) BAD IDEA!
\end{lstlisting}

\noindent Use of an \texttt{unsigned}~\texttt{int}, however, simply delays the
inevitable as the number of shares being traded is almost certainly
going to grow over time.

Furthermore, the algebra for unsigned quantities is entirely different
from what one would normally expect from an \texttt{int}. For example, if we
were to try to express the day-over-day increase in volume by
subtracting two calls to this function and if the number of shares
traded were to have decreased, then the \texttt{unsigned}~\texttt{int}
difference would wrap and the result would be a (typically) large
unsigned \textbf{garbage value}.{\cprotect\footnote{Because integer
literals are themselves of type \texttt{int} and not \texttt{unsigned},
comparing an unsigned value with a negative signed one does not
typically go well; hence, many compilers will warn when the two types
are mixed, which itself is problematic.}}

If we happen to be on a 64-bit platform, we might choose to return a
\texttt{long}:

\begin{lstlisting}[language=C++]
long volYMD(SecId stock, int year, int month, int day);  // (3) NOT A GOOD IDEA
\end{lstlisting}

\noindent The problems using \texttt{long} as the return type are that it (1) is
not (yet) generally considered a \textbf{vocabulary type} (see
{\it\titleref{longlong-appendix}} on page~\pageref{longlong-appendix}), and (2) would reduce portability (see
{\it\titleref{longlong-potential-pitfalls}: \titleref{relying-on-the-relative-sizes-of-int,-long,-and-long-long}} on page~\pageref{relying-on-the-relative-sizes-of-int,-long,-and-long-long}).

Prior to C++11, we might have considered returning a \texttt{double}:

\begin{lstlisting}[language=C++]
double volYMD(SecId stock, int year, int month, int day);  // (4) OK
\end{lstlisting}

\noindent At least with \texttt{double} we know that we will have (at no
additional size) sufficient precision (53 bits) to express
integers accurately into the quadrillions, which will certainly cover us
for any foreseeable future. The main drawback is that \texttt{double}
doesn't properly describe the nature of the type that we are returning
--- i.e., a whole integer number of shares --- and so its algebra,
although not as dubious as \texttt{unsigned}~\texttt{int}, isn't ideal
either.

With the advent of C++11, we might consider using one of the type aliases
in \texttt{<cstdint>}:

\begin{lstlisting}[language=C++]
std::int64_t volYMD(SecId stock, int year, int month, int day);  // (4) OK
\end{lstlisting}

\noindent This choice addresses most of the issues discussed above except that,
instead of being a specific C++ type, it is a platform-dependent alias
that is likely to be a \texttt{long} on a 64-bit platform and almost
certainly a \texttt{long}~\texttt{long} on a 32-bit one. Such exact size
requirements are often necessary for packing data in structures and
arrays but are not as useful when reasoning about them in the
interfaces of functions where having a common set of fundamental
\textbf{vocabulary types} becomes much more important (e.g., for
interoperability).

All of this leads us to our final alternative, \texttt{long}~\texttt{long}:

\begin{lstlisting}[language=C++]
long long volYMD(SecId stock, int year, int month, int day);  // (5) GOOD IDEA
\end{lstlisting}

\noindent In addition to being a signed fundamental integral type of sufficient
capacity on all platforms, \texttt{long}~\texttt{long} is the same C++
type \emph{relative} to other C++ types on all platforms.

\subsection[Potential Pitfalls]{Potential Pitfalls}\label{longlong-potential-pitfalls}

\subsubsection[Relying on the relative sizes of {\tt int}, {\tt long}, and {\tt long}~{\tt long}]{Relying on the relative sizes of {\SubsubsecCode int}, {\SubsubsecCode long}, and {\SubsubsecCode long}~{\SubsubsecCode long}}\label{relying-on-the-relative-sizes-of-int,-long,-and-long-long}

As discussed at some length in {\it\titleref{longlong-appendix}} on page~\pageref{longlong-appendix}, the
fundamental integral types have historically been a moving target. On
older, 32-bit platforms, a \texttt{long} was often 32~bits and, prior to
C++11, a (nonstandard) \texttt{long}~\texttt{long} (or its
platform-dependent equivalent) was needed to ensure that 64~bits were
available. When the correctness of code depends on either
\texttt{sizeof(int)}~\texttt{<}~\texttt{sizeof(long)} or
\texttt{sizeof(long)}~\texttt{<}~\texttt{sizeof(long}~\texttt{long)},
portability is needlessly restricted. Relying instead on only the
guaranteed{\cprotect\footnote{Due to the unfathomable amount of software
that would stop working if an \texttt{int} were ever anything but
exactly \emph{four} bytes, we --- along with the late Richard Stevens
of Unix fame (see \textbf{{stevens93}}, section~2.5.1., pp.~31--32, specifically row~6, column~4, Figure~2.2, p.~32) --- are prepared
to \emph{guarantee} that it will never become as large as a
\texttt{long}~\texttt{long} for any general-purpose computer.}}
property that
\texttt{sizeof(int)} \texttt{<} \texttt{sizeof(long} \texttt{long)}
avoids such portability issues since the relative sizes of the
(fundamental) \texttt{long} and \texttt{long}~\texttt{long} integral
types continue to evolve.

When precise control of size \emph{in the implementation} (as opposed to
in the interface) matters, consider using one of the standard signed
(\texttt{int*n*\_t}) or unsigned (\texttt{uint*n*\_t}) integer aliases
(\texttt{typedef}s) provided (since C++11) in \texttt{<cstdint>} and
summarized here in Table~\ref{longlong-table1}.\newpage

\begin{table}[h!]
\begin{center}
\begin{threeparttable}
\caption{Useful {\ttfamily\bfseries typedef}s found in {\ttfamily\bfseries <cstdint>} (since
C++11)}\label{longlong-table1} \vspace{1.5ex}
{\small \begin{tabular}{c|c|c}\thickhline
\rowcolor[gray]{.9} {\sffamily\bfseries Exact Size} & {\sffamily\bfseries Fastest (signed) integral type } & {\sffamily\bfseries Smallest (signed) integer type }\\
\rowcolor[gray]{.9}  & {\sffamily\bfseries having at least N bits} & {\sffamily\bfseries  having at least N bits}\\\hline
{\tt int8\_t} & {\tt int\_fast8\_t} & {\tt int\_least8\_t}\\ \hline
{\tt int16\_t}\tnote{a} & {\tt int\_fast16\_t} & {\tt int\_least16\_t}\\ \hline
{\tt int32\_t} & {\tt int\_fast32\_t} & {\tt int\_least32\_t}\\ \hline
{\tt int64\_t} & {\tt int\_fast64\_t} & {\tt int\_least64\_t}\\ \thickhline
\end{tabular} }
\begin{tablenotes}{\footnotesize
\item[a]{optional\\
Note: Also see {\tt intmax\_t}, the maximum width integer type, which might be none of the above.}
}
\end{tablenotes}
\end{threeparttable}
\end{center}
\end{table}

\subsection[See Also]{See Also}\label{see-also}

\begin{itemize}
\item{Section~\ref{digit-separators}, ``\titleref{digit-separators}" — Safe C++11 feature that can help with visually separating digits of large \texttt{long}~\texttt{long} literals}
\item{Section~\ref{binary-literals}, ``\titleref{binary-literals}" — Safe C++11 feature that allows programmers to specify binary constants directly in the source code; large binary values might only fit in a \texttt{long}~\texttt{long} or even \texttt{unsigned}~\texttt{long}~\texttt{long}}
\end{itemize}

\subsection[Further Reading]{Further Reading}\label{further-reading}

None so far

\subsection[Appendix: Historical Perspective on the Evolution of Use of Fundamental Integral Types]{Appendix: Historical Perspective on the Evolution of Use of Fundamental Integral Types}\label{longlong-appendix}
\label{historical-perspective-on-the-evolution-of-use-of-fundamental-integral-types}

The designers of C got it right back in 1972 when
they created a portable \texttt{int} type that could act as a bridge
from a single-word (16-bit) integer, \texttt{short}, to a double-word
(32-bit) integer, \texttt{long}. Just by using \texttt{int}, one would
get the optimal space versus speed trade-off as the 32-bit computer \emph{word}
was on its way to becoming the norm.{\cprotect\footnote{The Motorola
68000 series (c.~1979) was a hybrid \emph{CISC} architecture employing
a 32-bit instruction set with 32-bit registers and a 32-bit external
data bus; internally, however, it used only 16-bit ALUs and a 16-bit
data bus.}}

During the late 1980s and into the 1990s, the word size of the machine and
the size of an \texttt{int} were synonymous.{\cprotect\footnote{Some of
the earlier mainframe computers, such as IBM 701 (c.~1954), had a word
size of 36 characters (1) to allow accurate representation of a signed
10-digit decimal number or (2) to hold up to six 6-bit characters.
Smaller computers, such as Digital Equipment Corporation's
PDP-1/PDP-9/PDP-15 used 18-bit words (so a double word held 36-bits);
memory addressing, however, was limited to just 12--18 bits (i.e., a
maximum 4K--256K 18-bit words of \emph{DRAM}). With the standardization
of 7-bit ASCII (c.~1967), its adoption throughout the 1970s, and its most
recent update (c.~1986), the common typical notion of character size
moved from 6 to 7 bytes. Some early conforming implementations (of C)
would choose to set \texttt{CHAR\_BIT} to 9 to allow two characters
per half word. (On some early vector-processing computers,
\texttt{CHAR\_BIT} is 32, making every type, including a
\texttt{char}, at least a 32-bit quantity.) As double-precision
floating (and floating-point coprocessors) for type \texttt{double}
became typical for scientific calculations, machine architectures
naturally evolved from 9-, 18-, and 36-bit words to the familiar 8-,
16-, 32-, and now 64-bit addressable integer words we have today.
Apart from embedded systems and \emph{DSPs}, a \texttt{char} is now
almost universally considered to be exactly 8 bits. Instead of
scrupulously and actively using \texttt{CHAR\_BIT} for the number of bits
in a \texttt{char}, consider statically asserting it instead:

\begin{lstlisting}[language=C++, basicstyle={\ttfamily\footnotesize}]
static_assert(CHAR_BIT == 8, "A (ù{\codeincomments{char}}ù) is not 8-bits on this CrAzY platform!");
\end{lstlisting}\vspace*{-1ex}
}} As cost of \emph{main memory} was decreasing exponentially
throughout the final two decades of the 20th
century,{\cprotect\footnote{Moore's law (c.~1965) --- the observation
that the number of transistors in densely packed integrated circuits
(e.g., DRAM) grows exponentially over time, doubling every 1--2 years
or so --- held for nearly a half century, until finally saturating in
the 2010s.}} the need for a much larger \emph{virtual address space}
quickly followed. Intel began its work on 64-bit architectures in the
early 1990s and realized one a decade later. As we progressed into
the 2000s, the common notion of \emph{word size} --- i.e., the width (in
bits) of typical registers within the CPU itself --- began to shift from
``the size of an \texttt{int}'' to ``the size of a simple (nonmember)
pointer type,'' e.g., \texttt{8}~\texttt{*}~\texttt{sizeof(void*)}, on the host platform. By this time, 16-bit \texttt{int} types (like
16-bit architectures) were long gone, but \texttt{long} was still
expected to be 32 bits on a 32-bit platform.{\cprotect\footnote{Sadly,
\texttt{long} was often used (improperly) to hold an address; hence,
the size of {\tt long} is associated with a de facto need (due to immeasurable amounts of legacy code) to remain in lockstep with pointer size.}}

Something new was needed to mean at least 64-bits on all platforms.
Enter \texttt{long}~\texttt{long}. We have now come full circle. On
64-bit platforms, an \texttt{int} is still 4~bytes, but a \texttt{long}
is now --- for practical reasons --- typically 8~bytes unless requested
explicitly{\cprotect\footnote{On 64-bit systems, \texttt{sizeof(long)}
is typically 8~bytes. Compiling with the \texttt{-m32} flag on either
GCC or Clang emulates compiling on a 32-bit platform:
\texttt{sizeof(long)} is likely to be~4, while
\texttt{sizeof(long}~\texttt{long)} remains~8.}} to be otherwise. To ensure portability until 32-bit machines go the way of 16-bit ones,
we have \texttt{long}~\texttt{long} to (1) provide a common \emph{vocabulary type}, (2)
make our intent clear, and (3) avoid the portability issue for
at least the next decade or two; still, see {\it\titleref{longlong-potential-pitfalls}: \titleref{relying-on-the-relative-sizes-of-int,-long,-and-long-long}} on page~\pageref{relying-on-the-relative-sizes-of-int,-long,-and-long-long} for some alternative ideas.




\newpage
\section[Alias Declarations and Alias Templates]{Alias Declarations and Alias Templates}\label{alias-declarations-and-alias-templates}


Alias declarations and alias templates provide an expanded use of the
\texttt{using} keyword, offering an alternative syntax (to
\texttt{typedef}) for creating a \textbf{type alias} that can itself be
a template.

\subsection[Description]{Description}\label{description}

The keyword \texttt{using} has historically supported the introduction
of an alias for a named entity (e.g., type, function, or data) from some
named scope into the current one; see {\it\titleref{appendix:-brief-review-of-(c++03)-using-declarations}} on page~\pageref{appendix:-brief-review-of-(c++03)-using-declarations}. As of C++11, we can
employ the \texttt{using} keyword to achieve everything that could
previously be accomplished with a \texttt{typedef} declaration but in a
syntactic form that many people find more natural and intuitive (but
that offers nothing profoundly new):

\begin{lstlisting}[language=C++]
using Type1 = int;     // equivalent to (ù{\codeincomments{typedef int Type1;}}ù)
using Type2 = double;  // equivalent to (ù{\codeincomments{typedef double Type2;}}ù)
\end{lstlisting}

\noindent In contrast to \texttt{typedef}, the name of the synonym created via the
\texttt{using} syntax always appears on the left side of the \texttt{=}
token and separate from the type declaration itself --- the advantage of
which becomes apparent with more involved types, such as
\emph{pointer-to-functions}, \emph{pointer-to-member-function}, or
\emph{pointer-to-data-member}:

\begin{lstlisting}[language=C++]
struct S { int i; void f(); };  // user-defined type (ù{\codeincomments{S}}ù) defined at file scope

using Type3 = void(*)();        // equivalent to (ù{\codeincomments{typedef void(*Type3)();}}ù)
using Type4 = void(S::*)();     // equivalent to (ù{\codeincomments{typedef void(S::*Type4)();}}ù)
using Type5 = int S::*;         // equivalent to (ù{\codeincomments{typedef int S::*Type5;}}ù)
\end{lstlisting}

\noindent Just as with a \texttt{typedef}, the name representing the type can be
qualified, but the symbol representing the synonym cannot:

\begin{lstlisting}[language=C++]
namespace N { struct S { }; }  // original type (ù{\codeincomments{S}}ù) defined with namespace (ù{\codeincomments{N}}ù)

using Type6 = N::S;            // equivalent to (ù{\codeincomments{typedef N::S Type6;}}ù)
using ::Type7 = int;           // Error: the alias's name must be unqualified.
\end{lstlisting}

\noindent Unlike a \texttt{typedef}, however, a type alias employing
\texttt{using} can itself be a template, known as an \emph{alias
template}:

\begin{lstlisting}[language=C++]
template <typename T>
using Type8 = T;  // "identity" alias template

Type8<int>    i;  // equivalent to (ù{\codeincomments{int i;}}ù)
Type8<double> d;  // equivalent to (ù{\codeincomments{double d;}}ù)
\end{lstlisting}

\noindent Note, however, that neither partial nor explicit specialization of alias
templates is supported:

\begin{lstlisting}[language=C++]
template <typename, typename>   // general alias template
using Type9 = char;             // OK

template <typename T>           // attempted partial specialization of above
using Type9<T, int> = char;     // error: expected (ù{\codeincomments{=}}ù) before (ù{\codeincomments{<}}ù) token

template <>                     // attempted full specialization of above
using Type10<int, int> = char;  // error: expected unqualified-id before (ù{\codeincomments{using}}ù)
\end{lstlisting}

\noindent Used in conjunction with existing class templates, alias templates allow
programmers to \emph{bind} one or more template parameters to a fixed
type, while leaving others open:

\begin{lstlisting}[language=C++]
#include <utility>  // (ù{\codeincomments{std::pair}}ù)

template <typename T>
using PairOfCharAnd = std::pair<char, T>;
// alias template that binds (ù{\codeincomments{char}}ù) to the first type parameter of (ù{\codeincomments{std::pair}}ù)

PairOfCharAnd<int>    pci;  // equivalent to (ù{\codeincomments{std::pair<char, int> pci;}}ù)
PairOfCharAnd<double> pcd;  // equivalent to (ù{\codeincomments{std::pair<char, double> pcd;}}ù)
\end{lstlisting}

\noindent Finally, note that the equivalent functionality of alias templates can be
achieved in C++03, though with additional boilerplate code at both the
point of definition and the call site:

\begin{lstlisting}[language=C++]
template <typename T>
struct PairOfCharAnd
// template class holding an alias, (ù{\codeincomments{Type}}ù), to (ù{\codeincomments{std::pair<char, T>}}ù)
{
typedef std::pair<char, T> Type;
// type alias binding (ù{\codeincomments{char}}ù) to the first type parameter of (ù{\codeincomments{std::pair}}ù)
};

PairOfCharAnd<int>::Type    pci;  // equivalent to (ù{\codeincomments{std::pair<char, int> pci;}}ù)
PairOfCharAnd<double>::Type pcd;  // equivalent to (ù{\codeincomments{std::pair<char, double> pcd;}}ù)
\end{lstlisting}


\subsection[Use Cases]{Use Cases}\label{use-cases}

\subsubsection[Simplifying convoluted {\tt typedef} declarations]{Simplifying convoluted {\SubsubsecCode typedef} declarations}\label{simplifying-convoluted-typedef-declarations}

Complex \texttt{typedef} declarations involving pointers to functions,
member functions, or data members require looking in the middle of the
declaration to find the alias name. As an example, consider a
\emph{callback} type alias intended to be used with asynchronous functions:

\begin{lstlisting}[language=C++]
typedef void(*CompletionCallback)(void* userData);
\end{lstlisting}

\noindent Developers coming from a background other than C or C++03 might find the
above declaration hard to parse since the name of the alias
(\texttt{CompletionCallback}) is embedded in the function pointer type.
Replacing \texttt{typedef} with \texttt{using} results in a simpler,
more consistent formulation of the same alias:

\begin{lstlisting}[language=C++]
using CompletionCallback = void(*)(void* userData);
\end{lstlisting}

\noindent The \texttt{CompletionCallback} alias declaration (above) reads almost
completely left-to-right,{\cprotect\footnote{In order to make the
\texttt{CompletionCallback} alias read left-to-right, a
trailing return (see Section~\ref{trailing-function-return-types}, ``\titleref{trailing-function-return-types}") can be used:

\begin{lstlisting}[language=C++, basicstyle={\ttfamily\footnotesize}]
using CompletionCallback = auto(*)(void* userData) -> void;
\end{lstlisting}\vspace*{-1ex}

\noindent The alias declaration above can be read as,
``\texttt{CompletionCallback} is an alias for a pointer to a
function taking a \texttt{void*} parameter named \texttt{userData} and
returning \texttt{void}.''}} and the name of the alias is clearly
specified after the \texttt{using} keyword.

\subsubsection[Binding template arguments]{Binding template arguments}\label{binding-template-arguments}

An alias template can be used to \emph{bind} one or more template
parameters of, say, a commonly used class template, while leaving the
other parameters open to variation. Suppose, for example, we have a class, \texttt{UserData}, that contains
several (e.g., four) distinct instances of \texttt{std::map} --- each
having the same key type, \texttt{UserId}, but with different payloads:

\begin{lstlisting}[language=C++]
class UserData  // class having excessive code repetition (BAD IDEA)
{
private:
std::map<UserId, Message>          d_messages;
std::map<UserId, Photos>           d_photos;
std::map<UserId, Article>          d_articles;
std::map<UserId, std::set<UserId>> d_friends;
};
\end{lstlisting}

\noindent The example above, though clear and regular, involves significant
repetition, making it more difficult to maintain should we later opt to
change data structures. If we were to instead use an \textbf{alias
template} to bind the \texttt{UserId} type to the first type
parameter of \texttt{std::map}, we could both (1) reduce code repetition
and (2) enable the programmer to consistently replace \texttt{std::map}
to another container
(e.g., \texttt{std::unordered\_map}{\cprotect\footnote{An
\texttt{std::unordered\_map} is an STL container type that became
available on all conforming platforms along with C++11. The
functionality is similar except that, since it is not required to
support ordered traversal or (worst case) \texttt{O[log(n)]} lookups
and \texttt{O[n*log(n)]} insertions, \texttt{std::unordered\_map} can
be implemented as a hash table instead of a balanced tree, yielding
significantly faster average access times. See
\textbf{cppreferenceb}.}}) by performing the change in only
one place:

\begin{lstlisting}[language=C++]
class UserData  // class with well-factored implementation (GOOD IDEA)
{
private:
template <typename V>                  // using a template alias to bind
using Mapping = std::map<UserId, V>;   // (ù{\codeincomments{UserId}}ù) as the key type

Mapping<Message>          d_messages;
Mapping<Photos>           d_photos;
Mapping<Article>          d_articles;
Mapping<std::set<UserId>> d_friends;
};
\end{lstlisting}


\subsubsection[Providing a shorthand notation for type traits]{Providing a shorthand notation for type traits}\label{providing-a-shorthand-notation-for-type-traits}

Alias templates can provide a shorthand notation for \textbf{type
traits}, avoiding \textbf{boilerplate code} in the usage site. As an
example, consider a simple type trait that adds a pointer to a given
type (akin to \texttt{std::add\_pointer}):

\begin{lstlisting}[language=C++]
template <typename T>
struct AddPointer
{
typedef T* Type;
};
\end{lstlisting}

\noindent To use the trait above, the \texttt{AddPointer} class template
must be instantiated and its nested \texttt{Type} alias must be
accessed by prepending the \texttt{typename} keyword:

\begin{lstlisting}[language=C++]
void f()
{
int i;
typename AddPointer<int>::Type p = &i;
}
\end{lstlisting}

\noindent The syntactical overhead of \texttt{AddPointer} can be removed by
creating an alias template for its nested type alias, such as
\texttt{AddPointer\_t}{\cprotect\footnote{Note that, since C++14, all
the standard type traits defined in the \texttt{<type\_traits>} header
provide a corresponding alias template with the goal of reducing
boilerplate code. For instance, C++14 introduces the
\texttt{std::remove\_reference\_t} alias template for the C++11
\texttt{std::remove\_reference} type trait:

\begin{lstlisting}[language=C++, basicstyle={\ttfamily\footnotesize}]
typename std::remove_reference<int&>::type i0 = 5; // OK in both C++11 and C++14
std::remove_reference_t<int&> i1 = 5;              // OK in C++14
\end{lstlisting}
}}:

\begin{lstlisting}[language=C++]
template <typename T>
using AddPointer_t = typename AddPointer<T>::Type;
\end{lstlisting}

\noindent Using \texttt{AddPointer\_t} instead of \texttt{AddPointer} results in
shorter code devoid of boilerplate:

\begin{lstlisting}[language=C++]
void g()
{
int i;
AddPointer_t<int> p = &i;
}
\end{lstlisting}


\subsection[Potential Pitfalls]{Potential Pitfalls}\label{potential-pitfalls}

None so far

\subsection[Annoyances]{Annoyances}\label{annoyances}

None so far

\subsection[See Also]{See Also}\label{see-also}

\begin{itemize}
\item{Section~\ref{ctorinheriting}, ``\titleref{ctorinheriting}" — Safe C++11 feature providing another meaning for the \texttt{using} keyword to allow base-class constructors to be invoked as part of the derived class}
\item{Section~\ref{trailing-function-return-types}, ``\titleref{trailing-function-return-types}" — Safe C++11 feature providing an alternative syntax for function declaration, which can help improve readability in type aliases and alias templates involving function types}
\end{itemize}

\subsection[Further Reading]{Further Reading}\label{further-reading}

None so far

\subsection[Appendix: Brief Review of (C++03) {\tt using} Declarations]{Appendix: Brief Review of (C++03) {\SubsecCode using} Declarations}\label{appendix:-brief-review-of-(c++03)-using-declarations}

The \texttt{using} keyword serves another, similar purpose: It introduces an
alias for a (named) entity from a distinct (named) scope into the
current scope. The first usage category for employing \texttt{using} to
create local aliases is with respect to other namespaces:

\begin{lstlisting}[language=C++]
namespace N  // namespace containing various named constructs
{
void f();        // (0) overloaded function (ù{\codeincomments{f}}ù) declared at namespace scope
void f(int);     // (1)      "        "      "      "    "      "       "
void f(double);  // (2)      "        "      "      "    "      "       "
void g();        // (3) function (ù{\codeincomments{g}}ù) declared at namespace scope
void h();        // (4)     "    (ù{\codeincomments{h}}ù)    "      "     "       "
int x;           // (5) integer variable (ù{\codeincomments{x}}ù) declared at namespace scope
int y;           // (6)      "      "     (ù{\codeincomments{y}}ù)     "     "     "      "
class C;         // (7) class (ù{\codeincomments{C}}ù) declared but not defined at namespace scope
};

void h();           // (8) function (ù{\codeincomments{h}}ù) declared at file (aka global) scope

void client1()      // client illustrating usage w.r.t. namespaces
{
N::f();         // OK, invokes (0) above
N::f(1);        // OK, invokes (1) above
N::f(2.0);      // OK, invokes (2) above
f(2.0);         // Error: function (ù{\codeincomments{f}}ù) is not found.
using N::f();   // Error: using must apply to all overloads at once.
using N::f;     // OK, creates local aliases for all three (ù{\codeincomments{f}}ù) overloads
f();            // OK, invokes (0) above
f(1);           // OK, invokes (1) above
f(2.0);         // OK, invokes (2) above

x = 3;          // error: variable (ù{\codeincomments{x}}ù) not found
N::x = 3;       // OK, assigns 3 to (5) above

using N::x;     // OK, creates local alias for (ù{\codeincomments{x}}ù)
x = 4;          // OK, assigns 4 to (5) above
y = 5;          // error: variable (ù{\codeincomments{y}}ù) not found
g();            // error: function (ù{\codeincomments{g}}ù) not found
C *p;           // error: Class (ù{\codeincomments{C}}ù) not found
N::C *p;        // OK, creates pointer (ù{\codeincomments{p}}ù) to incomplete type (ù{\codeincomments{C}}ù) (8) above

using namespace N;
// OK, create local aliases for all named entities in (ù{\codeincomments{namespace}}ù) (ù{\codeincomments{N}}ù).

y = 6;         // OK, assigns 6 to (6) above
g();           // OK, invokes (3) above
h();           // Error: alias for (ù{\codeincomments{h}}ù) is ambiguous; (4) or (8) above.
::h();         // OK, invokes (4) above
N::h();        // OK, invokes (8) above
C *q;          // // OK, creates pointer (ù{\codeincomments{q}}ù) to incomplete type (ù{\codeincomments{C}}ù) (8) above
}
\end{lstlisting}

\noindent The second usage category for employing \texttt{using} to create local
aliases is with respect to \texttt{public} (or \texttt{protected})
members of \emph{privately} (or \emph{protectedly}) inherited base
classes into a \texttt{public} (or \texttt{protected}) region of the
derived class{\cprotect\footnote{The alternatives, shown here in
parentheses, are provided for technical accuracy but are unlikely to
be useful in practice.}}:

\begin{lstlisting}[language=C++]
struct B   // base class having various (ù{\codeincomments{public}}ù) named entities
{
void fb();         // (10) overloaded member function
void fb(int);      // (11)     "        "       "
void fb(double);   // (12)     "        "       "
void gb();         // (13) member function
static void hb();  // (14) static member function
typedef int Tb;    // (15) type alias for an integer
int xb;            // (16) integer data member
int yb;            // (17) integer data member
};

struct D : private B  // class aliasing private constructs via (ù{\codeincomments{using}}ù)
{
using B::fb;      // local aliases for all three overloads of (ù{\codeincomments{fb}}ù)
using B::hb;      // local alias for (ù{\codeincomments{static}}ù) member function (ù{\codeincomments{hb}}ù)
using B::xb;      // local alias for (ù{\codeincomments{int}}ù) data member (ù{\codeincomments{xb}}ù)
using B::Tb;      // local alias for (ù{\codeincomments{int}}ù) type alias

protected:
using B::yb;      // (ù{\codeincomments{protected}}ù) local alias for (ù{\codeincomments{int}}ù) data member (ù{\codeincomments{yb}}ù)
};

void client2()  // client illustrating usage w.r.t. inheritance
{
D d;        // Create an instance of derived type (ù{\codeincomments{D}}ù).
d.fb();     // OK, alias created by (ù{\codeincomments{using B::fb}}ù)  invokes (10) above.
d.fb(1);    // OK,   "     "     "     "     "     invokes (11) above.
d.fb(2.0);  // OK,   "     "     "     "     "     invokes (12) above.
d.gb();     // Error: (ù{\codeincomments{gb}}ù) is privately inherited without using declaration.
d.hb();     // OK, alias created by (ù{\codeincomments{using B::hb}}ù)  invokes (14) above.
D::hb();    // OK,   "      "    "     "     "     invokes (14) above.
D::Tb i;    // OK,   "      "    "     "  (ù{\codeincomments{B::Tb}}ù)  aliases (15) above.
D::xb = 1;  // OK,   "      "    "     "  (ù{\codeincomments{B::xb}}ù)  assigns (16) above.
D::yb = 1;  // Error, using for (ù{\codeincomments{yb}}ù) is (ù{\codeincomments{protected}}ù), not (ù{\codeincomments{public}}ù).
}
\end{lstlisting}

\noindent Finally, for completeness, we note that the using directive for
\texttt{yb} in the \texttt{protected} region of \texttt{D} leaves the
local alias for \texttt{yb} in \texttt{D} accessible to classes that are
derived from \texttt{D}:

\begin{lstlisting}[language=C++]
struct DD : D  // doubly derived class accessing protected alias
{
DD(int v) { yb = v };
// OK, (ù{\codeincomments{using yb}}ù) in (ù{\codeincomments{D}}ù) exposes (ù{\codeincomments{protected}}ù) alias; assigns (17).
};
\end{lstlisting}




\newpage
\section[Explicit Conversions]{Explicit Conversion Operators\sectionmark{Explicit Conversions}}\label{explicit-conversion-operators}\sectionmark{Explicit Conversions}


Ensure that a (user-defined) type is convertible to another type only in
contexts where the conversion is made obvious in the code.

\subsection[Description]{Description}\label{description-explicitconv}

Though sometimes desirable, implicit conversions achieved via (user-defined) \emph{conversion
functions} --- either (1) \textbf{converting constructors} (accepting a
single argument) or (2) \textbf{conversion operators} --- can also be problematic, especially when the
conversion involves a commonly used type (e.g., \texttt{int} or
\texttt{double}){\cprotect\footnote{Use of a conversion operator to
calculate distance from the origin in this unrealistically simple \texttt{Point}
example is for didactic purposes only. In practice, we would typically
use a named function for this purpose; see {\it\titleref{potential-pitfalls-explicitconv}: \titleref{sometimes-a-named-function-is-better}} on page~\pageref{sometimes-a-named-function-is-better}.}}:

\begin{lstlisting}[language=C++]
class Point  // implicitly convertible from an (ù{\codeincomments{int}}ù) or to a (ù{\codeincomments{double}}ù)
{
int d_x, d_y;

public:
Point(int x = 0, int y = 0);  // default, conversion, & value constructor
// ...
operator double() const;  // Return distance from origin as a (ù{\codeincomments{double}}ù).
};
\end{lstlisting}

\noindent As ever, calling a function \texttt{g} that takes a \texttt{Point} but
accidentally passing an \texttt{int} can lead to surprises:

\begin{lstlisting}[language=C++]
void g0(Point p);         // arbitrary function taking a (ù{\codeincomments{Point}}ù) object by value
void g1(const Point& p);  // arbitrary function taking a (ù{\codeincomments{Point}}ù) by (ù{\codeincomments{const}}ù) reference

void f1(int i)
{
g0(i);  // oops, called (ù{\codeincomments{g0}}ù) with (ù{\codeincomments{Point(i, 0)}}ù) by mistake
g1(i);  // oops, called (ù{\codeincomments{g1}}ù) with (ù{\codeincomments{Point(i, 0)}}ù) by mistake
}
\end{lstlisting}

\noindent This problem could have been solved even in C++98 by declaring the
constructor to be \texttt{explicit}:

\begin{lstlisting}[language=C++]
explicit Point(int x = 0, int y = 0);  // explicit converting constructor
\end{lstlisting}

\noindent If the conversion is desired, it must now be specified explicitly:

\begin{lstlisting}[language=C++]
void f2(int i)
{
g0(i)          // error: could not convert (ù{\codeincomments{i}}ù) from (ù{\codeincomments{int}}ù) to (ù{\codeincomments{Point}}ù)
g1(i);         // error: invalid initialization of reference type
g0(Point(i));  // OK
g1(Point(i));  // OK
}
\end{lstlisting}

\noindent The companion problem stemming from an \emph{implicit conversion
operator}, albeit less severe, remained:

\begin{lstlisting}[language=C++]
void h(double d);

double f3(const P& p)
{
h(p);      // OK? Or maybe called (ù{\codeincomments{h}}ù) with a "hypotenuse" by mistake
return p;  // OK? Or maybe this is a mistake too.
}
\end{lstlisting}

\noindent As of C++11, we can now use the \textbf{\texttt{explicit} specifier}
when declaring \textbf{conversion operators} (as well as
\textbf{converting constructors}), thereby forcing the client to request
conversion explicitly --- e.g., using \textbf{direct initialization} or
\texttt{static\_cast}):

\begin{lstlisting}[language=C++]
struct S0 { explicit operator int(); };

void g()
{
S0 s0;
int i = s0;                    // error (copy initialization)
double d = s0;                 // error (copy initialization)
int j = static_cast<int>(s0);  // OK (static cast)
if (s0) { }                    // error (contextual conversion to (ù{\codeincomments{bool}}ù))
int k(s0);                     // OK (direct initialization)
double e(s0);                  // error (direct initialization)
}
\end{lstlisting}

\noindent In contrast, had the conversion operator above not been declared to be
\texttt{explicit}, all conversions shown above would compile:

\begin{lstlisting}[language=C++]
struct S1 { /* implicit */ operator int(); };

void f()
{
S1 s1;
int i = s1;                    // OK (copy initialization)
double d = s1;                 // OK (copy initialization)
int j = static_cast<int>(s1);  // OK (static cast)
if (s1) { }                    // OK (contextual conversion to (ù{\codeincomments{bool}}ù))
int k(s1);                     // OK (direct initialization)
double e(s1);                  // OK (direct initialization)
}
\end{lstlisting}

\noindent Additionally, the notion of \textbf{contextual convertibility to
\texttt{bool}}{\cprotect\footnote{Since the early days of C++, a common
idiom to test for validity of an object has been to use it in a
context where it can (implicitly) convert itself to a type whose value
can be interpreted (contextually) as a boolean, with \texttt{true}
implying validity (and \texttt{false} otherwise). Implicit conversion
to \texttt{bool} (an integral type) was considered too dangerous,
so the cumbersome \textbf{safe-\texttt{bool} idiom} was used instead,
converting to a type that --- while contextually convertible to
\texttt{bool} --- could not (by design) participate in any other
operations. While making the conversion to \texttt{bool} (or
\texttt{const}~\texttt{bool}) \texttt{explicit} solves the safety
issue, the benefit of the idiom would be entirely lost if an explicit
cast would have to be performed to test for validity. To address this,
C++11 extends contextual conversion to \texttt{bool} for a given
expression \texttt{E} to include an application of
\texttt{static\_cast<const}~\texttt{volatile}~\texttt{bool>} to
\texttt{E}, thus enabling explicit conversion to \texttt{bool} to be
used in lieu of the (now deprecated) \textbf{safe-\texttt{bool} idiom}; see
\textbf{{sharpe13}}.}} applicable to arguments of logical operations
(e.g., \texttt{\&\&}, \texttt{||}, and \texttt{!}) and conditions of
most control-flow constructs (e.g., \texttt{if}, \texttt{while}) was
extended in C++11 to admit \emph{explicit} (user-defined) \texttt{bool}
conversion operators (see {\it\titleref{use-cases-explicitconv}: \titleref{enabling-contextual-conversions-to-bool-as-a-test-for-validity}} on page~\pageref{enabling-contextual-conversions-to-bool-as-a-test-for-validity}):

\begin{lstlisting}[language=C++]
struct S2 { explicit operator bool(); };

void h()
{
S2 s2;
int i = s2;                    // error (copy initialization)
double d = s2;                 // error (copy initialization)
int j = static_cast<int>(s2);  // error (static cast)
if (s2) { }                    // OK (contextual conversion to (ù{\codeincomments{bool}}ù))
int k(s2);                     // error (direct initialization)
double fd(s2);                 // error (direct initialization)
}
\end{lstlisting}

\noindent Prior to C++11, essentially the same effect as having an \emph{explicit}
\texttt{operator}~\texttt{bool()} member was achieved (albeit far less
conveniently) via the \textbf{safe-\texttt{bool} idiom}.

\subsection[Use Cases]{Use Cases}\label{use-cases-explicitconv}

\subsubsection[Enabling contextual conversions to {\tt bool} as a test for validity]{Enabling contextual conversions to {\SubsubsecCode bool} as a test for validity}\label{enabling-contextual-conversions-to-bool-as-a-test-for-validity}

Having a conventional test for validity that involves testing whether the object itself evaluates to \texttt{true} or \texttt{false} is an idiom that goes back to the
origins of C++. The \texttt{<iostream>} library, for example, uses this
idiom to determine if a given stream is valid:

\begin{lstlisting}[language=C++]
// C++03
#include <iostream>  // (ù{\codeincomments{std::ostream}}ù)

std::ostream& printTypeValue(std::ostream& stream, double value)
{
if (stream)  // relies on an implicit conversion to (ù{\codeincomments{bool}}ù)
{
stream << "double(" << value << ')';
}
else
{
// ... (handle stream failure)
}

return stream;
}
\end{lstlisting}

\noindent Implementing the implicit conversion to \texttt{bool} was, however,
problematic as the straight\-forward approach of using a
\textbf{conversion operator} could easily allow accidental misuse to go
undetected:

\begin{lstlisting}[language=C++]
class ostream
{
// ...

/* implicit */ operator bool();  // hypothetical (bad) idea
};

int client(std::ostream& out)
{
// ...
return out + 1;  // likely a latent runtime bug: always returns 1 or 2
}
\end{lstlisting}

\noindent The classic workaround, the \textbf{safe-\texttt{bool} idiom},
was to return some obscure pointer\linebreak[4] %%%%%
type (e.g., \textbf{pointer to
member}) that could not possibly be useful in any context other\linebreak[4] %%%%%
than one in which \texttt{false} and a null pointer-to-member value (e.g.,\linebreak[4] %%%%%
\texttt{static\_cast<(ostream*::operator}~\texttt{bool)()>(0)}) are
treated equivalently.

When implementing this idiom in a user-defined type ourselves, we need not go to such lengths to avoid inviting unintended use
via an \emph{implicit} conversion to \texttt{bool}. As discussed in \textit{\titleref{description-explicitconv}} on page~\pageref{description-explicitconv}, a conversion operator to type
\texttt{bool} that is declared \texttt{explicit} continues to act as if
it were \emph{implicit} only in those places where we might want it to
do so and nowhere else --- i.e., exactly those places that enable
\textbf{contextual conversion to \texttt{bool}}.{\cprotect\footnote{Note that two
consecutive \texttt{!} operators can be used to synthesize a
\textbf{contextual conversion to \texttt{bool}} --- i.e., if \texttt{X} is an
expression that is explicitly convertible to \texttt{bool}, then
\texttt{(!!(X))} will be \texttt{(true)} or \texttt{(false)}
accordingly.}}

As a concrete example, consider a \texttt{ConnectionHandle} class that
can be in either a \emph{valid} or \emph{invalid} state. For the user's
convenience and consistency with other proxy types (e.g., raw pointers)
that have a similar \emph{invalid} state, representing the invalid (or null) state via an explicit conversion to
\texttt{bool} might be desirable:

\begin{lstlisting}[language=C++]
struct ConnectionHandle
{
std::size_t maxThroughput() const;
// Return the maximum throughput (in bytes) of the connection.

explicit operator bool() const;
// Return (ù{\codeincomments{true}}ù) if the handle is valid and (ù{\codeincomments{false}}ù) otherwise.
};
\end{lstlisting}

\noindent Instances of \texttt{ConnectionHandle} will convert to \texttt{bool}
only where one might reasonably want them to do so, say, as the
predicate of an \texttt{if} statement:

\begin{lstlisting}[language=C++]
int ping(const ConnectionHandle& handle)
{
if (handle)  // OK (contextual conversion to bool)
{
// ...
return 0;  // success
}

std::cerr << "Invalid connection handle.\n";
return -1;  // failure
}
\end{lstlisting}

\noindent Having an \texttt{explicit} conversion operator prevents unwanted
conversions to \texttt{bool} that might otherwise happen inadvertently:

\begin{lstlisting}[language=C++]
bool hasEnoughThroughput(const ClientConnection& connection,
const ResourceHandle&   handle)
{
return connection.throughput() <= handle;  // Compilation error, thankfully
//                                    ^~~~~~
}
\end{lstlisting}

\noindent After the relational operator (\texttt{<=}) in the example above, the
programmer mistakenly wrote \texttt{handle} instead of
\mbox{\texttt{handle.maxThroughput()}}. Fortunately the conversion operation of\linebreak[4] %%%%%
\mbox{\texttt{ResourceHandle}} was declared to be \texttt{explicit} and a
compile-time error (thankfully) ensued; if the conversion had
been \emph{implicit}, the example code above would have compiled, and,
if executed, the very same source for the \mbox{\texttt{hasEnoughThroughput}}
function would have silently exhibited well-defined but incorrect
behavior.

\subsection[Potential Pitfalls]{Potential Pitfalls}\label{potential-pitfalls-explicitconv}

\subsubsection[Sometimes implicit conversion is indicated]{Sometimes implicit conversion is indicated}\label{sometimes-implicit-conversion-is-indicated}

Implicit conversions to and from common arithmetic types, especially
\texttt{int} are generally ill advised, given the likelihood of
accidental misuse. However, sometimes \emph{implicit}
conversion is exactly what is needed. Such cases occur frequently with
wrapper and proxy types that might need to interoperate with a large
legacy codebase. Consider, for example, an initial implementation of
memory allocators in which each constructor takes, as an optional
trailing argument, a pointer to an abstract memory resource that itself
provides pure virtual \texttt{allocate} and \texttt{deallocate} member
functions. Later, we decide to move in the direction of the
\texttt{std::pmr} (C++17) standard and wrap those pointers in classes
that support additional operations. Making such constructors on the
wrapper explicit would force every client supplying an allocator to a
container to rework their code (e.g., by using \texttt{static\_cast}).
An implicit conversion in this case is further justified because the
likelihood of accidental spontaneous conversion to an \texttt{Allocator}
is all but nonexistent.

The same sort of stability argument favors implicit conversion for proxy
types intended to be dropped in and used in existing codebases. If, for
example, we wanted to provide a proxy for a writeable
\texttt{std::string} that, say, also logged, we might want an implicit
conversion to a \texttt{std::string\&\&} (perhaps using
{\intraref{{reference qualifiers}}}). In such cases, making the
conversion explicit would entirely defeat the purpose of the proxy,
which is to achieve new functionality with minimal effect on existing
client code.

\subsection[Sometimes a named function is better]{Sometimes a named function is better}\label{sometimes-a-named-function-is-better}

Other kinds of overuses of even \emph{explicit} conversion
operators exist. Like any user defined operator, when the operation being
implemented is not somehow either canonical or ubiquitously idiomatic
for that operator, expressing that operation by a
named (i.e., non-operator) function is often better. Recall from
{\it\titleref{description-explicitconv}} on page~\pageref{description-explicitconv} that we used a conversion operator of
class \texttt{Point} to represent the distance from the origin. This
example serves both to illustrate how conversion operators \emph{can} be
used and also how they probably should \emph{not} be. Consider that (1)
many mathematical operations on a 2-D integral point might return a \texttt{double} (e.g., \texttt{magnitude},
\texttt{angle}) and (2) we might want to represent the same
information but in different units (e.g., \texttt{angleInDegrees},
\texttt{angleInRadians}).{\cprotect\footnote{Another valid design
decision is returning an object of type \texttt{Angle} that captures
the amplitude and provides named accessory to the different units
(e.g., \texttt{asDegrees}, \texttt{asRadians}).}}

Rather than employing any conversion \emph{operator} (\texttt{explicit}
or otherwise), consider instead providing a named function, which (1) is
automatically \texttt{explicit} and (2) affords both flexibility (in
writing) and clarity (in reading) for a variety of domain-specific
functions --- now and in the future --- that might well have had
overlapping return types:

\begin{lstlisting}[language=C++]
class Point  // only explicitly convertible (and from only an (ù{\codeincomments{int}}ù))
{
int d_x, d_y;

public:
explicit Point(int x = 0, int y = 0);  // explicit converting constructor
// ...
double magnitude() const;  // Return distance from origin as a (ù{\codeincomments{double}}ù).
};
\end{lstlisting}

\noindent Note that defining \textbf{nonprimitive functionality}, like
\texttt{magnitude}, in a separate \emph{utility} at a higher level in the
physical hierarchy might be better still.{\cprotect\footnote{For more on
separating out \textbf{nonprimitive functionality}, see
\textbf{{lakos20}}, sections 3.2.7--3.2.8, pp 529--552.}}

\subsection[Annoyances]{Annoyances}\label{annoyances}

None so far

\subsection[See Also]{See Also}\label{see-also}

None so far

\subsection[Further Reading]{Further Reading}\label{further-reading}

None so far


\newpage
\section[{\tt alignof}]{{\SecCode alignof}}\label{alignof}


The keyword \texttt{alignof} serves as a compile-time operator used to
query the \textbf{alignment requirements} of a type on the current
platform.

\subsection[Description]{Description}\label{description}

The \texttt{alignof} operator, when applied to a type, evaluates to an
\textbf{integral constant expression} that represents the
\textbf{alignment requirements} of its argument type. Similar to
\texttt{sizeof}, the (compile-time) value of \texttt{alignof} is of type
\texttt{std::size\_t}; unlike \texttt{sizeof} (which can accept an
arbitrary expressions), \texttt{alignof} is defined (in the C++
Standard) on only a type identifier but often works on expressions
anyway (see \textit{\titleref{annoyances-alignof}} on page~\pageref{annoyances-alignof}). The argument type,
\texttt{T}, supplied to \texttt{alignof} must be either a
\textbf{complete type}, a \textbf{reference type}, or an \textbf{array
type}. If \texttt{T} is a \textbf{complete type}, the result is the
alignment requirement for \texttt{T}. If \texttt{T} is a
\textbf{reference type}, the result is the alignment requirement for the
referenced type. If \texttt{T} is an \textbf{array type}, the
result is the alignment requirement for every element in the array{\cprotect\footnote{According to the C++11 Standard, ``An object of \textbf{array type} contains a contiguously allocated
non-empty set of \texttt{N} subobjects of type \texttt{T}''  (\textbf{cpp11}, section 8.3.4, ``Arrays," paragraph 1, p. 188). Note
that, for every type \texttt{T}, \texttt{sizeof(T)} is always a
multiple of \texttt{alignof(T)}; otherwise storing multiple \texttt{T} instances in an array would be impossible without padding,
and the Standard explicitly prohibits padding between array elements.}}:

\begin{lstlisting}[language=C++]
static_assert(alignof(short)    == 2, "");  // complete type   ((ù{\codeincomments{sizeof}}ù) is 2)
static_assert(alignof(short&)   == 2, "");  // reference type  ((ù{\codeincomments{sizeof}}ù) is 2)
static_assert(alignof(short[5]) == 2, "");  // array type      ((ù{\codeincomments{sizeof}}ù) is 2)
static_assert(alignof(short[])  == 2, "");  // array type      ((ù{\codeincomments{sizeof}}ù) fails)
\end{lstlisting}


\subsubsection[\tt{alignof} Fundamental Types]{{\SubsubsecCode alignof} Fundamental Types}\label{alignof-fundamental-types}

Like their size, the alignment requirements of a \texttt{char},
\texttt{signed}~\texttt{char}, and \texttt{unsigned}~\texttt{char} are
all guaranteed to be 1 (i.e., 1-byte aligned) on every conforming
platform. For any other fundamental or pointer type \texttt{FPT},
\texttt{alignof(FPT)} (like \texttt{sizeof(FPT)}) is platform-dependent but is typically approximated well by the type's \textbf{natural
alignment} --- i.e.,
\texttt{sizeof(FPT)}~\texttt{==}~\texttt{alignof(FPT)}:

\begin{lstlisting}[language=C++]
static_assert(alignof(char)   == 1, "");  // guaranteed to be 1
static_assert(alignof(short)  == 2, "");  // platform-dependent
static_assert(alignof(int)    == 4, "");  //    "         "
static_assert(alignof(double) == 8, "");  //    "         "
static_assert(alignof(void*)  >= 4, "");  //    "         "
\end{lstlisting}


\subsubsection[\tt{alignof} User-Defined Types]{{\SubsubsecCode alignof} User-Defined Types}\label{alignof-user-defined-types}

When applied to user-defined types, alignment is always at least that of
the strictest alignment of any of its arguments' base or member objects.
Empty types are defined to have a size (and alignment) of 1 to
ensure that every object has a unique address.{\cprotect\footnote{An
exception is made for an object of a type derived from an empty (base)
class in that neither the size nor the alignment of the derived object
is affected by the derivation:

\begin{lstlisting}[language=C++, basicstyle={\ttfamily\footnotesize}]
struct S { int i; }      // size = 4; alignment = 4
struct E { };            // size = 1; alignment = 1
struct D : E { int i };  // size = 4; alignment = 4
\end{lstlisting}
}} Compilers will (by default) avoid nonessential padding because any
extra padding would be wasteful of (e.g., cache)
memory{\cprotect\footnote{Compilers are permitted to increase alignment
(e.g., in the presence of virtual functions) but have certain restrictions
on padding. For example, they must ensure that each comprised type is
itself sufficiently aligned and that the alignment of the parent type
divides its size. This ensures that the fundamental identity for
arrays holds for all types, \texttt{T}, and positive integers,
\texttt{N}:

\begin{lstlisting}[language=C++, basicstyle={\ttfamily\footnotesize}]
T a[N]; static_assert(n == sizeof(a) / sizeof(*a));  // guaranteed
\end{lstlisting}

\noindent The alignment of user-defined types can be made artificially stricter
(but not weaker) using the {\tt alignas} (see ``\titleref{alignas}" on page~\pageref{alignas}) specifier.
Also note that, for \textbf{standard-layout types}, the address of the
first member object is guaranteed to be the same as that of the parent
object:

\begin{lstlisting}[language=C++, basicstyle={\ttfamily\footnotesize}]
struct S { int i; }
class T { public: S s; }
T t;
static_assert(&t.s == &t,     "");  // guaranteed
static_assert(&t.s == &t.s.i, "");  // guaranteed
\end{lstlisting}

\noindent This property also holds for (e.g., anonymous) unions:

\begin{lstlisting}[language=C++, basicstyle={\ttfamily\footnotesize}]
struct { union { char c; float f; double d; } } u;
static_assert(&u == &u.c, "");  // guaranteed
static_assert(&u == &u.f, "");  // guaranteed
static_assert(&u == &u.d, "");  // guaranteed
\end{lstlisting}
}}:

\begin{lstlisting}[language=C++]
struct S0 { };                          // (ù{\codeincomments{sizeof(S0)}}ù) is  (ù{\codeincomments{1}}ù); (ù{\codeincomments{alignof(S0)}}ù) is  (ù{\codeincomments{1}}ù)
struct S1 { char c; };                  // (ù{\codeincomments{sizeof(S1)}}ù) is  (ù{\codeincomments{1}}ù); (ù{\codeincomments{alignof(S1)}}ù) is  (ù{\codeincomments{1}}ù)
struct S2 { short s; };                 // (ù{\codeincomments{sizeof(S2)}}ù) is  (ù{\codeincomments{2}}ù); (ù{\codeincomments{alignof(S2)}}ù) is  (ù{\codeincomments{2}}ù)
struct S3 { char c; short s; };         // (ù{\codeincomments{sizeof(S3)}}ù) is  (ù{\codeincomments{4}}ù); (ù{\codeincomments{alignof(S3)}}ù) is  (ù{\codeincomments{2}}ù)
struct S4 { short s1; short s2; };      // (ù{\codeincomments{sizeof(S4)}}ù) is  (ù{\codeincomments{4}}ù); (ù{\codeincomments{alignof(S4)}}ù) is  (ù{\codeincomments{2}}ù)
struct S5 { int i; char c; };           // (ù{\codeincomments{sizeof(S5)}}ù) is  (ù{\codeincomments{8}}ù); (ù{\codeincomments{alignof(S5)}}ù) is  (ù{\codeincomments{4}}ù)
struct S6 { char c1; int i; char c2};   // (ù{\codeincomments{sizeof(S6)}}ù) is (ù{\codeincomments{12}}ù); (ù{\codeincomments{alignof(S6)}}ù) is  (ù{\codeincomments{4}}ù)
struct S7 { char c; short s; int i; };  // (ù{\codeincomments{sizeof(S7)}}ù) is  (ù{\codeincomments{8}}ù); (ù{\codeincomments{alignof(S7)}}ù) is  (ù{\codeincomments{4}}ù)
struct S8 { double d; };                // (ù{\codeincomments{sizeof(S8)}}ù) is  (ù{\codeincomments{8}}ù); (ù{\codeincomments{alignof(S8)}}ù) is  (ù{\codeincomments{8}}ù)
struct S9 { double d; char c};          // (ù{\codeincomments{sizeof(S9)}}ù) is (ù{\codeincomments{16}}ù); (ù{\codeincomments{alignof(S9)}}ù) is  (ù{\codeincomments{8}}ù)
struct SA { long double; };             // (ù{\codeincomments{sizeof(SA)}}ù) is (ù{\codeincomments{16}}ù); (ù{\codeincomments{alignof(SA)}}ù) is (ù{\codeincomments{16}}ù)
struct SB { long double; char c};       // (ù{\codeincomments{sizeof(SB)}}ù) is (ù{\codeincomments{32}}ù); (ù{\codeincomments{alignof(SB)}}ù) is (ù{\codeincomments{16}}ù)
\end{lstlisting}


\subsection[Use Cases]{Use Cases}\label{use-cases}

\subsubsection[Probing the alignment of a type during development]{Probing the alignment of a type during development}\label{probing-the-alignment-of-a-type-during-development}

Both \texttt{sizeof} and \texttt{alignof} are often used informally
during development and debugging to confirm the compiler's understanding
of those attributes for a given type on the current platform. For
example:

\begin{lstlisting}[language=C++]
#include <iostream>

void f()
{
std::cout << " sizeof(double): " <<  sizeof(double) << '\n';  //  always 8
std::cout << "alignof(double): " << alignof(double) << '\n';  // usually 8
}
\end{lstlisting}

\noindent Printing the size and alignment of a \texttt{struct} along with those of
each of its individual data members can lead to the discovery of
suboptimal ordering of data members (resulting in wasteful extra
padding). As an example, consider two \texttt{struct}s,
\texttt{Wasteful} and \texttt{Optimal}, having the same three data members but
in different order:

\begin{lstlisting}[language=C++]
struct Wasteful
{
char   d_c;  // size =  1;  alignment = 1
double d_d;  // size =  8;  alignment = 8
int    d_i;  // size =  4;  alignment = 4
};               // size = 24;  alignment = 8

struct Optimal
{
double d_d;  // size =  8;  alignment = 8
int    d_i;  // size =  4;  alignment = 4
char   d_c;  // size =  1;  alignment = 1
};               // size = 16;  alignment = 8
\end{lstlisting}

\noindent Both \texttt{alignof(Wasteful)} and \texttt{alignof(Optimal)} are
\texttt{8} but \texttt{sizeof(Wasteful)} is \texttt{24}, whereas
\texttt{sizeof(Optimal)} is only \texttt{16}. Even though these two
\texttt{struct}s contain the very same data members, the individual
alignment requirements of these members forces the compiler to insert
more total padding between the data members in \texttt{Wasteful} than is
necessary in \texttt{Optimal}:

\begin{lstlisting}[language=C++]
struct Wasteful
{
char   d_c;           // size =  1;  alignment = 1
char   padding_0[7];  // size =  7
double d_d;           // size =  8;  alignment = 8
int    d_i;           // size =  4;  alignment = 4
char   padding_1[4];  // size =  4
};                        // size = 24;  alignment = 8

struct Optimal
{
double d_d;           // size =  8;  alignment = 8
int    d_i;           // size =  4;  alignment = 4
char   d_c;           // size =  1;  alignment = 1
char   padding_0[3];  // size =  3
};                        // size = 16;  alignment = 8
\end{lstlisting}


\subsubsection[Determining if a given buffer is sufficiently aligned]{Determining if a given buffer is sufficiently aligned}\label{determining-if-a-given-buffer-is-sufficiently-aligned}

The \texttt{alignof} operator can be used to determine if a given (e.g.,
\texttt{char}) buffer is suitably aligned for storing an object of
arbitrary type. As an example, consider the task of creating a
\textbf{value-semantic} class, \texttt{MyAny}, that represents an object
of arbitrary type{\cprotect\footnote{The C++17 Standard Library provides
the (nontemplate) class \texttt{std::any}, which is a type-safe
container for single values of \emph{any} \textbf{regular type}. The
implementation strategies surrounding alignment for \texttt{std::any}
in both \texttt{libstdc++} and \texttt{libc++} closely mirror those
used to implement the simplified \texttt{MyAny} class presented here.
Note that \texttt{std::any} also records the current \texttt{typeid}
(on construction or assignment) so that it can implement a
\texttt{const} template member function,
\texttt{bool}~\texttt{is<T>()}~\texttt{const}, to query, at runtime,
whether a specified type is currently the active one:

\begin{lstlisting}[language=C++, basicstyle={\ttfamily\footnotesize}]
void f(const std::any& object)
{
if (object.is<int>()) { /* ... */ }
}
\end{lstlisting}
}}:

\begin{lstlisting}[language=C++]
void f()
{
MyAny obj = 10;               // can be initialized with values of any type
assert(obj.as<int>() == 10);  // inner data can be retrieved at runtime

obj = std::string{"hello"};   // can be reassigned from a value of any type
assert(obj.as<std::string>() == "hello");
}
\end{lstlisting}

\noindent A straightforward implementation of \texttt{MyAny} would be to allocate
an appropriately sized block of dynamic memory each time a value of a
new type is assigned. Such a naive implementation would force memory
allocations even though the vast majority of values assigned in practice
are small (e.g., fundamental types), most of which would fit within the
space that would otherwise be occupied by just the pointer needed to
refer to dynamic memory. As a practical optimization, we might instead
consider reserving a small buffer (say, roughly{\cprotect\footnote{We
would likely choose a slightly larger value, e.g., 35 or 39, if that
space would otherwise be filled with essential padding due to overall
alignment requirements.}} 32 bytes) within the footprint of the
\texttt{MyAny} object to hold the value provided (1) it will fit and (2)
the buffer is sufficiently aligned. The natural implementation of this
type --- the union of a char array and a \texttt{struct} (containing a
\texttt{char} pointer and a size) --- will naturally result in the minimal
alignment requirement of the \texttt{char*} (i.e., 4 on a 32-bit
platform and 8 on a 64-bit one){\cprotect\footnote{We could, in
addition, use the {\tt alignas} attribute to ensure that
the minimal alignment of \texttt{d\_buffer} was at least 8 (or even
16):

\begin{lstlisting}[language=C++, basicstyle={\ttfamily\footnotesize}]
// ...
alignas(8) char d_buffer[39];  // small buffer aligned to (at least) 8
// ...
\end{lstlisting}
}}:

\begin{lstlisting}[language=C++]
class MyAny  // nontemplate class
{
union
{
struct
{
char*       d_buf_p;  // pointer to dynamic memory if needed
std::size_t d_size;   // for (ù{\codeincomments{d\_buf\_p}}ù); same alignment as (ù{\codeincomments{(char*)}}ù)
} d_imp;  // Size/alignment of (ù{\codeincomments{d\_imp}}ù) is (ù{\codeincomments{sizeof(d\_buf\_p)}}ù) (e.g., 4 or 8).

char d_buffer[39];         // small buffer aligned as a (ù{\codeincomments{(char*)}}ù)
};  // Size of (ù{\codeincomments{union}}ù) is (ù{\codeincomments{39}}ù); alignment of (ù{\codeincomments{union}}ù) is (ù{\codeincomments{alignof(char*)}}ù).

bool d_onHeapFlag;             // boolean (discriminator) for union (above)

public:
template <typename T>
MyAny(const T& x);               // (member template) constructor

template <typename T>
MyAny& operator=(const T& rhs);  // (member template) assignment operator

template <typename T>
const T& as() const;             // (member template) accessor

// ...

};  // Size of (ù{\codeincomments{MyAny}}ù) is (ù{\codeincomments{40}}ù); alignment of (ù{\codeincomments{MyAny}}ù) is (ù{\codeincomments{alignof(char*)}}ù) (e.g., 8).
\end{lstlisting}

\noindent The (templated) constructor{\cprotect\footnote{In a real-world
implementation, a \emph{forwarding reference} would be used as the
parameter type of \texttt{MyAny}'s constructor to
\emph{perfectly forward} the argument object into the appropriate
storage; see ``\titleref{forwardingref}" on page~\ref{forwardingref}.}} of \texttt{MyAny}
can then decide (potentially at compile time) whether to store the given
object \texttt{x} in the internal small buffer storage or on the heap,
depending on \texttt{x}'s size and alignment:

\begin{lstlisting}[language=C++]
template <typename T>
MyAny::MyAny(const T& x)
{
if (sizeof(x) <= 39 && alignof(T) <= alignof(char*))
{
// Store (ù{\codeincomments{x}}ù) in place in the small buffer.
new(d_buffer) T(x);
d_onHeapFlag = false;
}
else
{
// Store (ù{\codeincomments{x}}ù) on the heap and a pointer to it in the small buffer.
d_imp.d_buf_p = new T(x);
d_imp.d_size = sizeof(x);
d_onHeapFlag = true;
}
}
\end{lstlisting}

\noindent Using the (compile-time) \texttt{alignof} operator in the constructor
above to check whether the alignment of \texttt{T} is compatible with
the alignment of the small buffer is necessary to avoid attempting to
store overly aligned objects in place --- even if they would fit in the
39-byte buffer. As an example, consider \texttt{long}~\texttt{double},
which on typical platforms has both a size and alignment of
\texttt{16}. Even though \texttt{sizeof(long}~\texttt{double)} (16) is not greater
than 39, \texttt{alignof(long}~\texttt{double)} (16) is greater than
that of \texttt{d\_buffer} (8); hence, attempting to store an instance
of \texttt{long}~\texttt{double} in the small buffer, \texttt{d\_buffer}, might
--- depending on where the \texttt{MyAny} object resides in memory --- result
in \textbf{undefined behavior}. User-defined types that either contain
a \texttt{long}~\texttt{double} or have had their alignments
artificially extended beyond 8 bytes are also unsuitable candidates for the
internal buffer even if they might otherwise fit:

\begin{lstlisting}[language=C++]
struct Unsuitable1 { long double d_value };
// Size is 16 (<= 39), but alignment is 16 (> 8).

struct alignas(32) Unsuitable2 { };
// Size is  1 (<= 39), but alignment is 32 (> 8).
\end{lstlisting}

\subsubsection[Monotonic memory allocation]{Monotonic memory allocation}\label{monotonic-memory-allocation}

A common pattern in software --- e.g., request/response in client/server
architectures --- is to quickly build up a complex data structure,
use it, and then quickly destroy it. A \textbf{monotonic allocator} is
a special-purpose memory allocator that returns a monotonically
increasing sequence of addresses into an arbitrary buffer subject to
specific size and alignment requirements.{\cprotect\footnote{C++17
introduces an alternate interface to supply memory allocators via an
abstract base class. The C++17 Standard Library provides a complete
version of standard containers using this more interoperable design in
a sub-namespace, \texttt{std::pmr}, where \texttt{pmr} stands for
\textbf{polymorphic memory resource}. Also adopted as part of C++17
are two concrete memory resources,
\texttt{std::pmr::monotonic\_buffer\_resource} and
\texttt{std::pmr::unsynchronized\_pool\_resource}.}} Especially when
the memory is allocated by a single thread, there are prodigious\footnote{see
\textbf{lakos16}} performance benefits to having unsynchronized raw
memory to be taken directly off the (always hot) program stack. In what
follows, we will provide the building blocks of a monotonic memory
allocator wherein the \texttt{alignof} operator plays an essential role.

As a practically useful example, suppose that we want to create a
lightweight\linebreak[4] \mbox{\texttt{MonotonicBuffer}} class template that will allow us
to allocate raw memory directly from the footprint of the object. Just
by creating an object of an (appropriately sized) instance of this type
on the program stack, memory will natural come from the stack. For
didactic reasons, we will start with a first pass at this class ---
ignoring alignment --- and then go back and fix it using
\texttt{alignof} so that it returns properly aligned memory:

\begin{lstlisting}[language=C++]
template <std::size_t N>
struct MonotonicBuffer  // first pass at a monotonic memory buffer
{
char  d_buffer[N];  // fixed-size buffer
char* d_top_p;      //  next available address

MonotonicBuffer() : d_top_p(d_buffer) { }
// Initialize the next available address to be the start of the buffer.

template <typename T>
void* allocate()             // BAD IDEA --- doesn't address alignment
{
void* result = d_top_p;  // Remember the current next-available address.
d_top_p += sizeof(T);    // Reserve just enough space for this type.
return result;           // Return the address of the reserved space.
}
};
\end{lstlisting}

\noindent \texttt{MonotonicBuffer} is a class template with one integral template
parameter that controls the size of the \texttt{d\_buffer} member from
which it will dispense memory. Note that, while \texttt{d\_buffer} has
an alignment of 1, the \texttt{d\_top\_p} member, used to keep track of
the next available address, has an alignment that is typically 4 or 8
(corresponding to 32-bit and 64-bit architectures, respectively). The
constructor merely initializes the next-address pointer,
\texttt{d\_top\_p} to the start of the local memory pool,
\texttt{d\_buffer[N]}. The interesting part is how the \texttt{allocate}
function manages to return a sequence of addresses corresponding to
objects allocated sequentially from the local pool:

\begin{lstlisting}[language=C++]
MonotonicBuffer<20> mb;  // On a 64-bit platform, the alignment will be 8.
char*   cp = static_cast<char*  >(mb.allocate<char  >());  // &d_buffer[ 0]
double* dp = static_cast<double*>(mb.allocate<double>());  // &d_buffer[ 1]
short*  sp = static_cast<short* >(mb.allocate<short >());  // &d_buffer[ 9]
int*    ip = static_cast<int*   >(mb.allocate<int   >());  // &d_buffer[11]
float*  fp = static_cast<float* >(mb.allocate<float >());  // &d_buffer[15]
\end{lstlisting}

\noindent The predominant problem with this first attempt at an implementation of
\texttt{allocate} is that the addresses returned do not necessarily
satisfy the minimum alignment requirements of the supplied type. A
secondary concern is that there is no internal check to see if
sufficient room remains. To patch this faulty implementation,
we will need a function that, given an initial address and an alignment
requirement, returns the amount by which the address must be rounded up
(i.e., necessary padding) for an object having that alignment
requirement to be properly aligned:

\begin{lstlisting}[language=C++]
std::size_t calculatePadding(const char* address, std::size_t alignment)
// Requires: alignment is a (non-negative, integral) power of 2.
{
// rounding up (ù{\codeincomments{X}}ù) to (ù{\codeincomments{N}}ù) (where (ù{\codeincomments{N}}ù) is a power of 2): (ù{\codeincomments{(x + N - 1) \& \textasciitilde(N - 1)}}ù)
const std::size_t maxA = alignof(std::max_align_t);
const std::size_t a = reinterpret_cast<std::size_t>(address) & (maxA - 1);
const std::size_t am1 = alignment - 1;
const std::size_t alignedAddress = (a + am1) & ~am1;  // round up
return alignedAddress - a;                            // return padding
}
\end{lstlisting}

\noindent Armed with the
\texttt{calculatePadding} helper function (above), we are all set to write the final (correct) version of the \texttt{allocate} method of the \texttt{MonotonicBuffer} class template:

\begin{lstlisting}[language=C++]
template <typename T>
void* MonotonicBuffer::allocate()
{
// Calculate just the padding space needed for alignment.
const std::size_t padding = calculatePadding(d_top_p, alignof(T));

// Calculate the total amount of space needed.
const std::size_t delta = padding + sizeof(T);

// Check to make sure the properly aligned object will fit.
if (delta > d_buffer + N - d_top_p)  // if (Needed > Total - Used)
{
return 0;  // not enough properly aligned unused space remaining
}

// Reserve needed space; return the address for a properly aligned object.
void* alignedAddress = d_top_p + padding;  // Align properly for (ù{\codeincomments{T}}ù) object.
d_top_p += delta;                          // Reserve memory for (ù{\codeincomments{T}}ù) object.
return alignedAddress;                     // Return memory for (ù{\codeincomments{T}}ù) object.
}
\end{lstlisting}

\noindent Using this corrected implementation that uses \texttt{alignof} to pass
the alignment of the supplied type \texttt{T} to the
\texttt{calculatePadding} function, the addresses returned from the
benchmark example (above) would be different{\cprotect\footnote{Note
that on a 32-bit architecture, the \texttt{d\_top\_p} character
pointer would be only four-byte aligned, which means that the entire
buffer might be only four-byte aligned. In that case, the respective
offsets for \texttt{cp}, \texttt{dp}, \texttt{sp}, \texttt{ip}, and
\texttt{bp} in the example for the aligned use case might sometimes
instead be 0, 4, 12, 16, and \texttt{nullptr}, respectively. If
desired, we can use the \texttt{alignas}
attribute/keyword to artificially constrain the \texttt{d\_buffer}
data member always to reside on a maximally aligned address boundary,
thereby improving consistency of behavior, especially on 32-bit
platforms.}}:

\begin{lstlisting}[language=C++]
MonotonicBuffer<20> mb;  // Assume 64-bit platform (8-byte aligned).
char*   cp = static_cast<char*  >(mb.allocate<char  >());  // &d_buffer[ 0]
double* dp = static_cast<double*>(mb.allocate<double>());  // &d_buffer[ 8]
short*  sp = static_cast<short* >(mb.allocate<short >());  // &d_buffer[16]
int*    ip = static_cast<int*   >(mb.allocate<int   >());  // 0 (out of space)
bool*   bp = static_cast<bool*  >(mb.allocate<bool  >());  // &d_buffer[18]
\end{lstlisting}

\noindent In practice, an object that allocates memory, such as a \texttt{vector}
or a \texttt{list} will be constructed with an object that allocates and
deallocates memory that is guaranteed to be either \textbf{maximally
aligned}, \textbf{naturally aligned}, or sufficiently aligned to satisfy
an optionally specified alignment requirement.

Finally, instead of returning a null pointer when the buffer was
exhausted, we would typically have the concrete allocator fall back to a
geometrically growing sequence of dynamically allocated blocks; the
\texttt{allocate} method would then fail (i.e., a
\texttt{std::bad\_alloc} exception would somehow be thrown) only if all
of available memory were exhausted and the \textbf{\texttt{new} handler}
were unable to acquire more memory yet still opted to return control
to its caller.

\subsection[Annoyances]{Annoyances}\label{annoyances-alignof}

\subsubsection[\tt{alignof} (unlike \tt{sizeof}) is defined only on types]{{\SubsubsecCode alignof} (unlike {\SubsubsecCode sizeof}) is defined only on types}\label{alignof-(unlike-sizeof)-is-defined-only-on-types}

The (compile-time) \texttt{sizeof} operator comes in two different
forms: one accepting a \emph{type} and the other accepting an
\emph{expression}. The C++ Standard currently requires that
\texttt{alignof} support only the former{\cprotect\footnote{Although
the Standard does not require \texttt{alignof} to work on arbitrary
expressions, \texttt{alignof} is a common GNU extension and most compilers support
it. Both Clang and GCC will warn only if \texttt{-Wpedantic} is set.}}:

\begin{lstlisting}[language=C++]
static_assert(sizeof(int)  == 4, "");     // OK, (ù{\codeincomments{int}}ù) is a type.
static_assert(alignof(int) == 4, "");     // OK, (ù{\codeincomments{int}}ù) is a type.
static_assert(sizeof(3 + 2))  == 4, "");  // OK, (ù{\codeincomments{3 + 2}}ù) is an expression.
static_assert(alignof(3 + 2)) == 4, "");  // Error, (ù{\codeincomments{3 + 2}}ù) is not a type.
\end{lstlisting}

\noindent This asymmetry can result in a need to leverage
\texttt{decltype} (see ``\titleref{decltype}" on page~\pageref{decltype}) when inspecting an expression instead
of a type:

\begin{lstlisting}[language=C++]
int f()
{
enum { e_SUCCESS, e_FAILURES } result;
std::cout << "size: " << sizeof(result) << '\n';
std::cout << "alignment:" << alignof(decltype(result)) << '\n';
}
\end{lstlisting}

\noindent The same sort of issue occurs in conjunction with modern \textbf{type
inference} features such as \texttt{auto} (see ``\titleref{auto-feature}" on page~\pageref{auto-feature}) and
generic lambdas (see ``\titleref{genericlambda}" on page~\pageref{genericlambda}). As a real-world example, consider the
generic lambda (C++14) being used to introduce a small
\emph{local function} that prints out information regarding the size and
alignment of a given \texttt{object}, likely for debugging purposes:

\begin{lstlisting}[language=C++]
auto printTypeInformation = [](auto object)
{
std::cout << "     size: " << sizeof(object) << '\n'
<< "alignment: " << alignof(decltype(object)) << '\n';
};
\end{lstlisting}

\noindent Because there is no explicit type available within the body of the
\texttt{printTypeInformation} lambda,{\cprotect\footnote{In C++20, referring to the type of a generic lambda parameter explicitly is possible (due to the addition to lambdas of some familiar template syntax):

\begin{lstlisting}[language=C++, basicstyle={\ttfamily\footnotesize}]
auto printTypeInformation = []<typename T>(T object)
{
std::cout << "     size: " << sizeof(T) << '\n'
<< "alignment: " << alignof(T) << '\n';
};
\end{lstlisting}
}} a programmer wishing to remain entirely within the C++
standard{\cprotect\footnote{Note that \texttt{alignof(object)} will work
on every major compiler (GCC~10.x, Clang~10.x, and MSVC~19.x) as a
nonstandard extension.}} is forced to use the
\texttt{decltype} construct explicitly to first obtain
the type of \texttt{object} before passing it on to \texttt{alignof}.

\subsection[See Also]{See Also}\label{see-also}

\begin{itemize}
\item{``\titleref{alignas}" — Safe C++11 feature that can be used to provide an artificially stricter alignment (e.g., more than \textbf{natural alignment}).}
\item{``\titleref{decltype}" — Safe C++11 feature that helps work around \texttt{alignof}'s limitation of accepting only a type, not an expression (see \textit{\titleref{annoyances-alignof}} on page~\pageref{annoyances-alignof}).}
\end{itemize}

\subsection[Further Reading]{Further Reading}\label{further-reading}

None so far




\newpage
\section[Inheriting Constructors]{Inheriting Constructors}\label{ctorinheriting}\label{inheriting-constructors}


The term \textit{inheriting constructors} refers to the use of a
\textbf{{\ttfamily\bfseries using}-declaration} to expose nearly all of the
constructors of a base class in the scope of a derived class.

\subsection[Description]{Description}\label{description-inheritingctor}

In a class definition, a \textbf{{\ttfamily\bfseries using} declaration} naming a
base class's constructor results in the derived class ``inheriting'' all
of the nominated base class's constructors, except for \emph{copy} and
\emph{move} constructors. Just like other \texttt{using} declarations, the nominated base class's
constructors will be searched when no matching constructor is found in
the derived class. When a base class constructor is selected in this way,
that constructor will be used to construct the base class and the
remaining bases and data members of the subclass will be initialized as
if by the default constructor (e.g., applying default initializers;
see ``\titleref{Default-Member-Initializers}" on page~\pageref{Default-Member-Initializers}).

\begin{lstlisting}[language=C++]
struct B0
{
B0() = default;      // public, default constructor
B0(int)         { }  // public, one argument (implicit) value constructor
B0(int, int)    { }  // public, two argument value constructor

private:
B0(const char*) { }  // private, one argument constructor
};

struct D0 : B0
{
using B0::B0;  // (ù{\codeincomments{using}}ù) declaration
D0(double d);  // suppress implicit default constructor
};

D0 t(1);     // OK, inherited from (ù{\codeincomments{B0::B0(int)}}ù)
D0 u(2, 3);  // OK, inherited from (ù{\codeincomments{B0::B0(int, int)}}ù)
D0 v("hi");  // Error: Base constructor is declared (ù{\codeincomments{private}}ù).
\end{lstlisting}

\noindent The only constructors that are explicitly \emph{not} inheritable by the
derived class are the (potentially compiler-generated) \emph{copy} and
\emph{move} constructors{\cprotect\footnote{Note that we use
braced initialization (see ``\titleref{bracedinit}" on page~\pageref{bracedinit}) in \texttt{D0}~\texttt{x(B0{});}
to ensure that a variable \texttt{x} of type \texttt{D0} is declared.
\texttt{D0}~\texttt{x(B0());} would instead be interpreted as a
declaration of a function \texttt{x} returning \texttt{D0} and
accepting a pointer to a nullary function returning \texttt{B0}, which
is referred to as the \textbf{most vexing parse}.}}:

\begin{lstlisting}[language=C++]
#include <utility>  // (ù{\codeincomments{std::move}}ù)

B0 b1(1);              // OK, base-class object can be created.
B0 b2(2, 3);           // OK, base-class object can be created.
B0 b3(b1);             // OK, base-class object can be copied (from *lvalue*).
B0 b4(std::move(b1));  // OK, base-class object can be moved (from *rvalue).

D0 w(b1);    // Error: Base-class copy constructor is not inherited.
D0 v;        // OK, base-class default constructor is inherited.
D0 x(B0{});  // Error: Base-class move constructor is not inherited.

D0 y(B0(4));  // Error: Base-class move constructor is not inherited.
D0 z(t);      // OK, uses compiler-generated (ù{\codeincomments{D0::D0(const D0\&)}}ù)
D0 j(D0(5));  // OK, uses compiler-generated (ù{\codeincomments{DO::D0(D\&\&)}}ù)
\end{lstlisting}

\noindent The constructors inherited by the derived class have the same effect on
whether the compiler implicitly generates special member functions as
explicitly implemented ones would. For example, \texttt{D0}'s default
constructor would be implicitly \emph{deleted} (see ``\titleref{deleted-functions}" on page~\pageref{deleted-functions}) if
\texttt{B0} doesn't have a default constructor. Note that since the copy
and move constructors are \emph{not} inherited, their presence in the
base class wouldn't suppress implicit generation of copy and move
assignment in the derived class. For instance, \texttt{D0}'s implicitly
generated assignment operators obliviously \textbf{hide} their
counterparts in \texttt{B0}:

\begin{lstlisting}[language=C++]
void f()
{
B0 b(0), bb(0);  // Create destination and source (ù{\codeincomments{B0}}ù) objects.
D0 d(0), dd(0);  //   "         "       "    "    (ù{\codeincomments{D0}}ù)    ".

b = bb;          // OK, assign base from lvalue base.
b = B0(0);       // OK,   "       "   "  rvalue   "

d = bb;          // Error: (ù{\codeincomments{B0::operator=}}ù) is hidden by (ù{\codeincomments{D0::operator=}}ù).
d = B0(0);       // Error:       "         "    "     "        "

d.B0::operator=(bb);     // OK, explicit slicing is still possible.
d.B0::operator=(B0(0));  // OK,    "         "      "   "      "

d = dd;          // OK, assign derived from lvalue derived.
d = D0(0);       // OK,   "        "     "  rvalue    "
}
\end{lstlisting}

\noindent Note that, when inheriting constructors, private constructors in the
base class are accessed as private constructors of that base class and
are subject to the same access controls; see \textit{\titleref{annoyances-inheritingctor}: \titleref{access-levels-of-inherited-constructors-are-same-as-in-base-class}} on page~\pageref{access-levels-of-inherited-constructors-are-same-as-in-base-class}.

Inheriting constructors having the same \textbf{signature} from multiple
base classes lead to ambiguity errors:

\begin{lstlisting}[language=C++]
struct B1A { B1A(int); };
struct B1B { B1B(int); };

struct D1 : B1A, B1B
{
using B1A::B1A;
using B1B::B1B;
};

D1 d1(0);  // Error: Call of overloaded (ù{\codeincomments{D1(int)}}ù) is ambiguous.
\end{lstlisting}

\noindent Each inherited constructor shares the same characteristics as the
corresponding one in the nominated base class's constructors and then
delegates to it. This means the \textbf{access specifiers}, the
\texttt{explicit} specifier, the \texttt{constexpr} specifier, the
default arguments, and the exception specification are also preserved by
constructor inheritance; see ``\titleref{noexcept}" on page~\pageref{noexcept} and ``\titleref{constexprfunc}" on page~\pageref{constexprfunc}. For template
constructors, the template parameter list and the default template
arguments are preserved as well:

\begin{lstlisting}[language=C++]
struct B2
{
template <typename T = int>
explicit B2(T) { }
};

struct D2 : B2 { using B2::B2; };
\end{lstlisting}

\noindent The declaration \texttt{using}~\texttt{B2::B2} above behaves as if a
constructor template that delegates to its nominated base class's
template was provided in \texttt{D2}:

\begin{lstlisting}[language=C++]
// pseudocode
struct D2 : B2
{
template <typename T = int>
explicit D2(T i) : B2(i) { }
}
\end{lstlisting}

\noindent When deriving from a base class in which inheriting most
(but not all) of its constructors is desirable, suppressing
inheritance of one or more of them is possible by providing constructors in the
derived class having the same signature as the ones that would be
inherited:

\begin{lstlisting}[language=C++]
struct B2
{
B2()         { std::cout << "B2()\n"; }
B2(int)      { std::cout << "B2(int)\n"; }
B2(int, int) { std::cout << "B2(int, int)\n"; }
};

struct D2 : B2
{
using B2::B2;
D2(int) { std::cout << "D2(int)\n"; }
};

D2 d;        // prints (ù{\codeincomments{"B2()"}}ù)
D2 e(0);     // Prints (ù{\codeincomments{"D2(int)"}}ù) --- The derived constructor is invoked.
D2 f(0, 0);  // prints (ù{\codeincomments{"B2(int, int)"}}ù)
\end{lstlisting}

\noindent In other words, we can suppress what would otherwise be an inherited
constructor from a nominated base class by simply declaring a
replacement with the same signature in the derived class. We can then
choose to either implement it ourselves, default it (see ``\titleref{defaulted-special-member-functions}" on page~\pageref{defaulted-special-member-functions}), or \texttt{delete} it (see ``\titleref{deleted-functions}" on page~\pageref{deleted-functions}).

If we have chosen to inherit the constructors from multiple
base classes, we can disambiguate conflicts by declaring the offending
constructor(s) explicitly in the derived class and then delegating to
the base classes if and as appropriate:

\begin{lstlisting}[language=C++]
struct B1A { B1A(int); };  // Here we have two bases classes, each of which
struct B1B { B1B(int); };  // provides a conversion constructor from an (ù{\codeincomments{int}}ù).

struct D1 : B1A, B1B
{
using B1A::B1A;  // Inherit the (ù{\codeincomments{int}}ù) constructor from base class (ù{\codeincomments{B1A}}ù).
using B1B::B1B;  // Inherit the (ù{\codeincomments{int}}ù) constructor from base class (ù{\codeincomments{B1B}}ù).

D1(int i) : B1A(i), B1B(i) { }  // Declare the (ù{\codeincomments{int}}ù) conversion constructor
};                                  // explicitly, and then delegate to bases.

D1 d1(0);  // OK, calls (ù{\codeincomments{D1(int)}}ù)
\end{lstlisting}

\noindent Lastly, inheriting constructors from a \textbf{dependent
type} affords a capability over C++03 that is more than just convenience
and avoidance of boilerplate code.{\cprotect\footnote{A decidedly more
complex alternative affording a different set of tradeoffs would
involve variadic template constructors (see ``\titleref{variadictemplate}" on page~\pageref{variadictemplate}) having
forwarding references (see ``\titleref{forwardingref}" on page~\pageref{forwardingref}) as parameters. In this
alternative approach, all of the constructors from the
\mbox{\texttt{public}}, \mbox{\texttt{protected}}, and \mbox{\texttt{private}} regions of the
bases class would now appear under the same access specifier --- i.e.,
the one in which the perfectly forwarding constructor is declared.
What's more, this approach would not retain other constructor
characteristics, such as \texttt{explicit}, \texttt{noexcept},
\texttt{constexpr}, and so on. The forwarding can, however, be restricted to
inheriting just the \texttt{public} constructors (without
characteristics) by constraining on \texttt{std::is\_constructible}
using \textbf{SFINAE}; see \textit{\titleref{annoyances-inheritingctor}: \titleref{access-levels-of-inherited-constructors-are-same-as-in-base-class}} on page~\pageref{access-levels-of-inherited-constructors-are-same-as-in-base-class}.}} In all of the example code in \textit{\titleref{description-inheritingctor}} thus far, we know how to spell the
base-class constructor; we are simply automating some drudge work. In
the case of a \emph{dependent} base class, however, we do \emph{not}
know how to spell the constructors, so we \emph{must} rely on
\textbf{inheriting constructors} if that is the forwarding semantic we
seek:

\begin{lstlisting}[language=C++]
template <class T>
struct S : T  // The base type, (ù{\codeincomments{T}}ù), is a *dependent type*.
{
using T::T;  // inheriting constructors (generically) from a dependent type
};

#include <string>
#include <vector>

S<std::string>        ss("hello");     // OK, uses constructor from base
S<std::vector<char>> svc("goodbye");  // Error: no suitable constructor in base
\end{lstlisting}

\noindent In this example, we created a class template, \texttt{S}, that
derived publicly from its template argument, \texttt{T}. Then, when
creating an object of type \texttt{S} parameterized by
\texttt{std::string}, we were able to pass it a string literal via
the inherited \texttt{std::string} constructor overloaded on a
\texttt{const}~\texttt{char*}. Notice, however, that no such constructor
is available in \texttt{std::vector}; hence, attempting to create the
derived class from a literal string results in a compile-time error. See \textit{\titleref{use-cases-ctorinheriting}: \titleref{incorporating-reusable-functionality-via-a-mix-in-class}} on page~\pageref{incorporating-reusable-functionality-via-a-mix-in-class}.

\subsection[Use Cases]{Use Cases}\label{use-cases-ctorinheriting}

\subsubsection[Abstract use case]{Abstract use case}\label{abstract-use-case}

Use of this form of \texttt{using} declaration to inherit a nominated
base class's constructors --- essentially verbatim --- suggests that one
or more of those constructors is sufficient to initialize the
\emph{entire} derived-class object to a valid useful state. Typically,
such will pertain only when the derived class adds no member data of its
own. While additional derived-class member data could possibly
default, this state must be \emph{orthogonal} to
any modifiable state initialized in the base class, as such state is
subject to independent change via \textbf{slicing}, which might in turn
invalidate \textbf{object invariants}. Derived-class data will need either
to default or to have its value set using member
initializers (see ``\titleref{Default-Member-Initializers}" on page~\pageref{Default-Member-Initializers}). Hence, most typical use cases will involve wrapping an
existing class by deriving from it (either publicly or privately),
adding only defaulted data members having orthogonal values, and then
adjusting the derived class's behavior via \textbf{overriding} its virtual
or \textbf{hiding} its and non-virtual member functions.

\subsubsection[Avoiding boilerplate code when employing structural inheritance]{Avoiding boilerplate code when employing structural inheritance}\label{avoiding-boilerplate-code-code-when-employing-structural-inheritance}

A key indication for the use of inheriting constructors is that the
derived class addresses only auxiliary or optional, rather than required
or necessary, functionality to its self-sufficient base class. As an
interesting, albeit mostly pedagogical,{\cprotect\footnote{Although this
example might be compelling, it suffers from inherent deficiencies
making it insufficient for general use in practice: Passing the
derived class to a function --- whether by value or reference -- will
strip it of its auxiliary functionality. The best-known solution --- a
C++2x language-based contract-checking facility --- is exactly what's
needed ubiquitously. We plan to cover this topic in \textbf{lakos23}.}} example, suppose we
want to provide a proxy for a \texttt{std::vector} that performs
explicit checking of indices supplied to its index operator:

\begin{lstlisting}[language=C++]
#include <vector>
#include <cassert>

template <typename T>
struct CheckedVector : std::vector<T>
{
using std::vector<T>::vector;      // Inherit (ù{\codeincomments{std::vector}}ù)'s constructors.

T& operator[](std::size_t index)   // Hide (ù{\codeincomments{std::vector}}ù)'s index operator.
{
assert(index < std::vector<T>::size());
return std::vector<T>::operator[](index);
}

const T& operator[](std::size_t index) const  // Hide (ù{\codeincomments{const}}ù) index operator.
{
assert(index < std::vector<T>::size());
return std::vector<T>::operator[](index);
}
};
\end{lstlisting}

\noindent In the example above, inheriting constructors allowed us to use public
(structural) inheritance to readily create a distinct new type having
all of the functionality of its base type except for a couple of
functions where we chose to augment the original behavior.

\subsubsection[Avoiding boilerplate code when employing implementation inheritance]{Avoiding boilerplate code when employing implementation inheritance}\label{avoiding-boilerplate-code-when-employing-implementation-inheritance}

Sometimes it can be cost effective to adapt \textbf{concrete class}
having virtual functions{\cprotect\footnote{Useful design patterns
exist where a \textbf{partial implementation} class, derived from a
pure abstract interface (a.k.a. a \textbf{protocol}), contains data,
constructors, and pure virtual functions; see
\textbf{lakos2a}, section~4.7.}} to a specialized purpose
using inheritance.{\cprotect\footnote{Such inheritance, known as
\textbf{implementation inheritance} is decidedly distinct from pure
\textbf{interface inheritance}, which is often the preferred design
pattern in practice; see \textbf{{lakos2b}}, section~4.6.}}
As an example, consider a \textbf{concrete} base class,
\texttt{NetworkDataStream}, that allows overriding its virtual functions
for processing a stream of data from an expanding variety of arbitrary
sources over the network:

\begin{lstlisting}[language=C++]
class NetworkDataStream
{
private:
// ...                   (member data)

public:
explicit NetworkDataStream(TCPConnection* tcpConnection);
explicit NetworkDataStream(UDPConnection* udpConnection);
explicit NetworkDataStream(RawDataStreamHandle* rawDataStreamHandle);

virtual ~NetworkDataStream();

virtual void onPacketReceived(DataPacket& dataPacket) = 0;
// Derived classes must override this method.
\end{lstlisting}

\noindent The concrete class above now provides three constructors (with more
under development) that can be used assuming no per-packet processing is
required. Now, imagine the need for logging information about received
packets (e.g., for auditing purposes). Inheriting constructors make
deriving from \texttt{NetworkDataStream} and overriding (see
``\titleref{override}" on page~\pageref{override})
\texttt{onPacketReceived(DataPacket\&)} more convenient --- i.e.,
without having to reimplement each of the constructors, which are
anticipated to increase in number over time:

\begin{lstlisting}[language=C++]
class LoggedNetworkDataStream : public NetworkDataStream
{
public:
using NetworkDataStream::NetworkDataStream;

void onPacketReceived(DataPacket& dataPacket) override
{
LOG_TRACE << "Received packet " << dataPacket;    // local log facility
NetworkDataStream::onPacketReceived(dataPacket);  // Delegate to base.
}
};
\end{lstlisting}


\subsubsection[Implementing a strong {\tt typedef}]{Implementing a strong {\SubsubsecCode typedef}}\label{implementing-a-strong-typedef}

Classic \texttt{typedef} declarations --- just like C++11
\texttt{using} declarations (see ``\titleref{alias-declarations-and-alias-templates}" on page~\pageref{alias-declarations-and-alias-templates}) --- are just synonyms; they
offer absolutely no type safety. A commonly desired capability is to
provide an alias to an existing type \texttt{T} that is uniquely
interoperable with itself, explicitly convertible from \texttt{T}, but
not implicitly convertible from \texttt{T}. This somewhat \emph{more}
``type-safe'' form of alias is sometimes referred to as a \textbf{strong
\texttt{typedef}}.{\cprotect\footnote{A so-called \textbf{strong
\texttt{typedef}} is similar to a classic, C-style enumeration in
that it is (1) its own type and (2) implicitly convertible to its
base type (which for enumerators corresponds to its
\textbf{underlying type}; see ``\titleref{explicit-enumeration-underlying-type}" on page~\pageref{explicit-enumeration-underlying-type}). Unlike a classic
\texttt{enum}, however, a typical implementation of a \textbf{strong
\texttt{typedef}} allows only for explicit conversion from its base
type. An analogy to the more strongly typed
\texttt{enum}~\texttt{class} (see ``\titleref{enumclass}" on page~\pageref{enumclass}) would suppress conversion
in either direction, e.g., via private inheritance and then
\texttt{explicit} conversion constructors and
\texttt{explicit} conversion operators (see ``\titleref{explicit-conversion-operators}" on page~\pageref{explicit-conversion-operators}).}}

As a practical example, suppose we are exposing, to a fairly wide and varied audience, a class,
\texttt{PatientInfo}, that associates two \texttt{Date} objects to a
given hospital patient:

\begin{lstlisting}[language=C++]
class Date
{
// ...

public:
Date(int year, int month, int day);

// ...
};

class PatientInfo
{
private:
Date d_birthday;
Date d_appointment;

public:
PatientInfo(Date birthday, Date appointment);
// Please pass the birthday as the first date and the appointment as
// the second one!
};
\end{lstlisting}

\noindent For the sake of argument, imagine that our users are not as assiduous as
they should be in reading documentation to know which constructor
argument is which:

\begin{lstlisting}[language=C++]
PatientInfo client1(Date birthday, Date appointment)
{
return PatientInfo(birthday, appointment);  // OK
}

int client2(PatientInfo* result, Date birthday, Date appointment)
{
*result = PatientInfo(appointment, birthday);  // Oops! wrong order
return 0;
}
\end{lstlisting}

\noindent Now suppose that we continue to get complaints, from folks like
\texttt{client2} in the example above, that our code doesn't work. What can we
do?{\cprotect\footnote{Although this example is presented lightheartedly, misuse by clients is a perennial problem in large-scale
software organizations. Choosing the same type for both arguments
might well be the right choice in some environments but not in others.
We are not advocating use of this technique; we are merely
acknowledging that it exists.}}

One way is to force clients to make a conscious and explicit decision in
their own source code as to which \texttt{Date} is the birthday and
which is the appointment. Employing a \textbf{strong \texttt{typedef}}
can help us to achieve this goal. Inheriting constructors provide a
concise way to define a \textbf{strong \texttt{typedef}}; for
the example above, they can be used to define two new types to
represent, uniquely, a birthday and an appointment date:

\begin{lstlisting}[language=C++]
struct Birthday : Date  // somewhat type-safe alias for a (ù{\codeincomments{Date}}ù)
{
using Date::Date;  // inherit (ù{\codeincomments{Date}}ù)'s three integer ctor
explicit Birthday(Date d) : Date(d) { }  // (ù{\codeincomments{explicit}}ù) conversion from (ù{\codeincomments{Date}}ù)
};

struct Appointment : Date  // somewhat type-safe alias for a (ù{\codeincomments{Date}}ù)
{
using Date::Date;  // inherit (ù{\codeincomments{Date}}ù)'s three integer ctor
explicit Appointment(Date d) : Date(d) { }  // (ù{\codeincomments{explicit}}ù) conv. from (ù{\codeincomments{Date}}ù)
};
\end{lstlisting}

\noindent The \texttt{Birthday} and \texttt{Appointment} types expose the same
interface of \texttt{Date}, yet, given our inheritance-based design,
\texttt{Date} is not implicitly convertible to either. Most importantly,
however, these two new types are not implicitly convertible to each
other:

\begin{lstlisting}[language=C++]
Birthday b0(1994, 10, 4);  // OK, thanks to inheriting constructors
Date d0 = b0;              // OK, thanks to public inheritance
Birthday b1 = d0;          // error: no implicit conversion from (ù{\codeincomments{Date}}ù)
Appointment a0;            // Error: (ù{\codeincomments{Appointment}}ù) has no default ctor.
Appointment a1 = b0;       // error: no implicit conversion from (ù{\codeincomments{Birthday}}ù)
Birthday n2(d0);           // OK, thanks to an (ù{\codeincomments{explicit}}ù) constructor in (ù{\codeincomments{Birthday}}ù)
Birthday b3(a0);           // OK, an (ù{\codeincomments{Appointment}}ù) (unfortunately) is a (ù{\codeincomments{Date}}ù).
\end{lstlisting}

\noindent We can now reimagine a \texttt{PatientInfo} class that exploits this
newfound (albeit artificially manufactured{\cprotect\footnote{Replicating
types that have identical behavior in the name of type safety can run
afoul of interoperability. Distinct types that are otherwise
physically similar are often most appropriate when their respective
behaviors are inherently distinct and unlikely to interact in practice
(e.g., a \mbox{\texttt{CartesianPoint}} and a \mbox{\texttt{RationalNumber}},
each implemented as having two integral data members); see
\textbf{{lakos2a}}, section~4.4.}}) type-safety:

\begin{lstlisting}[language=C++]
class PatientInfo
{
private:
Birthday d_birthday;
Appointment d_appointment;

public:
PatientInfo(Birthday birthday, Appointment appointment);
// Why should I bother to write documentation you won't read anyway!?
};
\end{lstlisting}

\noindent Now our clients have no choice but to make their intentions clear at the
call site:

\begin{lstlisting}[language=C++]
PatientInfo client0(Date birthday, Date appointment)
{
return PatientInfo(birthday, appointment);  // Sorry, doesn't compile.
}

int client1(PatientInfo* result, Date birthday, Date appointment)
{
*result = PatientInfo(appointment, birthday);  // Nope! Doesn't compile.
return 0;
}

PatientInfo client3(Date birthday, Date appointment)
{
return PatientInfo(Birthday(birthday), Appointment(appointment));  // OK
}

int client4(PatientInfo* result, Date birthday, Date appointment)
{
Birthday b(birthday);
Appointment a(appointment)
*result = PatientInfo(b, a);  // OK
}
\end{lstlisting}

\noindent This example works because the \textbf{value constructor} takes three
arguments and cannot be invoked as part of an implicit conversion
sequence; see \textit{\titleref{potential-pitfalls-ctorinheriting}: \titleref{beware-of-inheriting-implicit-constructors}} on page~\pageref{beware-of-inheriting-implicit-constructors}. Note that, in an ideal
world where thorough unit testing is ubiquitous, such machinations would
most likely be supererogatory.

\subsubsection[Incorporating reusable functionality via a mix-in]{Incorporating reusable functionality via a mix-in}\label{incorporating-reusable-functionality-via-a-mix-in-class}

Some classes are designed to generically enhance the behavior of a class
just by inheriting from it; such classes are sometimes referred to as
\emph{mix-ins}. If we wish to adapt a class to support the additional
behavior of the mix-in, with no other change to its behavior, we can use
simple \textbf{structural inheritance} (e.g., to preserve reference
compatibility through function calls). To preserve the public interface,
however, we will need it to inherit the constructors as well.

Consider, for example, a simple class to track the total number of
objects created:

\begin{lstlisting}[language=C++]
template <typename T>
struct CounterImpl  // mix-in used to augment implementation of arbitrary type
{
static int s_constructed;  // count of the number of (ù{\codeincomments{T}}ù) objects constructed

CounterImpl()                   { ++s_constructed; }
CounterImpl(const CounterImpl&) { ++s_constructed; }
};

template <typename T>
CounterImpl<T>::s_constructed;  // required member definition
\end{lstlisting}

\noindent The class template \texttt{CounterImpl}, in the example above, counts the number of
times an object of type \texttt{T} was constructed during a run of the
program. We can then write a generic adapter, \texttt{Counted}, to
facilitate use of \texttt{CounterImpl} as a \emph{mix-in}:

\begin{lstlisting}[language=C++]
template <class T>
struct Counted : T, CounterImpl<T>
{
using T::T;
};
\end{lstlisting}

\noindent Note that the \texttt{Counted} adaptor class inherits all of the
constructors of the \emph{dependent} class, \texttt{T}, that it wraps,
without its having to know what those constructors are:

\begin{lstlisting}[language=C++]
#include <string>   // (ù{\codeincomments{std::string}}ù)
#include <vector>   // (ù{\codeincomments{std::vector}}ù)
#include "myfoo.h"  // (ù{\codeincomments{MyFoo}}ù)

Counted<std::string>        cs;  // Construct a counted string.
Counted<std::vector<char>> cvc;  // Construct a counted vector of (ù{\codeincomments{char}}ù).
Counted<MyFoo>             cmf;  // Construct a counted (ù{\codeincomments{MyFoo}}ù) object.
\end{lstlisting}

\noindent While inheriting constructors are a convenience in nongeneric
programming, they can be an essential tool for generic idioms.

\subsection[Potential Pitfalls]{Potential Pitfalls}\label{potential-pitfalls-ctorinheriting}

\subsubsection[Newly introduced constructors in the base class can silently alter program behavior]{Newly introduced constructors in the base class can silently alter\\[0.5ex] program behavior}\label{newly-introduced-constructors-in-the-base-class-can-silently-alter-program-behavior}

The introduction of a new constructor in a base class might silently
change a program's run-time behavior if that constructor happens to be a
better match during overload resolution of an existing instantiation of
a derived class. Consider a \texttt{Session} class that initially provides only two constructors:

\begin{lstlisting}[language=C++]
struct Session
{
Session();
explicit Session(RawSessionHandle* rawSessionHandle);
};
\end{lstlisting}

\noindent Now, imagine that a class, \texttt{AuthenticatedSession}, derived from
\texttt{Session}, inherits the two constructors of its base class and provides its own constructor that accepts an integral
authentication token:

\begin{lstlisting}[language=C++]
struct AuthenticatedSession : Session
{
using Session::Session;
explicit AuthenticatedSession(long long authToken);
};
\end{lstlisting}

\noindent Finally, consider an instantiation of \texttt{AuthenticatedSession} in
user-facing code:

\begin{lstlisting}[language=C++]
AuthenticatedSession authSession(45100);
\end{lstlisting}

\noindent In the line above and the example above that, \texttt{authSession} will be initialized by
invoking the constructor accepting a \texttt{long}~\texttt{long} (see ``\titleref{long-long}" on page~\pageref{long-long}) authentication token. If, however, a new
constructor, having the signature \texttt{Session(int)} is added to the
base class, it will be invoked instead because it is a better match to the
literal \texttt{45100} (of type \texttt{int}) than the constructor
taking a \texttt{long}~\texttt{long} supplied explicitly in the derived
class; hence, adding a constructor to a base class might lead to a
potential latent (runtime) defect that would go unreported at compile
time.

Note that this problem with shifting implicit conversions is not unique
to inheriting constructors; any form of \texttt{using} declaration or
invocation of an overloaded function carries a similar risk. Imposing
stronger typing --- e.g., by using \textbf{strong \texttt{typedef}s} (see \textit{\titleref{use-cases-ctorinheriting}: \titleref{implementing-a-strong-typedef}} on page~\pageref{implementing-a-strong-typedef}) --- might sometimes, however, help to prevent such
unfortunate missteps.

\subsubsection[Beware of inheriting implicit constructors]{Beware of inheriting implicit constructors}\label{beware-of-inheriting-implicit-constructors}

Inheriting from a class that has implicit constructors can cause
surprises. Consider again the use of inheriting constructors to
implement a \textbf{strong \texttt{typedef}} from \textit{\titleref{use-cases-ctorinheriting}: \titleref{implementing-a-strong-typedef}} on page~\pageref{implementing-a-strong-typedef}. This time, however, let's suppose we are
exposing, to a fairly wide and varied audience, a class
\texttt{PointOfInterest}, that associates the name and address of a
given popular tourist attraction:

\begin{lstlisting}[language=C++]
#include <string>  // (ù{\codeincomments{std::string}}ù)

class PointOfInterest
{
private:
std::string d_name;
std::string d_address;

public:
PointOfInterest(const std::string& name, const std::string& address);
// Please pass the (ù{\codeincomments{name}}ù) as the *first* and the (ù{\codeincomments{address}}ù) *second*!
};
\end{lstlisting}

\noindent Again imagine that our users are not always careful about inspecting the
function prototype:

\begin{lstlisting}[language=C++]
PointOfInterested client1(const char* name, const char* address)
{
return PointOfInterest(name, address);  // OK
}

int client2(PointOfInterest* result, const char* name, const char* address)
{
*result = PointOfInterest(address, name);  // Oops! wrong order
return 0;
}
\end{lstlisting}

\noindent We might think to again use \textbf{strong \texttt{typedef}s} here as we
did for \texttt{PatientAppointment} in \textit{\titleref{use-cases-ctorinheriting}: \titleref{implementing-a-strong-typedef}} on page~\pageref{implementing-a-strong-typedef}:

\begin{lstlisting}[language=C++]
struct Name : std::string  // somewhat type-safe alias for a (ù{\codeincomments{std::string}}ù)
{
using std::string::string;  // Inherit, as is, all of (ù{\codeincomments{std::string}}ù)'s ctors.
explicit Name(const std::string& s) : std::string(s) { }  // conversion
};

struct Address : std::string  // somewhat type-safe alias for a (ù{\codeincomments{std::string}}ù)
{
using std::string::string;  // Inherit, as is, all of (ù{\codeincomments{std::string}}ù)'s ctors.
explicit Address(const std::string& s) : std::string(s) { }  // conversion
};
\end{lstlisting}

\noindent The \texttt{Name} and \texttt{Address} types are not interconvertible; they expose the same interfaces as \texttt{std::string} but are not
implicitly convertible from it:

\begin{lstlisting}[language=C++]
Name n0 = "Big Tower";  // OK, thanks to inheriting constructors
std::string s0 = n0;    // OK, thanks to public inheritance
Name n1 = s0;           // error: no implicit conversion from (ù{\codeincomments{std::string}}ù)
Address a0;             // OK, unfortunately a (ù{\codeincomments{std::string}}ù) has a default ctor.
Address a1 = n0;        // error: no implicit conversion from (ù{\codeincomments{Name}}ù)
Name n2(s0);            // OK, thanks to an (ù{\codeincomments{explicit}}ù) constructor in (ù{\codeincomments{Name}}ù)
Name b3(a0);            // OK, an (ù{\codeincomments{Address}}ù) (unfortunately) is a (ù{\codeincomments{std::string}}ù).
\end{lstlisting}

\noindent We can rework the \texttt{PointOfInterest} class to use the the
\textbf{strong \texttt{typedef}} idiom:

\begin{lstlisting}[language=C++]
class PointOfInterest
{
private:
Name    d_name;
Address d_address;

public:
PointOfInterest(const Name& name, const Address& address);
};
\end{lstlisting}

\noindent Now if our clients use the base class itself as a parameter, they will
again need to make their intentions known:

\begin{lstlisting}[language=C++]
PointOfInterested client1(const std::string& name, const std::string address)
{
return PointOfInterest(address, name);  // sorry, doesn't compile
}

PointOfInterested client2(const char* name, const char* address)
{
return PointOfInterest(Name(name), Address(address));  // OK
}
\end{lstlisting}

\noindent But suppose that some clients instead pass the arguments by
\texttt{const}~\texttt{char*} instead of\linebreak[4]
\mbox{\texttt{const}~\texttt{std::string\&}}:

\begin{lstlisting}[language=C++]
PointOfInterested client3(const char* name, const char* address)
{
return PointOfInterest(address, name);  // Oops! compiles but runtime error
}
\end{lstlisting}

\noindent In the case of \texttt{client3} in the code snippet above, passing the arguments through
\emph{does} compile because the \texttt{const}~\texttt{char*}
constructors are inherited; hence, there is no attempt to convert
to a \texttt{std::string} before matching the \emph{implicit} conversion
constructor. Had the \texttt{std::string} conversion
constructor been declared to be \texttt{explicit}, the code would not
have compiled. In short, inheriting constructors from types that perform implicit
conversions seriously undermine the effectiveness of the \textbf{strong
\texttt{typedef}} idiom.

\subsection[Annoyances]{Annoyances}\label{annoyances-inheritingctor}

\subsubsection[Inherited constructors cannot be selected individually]{Inherited constructors cannot be selected individually}\label{inherited-constructors-cannot-be-selected-individually}

The inheriting-constructors feature does not allow the programmer
to select a subset of constructors to inherit; all of the base
class's eligible constructors are always inherited unless a constructor
with the same signature is provided in the derived class. If the
programmer desires to inherit all constructors of a base class except
for perhaps one or two, the straightforward workaround would be to
declare the undesired constructors in the derived class and then use
deleted functions (see ``\titleref{deleted-functions}" on page~\pageref{deleted-functions}) to explicitly exclude them.

For example, suppose we have a general class, \texttt{Datum}, that can
be constructed from a variety of types:

\begin{lstlisting}[language=C++]
struct Datum
{
Datum(bool);
Datum(char);
Datum(short);
Datum(int);
Datum(long);
Datum(long long);
};
\end{lstlisting}

\noindent If we wanted to create a version of \texttt{Datum}, call it
\texttt{NumericalDatum}, that inherits all but the one constructor
taking a \texttt{bool}, our derived class would (1) inherit publicly,
(2) declare the unwanted constructor, and then (3) mark it with
\texttt{=}~\texttt{delete}:

\begin{lstlisting}[language=C++]
struct NumericalDatum : Datum
{
using Datum::Datum;             // Inherit all the constructors...
NumericalDatum(bool) = delete;  // ...except the one taking a (ù{\codeincomments{bool}}ù).
};
\end{lstlisting}

\noindent Note that the subsequent addition of any non-numerical constructor to
\texttt{Datum} (e.g., a constructor taking \texttt{std::string}) would
defeat the purpose of \texttt{NumericalDatum}.

\subsubsection[Access levels of inherited constructors are the same as in base class]{Access levels of inherited constructors are the same as in base class}\label{access-levels-of-inherited-constructors-are-same-as-in-base-class}

Unlike base-class member functions that can be introduced with a
\texttt{using} directive with an arbitrary access level into the derived
class (as long as they are accessible by the derived class), the access
level of the \texttt{using} declaration for inherited constructors is
ignored.{\cprotect\footnote{Alisdair Meredith, one of the authors of the
Standards paper that proposed this feature (\textbf{meredith08}) suggests that
placing the \texttt{using} declaration for \textbf{inheriting
constructors} as the very first member declaration and preceding any
\textbf{access specifiers} might be the least confusing location. Programmers might still be confused by
the disparate default access levels of \texttt{class} versus
\texttt{struct}.}} The inherited constructor overload is instead
accessible \emph{if} the corresponding base-class constructor would be
accessible:

\begin{lstlisting}[language=C++]
struct Base
{
private:
Base(int) { }  // This constructor is declared (ù{\codeincomments{private}}ù) in the base class.
void pvt0() { }
void pvt1() { }

public:
Base() { }     // This constructor is declared (ù{\codeincomments{public}}ù) in the base class.
void pub0() { }
void pub1() { }
};
\end{lstlisting}

\noindent Note that, when employing \texttt{using} to (1) inherit constructors or
(2) elevate base-class definitions in the presence of private
inheritance, public clients of the class might find it necessary
to look at what are ostensibly private implementation details of the
derived class to make proper use of that type through its
public interface:

\begin{lstlisting}[language=C++]
struct Derived : private Base
{
using Base::Base;  // OK, inherited (ù{\codeincomments{Base()}}ù) as (ù{\codeincomments{public}}ù) constructor
// and (ù{\codeincomments{Base(int)}}ù) as (ù{\codeincomments{private}}ù) constructor

private:
using Base::pub0;  // OK, (ù{\codeincomments{pub0}}ù) is declared (ù{\codeincomments{private}}ù) in derived class.
using Base::pvt0;  // Error: (ù{\codeincomments{pvt0}}ù) was declared private in base class.

public:
using Base::pub1;  // OK, (ù{\codeincomments{pub1}}ù) is declared (ù{\codeincomments{public}}ù) in derived class.
using Base::pvt1;  // Error: (ù{\codeincomments{pvt1}}ù) was declared (ù{\codeincomments{private}}ù) in base class.
};

void client()
{
Derived x(0);  // Error: Constructor was declared private in base class.
Derived d;     // OK, constructor was declared (ù{\codeincomments{public}}ù) in base class.
d.pub0();      // Error: (ù{\codeincomments{pub0}}ù) was declared (ù{\codeincomments{private}}ù) in derived class.
d.pub1();      // OK, (ù{\codeincomments{pub1}}ù) was declared (ù{\codeincomments{public}}ù) in derived class.
d.pvt0();      // Error: (ù{\codeincomments{pvt0}}ù) was declared private in base class.
d.pvt1();      // Error: (ù{\codeincomments{pvt1}}ù) was declared private in base class.
}
\end{lstlisting}

\noindent This C++11 feature was itself created because the previously proposed
solution --- which also involved a couple of features new in C++11, namely
forwarding the arguments to base-class constructors with
forwarding references (see ``\titleref{forwardingref}" on page~\pageref{forwardingref}) and variadic
templates (see ``\titleref{variadictemplate}" on page~\pageref{variadictemplate}) --- made somewhat different tradeoffs and was
considered too onerous and fragile to be practically useful:

\begin{lstlisting}[language=C++]
#include <utility>  // (ù{\codeincomments{std::forward}}ù)

struct Base
{
Base(int) { }
};

struct Derived : private Base
{
protected:
template <typename... Args>
Derived(Args&&... args) : Base(std::forward<Args>(args)...)
{
}
};
\end{lstlisting}

\noindent In the example above, we have used forwarding references (see ``\titleref{forwardingref}" on page~\pageref{forwardingref})
to properly delegate the implementation of a constructor that is
declared \mbox{\texttt{protected}} in the derived class to a \texttt{public}
constructor of a privately inherited base class. Although this approach
fails to preserve many of the characteristics of the inheriting
constructors (e.g., \texttt{explicit}, \texttt{constexpr},
\texttt{noexcept}, and so on), the functionality described in the code snippet above is
simply not possible using the C++11 inheriting-constructors feature.

\subsection[See Also]{See Also}\label{see-also}

\begin{itemize}
\item{``\titleref{override}" on page~\pageref{override} — Used to ensure that a member function intended to override a virtual function actual does}
\item{``\titleref{deleted-functions}" on page~\pageref{deleted-functions} — Can be used to exclude inherited constructors that are unwanted entirely}
\item{``\titleref{Defaulted-Special-Member-Functions}" on page~\pageref{Defaulted-Special-Member-Functions} — Used to implement functions that might otherwise have been suppressed by inherited constructors}
\item{``\titleref{delegating-constructors}" on page~\pageref{delegating-constructors} — Related feature used to call one constructor from another from within the same user-defined type}
\item{``\titleref{Default-Member-Initializers}" on page~\pageref{Default-Member-Initializers} — Useful in conjunction with this feature when a derived class adds member data}
\item{``\titleref{forwardingref}" on page~\pageref{forwardingref} — Used in alternative (workaround) when access levels differ from those for base-class constructors}
\item{``\titleref{variadictemplate}" on page~\pageref{variadictemplate} — Used in alternative (workaround) when access levels differ from those for base-class constructors}
\item{``\titleref{Default-Member-Initializers}" on page~\pageref{Default-Member-Initializers} — Can be used to provide nondefault values for data members in derived classes that make use of inheriting constructors}
\end{itemize}

\subsection[Further Reading]{Further Reading}\label{further-reading}

None so far

\subsection[Appendix: C++17 Improvements Made Retroactive to C++11/14]{Appendix: C++17 Improvements Made Retroactive to C++11/14}\label{appendix}\label{c++17-improvements-made-retroactive-to-c++11/14}

The original specification of inheriting constructors in C++11 had a
significant number of problems with general use. As originally specified,
inherited constructors were treated as if they were redeclared in
the derived class. For C++17, a significant rewording of this feature\footnote{\textbf{smith15b}}
happened to instead find the base class
constructors and then define how they are used to construct an instance
of the derived class, as we have presented here. With a final fix in
C++20 with the resolution of CWG issue \#2356,\footnote{\textbf{smith18}} a complete
working feature was specified. All of these fixes for C++17 were
accepted as defect reports and thus apply retroactively to C++11 and
C++14. For the major compilers, this was either standardizing already
existing practice or quickly adopting the changes.{\cprotect\footnote{For example, GCC versions above 7.0
and Clang versions above 4.0 all have the modern behavior
fully implemented regardless of which standard version is chosen when
compiling.}}

The subsections that follow describe the subtle bugs that came with the previous
specification, both for completeness and to give a better
understanding of what to expect on very old compilers, though none fully
implemented the original specification as written.

\subsubsection[Inheriting constructors declared with a C-style ellipsis]{Inheriting constructors declared with a C-style ellipsis}

Forwarding arguments from a constructor declared using a C-style ellipsis cannot forward correctly. Arguments passed through the ellipsis are not available as named arguments but must instead be accessed through the \texttt{va\_arg} family of macros. Without named arguments, no easily supported way is available to call the base-class constructor with the additional arguments:
\begin{lstlisting}[language=C++]
struct Base
{
Base(int x, ...) { }  // constructor taking C-style variadic args
};

struct Derived : Base
{
using Base::Base;  // Error: Prior to C++17 fixes, standard wording
// does not allow forwarding C-style variadic args.
};
\end{lstlisting}
This problem is sidestepped in C++17 because the base-class constructor becomes available just like any other base-class function made available through a \texttt{using} declaration in the derived class.

\subsubsection[Inheriting constructors that rely on friendship to declare function parameters]{Inheriting constructors that rely on friendship to declare\\ function parameters}

When a constructor depends on access to a \texttt{private} member of a class (e.g., a \texttt{typedef}), an inheriting constructor does not implicitly grant friendship that the base class might have that makes the constructor valid. For example, consider the following class template, which grants friendship to class \texttt{B}:
\begin{lstlisting}[language=C++]
template <typename T>
struct S
{
private:
typedef int X;
friend struct B;
};
\end{lstlisting}
Then, we can create a class with a constructor that relies on that friendship. In this case, we consider a constructor template using the dependent member \texttt{X}, assuming that, in the normal case, \texttt{X} would be publicly accessible:
\begin{lstlisting}[language=C++]
struct B
{
template <typename T>
B(T, typename T::X);
};
\end{lstlisting}
Now consider class \texttt{D} derived from \texttt{B} and inheriting its constructors:
\begin{lstlisting}[language=C++]
struct D : B
{
using B::B;
};
\end{lstlisting}
Without friendship, we cannot construct a \texttt{D} from an \texttt{S}, but we can construct a \texttt{B} from an \texttt{S}, suggesting something is wrong with the inheritance. Note that the SFINAE rules for templates mean that the inheriting constructor is a problem only if we try to construct an \texttt{S} with the problem type and does not cause a hard error without that use case. The following example illustrates the problematic usage:
\begin{lstlisting}[language=C++]
S<int> s;   // full specialization of (ù{\codeincomments{S}}ù) for type (ù{\codeincomments{int}}ù)
B b(s, 2);  // OK, thanks to friendship
D d(s, 2);  // Error: Prior to C++17 fixes, friendship is not inherited.
\end{lstlisting}
As C++17 redefines the semantics of the inheriting constructor as if the base class’s constructors were merely exposed in the derived one, friendship is evaluated within the scope of the base class.

\subsubsection[Inheriting constructor templates would be ill formed for a local class]{Inheriting constructor templates would be ill formed for a local class}

A class declared within a function is a \textbf{local class}. Local classes have many restrictions, one of which is that they cannot declare member templates. If we inherit constructors from a base class with constructor templates, even \texttt{private} ones, the implicit declaration of a constructor template to forward arguments to the base-class constructor would be \textbf{ill formed}:
\begin{lstlisting}[language=C++]
struct Base
{
template <typename T>
Base(T);
};

void f()
{
class Local : Base
{
using Base::Base;  // Error: Prior to C++17 fixes, we cannot redeclare
// the constructor template in local class.
};
}
\end{lstlisting}
C++17 resolves this by directly exposing the base class constructors, rather than defining new constructors to forward arguments.

\subsubsection[SFINAE evaluation context with default function arguments]{SFINAE evaluation context with default function arguments}

Constructors that employ \textbf{SFINAE} tricks in default function arguments perform \mbox{\textbf{SFINAE}} checks in the wrong context and therefore inherit ill-formed constructors. No such issues occur when these \textbf{SFINAE} tricks are performed on default template arguments instead. As an example, consider a class template \texttt{Wrap} that has a template constructor with a \textbf{SFINAE} constraint:
\begin{lstlisting}[language=C++]
struct S { };

template <typename T>
struct Wrap
{
template <typename U>
Wrap(U, typename std::enable_if<
std::is_constructible<T, U>::value>::type* = nullptr)
// This constructor is enabled only if (ù{\codeincomments{T}}ù) is constructible from (ù{\codeincomments{U}}ù).
{
std::cout << "SFINAE ctor\n";
}

Wrap(S)
{
std::cout << "S ctor\n";
}
};
\end{lstlisting}
If we derive from \texttt{Wrap} and inherit its constructors, we would expect the \textbf{SFINAE} constraint to behave exactly as in the base class, i.e., the template constructor overload would be silently discarded if \texttt{std::is\_constructible<T,}~\texttt{U>::value} evaluates to \texttt{false}:
\begin{lstlisting}[language=C++]
template <typename T>
struct Derived : Wrap<T>
{
using Wrap<T>::Wrap;
};
\end{lstlisting}
However, prior to C++17’s retroactive fixes, \textbf{SFINAE} was triggered only for \texttt{Wrap}, not for \texttt{Derived}:
\begin{lstlisting}[language=C++]
void f()
{
S s;
Wrap<int> w(s);     // prints (ù{\codeincomments{"S ctor"}}ù)
Derived<int> d(s);  // error prior to fixes; prints (ù{\codeincomments{"S ctor"}}ù) afterward
}
\end{lstlisting}

\subsubsection[Suppression of constructors in the presence of default arguments]{Suppression of constructors in the presence of default arguments}

A constructor having one or more default arguments in the derived class does not suppress any corresponding constructors matching only the nondefaulted arguments in the base class, leading to ambiguities:
\begin{lstlisting}[language=C++]
struct B          // base class
{
B(int, int);  // value constructor with two (required) (ù{\codeincomments{int}}ù) parameters
};

struct D : B
{
using B::B;
D(int, int, int = 0);  // doesn't suppress (ù{\codeincomments{D(int, int)}}ù) from (ù{\codeincomments{B(int, int)}}ù)
};
\end{lstlisting}
In the code example above, the original defective behavior was that there would be two overloaded constructors in \texttt{D}; attempting to construct a \texttt{D} from two integers became ambiguous. In the corrected behavior, the inheriting \texttt{D(int,}~\texttt{int)} from the base-class constructor \texttt{B(int,}~\texttt{int)}, whose domain is fully subsumed by the derived class’s explicitly specified constructor \texttt{D(int,}~\texttt{int,}~\texttt{int}~\texttt{=}~\texttt{0)}, is suppressed.

\subsubsection[Suprising behavior with unary constructor templates]{Suprising behavior with unary constructor templates}

Because inherited constructors are redeclarations within the derived class and expect to forward properly to the corresponding base-class constructors, constructor templates may do very surprising things. In particular, a gregarious, templated constructor can appear to cause inheritance of a base-class copy constructor. Consider the following class with a constructor template:
\begin{lstlisting}[language=C++]
struct A
{
A() = default;
A(const A&) { std::cout << "copy\n"; }

template <typename T>
A(T) { std::cout << "convert\n"; }
};
\end{lstlisting}
This simple class can convert from any type and prints those of its constructors that were called. Now consider we want to make a \textbf{strong \texttt{typedef}} for \texttt{A}:
\begin{lstlisting}[language=C++]
struct B : A
{
using A::A;  // inherited base class (ù{\codeincomments{A}}ù)'s constructors
};
\end{lstlisting}
The problem is that because \texttt{A} can convert from anything, when \texttt{B} inherits \texttt{A}'s constructor template, \texttt{B} can then use the inherited constructor to construct an instance of \texttt{B} from \texttt{A}. Perhaps more surprising, because the definition of the inherited constructor in \texttt{B} is to initialize the \texttt{A} subobject with its parameters, the nontemplate inherited constructor will be chosen as the best match, not the templated, converting constructor!\cprotect\footnote{Note that if the template constructor for \texttt{A} were a \emph{copy} or \emph{move} constructor for \texttt{A}, then it would be excluded from being an inherited constructor and this odd behavior would be avoided. The by-value parameter of this constructor is also why \texttt{"copy"} is output twice in this example.
\begin{lstlisting}[language=C++, basicstyle={\ttfamily\footnotesize}]
A x;
B y = x;  // Surprise! This compiles, and it prints (ù{\codeincomments{"copy"}}ù) twice!
\end{lstlisting}
}


\newpage
\section[Unicode String and Character Literals]{Unicode String and Character Literals}\label{unicode-string-and-character-literals}

C++11 introduces a portable mechanism for ensuring that a literal is
encoded as UTF-8, UTF-16, or UTF-32.

\subsection[Description]{Description}\label{description-unicodestring}

According to the C++ Standard, the character encoding of string literals
is unspecified and can vary with the target platform or the configuration of
the compiler. In essence, the C++ Standard does not guarantee that the
string literal \texttt{"Hello"} will be encoded as the
ASCII{\cprotect\footnote{In fact, C++ still fully supports platforms
using EBCDIC, a rarely used alternative encoding to ASCII, as their primary text encoding.}} sequence
\texttt{{0x48,} \texttt{0x65,} \texttt{0x6C,} \texttt{0x6C,} \texttt{0x6F}}
or that the the character literal \texttt{'X'} has the value
\texttt{0x58}.

Table~\ref{unicodestring-table1} illustrates three new kinds of \emph{unicode}-compliant
\emph{string literals}, each delineating the precise encoding of each
character.
\begin{table}[h!]
\begin{center}
\begin{threeparttable}
\caption{Three new Unicode-compliant literal strings}\label{unicodestring-table1}\vspace{1.5ex}
{\small \begin{tabular}{c|c|c}\thickhline
\rowcolor[gray]{.9}{\sffamily\bfseries Encoding} & {\sffamily\bfseries Syntax} & {\sffamily\bfseries Underlying Type}\\ \hline
UTF-8   &  \texttt{u8"Hello"} & \texttt{char} (\texttt{char8\_t} in C++20) \\ \hline
UTF-16 & \texttt{u"Hello"}  & \texttt{char16\_t} \\ \hline
UTF-32  & \texttt{U"Hello"} & \texttt{char32\_t}\\ \thickhline
\end{tabular}
} % end small
\end{threeparttable}
\end{center}
\end{table}

\noindent A unicode literal value is guaranteed to be encoded in UTF-8, UTF-16, or
UTF-32, for \texttt{u8}, \texttt{u}, and \texttt{U} literals,
respectively:

\begin{lstlisting}[language=C++]
char s0[] = "Hello";
// unspecified encoding (albeit very likely ASCII)

char s1[] = u8"Hello";
// guaranteed to be encoded as (ù{\codeincomments{\{0x48, 0x65, 0x6C, 0x6C, 0x6F, 0x0\}}}ù)
\end{lstlisting}

\noindent C++11 also introduces \emph{universal character names} that provide a
reliably portable way of embedding Unicode code points in a C++ program.
They can be introduced by the \texttt{$\backslash$u} character
sequence followed by four hexadecimal digits or by the
\texttt{$\backslash$U} character sequence followed by eight
hexadecimal digits:

\begin{lstlisting}[language=C++]
std::puts(u8"\U0001F378");  // Unicode code point in a UTF-8 encoded literal
\end{lstlisting}

\noindent This output statement is guaranteed to emit the cocktail emoji
(\martini) to \texttt{stdout}, assuming that the receiving end is configured to
interpret output bytes as UTF-8.

\subsection[Use Cases]{Use Cases}\label{use-cases}

\subsubsection[Guaranteed-portable encodings of literals]{Guaranteed-portable encodings of literals}\label{guaranteed-portable-encodings-of-literals}

The encoding guarantees provided by the Unicode literals can be useful,
such as in communication with other programs or network/IPC protocols that
expect character strings having a particular encoding.

As an example, consider an instant-messaging program, in which both the
client and the server expect messages to be encoded in UTF-8. As part of
broadcasting a message to all clients, the server code uses UTF-8
Unicode literals to guarantee that every client will receive a sequence
of bytes they are able to interpret and display as human-readable text:

\begin{lstlisting}[language=C++]
void Server::broadcastServerMessage(const std::string& message)
{
Packet data;
data << u8"Message from the server: '" << message << u8"'\n";

broadcastPacket(data);
}
\end{lstlisting}

\noindent Not using \texttt{u8} literals in the code snippet above could potentially result in
nonportable behavior and might require compiler-specific flags to
ensure that the source is UTF-8 encoded.

\subsection[Potential Pitfalls]{Potential Pitfalls}\label{potential-pitfalls}

\subsubsection[Embedding Unicode graphemes]{Embedding Unicode graphemes}\label{embedding-unicode-graphemes}

The addition of Unicode string literals to the language did not bring
along an extension of the basic source character set: Even in C++11, the
default \textbf{basic source character set} is a subset of
ASCII.{\cprotect\footnote{Implementations are free to map characters
outside the basic source character set to sequences of its members,
resulting in the possibility of embedding other characters, such as emojis, in a C++ source file.}}

Developers might be fooled into thinking that \texttt{u8"\martini"} is a
portable way of embedding a string literal representing the cocktail
emoji in a C++ program, but they would be mistaken. The representation of the string literal depends on what
encoding the compiler assumes for the source file, which can generally
be controlled through compiler flags. The only portable way of embedding
the cocktail emoji is to use its corresponding Unicode code point escape
sequence (\texttt{u8"$\backslash$U0001F378"}), as demonstrated in
\textit{\titleref{description-unicodestring}} on page~\pageref{description-unicodestring}.

\subsubsection[Lack of library support for Unicode]{Lack of library support for Unicode}\label{lack-of-library-support-for-unicode}

Essential \textbf{vocabulary types}, such as \texttt{std::string}, are
completely unaware of encoding. They treat any stored string as a
sequence of bytes. Even when correctly using Unicode string literals,
programmers unfamiliar with Unicode might be surprised by seemingly
innocent operations, such as asking for the size of a string
representing the cocktail emoji:

\begin{lstlisting}[language=C++]
void f()
{
std::string cocktail(u8"\U0001F378");  // big character (!)
assert(cocktail.size() == 1);          // assertion failure (!)
}
\end{lstlisting}

\noindent Even though the cocktail emoji is a \emph{single} code point,
\texttt{std::string::size} returns the number of code units required to
encode it. The lack of Unicode-aware vocabulary types and utilities in
the Standard Library can be a source of defects and misunderstandings,
especially in the context of international program localization.

\subsubsection[UTF-8 quirks]{UTF-8 quirks}\label{utf-8-quirks}

UTF-8 string literals use \texttt{char} as their \textbf{underlying type}. Such a
choice is inconsistent with UTF-16 and UTF-32 literals, which provide
their own unique character types (\texttt{char16\_t} and
\texttt{char32\_t}), and prevents any overloading or template
specialization on UTF-8 strings because it would be indistinguishable from
default, narrow literal encoding. Furthermore, whether the underlying
type of \texttt{char} is a \texttt{signed} or \texttt{unsigned} type is
itself implementation defined.{\cprotect\footnote{Note that
\texttt{char} is distinct from both \texttt{signed}~\texttt{char} and
\texttt{unsigned}~\texttt{char}, but its behavior is guaranteed to be
the same as one of those.}}

C++20
fundamentally changes how UTF-8 string literals work, by introducing a
new nonaliasing \texttt{char8\_t} character type whose representation
is guaranteed to match \texttt{unsigned}~\texttt{char}. The new
character type provides several benefits:
\begin{itemize}
\item{Ensures an \texttt{unsigned} and distinct type for UTF-8 character data}
\item{Enables overloading for regular string literals versus UTF-8 string literals}
\item{Potentially achieves better performance due to the lack of special aliasing rules}
\end{itemize}
Unfortunately, the changes brought by C++20 are not
backward-compatible and might cause code targeting previous versions
of the language using \texttt{u8} literals either to fail to compile
or to silently change its behavior when targeting C++20:

\begin{lstlisting}[language=C++, basicstyle={\ttfamily\footnotesize}]
template <typename T> void print(const T*);  // (0)
void print(const char*);                     // (1)

void f()
{
print(u8"text");  // invokes (1) prior to C++20, (0) afterwards
}
\end{lstlisting}


\subsection[Annoyances]{Annoyances}\label{annoyances}

None so far

\subsection[See Also]{See Also}\label{see-also}

None so far

\subsection[Further Reading]{Further Reading}\label{further-reading}

None so far


\newpage
\section[Explicit Enumeration Underlying Type]{Explicit Enumeration Underlying Type}\label{explicit-enumeration-underlying-type}

The underlying type of an enumeration is the fundamental
\textbf{integral type} used to represent its enumerated values, which
can be specified explicitly in C++11.

\subsection[Description]{Description}\label{description}

Every enumeration employs an integral type, known as its
\textbf{underlying type}, to represent its compile-time-enumerated
values.{\cprotect\footnote{Note that \texttt{char} and
\texttt{wchar\_t}, like enumerations, are their own distinct types (as
opposed to \texttt{typedef}-like aliases such as
\texttt{std::uint8\_t}) and have their own implemenation-defined
underlying integral types. With \texttt{char}, for example, the
\textbf{underlying type} will always be either
\texttt{signed}~\texttt{char} or \texttt{unsigned}~\texttt{char} (both
of which are also distinct C++ types). The same is true in C++11 for
\texttt{char16\_t} and \texttt{char32\_t} and in C++20 for
\texttt{char8\_t}.}} By default, the \textbf{underlying type} of an
\texttt{enum}{\cprotect\footnote{Note that the default underlying type
of an \texttt{enum}~\texttt{class} is ubiquitously \texttt{int}, and
it is not implementation defined; see ``\titleref{enumclass}" on page~\pageref{enumclass}.}} is chosen by the
implementation to be large enough to represent all of the values in an
enumeration and is allowed to exceed the size of an \texttt{int}
\emph{only} if there are enumerators having values that cannot be
represented as an \texttt{int} or \texttt{unsigned}~\texttt{int}:

\begin{lstlisting}[language=C++]
enum RGB { e_RED, e_GREEN, e_BLUE };                    // fits any (ù{\codeincomments{char}}ù)

enum Port { e_LEFT = -81, e_RIGHT = -82 };              // fits (ù{\codeincomments{signed char}}ù)

enum Mask { e_LOW = 32767, e_HIGH = 65535 };            // fits (ù{\codeincomments{unsigned short}}ù)

enum Big { e_32 = 1<<32 };                              // too big for (ù{\codeincomments{int}}ù)

enum Err { K = 1024, M = K*K, G = M*K, T = G*K };       // (ù{\codeincomments{G*K}}ù) overflows (ù{\codeincomments{int}}ù)...

enum OK { K = 1<<10, M = 1<<20, G = 1<<30, T = 1<<40 }; // ...but (ù{\codeincomments{1<<40}}ù) is OK
\end{lstlisting}

\noindent The default underlying type chosen for an \texttt{enum} is always
sufficiently large to represent \emph{all} enumerator values defined for
that \texttt{enum}. If the value doesn't fit in an \texttt{int}, it will
be selected deterministically as the first type able to represent all
values from the sequence: \texttt{unsigned}~\texttt{int}, \texttt{long},
\texttt{unsigned}~\texttt{long}, \texttt{long}~\texttt{long},
\texttt{unsigned}~\texttt{long}~\texttt{long}.{\cprotect\footnote{While
specifying an enumeration's underlying type was impossible before
C++11, the compiler could be forced to choose at least a 32-bit or
64-bit signed integral type by adding an enumerator having a
sufficiently large negative value --- e.g.,
\texttt{-1}~\texttt{<<}~\texttt{31} for a 32-bit and
\texttt{-1}~\texttt{<<}~\texttt{63} for a 64-bit \emph{signed} integer
(assuming such is available on the target platform).}}

\subsubsection[Specifying underlying type explicitly]{Specifying underlying type explicitly}\label{specifying-underlying-type-explicitly}

As of C++11, we have the ability to specify the \textbf{integral type}
that is used to represent an \texttt{enum}. This is achieved by
providing the type explicitly in the \texttt{enum}'s declaration
following the enumeration's (optional) name and preceded by a colon:

\begin{lstlisting}[language=C++]
enum Port : unsigned char
{
// Each enumerator of (ù{\codeincomments{Port}}ù) is represented as an (ù{\codeincomments{unsigned char}}ù) type.

e_INPUT        =  37,  // OK, would have fit in a (ù{\codeincomments{signed char}}ù) too
e_OUTPUT       = 142,  // OK, would not have fit in a (ù{\codeincomments{signed char}}ù)
e_CONTROL      = 255,  // OK, barely fits in an 8-bit unsigned integer
e_BACK_CHANNEL = 256,  // error, doesn't fit in an 8-bit unsigned integer
};
\end{lstlisting}

\noindent If any of the values specified in the definition of the \texttt{enum} is
outside the boundaries of what the provided \textbf{underlying type} is
able to represent, the compiler will emit an error, but see \textit{\titleref{potential-pitfalls-underlyingenum}: \titleref{subtleties-of-integral-promotion}} on page~\pageref{subtleties-of-integral-promotion}.

\subsection[Use Cases]{Use Cases}\label{use-cases}

\subsubsection[Ensuring a compact representation where enumerator values are salient]{Ensuring a compact representation where enumerator values are salient}\label{ensuring-a-compact-representation-where-enumerator-values-are-salient}

When the enumeration needs to have an efficient representation, e.g.,
when it is used as a data member of a widely replicated type,
restricting the width of the underlying type to something smaller than
would occur by default on the target platform might be justified.

As a concrete example, suppose that we want to enumerate the months of
the year, for example, in anticipation of placing that enumeration
inside a date class having an internal representation that maintains the
year as a two-byte signed integer, the month as an enumeration, and the
day as an 8-bit signed integer:

\begin{lstlisting}[language=C++]
#include <cstdint>  // (ù{\codeincomments{std::int8\_t}}ù), (ù{\codeincomments{std::int16\_t}}ù)

class Date
{
std::int16_t d_year;
Month d_month;
std::int8_t day;

public:
Date(int year, Month month, int day);

// ...

int year() const    { return d_year; }
Month month() const { return d_month; }
int day() const     { return d_day; }
}
\end{lstlisting}

\noindent Within the software, the \texttt{Date} is typically constructed using
the values obtained through the GUI, where the month is always selected
from a drop-down menu. Management has requested that the month be
supplied to the constructor as an \texttt{enum} to avoid recurring
defects where the individual fields of the date are supplied in
month/day/year format. New functionality will be written to expect the
month to be enumerated. Still, the date class will be used in contexts
where the numerical value of the month is significant, such as in calls
to legacy functions that accept the month as an integer. Moreover,
iterating over a range of months is common and requires that the
enumerators convert automatically to their (integral) \textbf{underlying
type}, thus contraindicating use of the more strongly typed
\texttt{enum} \texttt{class}:

\begin{lstlisting}[language=C++]
enum Month  // defaulted underlying type (BAD IDEA)
{
e_JAN = 1, e_FEB, e_MAR,    // winter
e_APR    , e_MAY, e_JUN,    // spring
e_JUL    , e_AUG, e_SEP,    // summer
e_OCT    , e_NOV, e_DEC     // autumn
};

static_assert(sizeof(Month) == 4 && alignof(Month) == 4, "");
\end{lstlisting}

\noindent As it turns out, date values are used widely throughout this code base,
and the proposed \texttt{Date} type is expected to be used in large
aggregates. The underlying type of the \texttt{enum} in the code snippet
above is implementation-defined and could be as small as a \texttt{char}
or as large as an \texttt{int} despite all the values fitting in a
\texttt{char}. Hence, if this enumeration were used as a data member in
the \texttt{Date} class, \texttt{sizeof(Date)} would likely balloon to
12 bytes on some relevant platforms due to \textbf{natural alignment}!
(See ``\titleref{alignas}" on page~\pageref{alignas}.)

While reordering the data members of \texttt{Date} such that \texttt{d\_year} and
\texttt{d\_day} were adjacent would ensure that \texttt{sizeof(Date)}
would not exceed 8 bytes, a better approach is to explicitly specify the
enumeration's underlying type to ensure \texttt{sizeof(Date)} is exactly
the 4 bytes needed to accurately represent the value of the
\texttt{Date} object. Given that the values in this enumeration fit in
an 8-bit signed integer, we can specify its \textbf{underlying type} to
be, e.g., \texttt{std::int8\_t} or \texttt{signed}~\texttt{char}, on
every platform:

\begin{lstlisting}[language=C++]
enum Month : std::int8_t  // user-provided underlying type (GOOD IDEA)
{
e_JAN = 1, e_FEB, e_MAR,    // winter
e_APR    , e_MAY, e_JUN,    // spring
e_JUL    , e_AUG, e_SEP,    // summer
e_OCT    , e_NOV, e_DEC     // autumn
};

static_assert(sizeof(Month) == 1 && alignof(Month) == 1, "");
\end{lstlisting}

\noindent With this revised definition of \texttt{Month}, the size of a
\texttt{Date} class is 4 bytes, which is especially valuable for large
aggregates:

\begin{lstlisting}[language=C++]
Date timeSeries[1000 * 1000];  // (ù{\codeincomments{sizeof(timeSeries)}}ù) is now 4Mb (not 12Mb)
\end{lstlisting}


\subsection[Potential Pitfalls]{Potential Pitfalls}\label{potential-pitfalls-underlyingenum}

\subsubsection[External use of opaque enumerators]{External use of opaque enumerators}\label{external-use-of-opaque-enumerators}

Providing an explicit underlying type to an \texttt{enum} enables
clients to declare or redeclare it as a complete type with or without
its enumerators. Unless the opaque form of its definition is exported in
a header file separate from its full definition, external clients
wishing to exploit the opaque version will be forced to locally declare
it with its \textbf{underlying type} but without its enumerator list. If
the underlying type of the full definition were to change, any program
incorporating \emph{its own} original and now inconsistent elided
definition and the \emph{new} full one would become silently ill formed, no diagnostic required (\textbf{IFNDR}). (See ``\titleref{enumopaque}" on page~\pageref{enumopaque}.)

\subsubsection[Subtleties of integral promotion]{Subtleties of integral promotion}\label{subtleties-of-integral-promotion}

When used in an arithmetic context, one might naturally assume that the
type of a classic \texttt{enum} will first convert to its
\textbf{underlying type}, which is not always the case. When used in a
context that does not explicitly operate on the \texttt{enum} type
itself, such as a parameter to a function that takes that enum type,
\textbf{integral promotion} comes into play. For unscoped enumerations
without an explicitly specified underlying type and for character types
such as \texttt{wchar\_t}, \texttt{char16\_t}, and \texttt{char32\_t},
integral promotion will directly convert the value to the first type in
the list \texttt{int}, \texttt{unsigned}~\texttt{int}, \texttt{long},
\texttt{unsigned}~\texttt{long}, \texttt{long}~\texttt{long}, and
\texttt{unsigned}~\texttt{long}~\texttt{long} that is sufficiently large
to represent all of the values of the underlying type. Enumerations
having a fixed underlying type will, as a first step, behave as if they
had decayed to their underlying type.

In most arithmetic expressions, this difference is irrelevant.
Subtleties arise, however, when one relies on overload resolution for
identifying the underlying type:

\begin{lstlisting}[language=C++]
void f(signed char x);
void f(short x);
void f(int x);
void f(long x);
void f(long long x);

enum E1         { a, b, c, d, e };
enum E2 : short { f, g, h, i ,j };

void g()
{
f(E1::a);  // always calls (ù{\codeincomments{f(int)}}ù) on all platforms
f(E2::f);  // always calls (ù{\codeincomments{f(short)}}ù) on all platforms
}
\end{lstlisting}

\noindent The overload resolution for \texttt{f} considers the type to which each
\emph{individual} enumerator can be directly integrally promoted. This
conversion for \texttt{E1} can be only to \texttt{int}. For \texttt{E2},
the conversion will consider \texttt{int} \emph{and} \texttt{short}, and
\texttt{short}, being an exact match, will be selected. Note that even
though both enumerations are small enough to fit into a
\texttt{signed}~\texttt{char}, that overload of \texttt{f} will never be
selected.

One might want to get to the implementation-defined underlying type
though, and the standard does provide a trait to do that:
\texttt{std::underlying\_type} in C++11 and the corresponding
\texttt{std::underlying\_type\_t} alias in C++14. This trait can safely
be used in a cast without risking loss of value{\cprotect\footnote{See
``\titleref{auto}" on page~\pageref{auto}.}}:

\begin{lstlisting}[language=C++]
template <typename E>
std::underlying_type<E>::type toUnderlying(E value)
{
return static_cast<std::underlying_type<E>::type>(value);
}

void h()
{
auto e1 = toUnderlying(E1::a); // might be anywhere from (ù{\codeincomments{signed char}}ù) to (ù{\codeincomments{int}}ù)
auto e2 = toUnderlying(E2::f); // always deduced as (ù{\codeincomments{short}}ù)
}
\end{lstlisting}

\noindent As of C++20, however, the use of a classic enumerator in a context in
which it is compared to or otherwise used in a binary operation with
either an enumerator of another type or a nonintegral type (i.e., a
floating-point type, such as \texttt{float}, \texttt{double}, or
\texttt{long}~\texttt{double}) is deprecated, with the the possibility
of being removed in C++23. Platforms might decide to warn against such
uses retroactively:

\begin{lstlisting}[language=C++]
enum { k_GRAMS_PER_OZ = 28 };  // not the best idea

double gramsFromOunces(double ounces)
{
return ounces * k_GRAMS_PER_OZ;  // deprecated in C++20; might warn
}
\end{lstlisting}

\noindent Casting to the \textbf{underlying type} is \emph{not} necessarily the
same as direct integral promotion. In this context, we might want to
change our \texttt{enum} to a
\texttt{constexpr}~\texttt{int}{\cprotect\footnote{See
``\titleref{constexprvar}" on page~\pageref{constexprvar}.}} in the long
term:

\begin{lstlisting}[language=C++]
constexpr int k_GRAMS_PER_OZ = 28;  // future proof
\end{lstlisting}


\subsection[See Also]{See Also}\label{see-also}

\begin{itemize}
\item{``\titleref{enumclass}" on page~\pageref{enumclass} — a scoped, more strongly typed enumeration}
\item{``\titleref{enumopaque}" on page~\pageref{enumopaque} — a means of \textbf{insulating} individual enumerators from clients}
\item{``\titleref{constexprvar}" on page~\pageref{constexprvar} — an alternative way of declaring compile-time constants}
\end{itemize}

\subsection[Further Reading]{Further Reading}\label{further-reading}

TODO



\newpage
\section[{\tt enum} {\tt class}]{Strongly Typed Enumerations ({\SecCode enum} {\SecCode class})}\label{enumclass}


\texttt{enum}~\texttt{class} is an alternative to the classic
\texttt{enum} construct that simultaneously provides both stronger
typing and an enclosing scope for its enumerated values.

\subsection[Description]{Description}\label{description-enumclass}

Classic, C-style enumerations are useful and continue to fulfill
important engineering needs:

\begin{lstlisting}[language=C++]
enum EnumName { e_Enumerator0 /*= value0 */, e_EnumeratorN /* = valueN */ };
// classic, C-style (ù{\codeincomments{enum}}ù): enumerators are neither type-safe nor scoped
\end{lstlisting}

\noindent For more examples where the classic \texttt{enum} shines, see \textit{\titleref{potential-pitfalls-enumclass}: \titleref{strong-typing-of-an-enum-class-can-be-counterproductive}} on page~\pageref{strong-typing-of-an-enum-class-can-be-counterproductive} and \textit{\titleref{annoyances-enumclass}: \titleref{scoped-enumerations-do-not-necessarily-add-value}} on page~\pageref{scoped-enumerations-do-not-necessarily-add-value}. Still,
innumerable practical situations occur in which enumerators that are
both scoped and more type-safe would be preferred; see \textit{\titleref{introducing-the-c++11-enum-class}} on page~\pageref{introducing-the-c++11-enum-class}.

\subsubsection[Drawbacks and workarounds relating to unscoped C++03 enumerations]{Drawbacks and workarounds relating to unscoped C++03 enumerations}\label{drawbacks-and-workarounds-relating-to-unscoped-c++03-enumerations}

Since the enumerators of a classic \texttt{enum} leak out into the
enclosing scope, if two unrelated enumerations that happen to use the
same enumerator name appear in the same scope, an ambiguity could ensue:

\begin{lstlisting}[language=C++]
enum Color { e_RED, e_ORANGE, e_YELLOW };    // OK
enum Fruit { e_APPLE, e_ORANGE, e_BANANA };  // Error: (ù{\codeincomments{e\_ORANGE}}ù) is redefined.
\end{lstlisting}

\noindent The problems associated with the use of unscoped enumerations is
exacerbated when those enumerations are placed in their own respective
header files in the global or some other large namespace scope, such as
\texttt{std}, for general reuse. In such cases, latent defects will
typically not manifest unless and until the two enumerations are
included in the same translation unit.{\cprotect\footnote{Note that
we use a lowercase, single-letter prefix, such as \texttt{e\_}, to
ensure that the uppercase enumerator name is less likely to collide
with a legacy macro, which is especially useful in header files.}}

If the only issue were the leakage of the enumerators into the enclosing
scope, then the long-established workaround of enclosing the enumeration
within a \texttt{struct} would suffice:

\begin{lstlisting}[language=C++]
struct Color { enum Enum { e_RED, e_ORANGE, e_YELLOW };  };   // OK
struct Fruit { enum Enum { e_APPLE, e_ORANGE, e_BANANA }; };  // OK (scoped)
\end{lstlisting}

\noindent Employing the C++03 workaround in the above code snippet implies that,
when passing such an explicitly scoped, classical \texttt{enum} into a
function, the distinguishing name of the \texttt{enum} is subsumed by
its enclosing \texttt{struct} and the \texttt{enum} name itself, such as
\texttt{Enum}, becomes \textbf{boilerplate code}:

\begin{lstlisting}[language=C++]
int enumeratorValue1 = Color::e_ORANGE;  // OK
int enumeratorValue2 = Fruit::e_ORANGE;  // OK

void colorFunc(Color::Enum color);  // enumerated (scoped) (ù{\codeincomments{Color}}ù) parameter
void fruitFunc(Fruit::Enum fruit);  // enumerated (scoped) (ù{\codeincomments{Fruit}}ù) parameter
\end{lstlisting}

\noindent Hence, adding \emph{just} scope to a classic, C++03 \texttt{enum} is
easily doable and might be exactly what is indicated; see
\textit{\titleref{potential-pitfalls-enumclass}: \titleref{strong-typing-of-an-enum-class-can-be-counterproductive}} on page~\pageref{strong-typing-of-an-enum-class-can-be-counterproductive}.

\subsubsection[Drawbacks relating to weakly typed, C++03 enumerators]{Drawbacks relating to weakly typed, C++03 enumerators}\label{drawbacks-relating-to-weakly-typed,-c++03-enumerators}

Historically, C++03 enumerations have been employed to represent at
least two distinct concepts:

\begin{enumerate}
\item{A collection of related, but not necessarily unique, named integral values}
\item{A pure, perhaps ordered, set of named entities in which cardinal value has no relevance}
\end{enumerate}

\noindent It will turn out that the modern \texttt{enum}~\texttt{class} feature,
which we will discuss in \textit{\titleref{description-enumclass}: \titleref{introducing-the-c++11-enum-class}}, is more closely aligned with this second
concept.

A classic enumeration, by default, has an implementation-defined
\textbf{underlying type} (see ``\titleref{explicit-enumeration-underlying-type}" on page~\pageref{explicit-enumeration-underlying-type}), which it uses to represent
variables of that enumerated type as well as the values of its
enumerators. While implicit conversion \emph{to} an enumerated type is
never permitted, when implicitly converting \emph{from} a classical
\texttt{enum} type to some arithmetic type, the \texttt{enum} promotes
to integral types in a way similar to how its underlying type would
promote using the rules of \textbf{integral promotion} and
\textbf{standard conversion}:

\begin{lstlisting}[language=C++]
void f()
{
enum A { e_A0, e_A1, e_A2 };  // classic, C-style C++03 (ù{\codeincomments{enum}}ù)
enum B { e_B0, e_B1, e_B2 };  //    "       "       "     "

A a;  // Declare object (ù{\codeincomments{a}}ù) to be of type (ù{\codeincomments{A}}ù).
B b;  //   "       "    (ù{\codeincomments{b}}ù)  " "  "       (ù{\codeincomments{B}}ù).

a = e_B2;  // error: cannot convert (ù{\codeincomments{e\_B2}}ù) to (ù{\codeincomments{enum}}ù) type (ù{\codeincomments{A}}ù)
b = e_B2;  // OK, assign the value (ù{\codeincomments{e\_B2}}ù) (numerically 2) to (ù{\codeincomments{b}}ù).
a = b;     // error: cannot convert enumerator (ù{\codeincomments{b}}ù) to (ù{\codeincomments{enum}}ù) type (ù{\codeincomments{A}}ù)
b = b;     // OK, self-assignment
a = 1;     // error: invalid conversion from (ù{\codeincomments{int 1}}ù) to (ù{\codeincomments{enum}}ù) type (ù{\codeincomments{A}}ù)
a = 0;     // error: invalid conversion from (ù{\codeincomments{int 0}}ù) to (ù{\codeincomments{enum}}ù) type (ù{\codeincomments{A}}ù)

bool     v = a;     // OK
char     w = e_A0;  // OK
unsigned y = e_B1;  // OK
float    x = b;     // OK
double   z = e_A2;  // OK
char*    p = e_B0;  // error: unable to convert (ù{\codeincomments{e\_B0}}ù) to (ù{\codeincomments{char*}}ù)
char*    q = +e_B0; // error: invalid conversion of (ù{\codeincomments{int}}ù) to (ù{\codeincomments{char*}}ù)
}
\end{lstlisting}

\noindent Notice that, in this example, the final two diagnostics for the
attempted initializations of \texttt{p} and \texttt{q}, respectively,
differ slightly. In the first, we are trying to initialize a pointer,
\texttt{p}, with an enumerated type, \texttt{B}. In the second, we have
creatively used the built-in unary-plus operator to explicitly promote
the enumerator to an integral type before attempting to assign it to a
pointer, \texttt{q}. Even though the numerical value of the enumerator
is \texttt{0} and such is known at at compile time, implicit
conversion to a pointer type from anything but the literal integer
constant \texttt{0}{\cprotect\footnote{Excluding esoteric user-defined
types, only a literal \texttt{0} or, as of C++11, a value of type
\texttt{std::nullptr\_t} is implicitly convertible to an arbitrary
pointer type; see ``\titleref{null-pointer-literal-(nullptr)}" on page~\pageref{null-pointer-literal-(nullptr)}.}} is not
permitted.

C++ fully supports comparing values of \emph{classic} \texttt{enum}
types with values of arbitrary \textbf{arithmetic type} as well as those
of the same enumerated type; the operands of a comparator will be
promoted to a sufficiently large integer type and the comparison will be
done with those values. Comparing values having distinct enumerated
types, however, is deprecated and will typically elicit a
warning.{\cprotect\footnote{As of C++20, attempting to compare two values of distinct classically enumerated
types is a compile-time error. Note that explicitly converting at least one of them to an
integral type --- for example, using built-in unary plus --- both
makes our intentions clear and avoids warnings.

\begin{lstlisting}[language=C++, basicstyle={\ttfamily\footnotesize}]
if (e_A0 < 0)       { /* ... */ }  // OK, comparison with integral type
if (1.0 != e_B1)    { /* ... */ }  // OK, comparison with arithmetic type
if (A() <= e_A2)    { /* ... */ }  // OK, comparison with same enumerated type
if (e_A0 == e_B0)   { /* ... */ }  // warning, deprecated (error as of C++20)
if ( e_A0 == +e_B0) { /* ... */ }  // OK, unary (ù{\codeincomments{+}}ù) converts to integral type
if (+e_A0 ==  e_B0) { /* ... */ }  // OK,   "        "     "     "      "
if (+e_A0 == +e_B0) { /* ... */ }  // OK,   "        "     "     "      "
\end{lstlisting}
}}

\subsubsection[Introducing the C++11 {\tt enum class}]{Introducing the C++11 {\SubsubsecCode enum class}}\label{introducing-the-c++11-enum-class}

With the advent of modern C++, we now have a new, alternative
enumeration construct, \texttt{enum}~\texttt{class}, that simultaneously
addresses strong type safety and lexical scoping, two distinct and often
desirable properties:

\begin{lstlisting}[language=C++]
enum class Name { e_Enumerator0 /* = value0 */, e_EnumeratorN /* = valueN */ };
// (ù{\codeincomments{enum class}}ù) enumerators are both type-safe and scoped
\end{lstlisting}

\noindent Another major distinction is that the default
\textbf{underlying type} for a C-style \texttt{enum} is
\textbf{implementation defined}, whereas, for an
\texttt{enum}~\texttt{class}, it is always an \texttt{int}. See
\textit{\titleref{description-enumclass}: \titleref{enum-class-and-underlying-type}} on page~\pageref{enum-class-and-underlying-type} and
\textit{\titleref{potential-pitfalls-enumclass}: \titleref{external-use-of-opaque-enumerators}} on page~\pageref{external-use-of-opaque-enumerators}.

The enumerators within an \texttt{enum}~\texttt{class} are all scoped by
its name, while classic enumerations leak the enumerators into the
enclosing scope:

\begin{lstlisting}[language=C++]
enum Vehicle  { e_CAR,   e_TRAIN, e_PLANE };
enum Geometry { e_POINT, e_LINE,  e_PLANE };  // Error: (ù{\codeincomments{e\_PLANE}}ù) is redefined.
\end{lstlisting}

\noindent Unlike unscoped enumerations, \texttt{enum}~\texttt{class} does not leak
its enumerators into the enclosing scope and can therefore help avoid
collisions with other enumerations having like-named enumerators defined
in the same scope:

\begin{lstlisting}[language=C++]
enum       VehicleUnscoped  { e_CAR, e_TRAIN, e_PLANE };
struct     VehicleScopedExplicitly { enum { e_CAR, e_TRAIN, e_PLANE }; };
enum class VehicleScopedImplicitly { e_CAR, e_BOAT,  e_PLANE };
\end{lstlisting}

\noindent Just like an unscoped \texttt{enum} type, an object of type
\texttt{enum}~\texttt{class} is passed as a parameter to a function
using the enumerator name itself{\cprotect\footnote{If we use the approach for
adding scope to enumerators that is described in \textit{\titleref{description-enumclass}: \titleref{drawbacks-relating-to-weakly-typed,-c++03-enumerators}} on page~\pageref{drawbacks-relating-to-weakly-typed,-c++03-enumerators}, the name of the enclosing \texttt{struct} together with a
consistent tag, such as \texttt{Enum}, has to be used to indicate an
enumerated type:

\begin{lstlisting}[language=C++, basicstyle={\ttfamily\footnotesize}]
void f1(VehicleScopedExplicitly::Enum value);
// classically scoped (ù{\codeincomments{enum}}ù) passed by value
\end{lstlisting}
}}:

\begin{lstlisting}[language=C++]
void f1(VehicleUnscoped value);          // classic enumeration passed by value
void f2(VehicleScopedImplicitly value);  // modern enumeration passed by value
\end{lstlisting}

\noindent Qualifying the enumerators of a scoped enumeration is the same,
irrespective of whether the scoping is explicit or implicit:

\begin{lstlisting}[language=C++]
void g()
{
f1(VehicleUnscoped::e_PLANE);
// call (ù{\codeincomments{f1}}ù) with an explicitly scoped enumerator

f2(VehicleScopedImplicitly::e_PLANE);
// call (ù{\codeincomments{f2}}ù) with an implicitly scoped enumerator
}
\end{lstlisting}

\noindent Apart from implicit scoping, the modern, C++11
\texttt{enum}~\texttt{class} deliberately does \emph{not} support
implicit conversion, in any context, to its \textbf{underlying type}:

\begin{lstlisting}[language=C++]
int i1 = VehicleScopedExplicitly::e_PLANE;
// OK, scoped C++03 (ù{\codeincomments{enum}}ù) (implicit conversion)

int i2 = VehicleScopedImplicitly::e_PLANE;
// error: no implicit conversion to underlying type

if (VehicleScopedExplicitly::e_PLANE > 3) { /* OK */ }
if (VehicleScopedImplicitly::e_PLANE > 3) { /* error: implicit conversion */ }
\end{lstlisting}

\noindent Enumerators of an \texttt{enum}~\texttt{class} do, however, admit
equality and ordinal comparisons within their own type:

\begin{lstlisting}[language=C++]
enum class E { e_A, e_B, e_C };  // By default, enumerators increase from 0.

static_assert(E::e_A < E::e_C, "");  // OK, comparison between same-type values
static_assert(0 == E::e_A, "");      // error: no implicit conversion from (ù{\codeincomments{E}}ù)
static_assert(0 == static_cast<int>(E::e_A), "");  // OK, explicit conversion

void f(E v)
{
if (v > E::e_A) { /* ... */ }  // OK, comparing values of same type, (ù{\codeincomments{E}}ù)
}
\end{lstlisting}

\noindent Note that incrementing an enumerator variable from one strongly typed
enumerator's value to the next requires an explicit cast; see \textit{\titleref{potential-pitfalls-enumclass}: \titleref{strong-typing-of-an-enum-class-can-be-counterproductive}} on page~\pageref{strong-typing-of-an-enum-class-can-be-counterproductive}.

\subsubsection[{\tt enum} {\tt class} and underlying type]{{\SubsubsecCode enum} {\SubsubsecCode class} and underlying type}\label{enum-class-and-underlying-type}

Since C++11, both scoped and unscoped enumerations permit explicit
specification of their integral \textbf{underlying type}:

\begin{lstlisting}[language=C++]
enum Ec : char { e_X, e_Y, e_Z };
// underlying type is (ù{\codeincomments{char}}ù)

static_assert(1 == sizeof(Ec),     "");
static_assert(1 == sizeof Ec::E_X, "");

enum class Es : short { e_X, e_Y, e_Z };
// underlying type is (ù{\codeincomments{short int}}ù)

static_assert(sizeof(short) == sizeof(Es),     "");
static_assert(sizeof(short) == sizeof Es::E_X, "");
\end{lstlisting}

\noindent Unlike a classic \texttt{enum}, which has an
\textbf{implementation-defined} default \textbf{underlying type}, the
default \textbf{underlying type} for an \texttt{enum}~\texttt{class} is
always \texttt{int}:

\begin{lstlisting}[language=C++]
enum class Ei { e_X, e_Y, e_Z };
// When not specified the underlying type of an (ù{\codeincomments{enum class}}ù) is (ù{\codeincomments{int}}ù).

static_assert(sizeof(int) == sizeof(Ei),     "");
static_assert(sizeof(int) == sizeof Ei::E_X, "");
\end{lstlisting}

\noindent Note that, because the default \textbf{underlying type} of an
\texttt{enum}~\texttt{class} is specified by the Standard, eliding the
enumerators\footnote{See ``\titleref{enumopaque}" on page~\pageref{enumopaque}.} of an \texttt{enum}~\texttt{class} in
a local redeclaration is \emph{always} possible; see
\textit{\titleref{potential-pitfalls-enumclass}: \titleref{external-use-of-opaque-enumerators}} on page~\pageref{external-use-of-opaque-enumerators}.

\subsection[Use Cases]{Use Cases}\label{use-cases-enumclass}

\subsubsection[Avoiding unintended implicit conversions to arithmetic types]{Avoiding unintended implicit conversions to arithmetic types}\label{avoiding-unintended-implicit-conversions-to-arithmetic-types}

Suppose that we want to represent the result of selecting one of a fixed
number of alternatives from a drop-down menu as a simple unordered set
of uniquely valued named integers. For example, this might be the case
when configuring a product, such as a vehicle, for purchase:

\begin{lstlisting}[language=C++]
struct Trans
{
enum Enum { e_MANUAL, e_AUTOMATIC };  // classic, C++03 scoped (ù{\codeincomments{enum}}ù)
};
\end{lstlisting}

\noindent Although automatic promotion of a classic enumerator to \texttt{int}
works well when typical use of the enumerator involves knowing its
cardinal value, such promotions are less than ideal when cardinal values
have no role in intended usage:

\begin{lstlisting}[language=C++]
class Car { /* ... */ };

struct Trans
{                                         // explicitly scoped
enum Enum { e_MANUAL, e_AUTOMATIC };  // classic (ù{\codeincomments{enum}}ù)
};                                        // (BAD IDEA)

int buildCar(Car* result, int numDoors, Trans::Enum trans)
{
int status = Trans::e_MANUAL;    // Oops, accidental misuse!

for (int i = 0; i < trans; ++i)  // Oops, accidental misuse!
{
attachDoor(i);
}

return status;
}
\end{lstlisting}

\noindent As shown in the example above, it is never correct for a value of type
\texttt{Trans::Enum} to be assigned to, compared with, or otherwise
modified like an integer; hence, \emph{any} such use would necessarily
be considered a mistake and, ideally, flagged by the compiler as an
error. The stronger typing provided by \texttt{enum}~\texttt{class}
achieves this goal:

\begin{lstlisting}[language=C++]
class Car { /* ... */ };

enum class Trans { e_MANUAL, e_AUTOMATIC };  // modern (ù{\codeincomments{enum class}}ù) (GOOD IDEA)

int buildCar(Car* result, int numDoors, Trans trans)
{
int status = Trans::e_MANUAL;    // error: incompatible types

for (int i = 0; i < trans; ++i)  // error: incompatible types
{
attachDoor(i);
}

return status;
}
\end{lstlisting}

\noindent By deliberately choosing the \texttt{enum}~\texttt{class} over the
\emph{classic} \texttt{enum} above, we automate the detection of many common
kinds of accidental misuse. Secondarily, we slightly simplify the interface of the function signature by removing the extra \texttt{::Enum} boilerplate qualifications required of an explicitly
scoped, less-type-safe, classic \texttt{enum}, but see \textit{\titleref{potential-pitfalls-enumclass}: \titleref{strong-typing-of-an-enum-class-can-be-counterproductive}} on page~\pageref{strong-typing-of-an-enum-class-can-be-counterproductive}.

In an unlikely event that the numeric value of a strongly typed
enumerator is needed (e.g., for serialization), it can be extracted
explicitly via a \texttt{static\_cast}:

\begin{lstlisting}[language=C++]
const int manualIntegralValue    = static_cast<int>(Trans::e_MANUAL);
const int automaticIntegralValue = static_cast<int>(Trans::e_AUTOMATIC);
static_assert(0 == manualIntegralValue,    "");
static_assert(1 == automaticIntegralValue, "");
\end{lstlisting}

\subsubsection[Avoiding namespace pollution]{Avoiding namespace pollution}\label{avoiding-namespace-pollution}

Classic, C-style enumerations do not provide scope for their
enumerators, leading to unintended latent name collisions:

\begin{lstlisting}[language=C++]
// vehicle.h
// ...
enum Vehicle  { e_CAR, e_TRAIN, e_PLANE };  // classic, C-style (ù{\codeincomments{enum}}ù)
// ...

// geometry.h
// ...
enum Geometry { e_POINT, e_LINE,  e_PLANE };  // classic, C-style (ù{\codeincomments{enum}}ù)
// ...

// client
#include <vehicle.h>  // OK
#include <geometry.h> // error: (ù{\codeincomments{e\_PLANE}}ù) redefined
// ...
\end{lstlisting}

\noindent The common workaround is to wrap the \texttt{enum} in a \texttt{struct}
or \texttt{namespace}:

\begin{lstlisting}[language=C++]
// vehicle.h
// ...
struct Vehicle {                            // explicitly scoped
enum Enum { e_CAR, e_TRAIN, e_PLANE };  // classic, C-style (ù{\codeincomments{enum}}ù)
};
// ...

// geometry.h
// ...
struct Geometry {                            // explicitly scoped
enum Enum { e_POINT, e_LINE, e_PLANE };  // classic, C-style (ù{\codeincomments{enum}}ù)
};
// ...

// client
#include <vehicle.h>    // OK
#include <geometry.h>   // OK, enumerators are scoped explicitly.
// ...
\end{lstlisting}

\noindent If implicit conversions of enumerators to integral types are not
required, we can achieve the same scoping effect with much more type
safety and slightly less boilerplate --- i.e., without the
\texttt{::Enum} when declaring a variable --- by employing
\texttt{enum}~\texttt{class} instead:

\begin{lstlisting}[language=C++]
// vehicle.h
// ...
enum class Vehicle { e_CAR, e_TRAIN, e_PLANE };
// ...

// geometry.h
// ...
enum class Geometry { e_POINT, e_LINE, e_PLANE };
// ...

// client
#include <vehicle.h>  // OK
#include <geometry.h>   // OK, enumerators are scoped implicitly.
// ...
\end{lstlisting}

\subsubsection[Improving overloading disambiguation]{Improving overloading disambiguation}\label{improving-overloading-disambiguation}

Overloaded functions are notorious for providing opportunities for
misuse. Maintenance difficulties are exacerbated when arguments for
these overloads are convertible to more than a single parameter in the
function. As an illustration of the compounding of such maintenance
difficulties, suppose that we have a widely used, named type,
\texttt{Color}, and the numeric values of its enumerators are small,
unique, and irrelevant. Imagine we have chosen to represent
\texttt{Color} as a \emph{classic} \texttt{enum}:

\begin{lstlisting}[language=C++]
struct Color
{                                           // explicitly scoped
enum Enum { e_RED, e_BLUE /*, ...*/ };  // classic, C-style (ù{\codeincomments{enum}}ù)
};                                          // (BAD IDEA)
\end{lstlisting}

\noindent Suppose further that we have provided two overloaded functions, each
having two parameters, with one signature's parameters including the
enumeration \texttt{Color}:

\begin{lstlisting}[language=C++]
void clearScreen(int pattern, int orientation);          // (0)
void clearScreen(Color::Enum background, double alpha);  // (1)
\end{lstlisting}

\noindent Depending on the types of the arguments supplied, one or the other
functions will be selected or else the call will be ambiguous and the
program will fail to compile{\cprotect\footnote{GCC version 7.4.0
incorrectly diagnoses both ambiguity errors as warnings, although it
states in the warning that it is an error:

\begin{lstlisting}[language=C++, basicstyle={\ttfamily\footnotesize}]
warning: ISO C++ says that these are ambiguous, even though the worst conversion for the
first is better than the worst conversion for the second:

note: candidate 1: void clearScreen(int, int)
void clearScreen(int pattern, int orientation);
^~~~~~~~~~~
note: candidate 2: void clearScreen(Color::Enum, double)
void clearScreen(Color::Enum background, double alpha;
^~~~~~~~~~~
\end{lstlisting}
}}:

\begin{lstlisting}[language=C++]
void f0()
{
clearScreen(1           , 1           );  // calls (0) above
clearScreen(1           , 1.0         );  // calls (0) above
clearScreen(1           , Color::e_RED);  // calls (0) above

clearScreen(1.0         , 1           );  // calls (0) above
clearScreen(1.0         , 1.0         );  // calls (0) above
clearScreen(1.0         , Color::e_RED);  // calls (0) above

clearScreen(Color::e_RED, 1           );  // error: ambiguous call
clearScreen(Color::e_RED, 1.0         );  // calls (1) above
clearScreen(Color::e_RED, Color::e_RED);  // error: ambiguous call
}
\end{lstlisting}

\noindent Now suppose that we had instead defined our \texttt{Color} enumeration
as a modern \texttt{enum}~\texttt{class}:

\begin{lstlisting}[language=C++]
enum class Color { e_RED, e_BLUE /*, ...*/ };

void clearScreen(int pattern, int orientation);    // (2)
void clearScreen(Color background, double alpha);  // (3)
\end{lstlisting}

\noindent The function that will be called from a given set of arguments becomes
clear:

\begin{lstlisting}[language=C++]
void f1()
{
clearScreen(1           , 1           );  // calls (2) above
clearScreen(1           , 1.0         );  // calls (2) above
clearScreen(1           , Color::e_RED);  // error: no matching function

clearScreen(1.0         , 1           );  // calls (2) above
clearScreen(1.0         , 1.0         );  // calls (2) above
clearScreen(1.0         , Color::e_RED);  // error: no matching function

clearScreen(Color::e_RED, 1           );  // calls (3) above
clearScreen(Color::e_RED, 1.0         );  // calls (3) above
clearScreen(Color::e_RED, Color::e_RED);  // error: no matching function
}
\end{lstlisting}

\noindent Returning to our original, classic-\texttt{enum} design, suppose that we
find we need to add a third parameter, \texttt{bool}~\texttt{z}, to the
second overload:

\begin{lstlisting}[language=C++]
void clearScreen(int pattern, int orientation);                  // (0)
void clearScreen(Color::Enum background, double alpha, bool z);  // (4) classic
\end{lstlisting}

\noindent If our plan is that any existing client calls involving
\texttt{Color::Enum} will now be flagged as errors, we are going to be
very disappointed:

\begin{lstlisting}[language=C++]
void f2()
{
clearScreen(Color::e_RED, 1.0);  // calls (0) above
}
\end{lstlisting}

\noindent In fact, every combination of arguments above --- all nine of them ---
will call function (0) above with no warnings at all:

\begin{lstlisting}[language=C++]
void f3()
{
clearScreen(1           , 1           );  // calls (0) above
clearScreen(1           , 1.0         );  // calls (0) above
clearScreen(1           , Color::e_RED);  // calls (0) above

clearScreen(1.0         , 1           );  // calls (0) above
clearScreen(1.0         , 1.0         );  // calls (0) above
clearScreen(1.0         , Color::e_RED);  // calls (0) above

clearScreen(Color::e_RED, 1           );  // calls (0) above
clearScreen(Color::e_RED, 1.0         );  // calls (0) above
clearScreen(Color::e_RED, Color::e_RED);  // calls (0) above
}
\end{lstlisting}

\noindent Finally, let's suppose again that we have used
\texttt{enum}~\texttt{class} to implement our \texttt{Color}\linebreak[4]
\mbox{enumeration}:

\begin{lstlisting}[language=C++]
void clearScreen(int pattern, int orientation);            // (2)
void clearScreen(Color background, double alpha, bool z);  // (5) modern

void f4()
{
clearScreen(Color::e_RED, 1.0);  // error: no matching function
}
\end{lstlisting}

\noindent And in fact, the \emph{only} calls that succeed unmodified are precisely
those that do not involve the enumeration \texttt{Color}, as desired:

\begin{lstlisting}[language=C++]
void f5()
{
clearScreen(1           , 1           );  // calls (2) above
clearScreen(1           , 1.0         );  // calls (2) above
clearScreen(1           , Color::e_RED);  // error: no matching function

clearScreen(1.0         , 1           );  // calls (2) above
clearScreen(1.0         , 1.0         );  // calls (2) above
clearScreen(1.0         , Color::e_RED);  // error: no matching function

clearScreen(Color::e_RED, 1           );  // error: no matching function
clearScreen(Color::e_RED, 1.0         );  // error: no matching function
clearScreen(Color::e_RED, Color::e_RED);  // error: no matching function
}
\end{lstlisting}

\noindent Bottom line: Having a \emph{pure} enumeration --- such as
\texttt{Color}, used widely in function signatures --- be strongly typed
can only help to expose accidental misuse but, again, see
\textit{\titleref{potential-pitfalls-enumclass}: \titleref{strong-typing-of-an-enum-class-can-be-counterproductive}} on page~\pageref{strong-typing-of-an-enum-class-can-be-counterproductive}.

Note that strongly typed enumerations help to avoid accidental misuse by
requiring an explicit \emph{cast} should conversion to an arithmetic
type be desired:

\begin{lstlisting}[language=C++]
void f6()
{
clearScreen(Color::e_RED, 1.0);                   // error: no match
clearScreen(static_cast<int>(Color::e_RED), 1.0); // OK, calls (2) above
clearScreen(Color::e_RED, 1.0, false);            // OK, calls (5) above
}
\end{lstlisting}


\subsubsection[Encapsulating implementation details within the enumerators themselves]{Encapsulating implementation details within the enumerators themselves}\label{encapsulating-implementation-details-within-the-enumerators-themselves}

In rare cases, providing a pure, ordered enumeration having unique, but
not necessarily contiguous, numerical values that exploit lower-order
bits{\cprotect\footnote{To preserve the ordinality of the enumerators
overall, the higher-level bits must encode their relative order. The
lower-level bits are then available for arbitrary use in the
implementation.}} to categorize (and make readily available) important
individual properties might offer an advantage, such as in performance.

For example, suppose that we have a \texttt{MonthOfYear} enumeration
that encodes the months that have 31 days in their least-significant bit
and an accompanying \texttt{inline} function to quickly determine
whether a given enumerator represents such a month{\cprotect\footnote{In this example, we are using a new cross-cutting
feature of all enumerated types that allows the client defining the
type to specify its underlying type precisely. In this case, we have
chosen an \texttt{unsigned}~\texttt{char} to maximize the number of
flag bits while keeping the overall size to a single byte. Three bits
remain available. Had we needed more flag bits, we could have just as
easily used a larger underlying type, such as
\texttt{unsigned}~\texttt{short}; see ``\titleref{explicit-enumeration-underlying-type}" on page~\pageref{explicit-enumeration-underlying-type}.}}:

\begin{lstlisting}[language=C++]
enum class MonthOfYear : unsigned char  // optimized to flag long months
{
e_JAN = ( 1 << 4) + 0x1,
e_FEB = ( 2 << 4) + 0x0,
e_MAR = ( 3 << 4) + 0x1,
e_APR = ( 4 << 4) + 0x0,
e_MAY = ( 5 << 4) + 0x1,
e_JUN = ( 6 << 4) + 0x0,
e_JUL = ( 7 << 4) + 0x1,
e_AUG = ( 8 << 4) + 0x1,
e_SEP = ( 9 << 4) + 0x0,
e_OCT = (10 << 4) + 0x1,
e_NOV = (11 << 4) + 0x0,
e_DEC = (12 << 4) + 0x1
};

bool hasThirtyOneDays(MonthOfYear month)
{
return static_cast<std::underlying_type<MonthOfYear>::type>(month) & 0x1;
}
\end{lstlisting}

\noindent In such cases, the public clients are not intended to make use of the
cardinal values; hence clients are well advised to treat them as
implementation details, potentially subject to change without notice.
Representing this enumeration using the modern
\texttt{enum}~\texttt{class}, instead of an explicitly scoped classic
\texttt{enum}, deters clients from making any use (apart from same-type
comparisons) of the cardinal values assigned to the enumerators. Notice
that implementors of the \texttt{hasThirtyOneDays} function will require
a verbose but runtime efficient \texttt{static\_cast} to resolve the
cardinal value of the enumerator and thus make the requested
determination as efficiently as possible.

\subsection[Potential Pitfalls]{Potential Pitfalls}\label{potential-pitfalls-enumclass}

\subsubsection[Strong typing of an {\tt enum} {\tt class} can be counterproductive]{Strong typing of an {\SubsubsecCode enum} {\SubsubsecCode class} can be counterproductive}\label{strong-typing-of-an-enum-class-can-be-counterproductive}

The additive value in using a modern \texttt{enum}~\texttt{class} is
governed \emph{solely} by whether its stronger typing, \emph{not} its
implicit scoping, of its enumerators would be beneficial in its
anticipated typical usage. If the expectation is that the client will
never to need to know the specific values of the enumerators, then use
of the modern \texttt{enum}~\texttt{class} is often just what's needed.
But if the cardinal values themselves are ever needed during typical
use, extracting them will require the client to perform an explicit
cast. Beyond mere inconvenience, encouraging clients to use casts
invites defects.

Suppose, for example, we have a function, \texttt{setPort}, from an
external library that takes an integer port number:

\begin{lstlisting}[language=C++]
int setPort(int portNumber);
// Set the current port; return (ù{\codeincomments{0}}ù) on success and a nonzero value otherwise.
\end{lstlisting}

\noindent Suppose further that we have used the modern
\texttt{enum}~\texttt{class} feature to implement an enumeration,
\texttt{SysPort}, that identifies well-known ports on our system:

\begin{lstlisting}[language=C++]
enum class SysPort { e_INPUT = 27, e_OUTPUT = 29, e_ERROR = 32, e_CTRL = 6 };
// enumerated port values used to configure our systems
\end{lstlisting}

\noindent Now suppose we want to call the function \texttt{f} using one of these
enumerated values:

\begin{lstlisting}[language=C++]
void setCurrentPortToCtrl()
{
setPort(SysPort::e_CTRL);  // error: cannot convert (ù{\codeincomments{SetPort}}ù) to (ù{\codeincomments{int}}ù)
}
\end{lstlisting}

\noindent Unlike the situation for a \emph{classic} \texttt{enum}, no implicit
conversion occurs from an \texttt{enum}~\texttt{class} to its underlying
integral type, so anyone using this enumeration will be forced to
somehow explicitly \textbf{cast} the enumerator to some arithmetic type.
There are, however, multiple choices for performing this cast:

\begin{lstlisting}[language=C++]
#include <type_traits>  // (ù{\codeincomments{std::underlying\_type}}ù)

setPort(int(SysPort::e_CTRL));                                           // (1)
setPort((int)SysPort::e_CTRL);                                           // (2)
setPort(static_cast<int>(SysPort::e_CTRL));                              // (3)
setPort(static_cast<std::underlying_type<SysPort>::type>(                // (4)
SysPort::e_CTRL));
setPort(static_cast<int>(                                                // (5)
static_cast<std::underlying_type<SysPort>::type>(SysPort::e_CTRL)));
\end{lstlisting}

\noindent Any of the above casts would work in this case, but consider a future
where a platform changed \texttt{setPort} to take a \texttt{long} and
the control port was changed to a value that cannot be represented as an
\texttt{int}:

\begin{lstlisting}[language=C++]
int setPort(long portNumber);
enum class SysPort : unsigned { e_INPUT = 27, e_OUTPUT = 29, e_ERROR = 32,
e_CTRL = 0x80000000 };
// enumerated port values used to configure our systems
\end{lstlisting}

\noindent Only casting method (4) above will pass the correct value for
\texttt{e\_CTRL} to this new \texttt{setPort} implementation. The other
variations will all pass a negative number for the port, which would
certainly not be the intention of the user writing this code. A classic
C-style \texttt{enum} would have avoided any manually written cast
entirely and the proper value would propagate into \texttt{setPort} even
as the range of values used for ports changes:

\begin{lstlisting}[language=C++]
struct SysPort  // explicit scoping for a classic, C-style (ù{\codeincomments{enum}}ù)
{
enum Enum { e_INPUT = 27, e_OUTPUT = 29, e_ERROR = 32,
e_CTRL = 0x80000000 };

// Note that the underlying type of (ù{\codeincomments{Enum}}ù) is implicit and will be
// large enough to represent all of these values.
static_assert(
std::is_same<std::underlying_type<Enum>::type,unsigned>::value, "");
};

void setCurrentPortToCtrl()
{
setPort(SysPort::e_CTRL);  // OK, (ù{\codeincomments{SysPort::Enum}}ù) promotes to (ù{\codeincomments{long}}ù).
}
\end{lstlisting}

\noindent When the intended client will depend on the cardinal values of the
enumerators during routine use, we can avoid tedious, error-prone, and
repetitive casting by instead employing a classic, C-style
\texttt{enum}, possibly nested within a \texttt{struct} to achieve
explicit scoping of its enumerators. The subsections that follow
highlight specific cases in which classic, C-style, C++03
\texttt{enum}s are appropriate.

\subsubsection[Misuse of {\tt enum} {\tt class} for collections of named constants]{Misuse of {\SubsubsecCode enum} {\SubsubsecCode class} for collections of named constants}\label{misuse-of-enum-class-for-collections-of-named-constants}

When constants are truly independent, we are often encouraged to avoid
enumerations altogether, preferring instead individual constants; see
``\titleref{Default-Member-Initializers}" on page~\pageref{Default-Member-Initializers}. On the other hand, when the constants all participate within a coherent
theme, the expressiveness achieved using a \emph{classic} \texttt{enum}
to aggregate those values is compelling.{\cprotect\footnote{Another
advantage of an enumerator over an individual constant is that the
enumerator is guaranteed to be a \textbf{compile-time constant} (see
``\titleref{constexprvar}" on page~\pageref{constexprvar}) and a \textbf{prvalue} (see
``\titleref{Rvalue-References}" on page~\pageref{Rvalue-References}), which never needs static storage
and cannot have its address taken.}}

For example, suppose we want to collect the coefficients for various
numerical suffixes representing \emph{thousands}, \emph{millions}, and
\emph{billions} using an enumeration:

\begin{lstlisting}[language=C++]
enum class S0 { e_K = 1000, e_M = e_K * e_K, e_G = e_M * e_K };  // (BAD IDEA)
\end{lstlisting}

\noindent A client trying to access one of these enumerated values would need to
cast it explicitly:

\begin{lstlisting}[language=C++]
void client0()
{
int distance = 5 * static_cast<int>(S0::e_K);  // casting is error-prone
// ...
}
\end{lstlisting}

\noindent By instead making the enumeration an explicitly scoped, \emph{classic}
\texttt{enum} nested within a \texttt{struct}, no casting is needed
during typical use:

\begin{lstlisting}[language=C++]
struct S1  // scoped
{
enum Enum { e_K = 1000, e_M = e_K * e_K, e_G = e_M * e_K };
// *classic* (ù{\codeincomments{enum}}ù) (GOOD IDEA)
};

void client1()
{
int distance = 5 * S1::e_K;  // no casting required during typical use
// ...
}
\end{lstlisting}

\noindent If the intent is that these constants will be specified and used in a
purely local context, we might choose to drop the enclosing scope, along
with the name of the enumeration itself\footnote{See
``\titleref{local-types-as-template-arguments}" on page~\pageref{local-types-as-template-arguments}.}{\cprotect\footnote{We sometimes use the
lowercase prefix \texttt{k\_} instead of \texttt{e\_} to indicate
salient \textbf{compile-time constants} that are not considered part
of an enumerated set, irrespective of whether they are implemented as
enumerators:

\begin{lstlisting}[language=C++, basicstyle={\ttfamily\footnotesize}]
enum { k_NUM_PORTS = 500, k_PAGE_SIZE = 512 };     // compile-time constants
static const double k_PRICING_THRESHOLD = 0.03125; // compile-time constant
\end{lstlisting}
}}:

\begin{lstlisting}[language=C++]
void client2()
{
enum { e_K = 1000, e_M = e_K * e_K, e_G = e_M * e_K };  // function scoped

double salary = 95 * e_K;
double netWorth = 0.62 * e_M;
double companyRevenue = 47.2 * e_G;
// ...
}
\end{lstlisting}


\subsubsection[Misuse of {\tt enum} {\tt class} in association with bit flags]{Misuse of {\SubsubsecCode enum} {\SubsubsecCode class} in association with bit flags}\label{misuse-of-enum-class-in-association-with-bit-flags}

Using \texttt{enum}~\texttt{class} to implement enumerators that are
intended to interact closely with arithmetic types will typically
require the definition of arithmetic and bitwise operator overloads
between values of the same enumeration and between the enumeration and
arithmetic types, leading to yet more code that needs to be written,
tested, and maintained. This is often the case for bit flags. Consider, for example, an
enumeration used to control a file system:

\begin{lstlisting}[language=C++]
enum class Ctrl { e_READ = 0x1, e_WRITE = 0x2, e_EXEC = 0x4 };  // (BAD IDEA)
// low-level bit flags used to control file system

void chmodFile(int fd, int access);
// low-level function used to change privileges on a file
\end{lstlisting}

\noindent We could conceivably write a series of functions to combine the
individual flags in a type-safe manner:

\begin{lstlisting}[language=C++]
#include <type_traits>  // (ù{\codeincomments{std::underlying\_type}}ù)

int flags() { return 0; }
int flags(Ctrl a) { return static_cast<std::underlying_type<a>::type>(a); }
int flags(Ctrl a, Ctrl b) { return flags(a) | flags(b); }
int flags(Ctrl a, Ctrl b, Ctrl c) { return flags(a, b) | flags(c); }

void setRW(int fd)
{
chmodFile(fd, flags(Ctrl::e_READ, Ctrl::e_WRITE));  // (BAD IDEA)
}
\end{lstlisting}

\noindent Alternatively, a \emph{classic}, C-style \texttt{enum} nested within a
\texttt{struct} achieves what's needed:

\begin{lstlisting}[language=C++]
struct Ctrl // scoped
{
enum Enum { e_READ = 0x1, e_WRITE = 0x2, e_EXEC = 0x4 };  // classic (ù{\codeincomments{enum}}ù)
// low-level bit flags used to control file system (GOOD IDEA)
};

void chmodFile(int fd, int access);
// low-level function used to change privileges on a file

void setRW(int fd)
{
chmodFile(fd, Ctrl::e_READ | Ctrl::e_WRITE);  // (GOOD IDEA)
}
\end{lstlisting}


\subsubsection[Misuse of {\tt enum} {\tt class} in association with iteration]{Misuse of {\SubsubsecCode enum} {\SubsubsecCode class} in association with iteration}\label{misuse-of-enum-class-in-association-with-iteration}

Sometimes the relative values of enumerators are considered important as
well. For example, let's again consider enumerating the months of the
year:

\begin{lstlisting}[language=C++]
enum class MonthOfYear  // modern, strongly typed enumeration
{
e_JAN, e_FEB, e_MAR,  // winter
e_APR, e_MAY, e_JUN,  // spring
e_JUL, e_AUG, e_SEP,  // summer
e_OCT, e_NOV, e_DEC,  // autumn
};
\end{lstlisting}

\noindent If all we need to do is compare the ordinal values of the enumerators,
there's no problem:

\begin{lstlisting}[language=C++]
bool isSummer(MonthOfYear month)
{
return MonthOfYear::e_JUL <= month && month <= MonthOfYear::e_AUG;
}
\end{lstlisting}

\noindent Although the \texttt{enum}~\texttt{class} features allow for relational
and equality operations between like-typed enumerators, no arithmetic
operations are supported directly, which becomes problematic when we
need to iterate over the enumerated values:

\begin{lstlisting}[language=C++]
void doSomethingWithEachMonth()
{
for (MonthOfYear i =  MonthOfYear::e_JAN;
i <= MonthOfYear::e_DEC;
++i)  // error: no match for (ù{\codeincomments{++}}ù)
{
// ...
}
}
\end{lstlisting}

\noindent To make this code compile, an explicit cast from and to the enumerated
type will be required:

\begin{lstlisting}[language=C++]
void doSomethingWithEachMonth()
{
for (MonthOfYear i =  MonthOfYear::e_JAN;
i <= MonthOfYear::e_DEC;
i = static_cast<MonthOfYear>(static_cast<int>(i) + 1)
{
// ...
}
}
\end{lstlisting}

\noindent Alternatively, an auxiliary, helper function could be supplied to allow
clients to bump the enumerator:

\begin{lstlisting}[language=C++]
MonthOfYear nextMonth(MonthOfYear value)
{
return static_cast<MonthOfYear>(static_cast<int>(value) + 1);
}

void doSomethingWithEachMonth()
{
for (MonthOfYear i =  MonthOfYear::e_JAN;
i <= MonthOfYear::e_DEC;
i = nextMonth(i)
{
// ...
}
}
\end{lstlisting}

\noindent If, however, the cardinal value of the \texttt{MonthOfYear} enumerators
is likely to be relevant to clients, an explicitly scoped \emph{classic}
\texttt{enum} should be considered as a viable alternative:

\begin{lstlisting}[language=C++]
struct MonthOfYear  // explicit scoping for (ù{\codeincomments{enum}}ù)
{
enum Enum
{
e_JAN, e_FEB, e_MAR,  // winter
e_APR, e_MAY, e_JUN,  // spring
e_JUL, e_AUG, e_SEP,  // summer
e_OCT, e_NOV, e_DEC,  // autumn
};
};

bool isSummer(MonthOfYear::Enum month)  // must now pass nested (ù{\codeincomments{Enum}}ù) type
{
return MonthOfYear::e_JUL <= month && month <= MonthOfYear::e_AUG;
}

void doSomethingWithEachMonth()
{
for (int i =  MonthOfYear::e_JAN;  // iteration variable is now an (ù{\codeincomments{int}}ù)
i <= MonthOfYear::e_DEC;
++i)  // OK, convert to underlying type
{
// ... (might require cast back to enumerated type)
}
}
\end{lstlisting}

\noindent Note that such code presumes that the enumerated values will (1) remain
in the same order and (2) have contiguous numerical values irrespective
of the implementation choice.

\subsubsection[External use of opaque enumerators]{External use of opaque enumerators}\label{external-use-of-opaque-enumerators}

Since \texttt{enum}~\texttt{class} types have an \textbf{underlying
type} of \texttt{int} by default, clients are always able to (re)declare
it, as a \textbf{complete type}, without its enumerators. Unless the
opaque form of an \texttt{enum}~\texttt{class}'s definition is exported
in a header file separate from the one implementing the publicly
accessible full definition, external clients wishing to exploit the
opaque version will experience an \emph{attractive nuisance} in that
they can provide it locally, along with its \textbf{underlying type}, if
any.

If the underlying type of the full definition were to subsequently
change, any program incorporating the original elided definition locally
and also the new, full one from the header would become silently \textbf{ill formed, no diagnostic required (IFNDR)}; see ``\titleref{enumopaque}" on page~\pageref{enumopaque}.

\subsection[Annoyances]{Annoyances}\label{annoyances-enumclass}

\subsubsection[Scoped enumerations do not necessarily add value]{Scoped enumerations do not necessarily add value}\label{scoped-enumerations-do-not-necessarily-add-value}

When the enumeration is local, say, within the scope of a given
function, forcing an additional scope on the enumerators is superfluous.
For example, consider a function that returns an integer status
\texttt{0} on success and a nonzero value otherwise:

\begin{lstlisting}[language=C++]
int f()
{
enum { e_ERROR = -1, e_OK = 0 } result = e_OK;
// ...
if (/* error 1 */) { result = e_ERROR; }
// ...
if (/* error 2 */) { result = e_ERROR; }
// ...
return result;
}
\end{lstlisting}

\noindent Use of \texttt{enum}~\texttt{class} in this context would require
potentially needless qualification --- and perhaps even casting ---
where it might not be warranted:

\begin{lstlisting}[language=C++]
int f()
{
enum class RC { e_ERROR = -1, e_OK = 0 } result = RC::e_OK;
// ...
if (/* error 1 */) { result = RC::e_ERROR; } // undesirable qualification
// ...
if (/* error 2 */) { result = RC::e_ERROR; } // undesirable qualification
// ...
return static_cast<int>(result);  // undesirable explicit cast
}
\end{lstlisting}

\subsection[See Also]{See Also}\label{see-also}

\begin{itemize}
\item{``\titleref{explicit-enumeration-underlying-type}" on page~\pageref{explicit-enumeration-underlying-type} --- The underlying integral representation enumerator variables and values}
\item{``\titleref{enumopaque}" on page~\pageref{enumopaque} --- A means of \textbf{insulating} individual enumerators from clients}
\end{itemize}

\subsection[Further Reading]{Further Reading}\label{further-reading}

TODO

\newpage
\section[Opaque Enumeration Declarations]{Opaque Enumeration Declarations}\label{enumopaque}


placeholder text.........



\newpage
\section[{\ttfamily auto}]{{\SecCode auto}}\label{auto}


placeholder text.........




% to add to the TOC at the section level

\newpage
\section[Aggregate Member Initialization Relaxation]{Aggregate Member Initialization Relaxation}\label{aggregate-member-initialization-relaxation}

C++14 enables the use of \textbf{aggregate initialization} with classes
employing Default Member Initializers (see Section~\ref{Default-Member-Initializers}, ``\titleref{Default-Member-Initializers}").

\subsection[Description]{Description}\label{description}

Prior to C++14, classes that made use of \titleref{Default-Member-Initializers} --- i.e., initializers that appear directly within the
scope of the class --- were not considered \textbf{aggregate} types:

\begin{lstlisting}[language=C++]
struct S                // aggregate type in C++14 but not C++11
{
int i;
bool b = false;     // uses default member initializer
};

struct A                // aggregate type in C++11 and C++14
{
int  i;
bool b;             // does not use default member initializer
};
\end{lstlisting}

\noindent Because \texttt{A} (but not \texttt{S}) is considered an \textbf{aggregate} in
C++11, instances of \texttt{A} can be created via \textbf{aggregate
initialization} (whereas instances of \texttt{S} cannot):

\begin{lstlisting}[language=C++]
A a{100, true};  // OK in both C++11 and C++14
S s{100, true};  // error in C++11; OK in C++14
\end{lstlisting}


\noindent As of C++14, the requirements for a type to be categorized as an
\textbf{aggregate} are relaxed, allowing classes employing default
member initializers to be considered as such; hence both \texttt{A} and
\texttt{S} are considered \textbf{aggregates} in C++14 and eligible for
\textbf{aggregate initialization}:

\begin{lstlisting}[language=C++]
void f()
{
S s0{100, true};        // OK in C++14 but not in C++11
assert(s0.i == 100);    // set via explicit aggregate initialization (above)
assert(s0.b == true);   // set via explicit aggregate initialization (above)

S s1{456};              // OK in C++14 but not in C++11
assert(s1.i == 456);    // set via explicit aggregate initialization (above)
assert(s1.b == false);  // set via default member initializer
}
\end{lstlisting}

\noindent In the code snippet above, the C++14 aggregate \texttt{S} is initialized
in two ways: \texttt{s0} is created using aggregate initialization for
both data members; \texttt{s} is created using aggregate
initialization for only the first data member (and the second is set via its
default member \nobreak{initializer}).

\subsection[Use Cases]{Use Cases}\label{use-cases}

\subsubsection[Configuration \tt{struct}s]{Configuration {\SubsubsecCode struct}s}\label{configuration-structs}

\textbf{Aggregates} in conjunction with \titleref{Default-Member-Initializers} can be used to provide concise customizable
configuration \texttt{struct}s, packaged with typical default values. As
an example, consider a configuration \texttt{struct} for an HTTP request
handler:

\begin{lstlisting}[language=C++]
struct HTTPRequestHandlerConfig
{
int maxQueuedRequests = 1024;
int timeout           = 60;
int minThreads        = 4;
int maxThreads        = 8;
};
\end{lstlisting}

\noindent \textbf{Aggregate initialization} can be used when creating objects of
type \nobreak{\texttt{HTTPRequestHandlerConfig}} (above) to override one or more
of the defaults in definition order{\cprotect\footnote{In C++20, the
Designated Initializers feature adds flexibility (e.g., for
configuration \texttt{struct}s, such as
\texttt{HTTPRequestHandlerConfig}) by enabling explicit specification
of the names of the data members:

\begin{lstlisting}[language=C++, basicstyle={\ttfamily\footnotesize}]
HTTPRequestHandlerConfig lowTimeout{.timeout = 15};
// (ù{\codeincomments{maxQueuedRequests}}ù), (ù{\codeincomments{minThreads}}ù), and (ù{\codeincomments{maxThreads}}ù) have their default value.

HTTPRequestHandlerConfig highPerformance{.timeout = 120, .maxThreads = 16};
// (ù{\codeincomments{maxQueuedRequests}}ù) and (ù{\codeincomments{minThreads}}ù) have their default value.
\end{lstlisting}
}}:

\begin{lstlisting}[language=C++]
HTTPRequestHandlerConfig getRequestHandlerConfig(bool inLowMemoryEnvironment)
{
if (inLowMemoryEnvironment)
{
return HTTPRequestHandlerConfig{128};
// (ù{\codeincomments{timeout}}ù), (ù{\codeincomments{minThreads}}ù), and (ù{\codeincomments{maxThreads}}ù) have their default value.
}
else
{
return HTTPRequestHandlerConfig{2048, 120};
// (ù{\codeincomments{minThreads}}ù), and (ù{\codeincomments{maxThreads}}ù) have their default value.
}
}

// ...
\end{lstlisting}


\subsection[Potential Pitfalls]{Potential Pitfalls}\label{potential-pitfalls}

None so far

\subsection[Annoyances]{Annoyances}\label{annoyances}

\subsubsection[Syntactical ambiguity in the presence of \textbf{brace elision}]{Syntactical ambiguity in the presence of \textbf{brace elision}}\label{syntactical-ambiguity-in-the-presence-of-brace-elision}

During the initialization of multilevel \textbf{aggregates}, braces
around the initialization of a nested aggregate can be omitted
(\textbf{brace elision}):

\begin{lstlisting}[language=C++]
struct S
{
int arr[3];
};

S s0{{0, 1, 2}};  // OK, nested (ù{\codeincomments{arr}}ù) initialized explicitly
S s1{0, 1, 2};    // OK, brace elision for nested (ù{\codeincomments{arr}}ù)
\end{lstlisting}

\noindent The possibility of \textbf{brace elision} creates an interesting
syntactical ambiguity when used alongside \textbf{aggregates} with
\titleref{Default-Member-Initializers}. Consider a
\texttt{struct}~\texttt{X} containing three data members, one of which
has a default value:

\begin{lstlisting}[language=C++]
struct X
{
int a;
int b;
int c = 0;
};
\end{lstlisting}

\noindent Now, consider various ways in which an array of elements of type
\texttt{X} can be initialized:

\begin{lstlisting}[language=C++]
X xs0[] = {{0, 1}, {2, 3}, {4, 5}};
// OK, clearly 3 elements having the respective values:
// (ù{\codeincomments{\{0, 1, 0\}}}ù), (ù{\codeincomments{\{2, 3, 0\}}}ù), (ù{\codeincomments{\{4, 5, 0\}}}ù)

X xs1[] = {{0, 1, 2}, {3, 4, 5}};
// OK, clearly 2 elements with values:
// (ù{\codeincomments{\{0, 1, 2\}}}ù), (ù{\codeincomments{\{3, 4, 5\}}}ù)

X xs2[] = {0, 1, 2, 3, 4, 5};
// ...?
\end{lstlisting}

\noindent Upon seeing the definition of \texttt{xs2}, a programmer not versed in
the details of the C++ Language Standard might be unsure as to whether the
initializer of \texttt{xs2} is three elements (like \texttt{xs0}) or two
elements (like \texttt{xs1}). The Standard is, however, clear that the
compiler will interpret \texttt{xs2} the same as \texttt{xs1}, and,
thus, the default values of \texttt{X::c} for the two array elements
will be replaced with \texttt{2} and \texttt{5}, respectively.

\subsection[See Also]{See Also}\label{see-also}

\begin{itemize}
\item{Section~\ref{Default-Member-Initializers}, ``\titleref{Default-Member-Initializers}" — Conditionally safe C++11 feature that allows developers to provide a default initializer for a data member directly in the definition of a class}
\end{itemize}

\subsection[Further Reading]{Further Reading}\label{further-reading}

None so far


\newpage
\section[Digit Separators]{Digit Separators}
\label{digitseparator} % used with placeholder file
\label{digit-separators} % label had changed when actual file arrived


A digit separator is a single-character token (\texttt{'}) that can appear as part of a
numeric literal without altering its value.

\subsection[Description]{Description}\label{description}

A digit separator --- i.e., an instance of the single-quote
character (\texttt{'}) --- may be placed anywhere within a numeric
literal to visually separate its digits without affecting its value:

%%%%%%%%%%%%%%%% ALL code snippets in this subsection
%%%%%%%%  setting this code coloring manually
% Everything after // (including //) itself is a comment, and should be light blue (like -12345).
% `int`, `unsigned int`, `long`, `long long`, `float`, `double`, `long double`, `int`, `int`, `int` should be in the reddish color like the first occurrence of `int`.
% The variable names (e.g., i,u,j,k,f,d,e,hex,oct,bin) should be black.
% All equal signs should be black.
% All numeric literals (e.g., -12'345, 1'000'000u) should be black as well.

\begin{lstlisting}[language=C++]
int          (ù{\color{black} i = -12'345;}ù)                    (ù{\itshape\color{skyblue}// same as}ù) (ù{\codeincomments{-12345}}ù)
(ù{\color{maroon}unsigned int}ù) (ù{\color{black}u = 1'000'000u;}ù)                 (ù{\itshape\color{skyblue}// same as}ù) (ù{\codeincomments{1000000u}}ù)
(ù{\color{maroon}long}ù)         (ù{\color{black}j = 5'0'0'0'0'0L;}ù)               // same as (ù{\codeincomments{500000L}}ù)
(ù{\color{maroon}long long}ù)    (ù{\color{black}k = 9'223'372'036'854'775'807;}ù)  // same as (ù{\codeincomments{9223372036854775807}}ù)
(ù{\color{maroon}float}ù)        (ù{\color{black}f = 10'00.42'45f;}ù)               // same as (ù{\codeincomments{1000.4245f}}ù)
(ù{\color{maroon}double}ù)       (ù{\color{black}d = 3.1415926'53589793;}ù)         (ù{\itshape\color{skyblue}// same as}ù) (ù{\codeincomments{3.141592653589793}}ù)
(ù{\color{maroon}long double}ù)  (ù{\color{black}e = 3.1415926'53589793'23846;}ù)   (ù{\itshape\color{skyblue}// same as}ù) (ù{\codeincomments{3.14159265358979323846}}ù)
(ù{\color{maroon}int}ù)        (ù{\color{black}hex = 0x8C25'00F9;}ù)                // same as (ù{\codeincomments{0x8C2500F9}}ù)
int        (ù{\color{black}oct = 044'73'26;}ù)                  // same as (ù{\codeincomments{0447326}}ù)
int        (ù{\color{black}bin = 0b1001'0110'1010'0111;}ù)      (ù{\itshape\color{skyblue}// same as}ù) (ù{\codeincomments{0b1001011000110001}}ù)
\end{lstlisting}

\noindent Multiple digit separators within a single literal are allowed, but they
cannot be contiguous, nor can they appear either before or after the
\emph{numeric} part (i.e., digit sequence) of the
literal{\cprotect\footnote{Although the leading \texttt{0x} and
\texttt{0b} prefixes for hexadecimal and binary literals,
respectively, are not considered part of the \emph{numeric} part of
the lateral, a leading \texttt{0} in an octal literal is.}}:

\begin{lstlisting}[language=C++]
int (ù{\color{black}e0 = 10''00;}ù)  // error: consecutive digit separators
int (ù{\color{black}e1 = -'1000;}ù)  // error: before numeric part
(ù{\color{maroon}int}ù) (ù{\color{black}e2 = 1000'u;}ù)  // error: after numeric part
int (ù{\color{black}e3 = 0x'abc;}ù)  // error: before numeric part
(ù{\color{maroon}int}ù) (ù{\color{black}e4 = 0'xdef;}ù)  // error: way before numeric part
int (ù{\color{black}e5 = 0'89;}ù)    // error: non-octal digits
(ù{\color{maroon}int}ù) (ù{\color{black}e6 = 0'67;}ù)    // OK, valid octal literal
\end{lstlisting}

\noindent As a side note, remember that on some platforms an integer literal
that is too large to fit in a \texttt{long}~\texttt{long}~\texttt{int} but that does fit in an
\texttt{unsigned}~\texttt{long}~\texttt{long}~\texttt{int} might
generate a warning{\cprotect\footnote{Tested on GCC 7.4.0.}}:

\begin{lstlisting}[language=C++]
(ù{\color{maroon}unsigned long long}ù) (ù{\color{black}big1 = 9'223'372'036'854'775'808;}ù)  // (ù{\codeincomments{2\^{}63}}ù)
// warning: integer constant is so large that it is an
// unsigned long long big1 = 9'223'372'036'854'775'808;
//                           ^~~~~~~~~~~~~~~~~~~~~~~~~~
\end{lstlisting}

\noindent Such warnings can typically be suppressed by adding a \texttt{ull}
suffix to the literal:

\begin{lstlisting}[language=C++]
(ù{\color{maroon}unsigned long long}ù) (ù{\color{black}big2 = 9'223'372'036'854'775'808ull;}ù)  // OK
\end{lstlisting}

\noindent Warnings like the one above, however, are not typical when the implied
precision of a floating-point literal exceeds what can be represented:

\begin{lstlisting}[language=C++]
(ù{\color{maroon}float}ù) (ù{\color{black}reallyPrecise = 3.141'592'653'589'793'238'462'643'383'279'502'884;}ù)  // OK
// Everything after (ù{\codeincomments{3.141'592'6}}ù) is typically ignored silently.
\end{lstlisting}

\noindent For more information, see {\it\titleref{appendix:-silent-loss-of-precision-in-floating-point-literals}} on page~\pageref{appendix:-silent-loss-of-precision-in-floating-point-literals}.

\subsection[Use Cases]{Use Cases}\label{use-cases}

\subsubsection[Grouping digits together in large constants]{Grouping digits together in large constants}\label{grouping-digits-together-in-large-constants}

When embedding large constants in source code, consistently placing
digit separators (e.g., every thousand) might improve readability, as
illustrated in Table~\ref{digitseparator-table1}.

\begin{table}[h!]
\begin{center}
\begin{threeparttable}
\caption{Use of digit separators to improve readability}\label{digitseparator-table1}\vspace{1.5ex}
{\small \begin{tabular}{c|c}\thickhline
\rowcolor[gray]{.9}{\sffamily\bfseries Without Digit Separator} & {\sffamily\bfseries With Digit Separators} \\ \hline
\texttt{10000} & \texttt{10'000} \\ \hline
\texttt{100000} & \texttt{100'000} \\ \hline
\texttt{1000000} & \texttt{1'000'000} \\ \hline
\texttt{1000000000} & \texttt{1'000'000'000} \\ \hline
\texttt{18446744073709551615ull} & \texttt{18'446'744'073'709'551'615ull} \\ \hline
\texttt{1000000.123456} & \texttt{1'000'000.123'456} \\ \hline
\texttt{3.141592653589793238462l} & \texttt{3.141'592'653'589'793'238'462l} \\ \thickhline
\end{tabular}
} % end small
\end{threeparttable}
\end{center}
\end{table}
\noindent Use of digit separators is especially useful with binary
literals, as shown in Table~\ref{digitseparator-table2}.\begin{table}[h!]
\begin{center}
\begin{threeparttable}
\caption{Use of digit separators in binary data}\label{digitseparator-table2}\vspace{1.5ex}
{\small \begin{tabular}{c|c}
\thickhline
\rowcolor[gray]{.9} {\sffamily\bfseries Without Digit Separator} & {\sffamily\bfseries With Digit Separators} \\\hline
\texttt{0b1100110011001100} & \texttt{0b1100'1100'1100'1100} \\ \hline
\texttt{0b0110011101011011} & \texttt{0b0110'0111'0101'1011} \\ \hline
\texttt{0b1100110010101010} & \texttt{0b11001100'10101010} \\
\thickhline
\end{tabular}
} % end small
\end{threeparttable}
\end{center}
\end{table}

\subsection[Potential Pitfalls]{Potential Pitfalls}\label{potential-pitfalls}

None so far

\subsection[See Also]{See Also}\label{see-also}

\begin{itemize}
\item{Section~\ref{binary-literals}, ``\titleref{binary-literals}" — Safe C++14 feature representing a binary constant for which digit separators are commonly used to group bits in octets (\textbf{bytes}) or quartets (\textbf{nibbles})}
\end{itemize}

\subsection[Further Reading]{Further Reading}\label{further-reading}

\begin{itemize}
\item{William Kahan. ``Lecture Notes on the Status of
IEEE Standard 754 for Binary Floating-Point Arithmetic,'' \textbf{kahan97}}
\item{{\textit{IEEE Standard for Floating-PointArithmetic}}, \textbf{ieee19}}
\end{itemize}

\subsection[Appendix: Silent Loss of Precision in Floating-Point Literals]{Appendix: Silent Loss of Precision in Floating-Point Literals}\label{appendix:-silent-loss-of-precision-in-floating-point-literals}

Just because we can keep track of precision in floating-point literals
doesn't mean that the compiler can. As an aside, it is worth
pointing out that the binary representation of floating-point types is
not mandated by the Standard, nor are the precise minimums on the ranges
and precisions they must support. Although the C++ Standard says little
that is normative, the macros in \texttt{<cfloat>} are defined by
reference to the C Standard.{\cprotect\footnote{\textbf{PRODUCTION: WAITING FOR THESE REFERENCES TO DOUBLECHECK; CONSIDER THESE UNCONFIRMED.} \textbf{iso20}, sections [basic.fundamental] Fundamental types (6.8.1p12); [numeric.limits.members] \texttt{numeric\_limits} members 17.3.5.1; [cfloat.syn] Header \texttt{<cfloat>} synopsis (17.3.7p1); \textbf{iso18b}, section 5.2.4.2.2 Characteristics of floating types \texttt{<float.h>} }}

There are, however, normal and customary minimums that one can typically
rely upon in practice. On conforming compilers that employ the IEEE 754
floating-point standard representation\footnote{\textbf{ieee19}} (as most do),
a \texttt{float} can typically represent up to 7 significant decimal
digits accurately, while a \texttt{double} typically nearly 15 decimal
digits of precision. For any given program,
\texttt{long}~\texttt{double} is required to hold whatever a
\texttt{double} can hold, but is typically larger (e.g., 10, 12, or 16
bytes) and typically adds at least 5 decimal digits of precision (i.e.,
supports a total of at last 20 decimal digits). A table summarizing
typical precisions for various IEEE-conforming floating-point types is
presented for convenient reference in Table~\ref{digitseparator-table3}. The actual bounds on a
given platform can be found using the standard
\texttt{std::numeric\_limits} class template found in \texttt{<limits>}.\pagebreak[4]
\begin{table}[h!]
\begin{center}
\begin{threeparttable}
\caption{Available precisions for various IEEE-754 floating-point types}\label{digitseparator-table3}\vspace{1.5ex}
{\small \begin{tabular}{c|c|c|c|c|c}\thickhline
\rowcolor[gray]{.9}   {\sffamily\bfseries Name} & {\sffamily\bfseries Common} &
{\sffamily\bfseries Significant } & {\sffamily\bfseries Decimal }& {\sffamily\bfseries Exponent } & {\sffamily\bfseries Dynamic}\\
\rowcolor[gray]{.9}    & {\sffamily\bfseries Name} &
{\sffamily\bfseries Bits\tnote{a}} & {\sffamily\bfseries Bits}& {\sffamily\bfseries Bits} & {\sffamily\bfseries Range}\\ \hline
binary16 & Half precision & 11 & 3.31 & 5 & $\sim6.50\text{e}5$\\ \hline
binary32 & Single precision & 24 & 7.22 & 8 & $\sim3.4\text{e}38$\\ \hline
binary64 & Double precision & 53 & 15.95 & 11 & $\sim1.\text{e}308$\\ \hline
\rule{0pt}{3.5mm}binary80 & Extended precision & 69 & 20.77 & 11 & $\sim10^{308}$\\ \hline
\rule{0pt}{3.5mm}binary128 & Quadruple precision & 113 & 34.02 & 15 & $\sim10^{4932}$\\ \hline
\end{tabular}
} % end small
\begin{tablenotes}{\footnotesize
\item[a]{Note that the most significant bit of the \textbf{mantissa}
is always a \texttt{1} and, hence, is not stored explicitly, leaving 1
additional bit to represent the sign of the overall floating-point value
(the sign of the exponent is encoded using \textbf{excess-$\mathbf{n}$}
notation).}
} % end footnotesize
\end{tablenotes} % we end the table footnotes
\end{threeparttable}
\end{center}
\end{table}

Determining the minimum number of decimal digits needed to accurately
approximate a transcendental value, such as $\pi$, for a given type on
a given platform can be tricky (requiring some binary-search-like
detective work), which is likely why overshooting the precision without
warning is the default on most platforms. One way to establish that
\emph{all} of the decimal digits in a given floating-point literal are
relevant for a given floating-point type is to compare that literal and
a similar one with its least significant decimal digit
removed{\cprotect\footnote{Note that affixing the \texttt{f}
(\emph{literal suffix}) to a floating-point literal is
equivalent to applying a \texttt{static\_cast<float>} to the
(unsuffixed) literal:

\begin{lstlisting}[language=C++, basicstyle={\ttfamily\footnotesize}]
static_assert(3.14'159'265'358f == static_cast<float>(3.14'159'265'358));
\end{lstlisting}\vspace*{-1ex}
}}:

\begin{lstlisting}[language=C++]
static_assert(3.1415926535f != 3.141592653f, "too precise for float");
// This assert will fire on a typical platform.

static_assert(3.141592653f != 3.14159265f, "too precise for float");
// This assert too will fire on a typical platform.

static_assert(3.14159265f != 3.1415926f, "too precise for float");
// This assert will NOT fire on a typical platform.

static_assert(3.1415926f != 3.141592f, "too precise for float");
// This assert too will NOT fire on a typical platform.
\end{lstlisting}

\noindent If the values are \emph{not} the same, then that floating-point type
\emph{can} make use of the precision suggested by the original literal; if
they \emph{are} the same, however, then it is likely that the available
precision has been exceeded. Iterative use of this technique by
developers can help them to empirically narrow down the maximal number
of decimal digits a particular platform will support for a particular
floating-point type and value.

One final useful tidbit pertains to the safe (lossless) conversion
between binary and decimal floating-point representations; note that
``Single'' (below) corresponds to a single-precision IEEE-754-conforming
(32-bit) \texttt{float}{\cprotect\footnote{\textbf{kahan97}, section ``Representable Numbers," p.~4}}:

\begin{quote}
If a decimal string with at most 6 sig. dec. is converted to Single and then converted back to the
same number of sig. dec., then the final string should match the original. Also, ...

If a Single Precision floating-point number is converted to a decimal string with at least 9 sig.
dec. and then converted back to Single, then the final number must match the original.
\end{quote}

\noindent The ranges corresponding to 6--9 for a single-precision (32-bit)
\texttt{float} (described above), when applied to a double-precision
(64-bit) \texttt{double} and a quad-precision (128-bit)
\texttt{long}~\texttt{long}, are 15--17 and 33--36, respectively.




\newpage
\section[Variable Templates]{Variable Templates}
\label{variable-templates}


Variable templates extend traditional template syntax to define, in namespace or
class (but not function) scope, a family of like-named variables that
can subsequently be instantiated explicitly.

\subsection[Description]{Description}\label{variabletemplate-description}

By beginning a variable declaration with the familiar
\textbf{template-head} syntax --- e.g.,
\texttt{template}~\texttt{<typename}~\texttt{T>} --- we can create a
\emph{variable template}, which defines a family of variables having the
same name (e.g., \texttt{typeid}):

\begin{lstlisting}[language=C++]
template <typename> int typeId;  // template variable defined at file scope
\end{lstlisting}

\noindent Like any other kind of template, a variable template can be instantiated
(explicitly) by providing an appropriate number (one or more) of type or
non-type arguments:

\begin{lstlisting}[language=C++]
void f1()
{
typeId<bool> = -1;    // (ù{\codeincomments{typeId<bool>}}ù) is an (ù{\codeincomments{int}}ù)
typeId<char> = 1000;  // (ù{\codeincomments{typeId<char>}}ù) is an (ù{\codeincomments{int}}ù)
typeId<void> = -666;  // (ù{\codeincomments{typeId<void>}}ù) is an (ù{\codeincomments{int}}ù)

assert(typeId<bool> ==   -1);
assert(typeId<char> == 1000);
assert(typeId<void> == -666);
}
\end{lstlisting}

\noindent In the example above, the type of each instantiated variable --- i.e.,
\texttt{typeId<bool>} and \texttt{typeId<char>} --- is \texttt{int}.
Such need not be the case{\cprotect\footnote{Use of
\texttt{constexpr} variables would allow the instantiated
variables to be usable as a constant in a compile-time context (see
{\it\titleref{variabletemplate-use-cases}:} {\it\titleref{parametrized-constants}} on page~\pageref{parametrized-constants}).}}:

\begin{lstlisting}[language=C++]
template <typename T> const T pi(3.1415926535897932385);  // distinct types
\end{lstlisting}

\noindent In the example above, the type of the instantiated non-\texttt{const}
variable is that of its (type) argument, and its (mutable) value is
initialized to the best approximation of \(\pi\) offered by that type:

\begin{lstlisting}[language=C++]
void f2()
{
bool        pi_as_bool        = 1;                      // ( 1 bit)
int         pi_as_int         = 3;                      // (32 bits)
float       pi_as_float       = 3.1415927;              // (32 bits)
double      pi_as_double      = 3.141592653589793;      // (64 bits)
long double pi_as_long_double = 3.1415926535897932385;  // (80 bits)

assert(pi<bool>        == pi_as_bool);
assert(pi<int>         == pi_as_int);
assert(pi<float>       == pi_as_float);
assert(pi<double>      == pi_as_double);
assert(pi<long double> == pi_as_long_double);
}
\end{lstlisting}

\noindent For examples involving immutable variable templates, see {\it\titleref{variabletemplate-use-cases}:} {\it\titleref{parametrized-constants}} on page~\pageref{parametrized-constants}.

Variable templates, like \textbf{C-style functions}, may be declared at
namespace-scope or as \texttt{static} members of a
\texttt{class}, \texttt{struct}, or \texttt{union} but are not
permitted as non\texttt{static} members nor at all in function scope:

\begin{lstlisting}[language=C++]
template <typename T> T vt1;             // OK (external linkage)
template <typename T> static T vt2;      // OK (internal linkage)

namespace N
{
template <typename T> T vt3;           // OK (external linkage)
template <typename T> T vt4;           // OK (internal linkage)
}

struct S
{
template <typename T> T vt5;         // error: not (ù{\codeincomments{static}}ù)
template <typename T> static T vt6;  // OK (external linkage)
};

void f3()  // Variable templates cannot be defined in functions.
{
template <typename T> T vt7;         // compile-time error
template <typename T> static T vt8;  // compile-time error

vt1<bool> = true;                    // OK (to use them)
}
\end{lstlisting}

\noindent Like other templates, variable templates may be defined with multiple
parameters consisting of arbitrary combinations of type and non-type
parameters (including a \textbf{parameter pack}):

\begin{lstlisting}[language=C++]
namespace N
{
template <typename V, int I, int J> V factor;  // namespace scope
}
\end{lstlisting}

\noindent Variable templates can even be defined recursively (but see
{\it\titleref{variabletemplate-potential-pitfalls}:} {\it\titleref{recursive-variable-template-initializations-require-const-or-constexpr}} on page~\pageref{recursive-variable-template-initializations-require-const-or-constexpr}):

\begin{lstlisting}[language=C++]
template <int N>
const int sum = N + sum<N - 1>;    // recursive general template

template <> const int sum<0> = 0;  // base-case specialization

void f()
{
std::cout << sum<4> << '\n';  // prints 10
std::cout << sum<5> << '\n';  // prints 15
std::cout << sum<6> << '\n';  // prints 21
}
\end{lstlisting}

\noindent Note that variable templates do not enable any novel patterns;
anything that can be achieved using them could also have been achieved
in C++11 along with some additional boilerplate. The initial
\texttt{typeId} example could have instead been implemented using a
\texttt{struct}:

\begin{lstlisting}[language=C++]
template <typename> struct TypeId { static int value; };
\end{lstlisting}

\noindent And used with just a bit more syntax:

\begin{lstlisting}[language=C++]
void f1b()
{
TypeId<bool>::value = -1;    // (ù{\codeincomments{TypeId<bool>::value}}ù) is an (ù{\codeincomments{int}}ù).
TypeId<char>::value = 1000;  // (ù{\codeincomments{TypeId<char>::value}}ù) is an (ù{\codeincomments{int}}ù).
TypeId<void>::value = -666;  // (ù{\codeincomments{TypeId<void>::value}}ù) is an (ù{\codeincomments{int}}ù).

assert(TypeId<bool>.value ==   -1);
assert(TypeId<char>.value == 1000);
assert(TypeId<void>.value == -666);
}
\end{lstlisting}


\subsection[Use Cases]{Use Cases}\label{variabletemplate-use-cases}

\subsubsection[Parameterized constants]{Parameterized constants}\label{parametrized-constants}

A common effective use of variable templates is in the definition of
type-parameterized constants. As discussed in {\it\titleref{variabletemplate-description}} on page~\pageref{variabletemplate-description}, the mathematical
constant $\pi$ serves as our example. Here we want to
initialize the constant as part of the variable template (the literal
chosen is the shortest decimal string to do so accurately for an 80-bit
\texttt{long}~\texttt{double}){\cprotect\footnote{For
portability, a floating-point literal value of \(\pi\) that provides
sufficient precision for the longest \texttt{long}~\texttt{double} on
any relevant platform (e.g., 128 bits or 34 decimal digits:
\texttt{3.141'592'653'589'793'238'462'643'383'279'503}) should be
used; see Section~\ref{digit-separators}, ``\titleref{digit-separators}."}}:

\begin{lstlisting}[language=C++]
template <typename T>
constexpr T pi(3.1415926535897932385);
// smallest digit sequence to accurately represent pi as a (ù{\codeincomments{long double}}ù)
\end{lstlisting}

\noindent Notice that we have elected to use {\texttt{constexpr} variables
(from C++11) in place of a classic \texttt{const} as a stronger
guarantee that the provided initializer is a compile-time constant and
that \texttt{pi} itself will be usable as part of a constant expression.

With the definition above, we can provide a
\texttt{toRadians} function template that performs at maximum runtime
efficiency by avoiding needless type conversions during the computation:

\begin{lstlisting}[language=C++]
template <typename T>
constexpr T toRadians(T degrees)
{
return degrees * (pi<T> / T(180));
}
\end{lstlisting}


\subsubsection[Reducing verbosity of type traits]{Reducing verbosity of type traits}\label{reducing-verbosity-of-type-traits}

A \textbf{type trait} is an empty type carrying compile-time information
about one or more aspects of another type. The way in which type traits
have been specified historically has been to define a class template
having the trait name and a public \texttt{static} (or \texttt{enum})
data member, that is conventionally called \texttt{value}, which is
initialized in the primary template to \texttt{false}. Then, for each
type that wants to advertise that it has this trait, the header defining
the trait is included and the trait is specialized for that type,
initializing \texttt{value} to \texttt{true}. We can achieve precisely
this same usage pattern replacing a trait \texttt{struct} with a
variable template whose name represents the type trait and whose type of
variable itself is always \texttt{bool}. Preferring variable templates
in this use case decreases the amount of \textbf{boilerplate code} ---
both at the point of definition and at the call
site.{\cprotect\footnote{As of C++17, the Standard Library provides a
more convenient way of inspecting the result of a type trait, by
introducing variable templates named the same way as the corresponding
traits but with an additional \texttt{\_v} suffix:

\begin{lstlisting}[language=C++, basicstyle={\ttfamily\footnotesize}]
// C++11/14
std::is_default_constructible<T>::value

// C++17
std::is_default_constructible_v<T>
\end{lstlisting}
}}

Consider, for example, a boolean trait designating whether a particular
type \texttt{T} can be serialized to JSON:

\begin{lstlisting}[language=C++]
// isSerializableToJson.h

template <typename T>
constexpr bool isSerializableToJson = false;
\end{lstlisting}

\noindent The header above contains the general variable template trait that, by
default, concludes that a given type is not serializable to JSON. Next
we consider the streaming utility itself:

\begin{lstlisting}[language=C++]
// serializeToJson.h
#include <isSerializableToJson.h>  // general trait variable template

template <typename T>
JsonObject serializeToJson(const T& object)  // serialization function template
{
static_assert(isSerializableToJson<T>,
"(ù{\codeincomments{T}}ù) must support serialization to JSON.");

// ...
}
\end{lstlisting}

\noindent Notice that we have used the C++11
\texttt{static\_assert} feature to ensure that any type
used to instantiate this function will have specialized (see the next code snippet) the
general variable template associated with the specific type to be
\texttt{true}.

Now imagine that we have a type, \texttt{CompanyData}, that we would
like to advertise at compile time as being serializable to JSON. Like
other templates, variable templates can be specialized explicitly:

\begin{lstlisting}[language=C++]
// companyData.h
#include <isSerializableToJson.h>  // general trait variable template

struct CompanyData { /* ... */ };  // type to be JSON serialized

template <>
constexpr bool isSerializableToJson<CompanyData> = true;
// Let anyone who needs to know that this type is JSON serializable.
\end{lstlisting}

\noindent Finally, our \texttt{client} function incorporates all of the above and
attempts to serialize both a \texttt{CompanyData} object and an
\texttt{std::map<int,}~\texttt{char>>}:

\begin{lstlisting}[language=C++]
// client.h
#include <isSerializableToJson.h>  // general trait template
#include <companyData.h>           // JSON serializable type
#include <serializeToJson.h>       // serialization function
#include <map>                     // (ù{\codeincomments{std::map}}ù) (not JSON serializable)

void client()
{
auto jsonObj0 = serializeToJson<CompanyData>();         // OK
auto jsonObj1 = serializeToJson<std::map<int, char>>(); // compile-time error
}
\end{lstlisting}

\noindent In the \texttt{client()} function above, \texttt{CompanyData} works
fine, but, because the variable template \texttt{isSerializableToJson}
was never specialized to be \texttt{true} for type
\mbox{\texttt{std::map<int,} \texttt{char>>}}, the client header will --- as
desired --- fail to compile.

\subsection[Potential Pitfalls]{Potential Pitfalls}\label{variabletemplate-potential-pitfalls}

\subsubsection[Recursive variable template initializations require {\tt const} or {\tt constexpr}]{Recursive variable template initializations require {\SubsubsecCode const} or {\SubsubsecCode constexpr}}\label{recursive-variable-template-initializations-require-const-or-constexpr}

When discussing the intricacies of the C++ language with your peers, consider quizzing them on why the
example below, having no undefined behavior, might produce different results with popular compilers{\cprotect\footnote{For
example, GCC version 4.7.0 (2017) produces the expected results whereas
Clang version 10.x (2020) produces 1, 3, and 4, respectively.}}:

\begin{lstlisting}[language=C++]
#include <iostream>

template <int N>
int fib = fib<N - 1> + fib<N - 2>;

template <> int fib<2> = 1;
template <> int fib<1> = 1;

int main()
{
std::cout << fib<4> << '\n';  // 3 expected
std::cout << fib<5> << '\n';  // 5 expected
std::cout << fib<6> << '\n';  // 8 expected

return 0;
}
\end{lstlisting}

\noindent The didactic value in answering this question dwarfs any potential
practical value that recursive template variable instantiation can
offer. First, consider that this same issue could, in theory, have
occurred in C++03 using nested \texttt{static} members of a
\texttt{struct}:

\begin{lstlisting}[language=C++]
#include <iostream>

template <int N> struct Fib
{
static int value;                             // BAD IDEA: not (ù{\codeincomments{const}}ù)
};

template <> struct Fib<2> { static int value; };  // BAD IDEA: not (ù{\codeincomments{const}}ù)
template <> struct Fib<1> { static int value; };  // BAD IDEA: not (ù{\codeincomments{const}}ù)

template <int N> int Fib<N>::value = Fib<N - 1>::value + Fib<N - 2>::value;
int Fib<2>::value = 1;
int Fib<1>::value = 1;

int main()
{
std::cout << Fib<4>::value << '\n';  // 3 expected
std::cout << Fib<5>::value << '\n';  // 5 expected
std::cout << Fib<6>::value << '\n';  // 8 expected

return 0;
};
\end{lstlisting}

\noindent The problem did not manifest, however, because the simpler solution of
using \texttt{enum}s (below) obviated separate initialization of the
local \texttt{static} and didn't admit the possibility of failing to
make the initializer a compile-time constant:

\begin{lstlisting}[language=C++]
#include <iostream>

template <int N> struct Fib
{
enum { value = Fib<N - 1>::value + Fib<N - 2>::value };  // OK - (ù{\codeincomments{const}}ù)
};

template <> struct Fib<2> { enum { value = 1 }; };           // OK - (ù{\codeincomments{const}}ù)
template <> struct Fib<1> { enum { value = 1 }; };           // OK - (ù{\codeincomments{const}}ù)

int main()
{
std::cout << Fib<4>::value << '\n';  // 3 guaranteed
std::cout << Fib<5>::value << '\n';  // 5 guaranteed
std::cout << Fib<6>::value << '\n';  // 8 guaranteed

return 0;
};
\end{lstlisting}

\noindent It was not until C++14 that the variable templates feature
readily exposed this latent pitfall involving recursive initialization
of non-\texttt{const} variables. The root cause of the instability is
that the relative order of the initialization of the (recursively
generated) variable instantiations is not guaranteed because they are
not defined explicitly \emph{within the same translation unit}. The
magic sauce that makes everything work is the C++ language requirement
that any variable that is declared \texttt{const} and initialized with a
compile-time constant is itself to be treated as a compile-time constant
within the translation unit. This compile-time-constant propagation
requirement imposes the needed ordering to ensure that the expected
results are portable to all conforming compilers:

\begin{lstlisting}[language=C++]
#include <iostream>

template <int N>
const int fib = fib<N - 1> + fib<N - 2>;  // OK - compile-time (ù{\codeincomments{const}}ù).

template <> const int fib<2> = 1;         // OK - compile-time (ù{\codeincomments{const}}ù).
template <> const int fib<1> = 1;         // OK - compile-time (ù{\codeincomments{const}}ù).

int main()
{
std::cout << fib<4> << '\n';  // guaranteed to print out (ù{\codeincomments{3}}ù)
std::cout << fib<5> << '\n';  // guaranteed to print out (ù{\codeincomments{5}}ù)
std::cout << fib<6> << '\n';  // guaranteed to print out (ù{\codeincomments{8}}ù)

return 0;
}
\end{lstlisting}

\noindent Note that replacing each of the three \texttt{const} keywords with
{\texttt{constexpr} in the example above also achieves the
desired goal and does not consume memory in the \textbf{static data
space}.

\subsection[Annoyances]{Annoyances}\label{annoyances}

\subsubsection[Variable templates do not support template template parameters]{Variable templates do not support template template parameters}\label{variable-templates-do-not-support-template-template-parameters}

While a class or function template can accept a
\textbf{template template class parameter}, no equivalent
construct is available for variable templates{\cprotect\footnote{Pusz has proposed for C++23 a way to increase consistency between
variable templates and class templates when used as template template
parameters; see \textbf{{pusz20}}.}}:

\begin{lstlisting}[language=C++]
template <typename T> T vt(5);

template <template <typename> class>
struct S { };

S<vt> s1;  // compile-time error
\end{lstlisting}

\noindent Providing a wrapper \texttt{struct}
around a variable template might therefore be necessary in case the variable template needs to be passed to an interface
accepting a \textbf{template template parameter}:

\begin{lstlisting}[language=C++]
template <typename T>
struct Vt { static constexpr T value = vt<T>; }

S<Vt> s2;  // OK
\end{lstlisting}


\subsection[See Also]{See Also}\label{see-also}

\begin{itemize}
\item{Section~\ref{constexprvar}, ``\titleref{constexprvar}" — Conditionally safe C++11 feature providing an alternative to \texttt{const} template variables that can reduce unnecessary consumption of the \textbf{static data space}}
\end{itemize}

\subsection[Further Reading]{Further Reading}\label{further-reading}

None so far



\newpage
\section[Defaulted Special Member Functions]{Defaulted Special Member Functions}\label{Defaulted-Special-Member-Functions}\label{defaulted-special-member-functions}


Use of \texttt{=}~\texttt{default} in a \textbf{special member function}'s
declaration instructs the compiler to attempt generating the function
automatically.

\subsection[Description]{Description}\label{description}

Intrinsic to the design of C++ classes is the understanding that the
compiler will attempt to generate certain member functions pertaining to
\emph{creating}, \emph{copying}, \emph{destroying}, and now
\emph{moving} (see Section~\ref{Rvalue-References}, ``\titleref{Rvalue-References}") an object unless
developers intercede by implementing some or all of these functions
themselves. Determining which of the \textbf{special member functions}
will continue to be generated and which will be suppressed in the
presence of other \textbf{user-provided special member functions}
requires remembering the same rules the compiler uses.

\subsubsection[Declaring a special member function explicitly]{Declaring a special member function explicitly}\label{declaring-a-special-member-function-explicitly}

The rules specifying what happens in the presence of one or more
user-provided special member functions are inherently complex and not
necessarily intuitive; in fact, some are already
deprecated.{\cprotect\footnote{Even in the presence of a user-provided
destructor, both the copy constructor and copy-assignment operator
have historically been generated implicitly. Relying on such generated
behavior is not recommended because it is unlikely that a class
requiring a user-provided destructor will function correctly without
corresponding user-provided copy operations. As of C++11, reliance on
such dubious implicitly generated behavior is deprecated.}} Here, we
will briefly illustrate a few common cases and then refer you to Howard
Hinnant's now famous table (see page~\pageref{default-table1} of {\it\titleref{appendix:-implicit-generation-of-special-member-functions}}) to
demystify what's going on under the hood.

\paragraph[Example 1: Providing just the default constructor]{Example 1: Providing just the default constructor}\label{example-1:-providing-just-the-default-constructor}

Consider a \texttt{struct} with a user-provided default constructor:

\begin{lstlisting}[language=C++]
struct S1
{
S1();  // user-provided default constructor
};
\end{lstlisting}

\noindent A user-provided default constructor has no effect on other special
member functions. Providing any other constructor, however, will
suppress automatic declaration{\cprotect\footnote{A nondeclared
function is nonexistent, which means that it will \emph{not}
participate in overload resolution at all. In contrast, a
\textbf{deleted function} participates in overload resolution and, if
selected, results in a compilation failure; see Section~\ref{deleted-functions}, ``\titleref{deleted-functions}."}} of the default constructor. We can, however, use
\texttt{=}~\texttt{default} to restore the constructor as a \textbf{trivial
operation}; see {\it\titleref{default-use-cases}: \titleref{restoring-the-generation-of-a-special-member-function-suppressed-by-another}} on page~\pageref{restoring-the-generation-of-a-special-member-function-suppressed-by-another}.

\paragraph[Example 2: Providing just a copy constructor]{Example 2: Providing just a copy constructor}\label{example-2:-providing-just-a-copy-constructor}

Now, consider a \texttt{struct} with a user-provided copy constructor:

\begin{lstlisting}[language=C++]
struct S2
{
S2(const S2&);  // user-provided copy constructor
};
\end{lstlisting}

\noindent A user-provided copy constructor (1) suppresses the declaration of the
default constructor and both move operations and (2) allows implicit
generation of both the copy-assignment operator and the destructor.
Similarly, providing just the copy-assignment operator would allow the
compiler to implicitly generate both the copy constructor and the
destructor, but, in this case, it would also generate the default
constructor (see \texttt{S6} in the \texttt{example.h} code snippet on page~\pageref{default-exampleh-code}). Note that --- in either of these
cases --- relying on the compiler's implicitly generated copy operation
is deprecated.

\paragraph[Example 3: Providing just the destructor]{Example 3: Providing just the destructor}\label{example-3:-providing-just-the-destructor}

Finally, consider a \texttt{struct} with a user-provided destructor:


\begin{lstlisting}[language=C++]
struct S3
{
~S3();  // user-provided destructor
};
\end{lstlisting}

\noindent A user-provided destructor suppresses the declaration of move
operations but still allows copy operations to be generated. Again,
relying on either of these (implicitly) compiler-generated copy
operations is deprecated.

\paragraph[Example 4: Providing more than one special member function]{Example 4: Providing more than one special member function}\label{example-4:-providing-more-than-one-special-member}

When more than one special member function is declared explicitly, the
\emph{union} of their respective declaration suppressions and the
\emph{intersection} of their respective implicit generations pertain ---
e.g., if just the default constructor and destructor are provided
(\texttt{S1} + \texttt{S3} in Examples 1 and 3), then the declarations of both move
operations are suppressed and both copy operations are generated
implicitly.

\subsubsection[Defaulting the first declaration of a special member function explicitly]{Defaulting the first declaration of a special member function explicitly}\label{defaulting-the-first-declaration-of-a-special-member-function-explicitly}

Using the \texttt{=}~\texttt{default} syntax with the first declaration
of a special member function instructs the compiler to synthesize such a
function automatically (if possible) without treating it as being
user provided.{\cprotect\footnote{The compiler-generated version for a
special member function is required to call the corresponding special
member functions on (1) every base class in base-class-declaration
order and then (2) every data member of the encapsulating type in
declaration order (regardless of any access specifiers). Note that the
destructor calls will be in exactly the opposite order of the
other special-member-function calls.}}

For example, consider struct \texttt{S4} (in the code snippet below) in which we have chosen
to make explicit that the copy operations are to be autogenerated by
the compiler; note, in particular, that implicit declaration and generation
of each of the other special member functions is left unaffected.

\begin{lstlisting}[language=C++]
struct S4
{
S4(const S4&) = default;             // copy constructor
S4& operator=(const S4&) = default;  // copy-assignment operator

// has no effect on other other four special member functions, i.e.,
// implicitly generates the default constructor, the destructor,
// the move constructor, and the move-assignment operator
};
\end{lstlisting}

\noindent A defaulted declaration may appear with any \textbf{access specifier} ---
i.e., \texttt{private},\linebreak[4] \texttt{protected}, or \texttt{public} --- and,
hence, access to that generated function will be regulated accordingly:

\begin{lstlisting}[language=C++]
struct S5
{
private:
S5(const S5&) = default;             // private copy constructor
S5& operator=(const S1&) = default;  // private copy-assignment operator

protected:
~S5() = default;                     // protected destructor

public:
S5() = default;                     // public default constructor
};
\end{lstlisting}

\noindent In the example above, copy operations exist for use by \emph{member} and
\emph{friend} functions only. Declaring the destructor
\texttt{protected} or \texttt{private} limits which functions can create
automatic variables of the specified type to those functions with the
appropriately privileged access to the class. Declaring the default
constructor \texttt{public} is necessary to avoid its declaration's
being suppressed by another constructor (e.g., the private copy
constructor in the code snippet above) or \emph{any} move operation.

In short, use of \texttt{=}~\texttt{default} on first declaration
denotes that a special member function is intended to be generated by
the compiler --- irrespective of any user-provided declarations; in
conjunction with {\texttt{=}~\texttt{delete}} (see Section~\ref{deleted-functions}, ``\titleref{deleted-functions}"),
use of
\texttt{=}~\texttt{default} affords the fine-grained control over which
special member functions are to be generated and/or made publicly
available.

\subsubsection[Defaulting the implementation of a user-provided special member function]{Defaulting the implementation of a user-provided special member function}\label{defaulting-the-implementation-of-a-user-provided-special-member-function}

The \texttt{=}~\texttt{default} syntax can also be used after the first
declaration, but with a distinctly different meaning: The compiler will
treat the first declaration as a \textbf{user-provided special member
function} and thus will suppress the generation of other
\textbf{special member functions} accordingly.

\begin{lstlisting}[language=C++,label=default-exampleh-code]
// example.h

struct S6
{
S6& operator=(const S6&);  // user-provided copy-assignment operator

// suppresses the declaration of both move operations
// implicitly generates the default and copy constructors, and destructor
};

inline S6& S6::operator=(const S6&) = default;
// Explicitly request the compiler to generate the default implementation
// for this copy-assignment operator. This request might fail (e.g., if (ù{\codeincomments{S6}}ù)
// were to contain a non-copyable-assignable data member).
\end{lstlisting}

\noindent Alternatively, an explicitly defaulted non-inline implementation of this
copy-assignment operator may appear in a separate (\texttt{.cpp}) file;
see {\it\titleref{default-use-cases}: \titleref{physically-decoupling-the-interface-from-the-implementation}} on page~\pageref{physically-decoupling-the-interface-from-the-implementation}.

\subsection[Use Cases]{Use Cases}\label{default-use-cases}

\subsubsection[Restoring the generation of a special member function suppressed by another]{Restoring the generation of a special member function suppressed by another}\label{restoring-the-generation-of-a-special-member-function-suppressed-by-another}

Incorporating \texttt{=}~\texttt{default} in the declaration of a
special member function instructs the compiler to generate its
definition regardless of any other user-provided special member
functions. As an example, consider a \textbf{value-semantic}
\texttt{SecureToken} class that wraps a standard string
(\texttt{std::string}) and an arbitrary-precision-integer
(\texttt{BigInt}) token code that satisfy certain invariants:

\begin{lstlisting}[language=C++]
class SecureToken
{
std::string d_value;  // The default-constructed value is the empty string.
BigInt d_code;        // The default-constructed value is the integer zero.

public:
// All six special member functions are (implicitly) defaulted.

void setValue(const char* value);
const char* value() const;
BigInt code() const;
};
\end{lstlisting}

\noindent By default, a secure token's \texttt{value} will be the empty-string
value and the token's \texttt{code} will be the numerical value of zero
(because those are, respectively, the \textbf{default initialized} values
of the two data members, \texttt{d\_value} and \texttt{d\_tokenCode}):

\begin{lstlisting}[language=C++,label=default-voidf-code]
void f()
{
SecureToken token;                       // default constructed         (1)
assert(token.value() == std::string());  // default value: empty string (2)
assert(token.code() == BigInt());        // default value: zero         (3)
}
\end{lstlisting}

\noindent Now suppose that we get a request to add a \textbf{value constructor}
that creates and initializes a \texttt{SecureToken} from a specified
token string:

\begin{lstlisting}[language=C++]
class SecureToken
{
std::string d_value;  // The default-constructed value is the empty string.
BigInt d_tokenCode;   // The default-constructed value is the integer zero.

public:
SecureToken(const char* value);  // newly added value constructor

// suppresses the declaration of just the default constructor --- i.e.,
// implicitly generates all of the other five special member functions

void setValue(const char* value);
const char* value() const;
const BigInt& code() const;
};
\end{lstlisting}

\noindent Attempting to compile function \texttt{f} (from page~\pageref{default-voidf-code}) would now fail on the
first line, where it attempts to default-construct the token. Using
the \texttt{=}~\texttt{default} feature, however, we can reinstate the
default constructor to work trivially, just as
it did before:

\begin{lstlisting}[language=C++]
class SecureToken
{
std::string d_value;  // The default-constructed value is the empty string.
BigInt d_code;        // The default-constructed value is the integer zero.

public:
SecureToken() = default;         // newly defaulted default constructor
SecureToken(const char *value);  // newly added value constructor

// implicitly generates all of the other five special member functions

void setValue(const char *value);
const char *value() const;
const BigInt& code() const;
};
\end{lstlisting}


\subsubsection[Making class APIs explicit at no runtime cost]{Making class APIs explicit at no runtime cost}\label{making-class-apis-explicit-at-no-runtime-cost}

In the early days of C++, coding standards sometimes
required that each special member function be declared explicitly so
that it could be documented or even just to know that it hadn't been
forgotten:

\begin{lstlisting}[language=C++]
class C1
{
// ...

public:
C1();
// Create an empty object.

C1(const C1& rhs);
// Create an object having the same value as the specified (ù{\codeincomments{rhs}}ù) object.

~C1();
// Destroy this object.

C1& operator=(const C1& rhs);
// Assign to this object the value of the specified (ù{\codeincomments{rhs}}ù) object.
};
\end{lstlisting}

\noindent Over time, explicitly writing out what the compiler
could do more reliably itself became more clearly an inefficient use of developer time.
What's more, even if the function definition was empty, implementing it
explicitly often had performance implications over allowing
implementations to provide a \textbf{trivial} default. Hence, such
standards tended to evolve toward conventionally commenting out (e.g.,
using \texttt{//!}) the declarations of a function having an empty
body rather than providing it explicitly:

\begin{lstlisting}[language=C++]
class C2
a{
// ...

public:
//! C2();
// Create an empty object.

//! C2(const C2& rhs);
// Create an object having the same value as the specified (ù{\codeincomments{rhs}}ù) object.

//! ~C2();
// Destroy this object.

//! C2& operator=(const C2& rhs);
// Assign to this object the value of the specified (ù{\codeincomments{rhs}}ù) object.
};
\end{lstlisting}

\noindent Note, however, that the compiler does not check the commented code, which is easily susceptible to copy-paste and other errors. By
uncommenting the code and defaulting it explicitly in class scope, we
regain the compiler's syntactic checking of the function signatures
without incurring the cost of turning what would have been
\textbf{trivial} (i.e., compiler-generated) functions into equivalent
non-\textbf{trivial} ones:

\begin{lstlisting}[language=C++]
class C3
{
// ...

public:
C3() = default;
// Create an empty object.

C3(const C3& rhs) = default;
// Create an object having the same value as the specified (ù{\codeincomments{rhs}}ù) object.

~C3() = default;
// Destroy this object.

C3& operator=(const C3& rhs) = default;
// Assign to this object the value of the specified (ù{\codeincomments{rhs}}ù) object.
};
\end{lstlisting}


\subsubsection[Preserving trivial copyability]{Preserving trivial copyability}\label{preserving-trivial-copyability}

In some situations, a particular type \textit{must} be
usable with \texttt{std::memcpy} (e.g., runtime performance,
serialization to binary, or interoperability with C code). Only
\textbf{trivially copyable} types are safe to use with
\texttt{std::memcpy}; use with any other types results in
\textbf{undefined behavior}. A type \texttt{T} is \textbf{trivially
copyable} if it exposes a \textbf{trivial copy constructor}:
\begin{enumerate}
\item{the copy constructor for \texttt{T} is not user provided}
\item{the type \texttt{T} itself has no \texttt{virtual} member functions or
\texttt{virtual} base classes}
\item{any member or base class of
\texttt{T} is itself \textbf{trivially copyable} (recursively).}
\end{enumerate}

As an example, the \texttt{EntityHandle} class (in the code snippet below) represents an
integer handle (to an entity of opaque type) that must be usable with
\texttt{std::memcpy} for the purpose of efficient serialization (the
capacity of the encapsulated fundamental integral type is subject to
change){\cprotect\footnote{Objects of this type are sometimes said to
hold ``dumb data''; see \textbf{{lakos20}}, section~3.5.5,
pp.~629--633.}}:

\begin{lstlisting}[language=C++]
class EntityHandle
{
short int d_id;  // Note: Implementation size may increase over time.

public:
EntityHandle(int id);  // value constructor

// suppresses the declaration of just the default constructor --- i.e.,
// implicitly generates all of the other five special member functions

// ...
}
\end{lstlisting}

\noindent The presence of any other constructor, except a \emph{move constructor},
never affects implicit generation of a copy constructor, and
\texttt{short}~\texttt{int} (like all \emph{enumerated}, \emph{pointer},
and other \emph{fundamental} types) is a \textbf{trivial type}, thus
establishing the \emph{triviality} of copying an \texttt{EntityHandle}.
Now imagine that, to monitor the places in the codebase where
\emph{temporary} entity handles are exchanged (with the goal of
ultimately optimizing those), a user-provided \emph{move constructor} is
added{\cprotect\footnote{Note that a move constructor will be preferred
over a copy constructor when the type category of the argument is an
\emph{xvalue} (i.e., expiring value) or \emph{prvalue} (i.e., pure rvalue), which
are the value categories to which a temporary can pertain. See Section~\ref{Rvalue-References}, ``\titleref{Rvalue-References}," for more information.}}:

\begin{lstlisting}[language=C++]
class EntityHandle
{
short int d_id;  // Note: Implementation size may increase over time.

public:
EntityHandle(int id);              // value constructor
EntityHandle(EntityHandle&& rhs);  // user-provided move constructor

// implicitly generates only the destructor
// suppresses synthesis of all four other special member functions

// ...
};
\end{lstlisting}

\noindent As illustrated by Table~\ref{default-table1} on page~\pageref{default-table1}, the
presence of a user-provided \emph{move constructor} suppressed the
automatic generation of a copy constructor along with the destructor
and both the copy- and move-assignment operators, thereby rendering the
\texttt{EntityHandle} unusable. Replacing these four previously
generated functions with seemingly equivalent user-provided ones might
appear to work as intended:

\begin{lstlisting}[language=C++]
class EntityHandle
{
short int d_id;  // Note: Implementation size may increase over time.

public:
EntityHandle(int id);  // value constructor

EntityHandle(const EntityHandle& rhs);  // user-provided copy constructor
EntityHandle(EntityHandle&& rhs);       // user-provided move constructor

EntityHandle& operator=(const EntityHandle& rhs);
// user-provided copy-assignment operator

EntityHandle& operator=(EntityHandle&& rhs);
// user-provided move-assignment operator

// implicitly generates only the destructor
// suppresses synthesis of the default constructor

// ...
};
\end{lstlisting}

\noindent The user-provided nature of the copy constructor, however, renders the
\texttt{EntityHandle} class ineligible for copy triviality --- even if
the definitions are identical! Hence, any direct use of
\texttt{std::memcpy} with an \texttt{EntityHandle} object will result in
\textbf{undefined behavior}. We could have instead explicitly requested
that these four special member functions be generated using
\texttt{=}~\texttt{default}:

\begin{lstlisting}[language=C++]
class EntityHandle
{
short int d_id;  // Note: Implementation size may increase over time.

public:
EntityHandle(int id);  // value constructor

EntityHandle(const EntityHandle& rhs) = default;
// defaulted (trivial) copy constructor

EntityHandle(EntityHandle&& rhs);
// user-provided move constructor

EntityHandle& operator=(const EntityHandle& rhs) = default;
// default (trivial) copy-assignment operator

EntityHandle& operator=(EntityHandle&& rhs);
// user-provided move-assignment operator

// Implicitly generates only the destructor.
// suppresses synthesis of the default constructor

// ...
};
\end{lstlisting}

\noindent By explicitly defaulting these three special member functions {in class
scope}, we (1) re-enable their generation and (2) preserve the
\emph{copy triviality} of the class.

\subsubsection[Physically decoupling the interface from the implementation]{Physically decoupling the interface from the implementation}\label{physically-decoupling-the-interface-from-the-implementation}

Sometimes, especially during large-scale development, avoiding compile-time coupling clients to the
implementations of individual methods offers distinct maintenance advantages. Specifying that a special member
function is defaulted on its first declaration (i.e., in class scope)
implies that making any change to this implementation will force all
clients to recompile{\cprotect\footnote{The issue here is not just
compile time, per se, but compile-time \emph{coupling}; see
\textbf{{lakos20}}, section 3.10.5, pp.~783--789.}}:

\begin{lstlisting}[language=C++]
// smallscale.h

struct SmallScale
{
SmallScale() = default;  // explicitly defaulted default constructor
};
\end{lstlisting}

\noindent Alternatively, we can choose to declare the function but deliberately
\emph{not} default it in class scope (or anywhere in the \texttt{.h}
file):

\begin{lstlisting}[language=C++]
// largescale.h

struct LargeScale
{
LargeScale();  // user-provided default constructor
};
\end{lstlisting}

\noindent We can then default just the (non-inline) implementation in a
corresponding{\cprotect\footnote{In practice, every \texttt{.cpp} file
(other than the one containing \texttt{main}) typically has a unique
associated header (\texttt{.h}) file and often vice versa (a.k.a., a
\textbf{component}); see \textbf{{lakos20}}, sections 1.6 and 1.11,
pages 209--216 and 256--259, respectively.}}~\texttt{.cpp} file:

\begin{lstlisting}[language=C++]
// largescale.cpp
#include <largescale.h>

LargeScale::LargeScale() = default;
// Generate the default implementation for this default destructor.
\end{lstlisting}

\noindent Using this \emph{insulation} technique, we are free to change our minds
and implement the default constructor ourselves in any way we see fit
without necessarily forcing our clients to recompile.

\subsection[Potential Pitfalls]{Potential Pitfalls}\label{potential-pitfalls}

\subsubsection[Generation of defaulted functions is not guaranteed]{Generation of defaulted functions is not guaranteed}\label{generation-of-defaulted-functions-is-not-guaranteed}

Use of \texttt{=}~\texttt{default} does not guarantee that the special
member function of a type, \texttt{T}, will be generated. For example, a
noncopyable member variable (or base class) of \texttt{T} will inhibit
generation of \texttt{T}'s copy constructor even when
\texttt{=}~\texttt{default} is used. Such behavior can be observed in
the presence of a \texttt{std::unique\_ptr}{\cprotect\footnote{\texttt{std::unique\_ptr<T>}
is a move-only (movable but noncopyable) class template introduced in
C++11. It models unique ownership over a dynamically allocated
\texttt{T} instance, leveraging rvalue references (see Section~\ref{Rvalue-References}, ``\titleref{Rvalue-References}") to represent ownership transfer between instances:
%%% question

\begin{lstlisting}[language=C++, basicstyle={\ttfamily\footnotesize}]
int* p = new int(42);
std::unique_ptr<int> up(p);                   // OK, take ownership of (ù{\codeincomments{p}}ù).
std::unique_ptr<int> upCopy = up;             // compile-time error
std::unique_ptr<int> upMove = std::move(up);  // OK, transfer ownership.
\end{lstlisting}
}} data member:

\begin{lstlisting}[language=C++]
class Connection
{
private:
std::unique_ptr<Impl> d_impl;  // noncopyable data member

public:
Connection() = default;
Connection(const Connection&) = default;
};
\end{lstlisting}

\noindent Despite the defaulted copy constructor, \texttt{Connection} will not be
copy-constructible as\linebreak[4] \texttt{std::unique\_ptr} is a noncopyable type.
Some compilers \emph{may} produce a warning on the declaration of
{\texttt{Connection(const} \texttt{Connection\&)}, but they are not
required to do so since the example code above is well formed and would produce a
compilation failure only if an attempt were made to default-construct or
copy \texttt{Connection}.{\cprotect\footnote{Clang 8.x
produces a diagnostic with no warning flags specified.
GCC~8.x produces no warning, even with both
\texttt{-Wall} and \texttt{-Wextra} enabled.}}

If desired, a possible way to ensure that a defaulted special member
function has indeed been generated is to use
{\texttt{static\_assert}} (see Section~\ref{compile-time-assertions-(static_assert)}, ``\titleref{compile-time-assertions-(static_assert)}")
in conjunction with an
appropriate trait from the \texttt{<type\_traits>} header:

\begin{lstlisting}[language=C++]
class IdCollection
{
std::vector<int> d_ids;

public:
IdCollection() = default;
IdCollection(const IdCollection&) = default;
// ...
};

static_assert(std::is_default_constructible<IdCollection>::value,
"(ù{\codeincomments{IdCollection}}ù) must be default constructible.");

static_assert(std::is_copy_constructible<IdCollection>::value,
"(ù{\codeincomments{IdCollection}}ù) must be copy constructible.");

// ...
\end{lstlisting}

\noindent Routine use of such compile-time testing techniques can help to ensure
that a type will continue to behave as expected (at no additional
runtime cost) even when member (and base) types evolve as a result
of ongoing software maintenance.

\subsection[See Also]{See Also}\label{see-also}

\begin{itemize}
\item{Section~\ref{Rvalue-References}, ``\titleref{Rvalue-References}" — Conditionally Safe C++11 feature that is the foundation of \textbf{move semantics} — the move-constructor and move-assignment special member functions can be defaulted}
\item{Section~\ref{deleted-functions}, ``\titleref{deleted-functions}" — Safe C++11 feature that, among other use cases, allows the prevention of generation of special member functions, providing fine-grained control over the interface of a class if used in conjunction with \texttt{=}~\texttt{default}}
\item{Section~\ref{compile-time-assertions-(static_assert)}, ``\titleref{compile-time-assertions-(static_assert)}" — Safe C++11 feature that checks a predicate at compile time; useful to verify that a class’s special copy and move operations are available as expected}
\end{itemize}

\subsection[Further Reading]{Further Reading}\label{further-reading}

\begin{itemize}
\item{Howard Hinnant, ``Everything You Ever Wanted to Know About Move Semantics (and Then Some)," \textbf{hinnant14}}
\item{Howard Hinnant, ``Everything You Ever Wanted to Know About Move Semantics," \textbf{hinnant16}}
\end{itemize}

\subsection[Appendix: Implicit Generation of Special Member Functions]{Appendix: Implicit Generation of Special Member Functions}\label{appendix:-implicit-generation-of-special-member-functions}

The rules a compiler uses to decide if a special member function
should be generated implicitly are not entirely intuitive. Howard
Hinnant, lead designer and author of the C++11 proposal for move
semantics\footnote{\textbf{hinnant02}} (among other proposals), produced a tabular representation of
such rules in the situation where the user provides a single special
member function and leaves the rest to the compiler. To understand Table~\ref{default-table1}, after picking a special member function in the first
column, the corresponding row will show what is implicitly generated by
the compiler. (When selecting multiple rows, the intersection of the
defaulted functions results.)



\begin{table}[h!]  %%% PRODUCTION: REQUIRES REPRINT PERMISSION;
\begin{center}
\begin{threeparttable}
\caption{Implicit generation of special member functions. NEEDS A CREDIT LINE TO HINNANT.}\label{default-table1}
{\footnotesize %%% setting smaller to fit
\begin{tabular}{p{.12\textwidth}|p{.1\textwidth}|p{.11\textwidth}|p{.1\textwidth}|p{.12\textwidth}|p{.1\textwidth}|p{.12\textwidth}}
\thickhline
% header
\rowcolor[gray]{.9}    & {\sffamily\bfseries Default\linebreak[4] Ctor} & {\sffamily\bfseries Destructor} & {\sffamily\bfseries Copy\linebreak[4] Ctor} & {\sffamily\bfseries Copy\linebreak[4] Assignment} & {\sffamily\bfseries Move\linebreak[4] Ctor} & {\sffamily\bfseries Move\linebreak[4] Assignment} \tabularnewline \hline
% row 1
\cellcolor[gray]{.9}{\sffamily\bfseries Nothing} & Defaulted & Defaulted & Defaulted & Defaulted
& Defaulted & Defaulted \\ \hline
% row 2
\cellcolor[gray]{.9}{\sffamily\bfseries Any\linebreak[4] Ctor} & Not\linebreak[4] Declared &
Defaulted & Defaulted & Defaulted & Defaulted & Defaulted \\ \hline
% row 3
\cellcolor[gray]{.9}{\sffamily\bfseries Default\linebreak[4] Ctor} & User\linebreak[4] Declared & Defaulted & Defaulted &
Defaulted & Defaulted & Defaulted \\ \hline
% row 4
\cellcolor[gray]{.9}{\sffamily\bfseries Destructor} &
Defaulted & User\linebreak[4] Declared & Defaulted\tnote{a} & Defaulted\tnote{a} & Not\linebreak[4] Declared &
Not\linebreak[4] Declared \tabularnewline \hline
% row 5
\cellcolor[gray]{.9}{\sffamily\bfseries Copy\linebreak[4] Ctor} & Not\linebreak[4] Declared & Defaulted &
User\linebreak[4] Declared & Defaulted\tnote{a} & Not\linebreak[4] Declared & Not\linebreak[4] Declared \tabularnewline \hline
% row 6
\cellcolor[gray]{.9}{\sffamily\bfseries Copy\linebreak[4] Assignment} & Defaulted & Defaulted & Defaulted\tnote{a} & User\linebreak[4]
Declared & Not\linebreak[4] Declared & Not\linebreak[4] Declared \tabularnewline \hline
% row 7
\cellcolor[gray]{.9}{\sffamily\bfseries Move\linebreak[4] Ctor} &
Not\linebreak[4] Declared & Defaulted & Deleted & Deleted & User\linebreak[4] Declared & Not\linebreak[4]
Declared \tabularnewline \hline
% row 8
\cellcolor[gray]{.9}{\sffamily\bfseries Move\linebreak[4] Assignment} & Defaulted & Defaulted & Deleted
& Deleted & Not\linebreak[4] Declared & User\linebreak[4] Declared \tabularnewline
\thickhline
\end{tabular}
} % end small
\begin{tablenotes}{\footnotesize
\item[a]{Deprecated behavior: compilers might warn upon reliance of this
implicitly generated member \mbox{function}.}
} % end footnotesize
\end{tablenotes} % we end the table footnotes
\end{threeparttable}
\end{center}
\end{table}

As an example, explicitly declaring a \emph{copy-assignment} operator
would result in the \emph{default constructor}, \emph{destructor}, and
\emph{copy constructor} being defaulted and in the \emph{move}
operations not being declared. If more than one \emph{special member
function} is user declared (regardless of whether or how it is
implemented), the remaining generated member functions are those in the
intersection of the corresponding rows. For example, explicitly
declaring both the destructor and the default constructor would still
result in the copy constructor and the copy-assignment operator being
defaulted and both move operations not being declared. Relying on the
compiler-generated copy operations when the destructor is anything but
defaulted is dubious; if correct, defaulting them explicitly makes both
their existence and intended definition clear.




\newpage
\section[{\tt [[deprecated]]}]{The Standard {\SecCode [[deprecated]]} Attribute\sectionmark{{\RHCode [[deprecated]]}}}\label{deprecated}\label{the-standard-[[deprecated]]-attribute}\sectionmark{{\RHCode [[deprecated]]}}

The \texttt{[[deprecated]]} attribute discourages the use of a decorated
\textbf{entity}, typically via the emission of a compiler warning.

\subsection[Description]{Description}\label{description}

The standard \texttt{[[deprecated]]} attribute is used to portably
indicate that a particular \textbf{entity} is no longer recommended and
to actively discourage its use. Such deprecation typically follows the
introduction of alternative constructs that, in (ideally) all ways, are
superior to the original one, providing time for clients to migrate to
them (\emph{asynchronously}{\cprotect\footnote{A process for ongoing
improvement of legacy code bases, sometimes known as
\textbf{continuous refactoring}, often allows time for clients to
migrate --- on their own respective schedules and time frames --- from
existing \emph{deprecated} constructs to newer ones, rather than
having every client change in lock step. Allowing clients time to move
\emph{asynchronously} to newer alternatives is often the only viable
approach unless (1) the code base is a closed system, (2) all of the
relevant code governed by a single authority, and (3) there is some
sort of mechanical way to make the change.}}) before the deprecated
one is (in some subsequent release) removed. Although not strictly
required, the Standard explicitly encourages{\cprotect\footnote{The C++
Standard characterizes what constitutes a well-formed program, but
compiler vendors require a great deal of leeway to facilitate the
needs of their users. In case any feature induces warnings,
command line options are typically available to disable those warnings
(\texttt{-Wno-deprecated} in GCC) or methods are in place to suppress those warnings
locally (e.g.,
\texttt{\#pragma}~\texttt{GCC}~\texttt{diagnostic}~\texttt{ignored}~\texttt{"-Wdeprecated"}).}}
conforming compilers to produce a diagnostic message in case a program
refers to any \textbf{entity} to which the \texttt{[[deprecated]]}
attribute pertains. For instance, most popular compilers emit a
warning whenever a \texttt{[[deprecated]]} function or
object{\cprotect\footnote{The \texttt{[[deprecated]]} attribute can be
used portably to decorate other entities: \texttt{class},
\texttt{struct}, \texttt{union}, type alias, variable, data member,
function, enumeration, template specialization. Applying
\texttt{[[deprecated]]} to a specific enumerator or namespace,
however, is guaranteed to be supported only since C++17; see
\textbf{smith15a} for more information.}} is used:

\begin{lstlisting}[language=C++]
void f();
[[deprecated]] void g();

int a;
[[deprecated]] int b;

void h()
{
f();
g();  // Warning: (ù{\codeincomments{g}}ù) is deprecated.
a;
b;    // Warning: (ù{\codeincomments{b}}ù) is deprecated.
}
\end{lstlisting}

\noindent A programmer can (optionally) supply a \textbf{string literal} as an
argument to the\linebreak[4] \mbox{\texttt{[[deprecated]]}} attribute (e.g.,
\mbox{\texttt{[[deprecated("message")]]}} to inform human users regarding the
reason for the deprecation:

\begin{lstlisting}[language=C++]
[[deprecated("too slow, use (ù{\codeincomments{algo1}}ù) instead")]] void algo0();
void algo1();

void f()
{
algo0();  // Warning: (ù{\codeincomments{algo0}}ù) is deprecated; too slow, use (ù{\codeincomments{algo1}}ù) instead.
algo1();
}
\end{lstlisting}

\noindent An \textbf{entity} that is initially \emph{declared} without
\texttt{[[deprecated]]} can later be redeclared with the attribute and
vice versa:

\begin{lstlisting}[language=C++]
void f();
void g0() { f(); }  // OK, likely no warnings

[[deprecated]] void f();
void g1() { f(); }  // Warning: (ù{\codeincomments{f}}ù) is deprecated.

void f();
void g2() { f(); }  // Warning: (ù{\codeincomments{f}}ù) is deprecated (still).
\end{lstlisting}

\noindent As seen in \texttt{g2} (above), redeclaring an \textbf{entity} that was
previously decorated with\linebreak[4] \mbox{\texttt{[[deprecated]]}} without the attribute
does not un-deprecate the entity.

\subsection[Use Cases]{Use Cases}\label{use-cases}

\subsubsection[Discouraging use of an obsolete or unsafe \textbf{entity}]{Discouraging use of an obsolete or unsafe \textbf{entity}}\label{discouraging-use-of-an-obsolete-or-unsafe-entity}

Decorating any \textbf{entity} with \texttt{[[deprecated]]} serves both
to indicate a particular feature should not be used in the future and
to actively encourage migration of existing uses to a better
alternative. Obsolescence, lack of safety, and poor performance are
common motivators for deprecation.

As an example of productive deprecation, consider the
\texttt{RandomGenerator} class having a static \texttt{nextRandom}
member function to generate random numbers:

\begin{lstlisting}[language=C++]
struct RandomGenerator
{
static int nextRandom();
// Generate a random value between 0 and 32767 (inclusive).
};
\end{lstlisting}

\noindent Although such a simple random number generator can be very useful, it
might become unsuitable for heavy use because good pseudorandom number
generation requires more state (and the overhead of synchronizing such
state for a single \texttt{static} function can be a significant
performance bottleneck) while good random number generation requires
potentially very high overhead access to external sources of
entropy.{\cprotect\footnote{The C Standard Library provides
\texttt{rand}, available in C++ through the \texttt{<cstdlib>} header.
It has similar issues to our \texttt{RandomGenerator::nextRandom}
function, and similarly developers are guided to use the facilities
provided in the \texttt{<random>} header since C++11.}} One
solution is to provide an alternative random number generator that
maintains more state, allows users to decide where to store that state
(the random number generator objects), and overall offers more
flexibility for clients. The downside of such a change is that it comes
with a functionally distinct API, requiring that users update their code
to move away from the inferior solution:

\begin{lstlisting}[language=C++]
class BetterRandomGenerator
{
// ... (internal state of a quality pseudorandom number generator) ...

public:
int nextRandom();
// Generate a quality random value between 0 and 32767 (inclusive).
};
\end{lstlisting}

\noindent Any user of the original random number generator can migrate to the new
facility with little effort, but that is not a completely trivial
operation, and migration will take some time before the original feature is no
longer in use. The empathic maintainers of \texttt{RandomGenerator} can
decide, instead of removing it completely, to use the
\texttt{[[deprecated]]} attribute to (gently) discourage continued use
of \texttt{RandomGenerator::nextRandom()}:

\begin{lstlisting}[language=C++]
struct RandomGenerator
{
[[deprecated("Use (ù{\codeincomments{BetterRandomGenerator::nextRandom()}}ù) instead.")]]
static int nextRandom();
// ...
};
\end{lstlisting}

\noindent By using \texttt{[[deprecated]]} as shown above, existing clients of
\texttt{RandomGenerator} are informed that a superior
alternative, \texttt{BetterRandomGenerator}, is available, yet they are granted time to
migrate their code to the new solution (rather than their code being broken by the
removal of the old solution). When clients are notified of the
deprecation (thanks to a compiler diagnostic), they can schedule time to
(eventually) rewrite their applications to consume the new interface.{\cprotect\footnote{All joking aside, \textbf{continuous refactoring} is
an essential responsibility of a development organization, and
deciding when to go back and fix what's suboptimal instead of writing
new code that will please users and contribute more immediately to the
bottom line will forever be a source of tension. Allowing disparate
development teams to address such improvements in their own respective
time frames (perhaps subject to some reasonable overall deadline
date) is a proven real-world practical way of ameliorating this
tension.}}

\subsection[Potential Pitfalls]{Potential Pitfalls}\label{potential-pitfalls}

\subsubsection[Interaction with {\tt -Werror} (e.g., GCC, Clang) or {\tt /WX} (MSVC)]{Interaction with {\SubsubsecCode -Werror} (e.g., GCC, Clang) or {\SubsubsecCode /WX} (MSVC)}\label{interaction-with--werror-(e.g,-gcc,-clang)-or-/wx-(msvc)}

To prevent warnings from being overlooked, the \texttt{-Werror} flag
(\texttt{/WX} on MSVC) is sometimes used, which promotes warnings to
errors. Consider the case where a project has been successfully using
\texttt{-Werror} for years, only to one day face an unexpected
compilation failure due to one of the project's dependencies using
\texttt{[[deprecated]]} as part of their API.

Having the compilation process completely stopped due to use of a
deprecated \textbf{entity} defeats the purpose of the attribute because users of such \textbf{entity} are given no time to adapt their code
to use a newer alternative. On GCC and Clang, users can selectively demote deprecation errors back to warnings by using the
\texttt{-Wno-error=deprecated-declarations} compiler flag. On MSVC,
however, such demotion of warnings is not possible: The (unsatisfactory)
workarounds are to disable (entirely) either \texttt{/WX} or deprecation
diagnostics (using the \texttt{-wd4996} flag).

Furthermore, this interaction between \texttt{[[deprecated]]} and
\texttt{-Werror} makes it impossible for owners of a low-level library
to deprecate a function when releasing their code requires that they do
not break the ability for \textit{any} of their higher-level clients to compile;
a single client using the to-be-deprecated function along with
\texttt{-Werror} prevents the release of the code with the
\texttt{[[deprecated]]} attribute on it. With the default behaviors of
compilers and the frequent advice given in practice to use
\texttt{-Werror} aggressively, this can make any use of
\texttt{[[deprecated]]} completely unfeasible.

\subsection[Annoyances]{Annoyances}\label{annoyances}

None so far

\subsection[See Also]{See Also}\label{see-also}

None so far

\subsection[Further Reading]{Further Reading}\label{further-reading}

None so far




\newpage
\section[Relaxed {\ttfamily constexpr} Restrictions]{Relaxed {\SecCode constexpr} Restrictions\sectionmark{Relaxed {\RHCode constexpr} Restrictions}}\label{relaxed-constexpr-restrictions}\sectionmark{Relaxed {\RHCode constexpr} Restrictions}

C++14 lifts restrictions regarding use of many language features in the
body of a \texttt{constexpr} function (see ``\titleref{constexprfunc}" on page~\pageref{constexprfunc}).

\subsection[Description]{Description}\label{description}

The cautious introduction (in C++11) of \texttt{constexpr}
functions --- i.e., functions eligible for compile-time evaluation
--- was accompanied by a set of strict rules that, despite making life
easier for compiler implementers, severely narrowed the breadth of valid
use cases for the feature. In C++11, \texttt{constexpr}
function bodies were restricted to essentially a single
\texttt{return} statement and were not permitted to have any modifiable
local state (variables) or \textbf{imperative} language constructs
(e.g., assignment), thereby greatly reducing their \mbox{usefulness}:

\begin{lstlisting}[language=C++]
constexpr int fact11(int x)
{
static_assert(x >= 0, "");
// Error in C++11/14: (ù{\codeincomments{x}}ù) is not a constant expression.

static_assert(sizeof(x) >= 4, "");  // OK in C++11/14

return x < 2 ? 1 : x * fact11(x - 1);  // OK in C++11/14
}
\end{lstlisting}

\noindent Notice that recursive calls were supported, often leading to convoluted
implementations of algorithms (compared to an \textbf{imperative}
counterpart); see \textit{\titleref{use-cases-relaxedconstexpr}: \titleref{non-recursive-constexpr-algorithms}} on page~\pageref{non-recursive-constexpr-algorithms}.

The C++11 \texttt{static\_assert} feature (see ``\titleref{compile-time-assertions-(static_assert)}" on page~\pageref{compile-time-assertions-(static_assert)}) was always
permitted in a C++11 \texttt{constexpr} function body.
However, because the input variable \texttt{x} in \texttt{fact11}
(in the code snippet above) is inherently not a compile-time constant expression, it can
never appear as part of a \texttt{static\_assert} predicate. Note that a
\texttt{constexpr} function returning \texttt{void} was also permitted:

\begin{lstlisting}[language=C++]
constexpr void no_op() { };  // OK in C++11/14
\end{lstlisting}

\noindent Experience gained from the release and subsequent real-world use of
C++11 emboldened the standard committee to lift most of these (now
seemingly arbitrary) restrictions for C++14, allowing use of (nearly)
\emph{all} language constructs in the body of a \texttt{constexpr}
function. In C++14, familiar non-expression-based control-flow
constructs, such as \texttt{if} statements and \texttt{while} loops, are
also available, as are modifiable local variables and assignment
operations:

\begin{lstlisting}[language=C++]
constexpr int fact14(int x)
{
if (x <= 2)        // error in C++11; OK in C++14
{
return 1;
}

int temp = x - 1;  // error in C++11; OK in C++14
return x * fact14(temp);
}
\end{lstlisting}

\noindent Some useful features remain disallowed in C++14; most notably, any form
of dynamic allocation is not permitted, thereby preventing the use of
common standard container types, such as \texttt{std::string} and
\texttt{std::vector}{\cprotect\footnote{In C++20, even more
restrictions were lifted, allowing, for example, some limited forms of
dynamic allocation, \texttt{try} blocks, and uninitialized variables.}}:
\begin{enumerate}
\item{\texttt{asm} declarations}
\item{\texttt{goto} statements}
\item{Statements with labels other than \texttt{case} and \texttt{default}}
\item{\texttt{try} blocks}
\item{Definitions of variables
\begin{enumerate}
\item{of other than a \textbf{literal type} (i.e., fully processable at compile time)}
\item{decorated with either \texttt{static} or \texttt{thread\_local}}
\item{left uninitialized}
\end{enumerate}
}
\end{enumerate}
The restrictions on what can appear in the body of a \texttt{constexpr}
that remain in C++14 are reiterated here in codified
form\footnote{Note that the degree to which these remaining forbidden features are reported varies substantially from one popular compiler to the next.}:

\begin{lstlisting}[language=C++]
template <typename T>
constexpr void f()
try {                  // Error: (ù{\codeincomments{try}}ù) outside body isn't allowed (until C++20).
std::ifstream is;  // Error: objects of *non-literal* types aren't allowed.
int x;             // error: uninitialized vars. disallowed (until C++20)
static int y = 0;  // Error: (ù{\codeincomments{static}}ù) variables are disallowed.
thread_local T t;  // Error: (ù{\codeincomments{thread\_local}}ù) variables are disallowed.
try{}catch(...){}  // error: (ù{\codeincomments{try}}ù)/(ù{\codeincomments{catch}}ù) disallowed (until C++20)
if (x) goto here;  // Error: (ù{\codeincomments{goto}}ù) statements are disallowed.
[]{};              // Error: lambda expressions are disallowed (until C++17).
here: ;                // Error: labels (except (ù{\codeincomments{case}}ù)/(ù{\codeincomments{default}}ù)) aren't allowed.
asm("mov %r0");    // Error: (ù{\codeincomments{asm}}ù) directives are disallowed.
} catch(...) { }       // error: (ù{\codeincomments{try}}ù) outside body disallowed (until C++20)
\end{lstlisting}


\subsection[Use Cases]{Use Cases}\label{use-cases-relaxedconstexpr}

\subsubsection[Nonrecursive {\tt constexpr} algorithms]{Nonrecursive {\SubsubsecCode constexpr} algorithms}\label{non-recursive-constexpr-algorithms}

The C++11 restrictions on the use of \texttt{constexpr} functions often
forced programmers to implement algorithms (that would otherwise be
implemented iteratively) in a recursive manner. Consider, as a familiar
example, a naive{\cprotect\footnote{For a more efficient (yet less
intuitive) C++11 algorithm, see \textit{\titleref{appendix:-optimized-c++11-example-algorithms}, \titleref{recursive-fibonacci}} on page~\pageref{recursive-fibonacci}.}}
C++11-compliant \texttt{constexpr} implementation of a function,
\texttt{fib11}, returning the \emph{n}-th Fibonacci number\footnote{We used \texttt{long}~\texttt{long} (instead of \texttt{long})
here to ensure a unique C++ type having at least 8 bytes on all
conforming platforms for simplicity of exposition (avoiding an internal
copy). We deliberately chose \emph{not} to make the value returned
\texttt{unsigned} because the extra bit does not justify changing the
\textbf{algebra} (from \texttt{signed} to \texttt{unsigned}). For more
discussion on these specific topics, see ``\titleref{long-long}" on page~\pageref{long-long}.}:

\begin{lstlisting}[language=C++]
constexpr long long fib11(long long x)
{
return
x == 0 ? 0
: (x == 1 || x == 2) ? 1
: fib11(x - 1) + fib11(x - 2);
}
\end{lstlisting}

\noindent The implementation of the \texttt{fib11} function (above) has various
undesirable properties.
\begin{enumerate}
\item{\emph{Reading difficulty} — Because it must be implemented using a single \texttt{return} statement, branching requires a chain of \emph{ternary operators}, leading to a single long expression that might impede human comprehension.}
\item{\emph{Inefficiency and lack of scaling} — The explosion of recursive calls is taxing on compilers: (1) the time to compile is markedly slower for the \emph{recursive} (C++11) algorithm than it would be for its \emph{iterative} (C++14) counterpart, even for modest inputs,{\cprotect\footnote{As an example, Clang 10.0.0, running on an x86-64 machine, required more than 80 times longer to evaluate \texttt{fib(27)} implemented using the \emph{recursive} (C++11) algorithm than to evaluate the same functionality implemented using the \emph{iterative} (C++14) algorithm.}} and (2) the compiler might simply refuse to complete the compile-time calculation if it exceeds some internal (platform-dependent) \emph{threshold} number of operations.{\cprotect\footnote{The same Clang 10.0.0 compiler discussed in the previous footnote failed to compile \texttt{fib11(28)}:

\begin{lstlisting}[language=C++, basicstyle={\ttfamily\footnotesize}]
error: static_assert expression is not an integral constant expression
static_assert(fib11(28) == 317811, "");
^~~~~~~~~~~~~~~~~~~

note: constexpr evaluation hit maximum step limit; possible infinite loop?
\end{lstlisting}

\noindent GCC 10.x fails at \texttt{fib(36)}, with a similar diagnostic:

\begin{lstlisting}[language=C++, basicstyle={\ttfamily\footnotesize}]
error: 'constexpr' evaluation operation count exceeds limit of 33554432
(use '-fconstexpr-ops-limit=' to increase the limit)
\end{lstlisting}

\noindent Clang 10.x fails to compile any attempt at constant evaluating \texttt{fib(28)}, with the following diagnostic message:

\begin{lstlisting}[language=C++, basicstyle={\ttfamily\footnotesize}]
note: constexpr evaluation hit maximum step limit; possible infinite loop?
\end{lstlisting}
}} % end footnote, end cprotect
} % end item
\item{\emph{Redundancy} — Even if the recursive implementation were suitable for small input values during compile-time evaluation, it would be unlikely to be suitable for any run-time evaluation, thereby requiring programmers to provide and maintain \emph{two} separate versions of the same algorithm: a compile-time \emph{recursive} one and a runtime \emph{iterative} one.}
\end{enumerate}

In contrast, an \emph{imperative} implementation of a \texttt{constexpr}
function implementing a function returning the \emph{n\/}th Fibonacci
number in C++14, \texttt{fib14}, does not suffer from any of the three
issues discussed above:

\begin{lstlisting}[language=C++]
constexpr long long fib14(long long x)
{
if (x == 0) { return 0; }

long long a = 0;
long long b = 1;

for (long long i = 2; i <= x; ++i)
{
long long temp = a + b;
a = b;
b = temp;
}

return b;
}
\end{lstlisting}

\noindent As one would expect, the compile time required to evaluate the iterative
implementation (above) is manageable{\cprotect\footnote{Both GCC 10.x
and Clang 10.x evaluated \texttt{fib14(46)} 1836311903 correctly in
under 20ms on a machine running Windows 10 x64 and equipped with a
Intel Core i7-9700k CPU.}}; of course, far more
computationally efficient (e.g., closed form{\cprotect\footnote{E.g.,
see
http://mathonline.wikidot.com/a-closed-form-of-the-fibonacci-sequence.}})
solutions to this classic exercise are available.

\subsubsection[Optimized metaprogramming algorithms]{Optimized metaprogramming algorithms}\label{optimized-metaprogramming-algorithms}

C++14's relaxed \texttt{constexpr} restrictions enable the use of
modifiable local variables and \textbf{imperative} language constructs
for metaprogramming tasks that were historically often implemented by
using (byzantine) recursive template instantiation (notorious for their
voracious consumption of compilation time).

Consider, as the simplest of examples, the task of counting the number
of occurrences of a given type inside a \textbf{type list} represented
here as an empty variadic template (see ``\titleref{variadictemplate}" on page~\pageref{variadictemplate}) that can be
instantiated using a variable-length sequence of arbitrary C++ types{\cprotect\footnote{Variadic templates are a C++11
feature having many valuable and practical uses. In this case, the
variadic feature enables us to easily describe a template that takes
an arbitrary number of C++ type arguments by specifying an ellipsis
(\texttt{...}) immediately following \texttt{typename}. Emulating such
functionality in C++98/03 would have required significantly more
effort: A typical workaround for this use case would have been to
create a template having some fixed maximum number of arguments (e.g.,
20), each defaulted to some unused (incomplete) type (e.g.,
\texttt{Nil}):

\begin{lstlisting}[language=C++, basicstyle={\ttfamily\footnotesize}]
struct Nil;  // arbitrary unused (incomplete) type

template <typename = Nil, typename = Nil, typename = Nil, typename = Nil>
struct TypeList { };
// emulates the variadic (ù{\codeincomments{TypeList}}ù) template (ù{\codeincomments{struct}}ù) for up to four
// type arguments
\end{lstlisting}

\vspace*{-1ex}
\noindent Another theoretically appealing approach is to implement a Lisp-like
recursive data structure; the compile-time overhead for such
implementations, however, often makes them impractical.}}:

\begin{lstlisting}[language=C++]
template <typename...> struct TypeList { };
// empty variadic template instantiable with arbitrary C++ type sequence
\end{lstlisting}

\noindent Explicit instantiations of this variadic template could be used to
create objects:

\begin{lstlisting}[language=C++]
TypeList<>                 emptyList;
TypeList<int>              listOfOneInt;
TypeList<int, double, Nil> listOfThreeIntDoubleNil;
\end{lstlisting}

\noindent A naive C++11-compliant implementation of a \textbf{metafunction}
\texttt{Count}, used to ascertain the (order-agnostic) number of times a
given C++ type was used when creating an instance of the
\texttt{TypeList} template (above), would usually make recursive use of
(baroque) \textbf{partial class template
specialization}{\cprotect\footnote{The use of class-template
specialization (let alone partial specialization) might be unfamiliar
to those not accustomed to writing low-level template metaprograms, but the point of this use case is to obviate such
unfamiliar use. As a brief refresher, a general class template is what
the client typically sees at the user interface. A specialization is
typically an implementation detail consistent with the
\textbf{contract} specified in the general template but somehow more
restrictive. A partial specialization (possible for \emph{class} but
not \emph{function} templates) is itself a template but with one or
more of the general template parameters resolved. An \textbf{explicit}
or \textbf{full specialization} of a template is one in which
\emph{all} of the template parameters have been resolved and, hence, is
not itself a template. Note that a \textbf{full specialization} is a
stronger candidate for a match than a partial specialization, which is
a stronger match candidate than a simple template specialization,
which, in turn, is a better match than the general template (which, in
this example, happens to be an \textbf{incomplete type}).}} to satisfy the single-return-statement requirements{\cprotect\footnote{Notice that this \texttt{Count}
\textbf{metafunction} also makes use (in its implementation) of
variadic class templates to parse a \textbf{type list} of unbounded
depth. Had this been a C++03 implementation, we would have been forced
to create an approximation (to the simple class-template
specialization containing the \textbf{parameter pack}
\texttt{Tail...}) consisting of a bounded number (e.g., 20) of simple
(class) template specializations, each one taking an increasing number
of template arguments:

\begin{lstlisting}[language=C++, basicstyle={\ttfamily\footnotesize}]
template <typename X, typename Y>
struct Count<X, TypeList<Y>>
: std::integral_constant<int, std::is_same<X, Y>::value> { };
// (class) template specialization for one argument

template <typename X, typename Y, typename Z>
struct Count<X, TypeList<Y, Z>>
: std::integral_constant<int,
std::is_same<X, Y>::value + std::is_same<X, Z>::value> { };
// (class) template specialization for two arguments

template <typename X, typename Y, typename Z, typename A>
struct Count<X, TypeList<Y, Z, A>>
: std::integral_constant<int,
std::is_same<X, Y>::value + Count<X, TypeList<Z, A>>::value> { };
// recursive (class) template specialization for three arguments

// ...
\end{lstlisting}
}}:

\begin{lstlisting}[language=C++,label={relaxedconstexpr-countcode}]
#include <type_traits>  // (ù{\codeincomments{std::integral\_constant}}ù), (ù{\codeincomments{std::is\_same}}ù)

template <typename X, typename List> struct Count;
// general template used to characterize the interface for the (ù{\codeincomments{Count}}ù)
// metafunction
// Note that this general template is an incomplete type.

template <typename X>
struct Count<X, TypeList<>> : std::integral_constant<int, 0> { };
// partial (class) template specialization of the general (ù{\codeincomments{Count}}ù) template
// (derived from the integral-constant type representing a compile-time
// (ù{\codeincomments{0}}ù)), used to represent the base case for the recursion --- i.e., when
// the supplied (ù{\codeincomments{TypeList}}ù) is empty
// The payload (i.e., the enumerated (ù{\codeincomments{value}}ù) member of the base class)
// representing the number of elements in the list is (ù{\codeincomments{0}}ù).

template <typename X, typename Head, typename... Tail>
struct Count<X, TypeList<Head, Tail...>>
: std::integral_constant<int,
std::is_same<X, Head>::value + Count<X, TypeList<Tail...>>::value> { };
// simple (class) template specialization of the general (ù{\codeincomments{count}}ù) template
// for when the supplied list is not empty
// In this case, the second parameter will be partitioned as the first
// type in the sequence and the (possibly empty) remainder of the
// (ù{\codeincomments{TypeList}}ù). The compile-time value of the base class will be either the
// same as or one greater than the value accumulated in the (ù{\codeincomments{TypeList}}ù) so
// far, depending on whether the first element is the same as the one
// supplied as the first type to (ù{\codeincomments{Count}}ù).

static_assert(Count<int, TypeList<int, char, int, bool>>::value == 2, "");
\end{lstlisting}

\noindent Notice that we made use of a C++11 \textbf{parameter pack} ---
\texttt{Tail...} (see ``\titleref{variadictemplate}" on page~\pageref{variadictemplate}) in the
implementation of the simple template specialization to package up and
pass along any remaining types.

As should be obvious by now, the C++11 restriction encourages both
somewhat rarified metaprogramming-related knowledge and a
\emph{recursive} implementation that can be compile-time intensive in
practice.{\cprotect\footnote{For a more efficient C++11 version of
\texttt{Count}, see \textit{\titleref{appendix:-optimized-c++11-example-algorithms}, \titleref{constexpr-typelist-count-algorithm}} on page~\pageref{constexpr-typelist-count-algorithm}.}} By exploiting C++14's relaxed
\texttt{constexpr} rules, a simpler and typically more compile-time
friendly \emph{imperative} solution can be realized:

\begin{lstlisting}[language=C++]
template <typename X, typename... Ts>
constexpr int count()
{
bool matches[sizeof...(Ts)] = { std::is_same<X, Ts>::value... };
// Create a corresponding array of bits where (ù{\codeincomments{1}}ù) indicates sameness.

int result = 0;
for (bool m : matches)  // (C++11) range-based (ù{\codeincomments{for}}ù) loop
{
result += m;        // Add up (ù{\codeincomments{1}}ù) bits in the array.
}

return result;  // Return the accumulated number of matches.
}
\end{lstlisting}

\noindent The implementation above --- though more efficient and comprehensible
--- will require some initial learning for those unfamiliar with modern
C++ variadics. The general idea here is to use \textbf{pack expansion}
in a nonrecursive manner{\cprotect\footnote{\textbf{Pack expansion} is
a language construct that expands a \textbf{variadic pack} during
compilation, generating code for each element of the pack. This
construct, along, with a \textbf{parameter pack} itself is a
fundamental building block of variadic templates,
introduced in C++11. As a minimal example, consider the variadic
function template, \texttt{e}:

\begin{lstlisting}[language=C++, basicstyle={\ttfamily\footnotesize}]
template <int... Is> void e() { f(Is...); }
\end{lstlisting}

\noindent \texttt{e} is a function template that can be instantiated
with an arbitrary number of compile-time-constant integers. The
\texttt{int...}~\texttt{Is} syntax declares a \textbf{variadic pack}
of compile-time-constant integers. The \texttt{Is...} syntax (used to
invoke \texttt{f}) is a basic form of pack expansion that will resolve
to all the integers contained in the \texttt{Is} pack, separated by
commas. For instance, invoking
\texttt{e<0,}~\texttt{1,}~\texttt{2,}~\texttt{3>()} results in the
subsequent invocation of
\texttt{f(0,}~\texttt{1,}~\texttt{2,}~\texttt{3)}. Note that --- as
seen in the \texttt{count} example (which starts on page~\pageref{relaxedconstexpr-countcode}) --- any arbitrary
expression containing a variadic pack can be expanded:

\begin{lstlisting}[language=C++, basicstyle={\ttfamily\footnotesize}]
template <int... Is> void g() { h((Is > 0)...); }
\end{lstlisting}

\noindent The \texttt{(Is}~\texttt{>}~\texttt{0)...} expansion (above) will
resolve to \texttt{N} comma-separated Boolean values, where \texttt{N}
is the number of elements contained in the \texttt{Is}
\textbf{variadic pack}. As an example of this expansion, invoking
\texttt{g<5,}~\texttt{-3,}~\texttt{9>()} results in the subsequence
invocation of \texttt{h(true,}~\texttt{false,}~\texttt{true)}.}} to
initialize the \texttt{matches} array with a sequence of zeros and ones
(representing, respectively, mismatch and matches between \texttt{X} and
a type in the \texttt{Ts...} pack) and then iterate over the array to
accumulate the number of ones as the final \texttt{result}. This
\texttt{constexpr}-based solution is both easier to understand and
typically faster to compile.{\cprotect\footnote{For a type list
containing 1024 types, the imperative (C++14) solution compiles about
twice as fast on GCC 10.x and roughly 2.6 times faster on Clang
10.x.}}

\subsection[Potential Pitfalls]{Potential Pitfalls}\label{potential-pitfalls}

None so far

\subsection[Annoyances]{Annoyances}\label{annoyances}

None so far

\subsection[See Also]{See Also}\label{see-also}

\begin{itemize}
\item{``\titleref{constexprfunc}" — Conditionally safe C++11 feature that first introduced compile-time evaluations of functions.}
\item{``\titleref{constexprvar}" — Conditionally safe C++11 features that first introduced variables usable as constant expressions.}
\item{``\titleref{variadictemplate}" — Conditionally safe C++11 feature allowing templates to accept an arbitrary number of parameters.}
\end{itemize}

\subsection[Further Reading]{Further Reading}\label{further-reading}

None so far

\subsection[Appendix: Optimized C++11 Example Algorithms]{Appendix: Optimized C++11 Example Algorithms}\label{appendix:-optimized-c++11-example-algorithms}

\subsubsection[Recursive Fibonacci]{Recursive Fibonacci}\label{recursive-fibonacci}

Even with the restrictions imposed by C++11, we can write a
more efficient recursive algorithm to calculate the \emph{n\/}th
Fibonacci number:

\begin{lstlisting}[language=C++]
#include <utility>  // (ù{\codeincomments{std::pair}}ù)

constexpr std::pair<long long, long long> fib11NextFibs(
const std::pair<long long, long long> prev,  // last two calculations
int count)                                   // remaining steps
{
return (count == 0) ? prev : fib11NextFibs(
std::pair<long long, long long>(prev.second,
prev.first + prev.second),
count - 1);
}

constexpr long long fib11Optimized(long long n)
{
return fib11NextFibs(
std::pair<long long, long long>(0, 1), // first two numbers
n                                      // number of steps
).second;
}
\end{lstlisting}


\subsubsection[{\ttfamily constexpr} type list {\ttfamily Count} algorithm]{{\SubsubsecCode constexpr} type list {\SubsubsecCode Count} algorithm}\label{constexpr-typelist-count-algorithm}

As with the \texttt{fib11Optimized} example, providing a more efficient version of the \texttt{Count} algorithm in
C++11 is also possible, by accumulating the final result through recursive
\texttt{constexpr} function invocations:

\begin{lstlisting}[language=C++]
#include <type_traits>  // (ù{\codeincomments{std::is\_same}}ù)

template <typename>
constexpr int count11Optimized() { return 0; }
// Base case: always return (ù{\codeincomments{0}}ù).

template <typename X, typename Head, typename... Tail>
constexpr int count11Optimized()
// Recursive case: compare the desired type ((ù{\codeincomments{X}}ù)) and the first type in
// the list ((ù{\codeincomments{Head}}ù)) for equality, turn the result of the comparison
// into either (ù{\codeincomments{1}}ù) (equal) or (ù{\codeincomments{0}}ù) (not equal), and recurse with the rest
// of the type list ((ù{\codeincomments{Tail...}}ù)).
{
return (std::is_same<X, Head>::value ? 1 : 0)
+ count11Optimized<X, Tail...>();
}
\end{lstlisting}

\noindent This algorithm can be optimized even further in C++11 by using
a technique similar to the one shown for the iterative C++14
implementation. By leveraging a \texttt{std::array} as compile-time
storage for bits where \texttt{1} indicates equality between types, we can compute the final result with a fixed number of template
instantiations:

\begin{lstlisting}[language=C++]
#include <array>        // (ù{\codeincomments{std::array}}ù)
#include <type_traits>  // (ù{\codeincomments{std::is\_same}}ù)

template <int N>
constexpr int count11VeryOptimizedImpl(
const std::array<bool, N>& bits,  // storage for "type sameness" bits
int i)                            // current array index
{
return i < N
? bits[i] + count11VeryOptimizedImpl<N>(bits, i + 1)
// Recursively read every element from the (ù{\codeincomments{bits}}ù) array and
// accumulate into a final result.
: 0;
}

template <typename X, typename... Ts>
constexpr int count11VeryOptimized()
{
return count11VeryOptimizedImpl<sizeof...(Ts)>(
std::array<bool, sizeof...(Ts)>{ std::is_same<X, Ts>::value... },
// Leverage pack expansion to avoid recursive instantiations.
0);
}
\end{lstlisting}

\noindent Note that, despite being recursive, \texttt{count11VeryOptimizedImpl}
will be instantiated only once with \texttt{N} equal to the number of
elements in the \texttt{Ts...} pack.




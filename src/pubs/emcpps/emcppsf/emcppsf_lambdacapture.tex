\emcppsFeature{
        short={Lambda Captures},
        long={Lambda-Capture Expressions},
}{lambda-capture-expressions}


Lambda-capture expressions enable \textbf{synthetization} (spontaneous implicit creation) of
arbitrary data members within \textbf{closures} generated by
lambda expressions (see ``\titleref{lambda}" on page \pageref{lambda}).

\subsection[Description]{Description}\label{description}

In C++11, lambda expressions can capture variables in the
surrounding scope either \emph{by value} or \emph{by reference}{\cprotect\footnote{We use the familiar (C++11) feature
  \texttt{auto} (see ``\titleref{auto-feature}" on page~\pageref{auto-feature}) to deduce a closure's type since there is no
  way to name such a type explicitly.}}:

\begin{lstlisting}[language=C++]
int i = 0;
auto f0 = [i]{ };   // Create a copy of (ù{\codeincomments{i}}ù) in the generated closure named (ù{\codeincomments{f0}}ù).
auto f1 = [&i]{ };  // Store a reference to (ù{\codeincomments{i}}ù) in the generated closure named (ù{\codeincomments{f1}}ù).
\end{lstlisting}

\noindent Although one could specify \emph{which} and \emph{how} existing
variables were captured, the programmer had no control over the creation
of new variables within a \textbf{closure}. C++14 extends the
\textbf{lambda-introducer} syntax to support implicit creation of
arbitrary data members inside a \textbf{closure} via either \textbf{copy
initialization} or \textbf{list initialization}:

\begin{lstlisting}[language=C++]
auto f2 = [i = 10]{ /* body of closure */ };
    // Synthesize an (ù{\codeincomments{int}}ù) data member, (ù{\codeincomments{i}}ù), initialized with (ù{\codeincomments{10}}ù) in the closure.

auto f3 = [c{'a'}]{ /* body of closure */ };
    // Synthesize a (ù{\codeincomments{char}}ù) data member, (ù{\codeincomments{c}}ù), initialized with (ù{\codeincomments{'a'}}ù) in the closure.
\end{lstlisting}

\noindent Note that the identifiers \texttt{i} and \texttt{c} above do not refer
to any existing variable; they are specified by the programmer creating
the closure. For example, the \textbf{closure} type assigned (i.e.,
bound) to \texttt{f2} (above) is similar in functionality to an
\textbf{invocable} \texttt{struct} containing an \texttt{int} data
member:

\begin{lstlisting}[language=C++]
// pseudocode
struct f2LikeInvocableStruct
{
    int i = 10;  // The type (ù{\codeincomments{int}}ù) is deduced from the initialization expression.
    auto operator()() const { /* closure body */ }  // The (ù{\codeincomments{struct}}ù) is invocable.
};
\end{lstlisting}

\noindent The type of the data member is deduced from the initialization
expression provided as part of the capture in the same vein as
\texttt{auto} (see ``\titleref{auto-feature}" on page~\pageref{auto-feature}) type deduction; hence, it's not possible to
synthesize an uninitialized \textbf{closure} data member:

\begin{lstlisting}[language=C++]
auto f4 = [u]{ };    // Error: (ù{\codeincomments{u}}ù) initializer is missing for lambda capture.
auto f5 = [v{}]{ };  // Error: (ù{\codeincomments{v}}ù)'s type cannot be deduced.
\end{lstlisting}

\noindent It is possible, however, to use variables outside the scope of the
lambda as part of a lambda-capture expression (even capturing them \textit{by
reference} by prepending the \texttt{\&} token to the name of the
synthesized data member):

\begin{lstlisting}[language=C++]
int i = 0;  // zero-initialized (ù{\codeincomments{int}}ù) variable defined in the enclosing scope

auto f6 = [j   = i]{ };  // OK, the local (ù{\codeincomments{j}}ù) data member is a copy of (ù{\codeincomments{i}}ù).
auto f7 = [&ir = i]{ };  // OK, the local (ù{\codeincomments{ir}}ù) data member is an alias to (ù{\codeincomments{i}}ù).
\end{lstlisting}

\noindent Though capturing \textit{by reference} is possible, enforcing \texttt{const} on a lambda-capture expression is not:

\begin{lstlisting}[language=C++]
auto f8 = [const i = 10]{ };                    // error: invalid syntax
auto f9 = [const auto i = 10]{ };               // error: invalid syntax
auto fA = [i = static_cast<const int>(10)]{ };  // OK, (ù{\codeincomments{const}}ù) is ignored.
\end{lstlisting}

\noindent The initialization expression is evaluated during the \emph{creation} of
the closure, not its \emph{invocation}:

\begin{lstlisting}[language=C++]
#include <cassert>  // standard C (ù{\codeincomments{assert}}ù) macro

void g()
{
    int i = 0;

    auto fB = [k = ++i]{ };  // (ù{\codeincomments{++i}}ù) is evaluated at creation only.
    assert(i == 1);  // OK

    fB();  // Invoke (ù{\codeincomments{fB}}ù) (no change to (ù{\codeincomments{i}}ù)).
    assert(i == 1);  // OK
}
\end{lstlisting}

\noindent Finally, using the same identifier as an existing
variable is possible for a synthesized capture, resulting in the original variable
being \textbf{shadowed} (essentially hidden) in the lambda expression's
body but not in its \textbf{declared interface}. In the example below,
we use the (C++11) compile-time operator
\texttt{decltype} (see ``\titleref{decltype}" on page~\pageref{decltype}) to infer the C++ type from the
initializer in the capture to create a parameter of that same type as
that part of its \textbf{declared interface}{\cprotect\footnote{Note
that, in the shadowing example defining \texttt{fC}, GCC version 10.x
incorrectly evaluates \texttt{decltype(i)} inside the body of the
lambda expression as \texttt{const}~\texttt{char}, rather than
  \texttt{char}; see \textit{\titleref{potential-pitfalls-lambdacapture}: \titleref{forwarding-an-existing-variable-into-a-closure-always-results-in-an-object-(never-a-reference)}} on page~\pageref{potential-pitfalls-lambdacapture}.}}{\cprotect\footnote{Here we are using the (C++14) variable
  template (see ``\titleref{variable-templates}" on page~\pageref{variable-templates}) version of the standard \texttt{is\_same} metafunction where \texttt{std::is\_same<A,}~\texttt{B>::value} is replaced with
  \texttt{std::is\_same\_v<A,}~\texttt{B>}.}}:

\begin{lstlisting}[language=C++]
#include <type_traits>  // (ù{\codeincomments{std::is\_same}}ù)

int i = 0;

auto fC = [i = 'a'](decltype(i) arg)
{
    static_assert(std::is_same_v<decltype(arg), int>, "");
         // (ù{\codeincomments{i}}ù) in the interface (same as (ù{\codeincomments{arg}}ù)) refers to the (ù{\codeincomments{int}}ù) parameter.

    static_assert(std::is_same_v<decltype(i), char>, "");
        // (ù{\codeincomments{i}}ù) in the body refers to the (ù{\codeincomments{char}}ù) data member deduced at capture.
};
\end{lstlisting}

\noindent Notice that we have again used \texttt{decltype}, in conjunction with
the standard \texttt{is\_same} metafunction (which is \texttt{true} if
and only if its two arguments are the same C++ type). This time, we're using \texttt{decltype} to
demonstrate that the type (\texttt{int}), extracted from the local
variable \texttt{i} within the declared-interface portion of
\texttt{fC}, is distinct from the type (\texttt{char}) extracted from
the \texttt{i} within \texttt{fC}'s body. In other words, the effect
of initializing a variable in the capture portion of the lambda is to
hide the name of an existing variable that would otherwise be accessible
in the lambda's body.{\cprotect\footnote{Also note that, since the
deduced \texttt{char} member variable, \texttt{i}, is not materially
used (\textbf{ODR-used}) in the body of the lambda expression assigned
(bound) to \texttt{fC}, some compilers, e.g., Clang, may warn:

\begin{lstlisting}[language=C++, basicstyle={\ttfamily\footnotesize}]
warning: lambda capture 'i' is not required to be captured for this use
\end{lstlisting}
      }}

\subsection[Use Cases]{Use Cases}\label{use-cases-lambdacapture}

\subsubsection[Moving (as opposed to copying) objects into a closure]{Moving (as opposed to copying) objects into a closure}\label{moving-(as-opposed-to-copying)-objects-into-a-closure}

Lambda-capture expressions can be used to \emph{move} (see
``\titleref{Rvalue-References}" on page~\pageref{Rvalue-References}) an existing variable into a
closure{\cprotect\footnote{Though possible, it is surprisingly difficult
in C++11 to \emph{move} from an existing variable into a closure.
Programmers are either forced to pay the price of an unnecessary copy or to employ esoteric and fragile techniques, such as writing a wrapper
that hijacks the behavior of its copy constructor to do a \emph{move}
instead:

\begin{lstlisting}[language=C++, basicstyle={\ttfamily\footnotesize}]
template <typename T>
struct MoveOnCopy  // wrapper template used to hijack copy ctor to do move
{
    T d_obj;

    MoveOnCopy(T&& object) : d_obj{std::move(object)} { }
    MoveOnCopy(MoveOnCopy& rhs) : d_obj{std::move(rhs.d_obj)} { }
};

void f()
{
    std::unique_ptr<int> handle{new int(100)};  // move-only
        // Create an example of a handle type with a large body.

    MoveOnCopy<decltype(handle)> wrapper(std::move(handle));
        // Create an instance of a wrapper that moves on copy.

    auto lambda = [wrapper](){ /* use (ù{\codeincomments{wrapper.d\_obj}}ù) */ };
        // Create a "copy" from a wrapper that is captured by value.
}
\end{lstlisting}

\noindent In the example above, we make use of the bespoke (``hacked'')
\texttt{MoveOnCopy} class template to wrap a movable object;
when the lambda-capture expression tries to \emph{copy} the wrapper (\textit{by value}),
the wrapper in turn \emph{moves} the wrapped
  \texttt{handle} into the body of the closure.}} (as opposed to
capturing it \emph{by copy} or \emph{by reference}). As an example of
\emph{needing} to move from an existing object into a closure, consider
the problem of accessing the data managed by
\textbf{\texttt{std::unique\_ptr}} (movable but not copyable) from a
separate thread --- for example, by enqueuing a task in a \textbf{thread
pool}:

\begin{lstlisting}[language=C++]
ThreadPool::Handle processDatasetAsync(std::unique_ptr<Dataset> dataset)
{
    return getThreadPool().enqueueTask([data = std::move(dataset)]
    {
        return processDataset(data);
    });
}
\end{lstlisting}

\noindent As illustrated above, the \texttt{dataset} smart pointer is moved into
the closure passed to\linebreak[4] \mbox{\texttt{enqueueTask}} by leveraging lambda-capture
expressions --- the \textbf{\texttt{std::unique\_ptr}} is \emph{moved}
to a different thread because a copy would have not been possible.

\subsubsection[Providing mutable state for a closure]{Providing mutable state for a closure}\label{providing-mutable-state-for-a-closure}

Lambda-capture expressions can be useful in conjunction with
\texttt{mutable} lambda expressions to provide an initial state that
will change across invocations of the closure. Consider, for instance,
the task of logging how many TCP packets have been received on a socket
(e.g., for debugging or monitoring purposes){\cprotect\footnote{In
this example, we are making use of the (C++11) \texttt{mutable} feature
  of lambdas to enable the counter to be modified on each invocation.}}:

\begin{lstlisting}[language=C++]
TcpSocket tcpSocket(27015);  // some well-known port number
tcpSocket.onPacketReceived([counter = 0]() mutable
{
    std::cout << "Received " << ++counter << " packet(s)\n";
    // ...
});
\end{lstlisting}

\noindent Use of \texttt{counter}~\texttt{=}~\texttt{0} as part of the
\textbf{lambda introducer} tersely produces a \textbf{function object}
that has an internal counter (initialized with zero), which is
incremented on every received packet. Compared to, say, capturing a
\texttt{counter} variable \textit{by reference} in the closure, the solution
above limits the scope of \texttt{counter} to the body of the lambda
expression and ties its lifetime to the closure itself, thereby
preventing any risk of dangling references.

\subsubsection[Capturing a modifiable copy of an existing {\ttfamily const} variable]{Capturing a modifiable copy of an existing {\SubsubsecCode const} variable}\label{capturing-a-modifiable-copy-of-an-existing-const-variable}

Capturing a variable \textit{by value} in C++11 does allow the
programmer to control its \texttt{const} qualification; the generated
closure data member will have the same \texttt{const} qualification as
the captured variable, irrespective of whether the lambda is decorated
with \texttt{mutable}:

\begin{lstlisting}[language=C++]
void f()
{
    int i = 0;
    const int ci = 0;

    auto lc = [i, ci]             // This lambda is not decorated with (ù{\codeincomments{mutable}}ù).
    {
        static_assert(std::is_same_v<decltype(i), int>, "");
        static_assert(std::is_same_v<decltype(ci), const int>, "");
    };

    auto lm = [i, ci]() mutable       // Decorating with (ù{\codeincomments{mutable}}ù) has no effect.
    {
        static_assert(std::is_same_v<decltype(i), int>, "");
        static_assert(std::is_same_v<decltype(ci), const int>, "");
    };
}
\end{lstlisting}

\noindent In some cases, however, a lambda capturing a \texttt{const} variable
\emph{by value} might need to modify that value when invoked. As an
example, consider the task of comparing the output of two Sudoku-solving
algorithms, executed in parallel:

\begin{lstlisting}[language=C++]
template <typename Algorithm> void solve(Puzzle&);
    // This (ù{\codeincomments{solve}}ù) function template mutates a Sudoku grid in place to solution.

void performAlgorithmComparison()
{
    const Puzzle puzzle = generateRandomSudokuPuzzle();
        // (ù{\codeincomments{const}}ù)-correct: (ù{\codeincomments{puzzle}}ù) is not going to be mutated after being
        // randomly generated.

    auto task0 = getThreadPool().enqueueTask([puzzle]() mutable
    {
        solve<NaiveAlgorithm>(puzzle);  // Error: (ù{\codeincomments{puzzle}}ù) is (ù{\codeincomments{const}}ù)-qualified.
        return puzzle;
    });

    auto task1 = getThreadPool().enqueueTask([puzzle]() mutable
    {
        solve<FastAlgorithm>(puzzle);  // Error: (ù{\codeincomments{puzzle}}ù) is (ù{\codeincomments{const}}ù)-qualified.
        return puzzle;
    });

    waitForCompletion(task0, task1);
    // ...
}
\end{lstlisting}

\noindent The code above will fail to compile as capturing \texttt{puzzle} will
result in a \texttt{const}-qualified closure data member, despite the
presence of \texttt{mutable}. A convenient workaround is to use a
(C++14) lambda-capture expression in which a local modifiable copy is deduced:

\begin{lstlisting}[language=C++]
// ...

const Puzzle puzzle = generateRandomSudokuPuzzle();

auto task0 = getThreadPool().enqueueTask([p = puzzle]() mutable
{
    solve<NaiveAlgorithm>(p);  // OK, (ù{\codeincomments{p}}ù) is now modifiable.
    return puzzle;
});

// ...
\end{lstlisting}

\noindent Note that use of \texttt{p}~\texttt{=}~\texttt{puzzle} (above) is
roughly equivalent to the creation of a new variable using
\texttt{auto} (i.e.,
\texttt{auto}~\texttt{p}~\texttt{=}~\texttt{puzzle;}), which guarantees
that the type of \texttt{p} will be deduced as a non-\texttt{const}
\texttt{Puzzle}. Capturing an existing \texttt{const} variable as a mutable copy is
possible, but doing the opposite is not easy; see
\textit{\titleref{annoyances-lambdacapture}: \titleref{there’s-no-easy-way-to-synthesize-a-const-data-member}} on page~\pageref{there’s-no-easy-way-to-synthesize-a-const-data-member}.

\subsection[Potential Pitfalls]{Potential Pitfalls}\label{potential-pitfalls-lambdacapture}

\subsubsection[Forwarding an existing variable into a closure always results in an object (never a reference)]{Forwarding an existing variable into a closure always results in\\ an object (never a reference)}\label{forwarding-an-existing-variable-into-a-closure-always-results-in-an-object-(never-a-reference)}

Lambda-capture expressions allow existing variables to be
\textbf{perfectly forwarded} (see ``\titleref{forwardingref}" on page~\pageref{forwardingref})
into a closure:

\begin{lstlisting}[language=C++]
template <typename T>
void f(T&& x)  // (ù{\codeincomments{x}}ù) is of type forwarding reference to (ù{\codeincomments{T}}ù).
{
    auto lambda = [y = std::forward<T>(x)]
        // Perfectly forward (ù{\codeincomments{x}}ù) into the closure.
    {
        // ... (use (ù{\codeincomments{y}}ù) directly in this lambda body)
    };
}
\end{lstlisting}

\noindent Because \texttt{std::forward<T>} can evaluate to a reference (depending
on the nature of \texttt{T}), programmers might incorrectly assume that
a capture such as \texttt{y}~\texttt{=}~\texttt{std::forward<T>(x)}
(above) is somehow either a capture \emph{by value} or a capture
\emph{by reference}, depending on the original \textbf{value category}
of \texttt{x}.

Remembering that lambda-capture expressions work similarly to
\texttt{auto} type deduction for variables, however,
reveals that such captures will \emph{always} result in an object, \emph{never} a reference:

\begin{lstlisting}[language=C++]
// pseudocode ((ù{\codeincomments{auto}}ù) is not allowed in a lambda introducer.)
auto lambda = [auto y = std::forward<T>(x)] { };
    // The capture expression above is semantically similar to an (ù{\codeincomments{auto}}ù)
    // (deduced-type) variable.
\end{lstlisting}

\noindent If \texttt{x} was originally an \emph{lvalue}, then \texttt{y} will be
equivalent to a \emph{by-copy} capture of \texttt{x}. Otherwise,
\texttt{y} will be equivalent to a \emph{by-move} capture of
\texttt{x}.{\cprotect\footnote{Note that both \emph{by-copy} and
\emph{by-move} capture communicate \textbf{value} for
  \textbf{value-semantic types}.}}

If the desired semantics are to capture \texttt{x} \emph{by move} if it
originated from \textbf{rvalue} and \emph{by reference} otherwise, then
the use of an extra layer of indirection (using, e.g.,
\texttt{std::tuple}) is required:

\begin{lstlisting}[language=C++]
template <typename T>
void f(T&& x)
{
    auto lambda = [y = std::tuple<T>(std::forward<T>(x))]
    {
        // ... (Use (ù{\codeincomments{std::get<0>(y)}}ù) instead of (ù{\codeincomments{y}}ù) in this lambda body.)
    };
}
\end{lstlisting}

\noindent In the revised code example above, \texttt{T} will be an \textbf{lvalue
reference} if \texttt{x} was originally an \textbf{lvalue}, resulting in
the \textbf{synthetization} of a \texttt{std::tuple} containing an
\textbf{lvalue reference}, which --- in turn --- has semantics
equivalent to \texttt{x}'s being captured \emph{by reference}.
Otherwise, \texttt{T} will not be a reference type, and \texttt{x} will
be \emph{moved} into the closure.

\subsection[Annoyances]{Annoyances}\label{annoyances-lambdacapture}

\subsubsection[There’s no easy way to synthesize a {\ttfamily const} data member]{There’s no easy way to synthesize a {\SubsubsecCode const} data member}\label{there’s-no-easy-way-to-synthesize-a-const-data-member}

Consider the (hypothetical) case where the programmer desires to capture
a copy of a non-\texttt{const} integer \texttt{k} as a \texttt{const}
closure data member:

\begin{lstlisting}[language=C++]
[k = static_cast<const int>(k)]() mutable  // (ù{\codeincomments{const}}ù) is ignored
{
    ++k;  // "OK" -- i.e., compiles anyway even though we don't want it to
};
\end{lstlisting}


\begin{lstlisting}[language=C++]
[const k = k]() mutable  // error: invalid syntax
{
    ++k;  // no easy way to force this variable to be (ù{\codeincomments{const}}ù)
};
\end{lstlisting}

\noindent The language simply does not provide a convenient mechanism for
synthesizing, from a modifiable variable, a \texttt{const} data member.
If such a \texttt{const} data member somehow proves to be necessary, we
can either create a \texttt{ConstWrapper} \texttt{struct} (that adds
\texttt{const} to the captured object) or write a full-fledged
\textbf{function object} in lieu of the leaner \textbf{lambda
expression}. Alternatively, a \texttt{const} copy of the object can be
captured with traditional (C++11) lambda-capture expressions:

\begin{lstlisting}[language=C++]
int k;
const int kc = k;

auto l = [kc]() mutable
{
    ++kc;  // error: increment of read-only variable (ù{\codeincomments{kc}}ù)
};
\end{lstlisting}


\subsubsection[{\ttfamily std::function} supports only copyable callable objects]{{\SubsubsecCode std::function} supports only copyable callable objects}\label{std::function-supports-only-copyable-callable-objects}

Any lambda expression capturing a move-only object produces a closure
type that is itself movable but \emph{not} copyable:

\begin{lstlisting}[language=C++]
void f()
{
    std::unique_ptr<int> moo(new char);    // some move-only object
    auto la = [moo = std::move(moo)]{ };   // lambda that does move capture

    static_assert(false == std::is_copy_constructible_v<decltype(la)>, "");
    static_assert( true == std::is_move_constructible_v<decltype(la)>, "");
}
\end{lstlisting}

\noindent Lambdas are sometimes used to initialize instances of
\texttt{std::function}, which requires the stored \textbf{callable
object} to be copyable:

\begin{lstlisting}[language=C++]
std::function<void()> f = la;  // Error: (ù{\codeincomments{la}}ù) must be copyable.
\end{lstlisting}

\noindent Such a limitation --- which is more likely to be encountered when using
lambda-capture expressions --- can make \texttt{std::function}
unsuitable for use cases where move-only closures might conceivably be
reasonable. Possible workarounds include (1) using a different
type-erased, \textbf{callable object} wrapper type that supports
move-only callable objects,{\cprotect\footnote{The
\texttt{any\_invocable} library type, proposed for C++23, is an
example of a type-erased wrapper for move-only callable objects; see
  \textbf{calabrese20}.}} (2) taking a performance hit by wrapping the
desired \textbf{callable object} into a copyable wrapper (such as
\texttt{std::shared\_ptr}), or (3) designing software such that
noncopyable objects, once constructed, never need to
move.\footnote{For an in-depth discussion of how large systems can
benefit from a design that embraces local arena memory allocators and,
thus, minimizes the use of moves across natural memory boundaries
identified throughout the system, see \textbf{lakos22}.}

\subsection[See Also]{See Also}\label{see-also}

\begin{itemize}
\item{``\titleref{lambda}" on page~\pageref{lambda} — provides the needed background for understanding the feature in general}
\item{``\titleref{bracedinit}" on page~\pageref{bracedinit} — illustrates one possible way of initializing the captures}
\item{``\titleref{auto-feature}" on page~\pageref{auto-feature} — offers a model with the same type deduction rules}
\item{``\titleref{Rvalue-References}" on page~\pageref{Rvalue-References} — gives a full description of an important feature used in conjunction with movable types.}
\item{``\titleref{forwardingref}" on page~\pageref{forwardingref} — describes a feature that contributes to a source of misunderstanding of this feature}
\end{itemize}

\subsection[Further Reading]{Further Reading}\label{further-reading}

None so far



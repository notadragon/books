% 3 March 2021, to Josh for code check and addition to Annoyances 


 

\emcppsFeature{
    short={\lstinline!constexpr! Variables},
    tocshort={{\TOCCode constexpr} Variables},
    long={Compile-Time Accessible Variables},
    rhshort={{\RHCode constexpr} Variables},
}{constexprvar}
\setcounter{table}{0}
\setcounter{footnote}{0}
\setcounter{lstlisting}{0}
%\section[{\tt constexpr} Variables]{Compile-Time Accessible Variables}\label{constexprvar}

A variable or \emcppsgloss{variable template} of \emcppsgloss{literal type} may be
declared to be \lstinline!constexpr!, ensuring its successful construction
and enabling its use \emph{at compile-time}.

\subsection[Description]{Description}\label{description}

Variables of \emph{all} built-in types and certain user-defined types,
collectively known as \emcppsgloss[literal type]{literal types}, may be be declared
\lstinline!constexpr!, allowing them to be initialized \emph{at
compile-time} and subsequently used in \emcppsgloss[constant expression]{constant expressions}:

\begin{emcppshiddenlisting}[emcppsbatch=e1]
#include <array>  // (ù{\codeincomments{std::array}}ù)
\end{emcppshiddenlisting}
\begin{emcppslisting}[emcppsbatch=e1]
          int i0 = 5;
    const int i1 = 5;               // (ù{\codeincomments{i1}}ù) is a compile-time constant.
constexpr int i2 = 5;               // (ù{\codeincomments{i2}}ù)  " "    "      "     "

    const double d1 = 5.0;
constexpr double d2 = 5.0;          // (ù{\codeincomments{d2}}ù) is a compile-time constant.

          const char *s1 = "help";
constexpr const char *s2 = "help";  // (ù{\codeincomments{s2}}ù) is a compile-time constant.
\end{emcppslisting}

Although \lstinline!const! integers initialized in the view of the compiler
can be used within constant expressions --- e.g., as the first argument
to \lstinline!static_assert!, the size of an array, or as a non-type
template parameter --- such is not the case for any other types:

\begin{emcppslisting}[emcppsbatch=e1]
static_assert(i0 == 5, "");         // Error, (ù{\codeincomments{i0}}ù) is not a compile-time constant.
static_assert(i1 == 5, "");         // OK, (ù{\codeincomments{const}}ù) is "magical" for integers (only).
static_assert(i2 == 5, "");         // OK

static_assert(d1 == 5, "");         // Error, (ù{\codeincomments{d1}}ù) is not a compile-time constant.
static_assert(d2 == 5, "");         // OK

static_assert(s1[1] == 'e', "");    // Error, (ù{\codeincomments{s1}}ù) is not a compile-time constant.
static_assert(s2[1] == 'e', "");    // OK, the ASCII code for (ù{\codeincomments{e}}ù) is decimal 101.

int a[s2[1]];                       // OK, defines an array, (ù{\codeincomments{a}}ù), of 101 integers
static_assert(sizeof a == 404, ""); // OK, we are assuming the size of (ù{\codeincomments{int}}ù) is 4.

std::array<int, s1[1]> f;           // Error, (ù{\codeincomments{s1}}ù) is not (ù{\codeincomments{constexpr}}ù).
std::array<int, s2[1]> e;           // OK, defines a (ù{\codeincomments{std::array}}ù), (ù{\codeincomments{e}}ù), of 101 integers
\end{emcppslisting}
    
\noindent Prior to C++11, the types of variables usable in a \emcppsgloss{constant
expression} were quite limited:

\begin{emcppslisting}
const int b;         // Error, (ù{\codeincomments{const}}ù) scalar variable must be initialized.
extern const int c;  // OK, declaration
const int d = c;     // OK, not constant initialized ((ù{\codeincomments{c}}ù) initializer not seen)

int ca1[c];          // Error, (ù{\codeincomments{c}}ù) initializer not visible
int da1[d];          // Error, (ù{\codeincomments{d}}ù) initializer not constant

const int c = 7;
int ca2[c];          // OK, initializer is visible
int da2[d];          // Error, (ù{\codeincomments{d}}ù) initializer (still) not constant

const int e = 17;    // OK
int ea[e];           // OK
\end{emcppslisting}
    
\noindent For an \emcppsgloss{integral constant} to be usable at compile time (e.g, as
part of \emcppsgloss{constant expression}), certain requirements must be
satisfied:

\begin{enumerate}
\item{The variable must be marked \lstinline!const!.}
\item{The initializer for a variable must have been seen by the time it is used, and it must be a \emcppsgloss{constant expression} — this is the information needed for a compiler to be able to make use of the variable in other \emcppsgloss[constant expression]{constant expressions}.}
\item{The variable must be of \emph{integral} type, e.g., \lstinline!bool!, \lstinline!char!, \lstinline!short!, \lstinline!int!, \lstinline!long!, \lstinline!long!~\lstinline!long!, as well as the \lstinline!unsigned! variations on these and any additional \lstinline!char! types; see also \featureref{\locationa}{long-long}.}
\end{enumerate}

This restriction to integral types provides support for those values
where compile-time constants are most frequently needed while limiting
the complexity of what compilers were required to support at compile
time.

Use of \lstinline!constexpr! when declaring a variable (or \emcppsgloss{variable
template}; see \featureref{\locationb}{variable-templates}) enables a much richer
category of types to participate in \emcppsgloss[constant expression]{constant expressions}. This
generalization, however, was not made for mere \lstinline!const! variables
because they are not \emph{required} to be initialized by compile-time
constants:

\begin{emcppslisting}
int f() { return 0; }  // (ù{\codeincomments{f()}}ù) is not a compile-time (ù{\emphincomments{constant expression}ù).

                int x0 = f();  // OK
          const int x1 = f();  // OK, but (ù{\codeincomments{x1}}ù) is not a compile-time constant.
constexpr       int x2 = f();  // Error, (ù{\codeincomments{f()}}ù) "    "   "     "     "     "
constexpr const int x3 = f();  // Error, (ù{\codeincomments{f()}}ù) "    "   "     "     "     "
\end{emcppslisting}
    
\noindent As the example code above demonstrates, variables marked
\lstinline!constexpr! \emph{must} satisfy the same requirements needed for
integral constants to be usable as \emcppsgloss{constant expression}. Unlike
other integral constants, their initializers \emph{must} be constant
expressions or else the program is \emcppsgloss{ill formed}. 

For a variable of other than \lstinline!const! integral type to be usable
in a \emcppsgloss{constant expression}, certain criteria must hold:

\begin{enumerate}
\item{The variable must be annotated with \lstinline!constexpr!, which implicitly also declares the variable to be \lstinline!const!\footnote{C++20 added the \lstinline!constinit! keyword to identify a variable that is initialized at compile time (with a constant expression) but may then be modified at runtime.}:

\begin{emcppslisting}
struct S  // simple (aggregate) literal type
{
    int i;  // built-in integer data member
};

constexpr S s{1};  // OK, literal type initialized via constant expression

s = S();           // Error, (ù{\codeincomments{s}}ù) is implicitly declared (ù{\codeincomments{const}}ù) via (ù{\codeincomments{constexpr}}ù).

static_assert(s.i == 1);  // OK, subobjects of (ù{\codeincomments{constexpr}}ù) objects are (ù{\codeincomments{constexpr}}ù).

constexpr int j = s.i;    // OK, subobjects are usable in (ù{\emphincomments{constant expressions}}ù).
\end{emcppslisting}
    
\noindent In the example above, we have, for expedience of exposition, used brace
initialization to initialize the aggregate; see \featureref{\locationc}{bracedinit}. Note that subobjects of \lstinline!constexpr! objects
are also effectively \lstinline!constexpr! and can be used freely in
\emcppsgloss[constant expression]{constant expressions} even though they themselves might not be
explicitly declared \lstinline!constexpr!.}

\item{All \lstinline!constexpr! variables must be initialized with a \emcppsgloss{constant expression} when they are defined. Hence, every \lstinline!constexpr! variable has an initializer, and that initializer must be a valid \emcppsgloss{constant expression} (see \featureref{\locationc}{constexprfunc}):

\begin{emcppslisting}
          int g() { return 17; }  // a non-(ù{\codeincomments{constexpr}}ù) function
constexpr int h() { return 34; }  // a (ù{\codeincomments{constexpr}}ù) function

constexpr int v1;        // Error, (ù{\codeincomments{v1}}ù) is not initialized.
constexpr int v2 = 17;   // OK
constexpr int v3 = g();  // Error, (ù{\codeincomments{g()}}ù) is not (ù{\codeincomments{constexpr}}ù).
constexpr int v4 = h();  // OK

void func(int c)
{
    constexpr int v5 = c;         // Error, (ù{\codeincomments{c}}ù) not a compile-time constant.
    constexpr int v6 = sizeof(c);  // OK, (ù{\codeincomments{c}}ù) is not evaluated.
}
\end{emcppslisting}
}
    
\item{Any variable declared \lstinline!constexpr! must be of \emcppsgloss{literal type}; all literal types are, among other things, \emcppsgloss{trivially destructible}:

\begin{emcppslisting}
struct Lt  // literal type
{
    constexpr  Lt()  { }  // (ù{\codeincomments{constexpr}}ù) constructor
    ~Lt() = default;      // (ù{\codeincomments{default}}ù) trivial destructor
};

constexpr Lt lt;  // OK, (ù{\codeincomments{Lt}}ù) is a (ù{\emphincomments{literal type}ù).

struct Nlt  // (ù{\emphincomments{non}ù)literal type.
{
    Nlt()  { }  // cannot initialize at compile-time
    ~Nlt() { }  // cannot skip non-trivial destruction
};

constexpr Nlt nlt;  // Error, (ù{\codeincomments{Nlt}}ù) is not a (ù{\emphincomments{literal type}ù).
\end{emcppslisting}
    
\noindent Since all \emcppsgloss[literal type]{literal types} are trivially destructible, the
compiler does not need to emit any special code to manage the end of the
lifetime of a \lstinline!constexpr! variable, which can essentially live
``forever'' --- i.e., until the program exits.{\cprotect\footnote{In
C++20, literal types can have non-trivial destructors, and the
destructors for \lstinline!constexpr! variables will be invoked under the
same conditions that a destructor would be invoked for a
  non\lstinline!constexpr! global or \lstinline!static! variable.}}}

\item{Unlike integral constants, non\lstinline!static! data members cannot be \lstinline!constexpr!. Only variables at global or \lstinline!namespace! scope, automatic variables, or \lstinline!static! data members of a \lstinline!class! or \lstinline!struct! may be declared \lstinline!constexpr!. Consequently, any given \lstinline!constexpr! variable is a top-level object, never a subobject of another (possible non\lstinline!constexpr!) object:

\begin{emcppslisting}
               constexpr int i = 17;    // OK, file scope
namespace ns { constexpr int j = 34; }  // OK, namespace scope

struct C
{
    static constexpr int k = 51;  // OK, (ù{\codeincomments{static}}ù) data member
           constexpr int l = 68;  // Error, (ù{\codeincomments{constexpr}}ù) non(ù{\codeincomments{static}}ù) data member
};

void g()
{
    static constexpr int m = 85;  // OK
           constexpr int n = 92;  // OK
};
\end{emcppslisting}
    
\noindent Recall, however, that \emcppsgloss[nonstatic data member]{nonstatic data members} of
\lstinline!constexpr! objects are implicitly \lstinline!constexpr! and
therefore can be used directly in any \emcppsgloss[constant expression]{constant expressions}:

\begin{emcppslisting}
constexpr struct D { int i; } x{1};  // brace-initialized aggregate (ù{\codeincomments{x}}ù)
constexpr int k = x.i;  // Subobjects of (ù{\codeincomments{constexpr}}ù) objects are (ù{\codeincomments{constexpr}}ù).
\end{emcppslisting}
}
\end{enumerate}
    
\noindent Finally, it is important to note the significance of one of the
differences between a \lstinline!constexpr! integral variable and a
\lstinline!const! integral variable. Because the initializer of a
\lstinline!constexpr! variable is \emph{required} to be a \emcppsgloss{constant
expression}, it is not subject to the possibility of undefined behavior
(e.g., overflow) at run time and will instead result in a compile-time
error:

\begin{emcppslisting}
          const int iA = 1 << 15;  // 2^15 = 32,768 fits in 2 bytes.
          const int jA = iA * iA;  // OK

          const int iB = 1 << 16;  // 2^16 = 65,536 doesn't fit in 2 bytes.
          const int jB = iB * iB;  // Bug, overflow (might warn)

constexpr const int iC = 1 << 16;
constexpr const int jC = iC * iC;  // Error, overflow in constant expression

constexpr       int iD = 1 << 16;  // Example (ù{\codeincomments{D}}ù) is the same as (ù{\codeincomments{C}}ù), above.
constexpr       int jD = iD * iD;  // Error, overflow in constant expression
\end{emcppslisting}
    
\noindent The code example above shows that an integer constant-expression
overflow, absent \lstinline!constexpr!, is not required by the C++ Standard
to be treated as ill formed, whereas the initializer for a
\lstinline!constexpr! expression is required to report overflow as an error
(not just a warning).

There is a strong association between \lstinline!constexpr! variable and
functions; see\linebreak[4]%%%%%  
\featureref{\locationc}{constexprfunc}. Using a
\lstinline!constexpr! variable rather than just a \lstinline!const! one forces the
compiler to detect overflow within the body of \lstinline!constexpr!
function and report it --- as a compile-time error --- in a way that it
would not otherwise be authorized to do.

For example, suppose we have two similar functions, \lstinline!squareA! and
\lstinline!square!, defined for the built-in type (\lstinline!signed!)
\lstinline!int! that each return the integral product of multiplying the
argument with itself:

\begin{emcppslisting}[emcppsbatch=e2]
          int squareA(int i) { return i * i; }  // non-(ù{\codeincomments{constexpr}}ù) function
constexpr int squareB(int i) { return i * i; }  // (ù{\codeincomments{constexpr}}ù) function
\end{emcppslisting}
    
\noindent Declaring a variable to be just \lstinline!const! does nothing to force the
compiler to check the evaluation of either function for overflow:

\begin{emcppslisting}[emcppsbatch=e2]
                int xA0 = squareA(1 << 15);  // OK
          const int xA1 = squareA(1 << 15);  // OK
constexpr       int xA2 = squareA(1 << 15);  // Error, (ù{\codeincomments{squareA}}ù), not (ù{\codeincomments{constexpr}}ù)

                int yB0 = squareB(1 << 15);  // OK
          const int yB1 = squareB(1 << 15);  // OK
constexpr       int yB2 = squareB(1 << 15);  // OK

                int zC0 = squareB(1 << 16);  // Bug, (ù{\codeincomments{zC0}}ù) is likely 0.
          const int zC1 = squareB(1 << 16);  // Bug, (ù{\codeincomments{zC1}}ù)  "   "    "
constexpr       int zC2 = squareB(1 << 16);  // Error, (ù{\codeincomments{int}}ù) overflow detected!
\end{emcppslisting}
    
\noindent By declaring a variable to be not just \lstinline!const! but
\lstinline!constexpr!, we make the compiler evaluate that (necessarily
\lstinline!constexpr!) function for those specific arguments at compile
time, and, if there is overflow, immediately report the defect as being
\emcppsgloss{ill formed}.

\subsection[Use Cases]{Use Cases}\label{use-cases}

\subsubsection[Alternative to enumerated compile-time integral constants]{Alternative to enumerated compile-time integral constants}\label{alternative-to-enumerated-compile-time-integral-constants}

It is not uncommon to want to express specific integral constants at
compile time --- e.g., for precomputed operands to be used in
algorithms, mathematical constants, configuration variables, or any
number of other reasons. A naive, brute-force approach might be to
hard-code the constants where they are used:

\begin{emcppslisting}
int hoursToSeconds0(int hours)
    // Return the number of seconds in the specified (ù{\codeincomments{hours}}ù).  The behavior is
    // undefined unless the result can be represented as an (ù{\codeincomments{int}}ù).
{
    return hours * 3600;
}
\end{emcppslisting}
    
\noindent This use of \emph{magic constants} has, however, long been
known\footnote{\cite{kernighan99}, section~1.5, pp.~19-22} to make finding uses of the constants
and the relationships between related ones needlessly difficult. For
integral values only, we could always represent such compile-time
constants symbolically by using a classic \lstinline!enum! type (in
deliberate preference to the modern, type-safe enumerator; see \featureref{\locationc}{enumclass}):

\begin{emcppslisting}
struct TimeRatios1  // explicit scope for single classic anonymous (ù{\codeincomments{enum}}ù) type
{
    enum  // anonymous enumeration comprising related symbolic constants
    {
        k_SECONDS_PER_MINUTE = 60,     // Underlying type (UT) (ù{\emphincomments{might}ù) be (ù{\codeincomments{int}}ù).
        k_MINUTES_PER_HOUR   = 60,
        k_SECONDS_PER_HOUR   = 60*60,  // these enumerators have the same UT
    };
};

int hoursToSeconds1(int hours)
    // ...
{
    return hours * TimeRatios1::k_SECONDS_PER_HOUR;
}
\end{emcppslisting}
    
\noindent This traditional solution, while often effective, gave little control to
the underlying integral type of the enumerator used to represent the
symbolic compile-time constant, leaving it at the mercy of the totality
of values used to initialize its members. Such inflexibility might lead
to compiler warnings and nonintuitive behavior resulting from
\lstinline!enum!-specific ``integral-promotion'' rules, especially when the
\emcppsgloss{underlying type (UT)} used to represent the time ratios differs
from the integral type with which they are ultimately used; see \featureref{\locationc}{explicit-enumeration-underlying-type}.

In this particular example, extending the \lstinline!enum! to cover ratios
up to a week and conversions down to nanoseconds would manifestly change
its \emcppsgloss[underlying type (UT)]{UT} (because there are far more than $2^{32}$ nanoseconds in a week),
altering how all of the enumerators behave when used in expressions
with, say, values of type \lstinline!int! (e.g., to \lstinline!long!); see \featureref{\locationa}{long-long}:

\begin{emcppslisting}
struct TimeRatios2  // explicit scope for single classic anonymous (ù{\codeincomments{enum}}ù) type
{
    enum  // Anonymous enumeration --- UT is governed by all of the enumerators.
    {
        k_SECONDS_PER_MINUTE = 60,    // UT (ù{\emphincomments{might}ù) be (ù{\codeincomments{long}}ù) (or (ù{\codeincomments{long long}}ù)).
        k_MINUTES_PER_HOUR   = 60,
        k_SECONDS_PER_HOUR   = 3600,
        // ...
        k_USEC_PER_WEEK = 1000L*1000*60*60*24*7,  // same UT as all of the above
    };
};
\end{emcppslisting}
    
\noindent The original \emph{values} will remain unchanged, but the burden of all
of the warnings resulting from the change in \emcppsgloss[underlying type (UT)]{UT} and rippling throughout a large codebase could be expensive to
repair.

We would like the original values to remain unchanged (e.g., remain as
\lstinline!int! if that's what they were), and we want only those values
that do \emph{not} fit in an \lstinline!int! to morph into a larger
integral type. We might achieve this effect by placing each enumerator
in its own separate anonymous enumeration:

\begin{emcppslisting}
struct TimeRatios3  // explicit scope for multiple classic anonymous (ù{\codeincomments{enum}}ù) types
{
    enum { k_SECONDS_PER_MINUTE = 60               };  // UT: (ù{\codeincomments{int}}ù) (likely)
    enum { k_MINUTES_PER_HOUR   = 60               };  //  "    "      "
    enum { k_SECONDS_PER_HOUR   = 60*60            };  //  "    "      "
    // ...
    enum { k_USEC_PER_SEC  = 1000*1000             };  // UT: (ù{\codeincomments{int}}ù) (v. likely)
    enum { k_USEC_PER_MIN  = 1000*1000*60          };  // UT: (ù{\codeincomments{int}}ù) (v. likely)
    enum { k_USEC_PER_HOUR = 1000U*1000*60*60      };  // UT: (ù{\codeincomments{unsigned int}}ù)
    enum { k_USEC_PER_DAY  = 1000L*1000*60*60*24   };  // UT: (ù{\codeincomments{long}}ù)
    enum { k_USEC_PER_WEEK = 1000L*1000*60*60*24*7 };  // UT: (ù{\codeincomments{long}}ù)
};
\end{emcppslisting}
    
\noindent In this case, the original values as well as their respective \emcppsgloss[underlying type (UT)]{UTs} will
remain unchanged and each new enumerated value will independently take
on its own independent \emcppsgloss[underlying type (UT)]{UT}, which is either implemenation defined or else
dictated by the number of bits required to represent the value, which
is, in this case, non-negative.

A modern alternative to having separate anonymous \lstinline!enum!s for
each distinct value (or class of values) is to instead encode each ratio
as an explicitly typed \lstinline!constexpr! variable:

\begin{emcppslisting}
struct TimeRatios4
{
    static constexpr int k_SECONDS_PER_MINUTE = 60;
    static constexpr int k_MINUTES_PER_HOUR   = 60;
    static constexpr int k_SECONDS_PER_HOUR   = k_MINUTES_PER_HOUR *
                                                k_SECONDS_PER_MINUTE;
    // ...
    static constexpr long k_NANOS_PER_SECOND  = 1000*1000*1000;
    static constexpr long k_NANOS_PER_HOUR    = k_NANOS_PER_SECOND *
                                                k_SECONDS_PER_HOUR;
};

int hoursToSeconds(int hours)
    // ...
{
    return hours * TimeRatios4::k_SECONDS_PER_HOUR;
}

long hoursToNanos(int hours)
    // Return the number of nanoseconds in the specified (ù{\codeincomments{hours}}ù).  The behavior
    // is undefined unless the result can be represented as a (ù{\codeincomments{long}}ù).
{
    return hours * TimeRatios4::k_NANOS_PER_HOUR;
}
\end{emcppslisting}
    
\noindent In the example above, we've rendered the \lstinline!constexpr! variables as
\lstinline!static! members of a \lstinline!struct! rather than placing them at
namespace scope primarily to show that, from a user perspective, the two
are syntactically indistinguishable --- the substantive difference here
being that a client would be prevented from unilaterally adding logical
content to the ``namespace'' of a \lstinline!TimeRatio!~\lstinline!struct!.
When it comes to C-style \emcppsgloss[free function]{free functions}, however, the
advantages for \lstinline!static! members of a struct over namespace scope
are many and \mbox{unequivocal}.{\cprotect\footnote{\cite{lakos20}, section~2.4.9, pp.~312-321, specifically Figure 2-23}}

\subsubsection[Nonintegral symbolic numeric constants]{Nonintegral symbolic numeric constants}\label{non-integral-symbolic-numeric-constants}

Not all symbolic numeric constants that are needed at compile-time are
necessarily integral. Consider, for example, the mathematical constants
\lstinline!pi! and \lstinline!e!, which are typically represented as a
floating point type, such as \lstinline!double! (or
\lstinline!long!~\lstinline!double!).

The classical solution to avoid encoding this type of constant values as
a \emph{magic number} is to instead use a macro, such as is done in the
\lstinline!math.h! header on most operating systems:

\begin{emcppslisting}
#define M_E   2.7182818284590452354  /* e */
#define M_PI  3.14159265358979323846 /* pi */

double areaOfCircle(double radius)
{
    return 2 * M_PI * radius;
}
\end{emcppslisting}
    
\noindent While this approach can be effective, it comes with all the well known
downsides of using the C preprocessor. This approach is also fraught
with risk such that the headers standard on many systems make these
macros available in C or C++ only upon request by \lstinline!#define!ing
specific macros before including those headers.\footnote{See your library
documentation for details.}

Another safer and far less error-prone solution to name collisions is to
instead use a \lstinline!constexpr! variable for this form of nonintegral
constant. Note that, while the macro is defined with more precision to
be able to initialize variables of possibly higher-precision
floating-point types, here we need only enough digits to uniquely
identify the appropriate \lstinline!double! constant:

\begin{emcppslisting}[emcppsstandards={c++14}]
struct NumericConstants
{
    static constexpr double k_E  = 2.718'281'828'459'045;  /* e */
    static constexpr double k_PI = 3.141'592'653'589'793;  /* pi */
};

double areaOfCircle(double radius)
{
    return 2 * NumericConstants::k_PI * radius;
}
\end{emcppslisting}
    
\noindent In the example above, we have made valuable use of a safe C++14
feature to help identify the needed precision of the numeric literal;
see \featureref{\locationb}{digitseparator}. Beyond the potential name
collisions and global name pollution, preferring a constexpr variable
over a C preprocessor macro has the added benefit of making explicit the
C++ type of constant being defined. Note that supplying digits beyond
what are significant will nonetheless be silently ignored.

\subsubsection[Storing \lstinline!constexpr! data structures]{Storing {\SubsubsecCode constexpr} data structures}\label{storing-constexpr-data-structures}

Precomputing values (at compile time) for subsequent use (at run time)
is one impactful use of \lstinline!constexpr! \emph{functions}, but see \intraref{potential-pitfalls-constexprvar}{constexpr-function-pitfalls}. Storing these values in explicitly
\lstinline!constexpr! variables ensures that the values are (1) guaranteed
to be computed at compile time and not, for example, at startup as the
result of a (dangerous) runtime initialization of a file- or
namespace-scoped variable and (2) usable as part of the evaluation of
any \emcppsgloss{constant expression}; see \featureref{\locationc}{constexprfunc}.

Rather than attempting to circumvent the draconian limitations of the
C++11 version of \lstinline!constexpr! functions, we will make use of the
relaxed restrictions of C++14. For this, we will define a class template
that initializes an array member with the results of a
\lstinline!constexpr! functor applied to each array
index{\cprotect\footnote{Note that, in C++17, most of the manipulators
of \lstinline!std::array! have been changed to be \lstinline!constexpr! and,
when combined with the relaxation of the rules for \lstinline!constexpr!
evaluation in C++14 (see \featureref{\locationd}{relaxed-constexpr-restrictions}), this compile-time-friendly container provides a simple way to
  define functions that populate tables of values.}}:

\begin{emcppshiddenlisting}[emcppsbatch=e3,emcppsstandards={c++14}]
#include <cstddef>  // (ù{\codeincomments{std::size\_t}}ù)
\end{emcppshiddenlisting}
\begin{emcppslisting}[emcppsbatch=e3]
template <typename T, std::size_t N>
struct ConstexprArray
{
private:
    T d_data[N];  // data initialized at construction

public:
    template <typename F>
    constexpr ConstexprArray(const F &func)
    : d_data{}
    {
        for (int i = 0; i < N; ++i)
        {
            d_data[i] = func(i);
        }
    }

    constexpr const T& operator[](std::size_t ndx) const
    {
        return d_data[ndx];
    }
};
\end{emcppslisting}
    
\noindent The numerous alternative approaches to writing such data structures,
vary in their complexity, trade-offs, and understandability. In this
case, we default initialize our elements before populating them but do
not need to rely on any other significant new language infrastructure.
Other approaches could be taken; see \featureref{\locationc}{constexprfunc}.

Given this utility class, we can then precompute at compile time any
function that we can express as a \lstinline!constexpr! function, such as a
simple table of the first \lstinline!N! squares:

\begin{emcppslisting}[emcppsbatch=e3]
constexpr int square(int x) { return x * x; }

constexpr ConstexprArray<int, 500> squares(square);

static_assert(squares[1]   == 1,    "");
static_assert(squares[289] == 83521,"");
\end{emcppslisting}
    
\noindent Note that, as with many applications of \lstinline!constexpr! functions,
attempting to initialize a large array of \lstinline!constexpr! variables
will quickly bump up against compiler-imposed template instantiation
limits. What's more, attempting to perform more complex arithmetic at
compile time would be likely to exceed computation limits as well.

\subsubsection[Diagnosing undefined behavior at compile time]{Diagnosing undefined behavior at compile time}\label{diagnosing-undefined-behavior-at-compile-time}

Avoiding overflow during intermediate calculations is an important
consideration, especially from a security perspective, and yet is a
generally difficult-to-solve problem. Forcing computations to occur at
compile time brings the full power of the compiler to bear in addressing
such undefined behavior.

As an academically interesting example of this eminently practical
security problem, suppose we want to write a (compile-time) function in
C++ to compute the \emcppsgloss{Collatz length} of an arbitrary positive
integer and generate a compilation error if any intermediate calculation
would result in signed integer overflow.

First let's take a step back now to understand what we are talking about
here with respect to \emcppsgloss{Collatz length}. Suppose we have a function
\lstinline!cf! that takes a positive \lstinline!int!, \lstinline!n!, and for even
\lstinline!n! returns \lstinline!n/2! and for odd \lstinline!n! returns
\lstinline!3n+1!.

\begin{emcppslisting}
int cf(int n) { return n % 2 ? 3 * n + 1 : n / 2; }  // Collatz function
\end{emcppslisting}
    
\noindent Given a positive integer, \lstinline!n!, the \emcppsgloss{Collatz sequence},
\lstinline!cs(n)!, is defined as the sequence of integers generated by
repeated application of the \emcppsgloss{Collatz function} --- e.g,\linebreak[4]%%%%
 \lstinline!cs(1)!~\lstinline!=!~\lstinline!{!~\lstinline!4,!~\lstinline!2,!~\lstinline!1,!~\lstinline!4,!~\lstinline!2,!~\lstinline!1,!~\lstinline!4,!~\lstinline!...!~\lstinline!};!,
\lstinline!cs(3)!~\lstinline!=!~\lstinline!{!~\lstinline!10,!~\lstinline!5,!~\lstinline!16,!~\lstinline!8,!~\lstinline!4,!~\lstinline!2,!~\lstinline!1,!~\lstinline!4,!~\lstinline!...!~\lstinline!}!,
and so on. A classic (but as yet unproven) conjecture in mathematics
states that, for every positive integer, $n$, the \emcppsgloss{Collatz
sequence} for $n$ will eventually reach 1. The \emcppsgloss{Collatz length} of
the positive integer $n$ is the number of iterations of the
\emcppsgloss{Collatz function} needed to reach 1, starting from $n$.~Note that
the \emcppsgloss{Collatz sequence} for \lstinline!n!~\lstinline!=!~\lstinline!1! is
\lstinline!{!~\lstinline!1,!~\lstinline!1,!~\lstinline!1,!~\lstinline!...!~\lstinline!}!
and its \emcppsgloss{Collatz length} is 0.

This example showcases the need for a \lstinline!constexpr! variable in
that we need to create a \emcppsgloss{constexpr context} -- i.e., one
requiring a \emcppsgloss{constant expression} to require that the
evaluation of a \lstinline!constexpr! function occur at compile time.
Again, to avoid distractions related to implementing more complex
functionality within the limitations of C++11 \lstinline!constexpr!
functions, we will make use of the relaxed restrictions of C++14; see
\featureref{\locationc}{constexprfunc}:

\begin{emcppslisting}[emcppsstandards={c++14}]
constexpr int collatzLength(long long number)
    // Return the length of the Collatz sequence of the specified (ù{\codeincomments{number}}ù). The
    // behavior is undefined unless each intermediate sequence member can be
    // expressed as an (ù{\codeincomments{unsigned long long}}ù).
{
    int length = 0;         // collatLength(1) is 0.

    while (number > 1)      // The current value of number is not 1.
    {
        ++length;           // Keep track of the length of the sequence so far.

        if (number % 2)     // if the current number is odd
        {
            number = 3 * number + 1;    // advance from odd sequence value
        }
        else
        {
            number /= 2;                // advance from even sequence value
        }
    }

    return length;
}

const     int c1 = collatzLength(942488749153153);  // OK, 1862
constexpr int x1 = collatzLength(942488749153153);  // OK, 1862

const int c2 = collatzLength(104899295810901231);
    // Bug, program aborts at runtime.

constexpr int x2 = collatzLength(104899295810901231);
    // Error, overflow in constant evaluation
\end{emcppslisting}
    
\noindent In the example above, the variables \lstinline!c1! and \lstinline!x1! can be
initialized correctly at compile-time, but \lstinline!c2! and \lstinline!x2!
cannot. The non\lstinline!constexpr! nature of \lstinline!c2! allows the
overflow to occur and exhibit undefined behavior --- integer overflow
--- at run time. On the other hand, the variable \lstinline!x2!, due to
its being declared \lstinline!constexpr!, forces the computation to
occur at compile time, thereby discovering the overflow and dutifully
invoking the \emph{non}\lstinline!constexpr!~\lstinline!std::abort! function,
which in turn generates the desired error at compile time.

\subsection[Potential Pitfalls]{Potential Pitfalls}\label{potential-pitfalls-constexprvar}

\subsubsection[\lstinline!constexpr! function pitfalls]{{\SubsubsecCode constexpr} function pitfalls}\label{constexpr-function-pitfalls}

Many of the uses of \lstinline!constexpr! variables involve a corresponding
use of \lstinline!constexpr! functions (see \featureref{\locationc}{constexprfunc}). The pitfalls related to \lstinline!constexpr! functions are
similarly applicable to the variables in which their results might be
stored. In particular, it can be profoundly advantageous to forgo use of
the \lstinline!constexpr! function feature altogether, do the
precomputation externally to program, and embed the calculated result
--- along with a comment containing source text of the (e.g., Perl or
Python) script that performed the calculation --- into the C++ program
source itself.

\subsection[Annoyances]{Annoyances}\label{annoyances}

%%%%% JOSH: Pls address this when you do the code check. 
\subsubsection[TODO (VR): missing annoyance, linker error with ODR-use]{TODO (VR): missing annoyance, linker error with ODR-use}\label{todo-(vr):-missing-annoyance,-linker-error-with-odr-use}

TODO. We definitely need this one, it's when you have a static
\lstinline!constexpr! variable data member and then you get an unexpected
linker error due to ODR-use. See
https://\linebreak[4]
stackoverflow.com/questions/43193749/linker-error-for-constexpr-static-member-variable-in-gcc-and-clang.
Note that it was fixed in C++17, because static constexpr variables are
inline variables by default there.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection[No static \lstinline!constexpr! member variables defined in their own class]{No static {\SubsubsecCode constexpr} member variables defined in their own class}\label{no-static-constexpr-member-variables-defined-in-their-own-class}

When implementing a class using the singleton pattern, it may seem
desirable to have the single object of that type be a
\lstinline!constexpr!~\lstinline!private!~\lstinline!static! member of the class
itself, with guaranteed compile-time (data-race-free) initialization and
no direct accessibility outside the class. This does not work as easily
as planned because \lstinline!constexpr!~\lstinline!static! data members must
have a complete type and the class being defined is not complete until
its closing brace:

\begin{emcppslisting}[emcppsbatch=e4]
class S
{
    static const     S constVal;      // OK, initialized outside class below
    static constexpr S constexprVal;  // Error, (ù{\codeincomments{constexpr}}ù) must be initialized.
    static constexpr S constInit{};   // Error, (ù{\codeincomments{S}}ù) is not complete.
};

const S S::constVal{};  // OK, initialize static (ù{\codeincomments{const}}ù) member.
\end{emcppslisting}
    
\noindent The ``obvious'' workaround of applying a more traditional singleton
pattern, where the singleton object is a static local variable in a
function call, also fails (see \featureref{\locationa}{thread-safe-function-static-variables}) because \lstinline!constexpr! functions are not allowed to have
static variables (see \featureref{\locationc}{constexprfunc}):

\begin{emcppslisting}[emcppsbatch=e4,emcppsignore={Invalid function}]
constexpr const S& singleton()
{
   static constexpr S object{};  // Error, even in C++14, (ù{\codeincomments{static}}ù) is not allowed.
   return object;
}
\end{emcppslisting}
    
\noindent The only fully-featured solution available for \lstinline!constexpr!
objects of static storage duration is to put them outside of their type,
either at global scope, \lstinline!namespace! scope, or nested within a
befriended helper class{\cprotect\footnote{C++20 provides an alternate
partial solution with the \lstinline!constinit! keyword, allowing for
compile-time initialization of static data members, but that still
does not make such objects usable in a \emcppsgloss{constant expression}.}}:

\begin{emcppslisting}
class S
{
    friend struct T;
    S() = default;  // (ù{\codeincomments{private}}ù)
    // ...
};

struct T
{
    static constexpr S constexprS{};
};
\end{emcppslisting}
    

\subsection[See Also]{See Also}\label{see-also}

\begin{itemize}
\item{\seealsoref{constexprfunc}{\seealsolocationc}can be used to initialize a \lstinline!constexpr! variable.}
\item{\seealsoref{userdeflit}{\seealsolocationc}provide a convenient way of initializing a \lstinline!constexpr! variable of a UDT with a compile-time value.}
\end{itemize}

\subsection[Further Reading]{Further Reading}\label{further-reading}

TODO


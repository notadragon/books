\emcppsFeature{
        short={Aggregate Init '14},
        long={Aggregates Having Default Member Initializers},
}{aggregate-member-initialization-relaxation}

C++14 enables the use of \textbf{aggregate initialization} with classes
employing Default Member Initializers (see Section~\ref{Default-Member-Initializers}, ``\titleref{Default-Member-Initializers}").

\subsection[Description]{Description}\label{description}

Prior to C++14, classes that made use of \titleref{Default-Member-Initializers} --- i.e., initializers that appear directly within the
scope of the class --- were not considered \textbf{aggregate} types:

\begin{lstlisting}[language=C++]
struct S                // aggregate type in C++14 but not C++11
{
    int i;
    bool b = false;     // uses default member initializer
};

struct A                // aggregate type in C++11 and C++14
{
    int  i;
    bool b;             // does not use default member initializer
};
\end{lstlisting}

\noindent Because \texttt{A} (but not \texttt{S}) is considered an \textbf{aggregate} in
C++11, instances of \texttt{A} can be created via \textbf{aggregate
initialization} (whereas instances of \texttt{S} cannot):

\begin{lstlisting}[language=C++]
A a{100, true};  // OK in both C++11 and C++14
S s{100, true};  // error in C++11; OK in C++14
\end{lstlisting}


\noindent As of C++14, the requirements for a type to be categorized as an
\textbf{aggregate} are relaxed, allowing classes employing default
member initializers to be considered as such; hence both \texttt{A} and
\texttt{S} are considered \textbf{aggregates} in C++14 and eligible for
\textbf{aggregate initialization}:

\begin{lstlisting}[language=C++]
void f()
{
    S s0{100, true};        // OK in C++14 but not in C++11
    assert(s0.i == 100);    // set via explicit aggregate initialization (above)
    assert(s0.b == true);   // set via explicit aggregate initialization (above)

    S s1{456};              // OK in C++14 but not in C++11
    assert(s1.i == 456);    // set via explicit aggregate initialization (above)
    assert(s1.b == false);  // set via default member initializer
}
\end{lstlisting}

\noindent In the code snippet above, the C++14 aggregate \texttt{S} is initialized
in two ways: \texttt{s0} is created using aggregate initialization for
both data members; \texttt{s} is created using aggregate
initialization for only the first data member (and the second is set via its
default member \nobreak{initializer}).

\subsection[Use Cases]{Use Cases}\label{use-cases}

\subsubsection[Configuration \tt{struct}s]{Configuration {\SubsubsecCode struct}s}\label{configuration-structs}

\textbf{Aggregates} in conjunction with \titleref{Default-Member-Initializers} can be used to provide concise customizable
configuration \texttt{struct}s, packaged with typical default values. As
an example, consider a configuration \texttt{struct} for an HTTP request
handler:

\begin{lstlisting}[language=C++]
struct HTTPRequestHandlerConfig
{
    int maxQueuedRequests = 1024;
    int timeout           = 60;
    int minThreads        = 4;
    int maxThreads        = 8;
};
\end{lstlisting}

\noindent \textbf{Aggregate initialization} can be used when creating objects of
type \nobreak{\texttt{HTTPRequestHandlerConfig}} (above) to override one or more
of the defaults in definition order{\cprotect\footnote{In C++20, the
Designated Initializers feature adds flexibility (e.g., for
configuration \texttt{struct}s, such as
\texttt{HTTPRequestHandlerConfig}) by enabling explicit specification
of the names of the data members:

\begin{lstlisting}[language=C++, basicstyle={\ttfamily\footnotesize}]
HTTPRequestHandlerConfig lowTimeout{.timeout = 15};
    // (ù{\codeincomments{maxQueuedRequests}}ù), (ù{\codeincomments{minThreads}}ù), and (ù{\codeincomments{maxThreads}}ù) have their default value.

HTTPRequestHandlerConfig highPerformance{.timeout = 120, .maxThreads = 16};
    // (ù{\codeincomments{maxQueuedRequests}}ù) and (ù{\codeincomments{minThreads}}ù) have their default value.
\end{lstlisting}
      }}:

\begin{lstlisting}[language=C++]
HTTPRequestHandlerConfig getRequestHandlerConfig(bool inLowMemoryEnvironment)
{
    if (inLowMemoryEnvironment)
    {
        return HTTPRequestHandlerConfig{128};
            // (ù{\codeincomments{timeout}}ù), (ù{\codeincomments{minThreads}}ù), and (ù{\codeincomments{maxThreads}}ù) have their default value.
    }
    else
    {
        return HTTPRequestHandlerConfig{2048, 120};
            // (ù{\codeincomments{minThreads}}ù), and (ù{\codeincomments{maxThreads}}ù) have their default value.
    }
}

// ...
\end{lstlisting}


\subsection[Potential Pitfalls]{Potential Pitfalls}\label{potential-pitfalls}

None so far

\subsection[Annoyances]{Annoyances}\label{annoyances}

\subsubsection[Syntactical ambiguity in the presence of \textbf{brace elision}]{Syntactical ambiguity in the presence of \textbf{brace elision}}\label{syntactical-ambiguity-in-the-presence-of-brace-elision}

During the initialization of multilevel \textbf{aggregates}, braces
around the initialization of a nested aggregate can be omitted
(\textbf{brace elision}):

\begin{lstlisting}[language=C++]
struct S
{
    int arr[3];
};

S s0{{0, 1, 2}};  // OK, nested (ù{\codeincomments{arr}}ù) initialized explicitly
S s1{0, 1, 2};    // OK, brace elision for nested (ù{\codeincomments{arr}}ù)
\end{lstlisting}

\noindent The possibility of \textbf{brace elision} creates an interesting
syntactical ambiguity when used alongside \textbf{aggregates} with
\titleref{Default-Member-Initializers}. Consider a
\texttt{struct}~\texttt{X} containing three data members, one of which
has a default value:

\begin{lstlisting}[language=C++]
struct X
{
    int a;
    int b;
    int c = 0;
};
\end{lstlisting}

\noindent Now, consider various ways in which an array of elements of type
\texttt{X} can be initialized:

\begin{lstlisting}[language=C++]
X xs0[] = {{0, 1}, {2, 3}, {4, 5}};
    // OK, clearly 3 elements having the respective values:
    // (ù{\codeincomments{\{0, 1, 0\}}}ù), (ù{\codeincomments{\{2, 3, 0\}}}ù), (ù{\codeincomments{\{4, 5, 0\}}}ù)

X xs1[] = {{0, 1, 2}, {3, 4, 5}};
    // OK, clearly 2 elements with values:
    // (ù{\codeincomments{\{0, 1, 2\}}}ù), (ù{\codeincomments{\{3, 4, 5\}}}ù)

X xs2[] = {0, 1, 2, 3, 4, 5};
    // ...?
\end{lstlisting}

\noindent Upon seeing the definition of \texttt{xs2}, a programmer not versed in
the details of the C++ Language Standard might be unsure as to whether the
initializer of \texttt{xs2} is three elements (like \texttt{xs0}) or two
elements (like \texttt{xs1}). The Standard is, however, clear that the
compiler will interpret \texttt{xs2} the same as \texttt{xs1}, and,
thus, the default values of \texttt{X::c} for the two array elements
will be replaced with \texttt{2} and \texttt{5}, respectively.

\subsection[See Also]{See Also}\label{see-also}

\begin{itemize}
\item{Section~\ref{Default-Member-Initializers}, ``\titleref{Default-Member-Initializers}" — Conditionally safe C++11 feature that allows developers to provide a default initializer for a data member directly in the definition of a class}
\end{itemize}

\subsection[Further Reading]{Further Reading}\label{further-reading}

None so far


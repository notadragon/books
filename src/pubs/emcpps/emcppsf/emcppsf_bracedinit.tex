% 22 March 2021, cleaned up LaTeX, updated commands. 
% 23 March 2021, out to CE, Steven for tech review, external reviewers, and Josh for code check. 
% 23 March 2021 JMB, code checked except for last code snippet which i need to follow up on.


\emcppsFeature{
    short={Braced Init},
    long={Braced-Initialization Syntax: {\SecCode \{\}}},
    toclong={Braced-Initialization Syntax: \lstinline!\{\}!},
}{bracedinit}
\setcounter{table}{0}
\setcounter{footnote}{0}
\setcounter{lstlisting}{0}
%\section[Braced Init]{Brace-Initialization Syntax: {\SecCode \{\}}}\label{bracedinit}
%\subsection[Braced-Initialization Syntax: \tt{\{ \}}]{Braced-Initialization Syntax: {\SubsecCode \{ \}}}\label{braced-initialization-syntax:-{-}}

Braced initialization, a generalization of C++03 initialization syntax,
was designed with the intention designed to be used safely and uniformly
in any initialization context.

\subsection[Description]{Description}\label{description}

\emcppsgloss[list initialization]{List initialization}, originally dubbed \emcppsgloss{uniform initialization}, was conceived to enable a uniform syntax (having the
same meaning) to be used generically to initialize objects irrespective
of (1) the context in which the syntax is used or (2) the type of the
object being initialized. Braced-initialization syntax is the language
mechanism that --- in close collaboration with the C++ Standard
Library's \lstinline!std::initializer_list! template (see \featureref{\locationc}{initlist}) --- is used to implement
\emcppsgloss{list initialization} generally. As we will see, this design goal
was largely achieved albeit with some idiosyncrasies and rough edges.

\subsubsection[C++03 initialization syntax review]{C++03 initialization syntax review}\label{c++03-initialization-syntax-review}

Classic C++ affords several forms of initialization, each sporting its
own custom syntax, some of which is syntactically interchangeable yet
belying subtle differences. At the highest level, there are two dual
categories of initialization: (1) \emcppsgloss[copy direct]{copy/direct} (when you have
something from which to initialize) and (2) \emcppsgloss[default value]{default/value} (when
you don't).

The first dual category of syntactic/semantic initialization comprises
\emcppsgloss[copy initialization]{\emph{copy} initialization} and \emcppsgloss[direct initialization]{\emph{direct} initialization}. \emph{Direct} initialization is produced when
initializing an object with one or more arguments within parentheses,
such as initializing a data member or base class in a constructor's
initializer list, or in a \lstinline!new! expression. \emph{Copy}
initialization happens when initializing from a value without using
parentheses, such as passing an argument to a function, or returning a
value from a function. Both forms may be used to initialize a variable:

\begin{emcppslisting}
#include <cassert>  // standard C (ù{\codeincomments{assert}}ù) macro

void test()
{
    int i = 23;  // copy initialization
    int j(23);   // direct initialization

    assert(i == j);
}
\end{emcppslisting}
    
\noindent In both cases above, we are initializing the variable (\lstinline!i! or
\lstinline!j!) with the literal value \lstinline!23!.

For scalar types, there is no observable difference between these two
dual forms of initialization in C++03, but, for user-defined types,
there are. First \emcppsgloss[direct initialization]{\emph{direct} initialization} \emph{considers} (as
part of the overload set) all valid user-defined conversion sequences,
whereas \emcppsgloss[copy initialization]{\emph{copy} initialization} excludes explicit conversion:

\begin{emcppslisting}
struct S
{
    explicit S(int);       //     explicit value constructor (from (ù{\codeincomments{int}}ù))
             S(double);    // non-explicit value constructor (from (ù{\codeincomments{double}}ù))
             S(const S&);  // non-explicit copy  constructor
};

S s1(1);     // direct init of (ù{\codeincomments{s1}}ù): calls (ù{\codeincomments{S(int)}}ù)   ; copy constructor is not called
S s2(1.0);   // direct init of (ù{\codeincomments{s2}}ù): calls (ù{\codeincomments{S(double)}}ù);   "      "        "   "     "

S s3 = 1;    // copy init of (ù{\codeincomments{s3}}ù):   calls (ù{\codeincomments{S(double)}}ù); copy constructor may be called
S s4 = 1.0;  // copy init of (ù{\codeincomments{s4}}ù):   calls (ù{\codeincomments{S(double)}}ù);   "      "         "    "   "
\end{emcppslisting}
    
\noindent What's more, \emcppsgloss[copy initialization]{\emph{copy} initialization} is defined as if a
temporary object is constructed; the compiler is permitted to elide this
temporary and, in practice, typically does. Note, however, that
\emcppsgloss[copy initialization]{\emph{copy} initialization} is not permitted unless there is an
accessible \emph{copy} (or \emph{move}{\cprotect\footnote{If the
\emph{move} constructor for a user-defined type is declared and not
accessible, copy initialization is ill formed; see \featureref{\locationc}{Rvalue-References} and \featureref{\locationa}{deleted-functions}.}}) constructor,
even if the temporary would have been elided.{\cprotect\footnote{In
C++17, direct materialization replaces \emcppsgloss[copy initialization]{\emph{copy} initialization} in some contexts, thereby obviating the temporary
object construction and also the need for an accessible \emph{copy} or
  \emph{move} constructor.}} Note that function arguments and return
values are initialized using \emcppsgloss[copy initialization]{\emph{copy} initialization}.

Reference types are also initialized by copy and direct initialization,
binding the declared reference to an object (or function). For a
reference to a non\lstinline!const! qualified type, the referenced type
must match exactly. However, if binding a reference to a \lstinline!const!
qualified type, the compiler may copy initialize a temporary object of
the target type of the reference and bind the reference to that
temporary; in such cases, the lifetime of the temporary object is
extended to the end of the lifetime of the reference.

\begin{emcppslisting}
void ref_inits()
{
    int i = 0;          // OK, copy initialization of (ù{\codeincomments{int}}ù)
    int& x(i);          // OK, direct initialization of reference
    const long& y = x;  // OK, (ù{\codeincomments{y}}ù) binds to a temporary and extends lifetime
    long& z = x;        // Error, incompatible types
}
\end{emcppslisting}
    

\noindent The second dual category of syntactic/semantic initialization comprises
\emcppsgloss[default initialization]{\emph{default} initialization} and \emcppsgloss[value initialization]{\emph{value} initialization}. Both default and value initialization pertain to
situations in which \emph{no} argument is supplied, and are
distinguished by the presence or absence of parentheses, where the
absence of parentheses indicates default initialization and the presence
indicates value initialization. Note that in simple contexts such as
declaring a variable, empty parentheses may also indicate a function
declaration instead (see \intraref{use-cases-bracedinit}{avoiding-the-most-vexing-parse}):

\begin{emcppslisting}
int i;          // default initialization
int j();        // Oops, function declaration
int k = int();  // value initialization

int *pd = new int;    // default initialization of dynamic (ù{\codeincomments{int}}ù) object
int *pv = new int();  // value        "         "     "      "    "
\end{emcppslisting}
    

\noindent For \emcppsgloss[scalar type]{scalar types}, \emph{default} initialization does not
actually initialize an object, and \emph{value} initialization will
initialize that object as if by the literal \lstinline!0!. Note that the
representation of this value is not necessarily all zero bits, as some
platforms use distinct trap values for the null pointer value for
pointers and for pointer-to-member objects.

For class types with an accessible \emcppsgloss[user provided]{user-provided} default
constructor, default initialization and value initialization behave
identically, calling the default constructor. If there is no accessible
default constructor, both forms produce a compilation error. For objects
of class types with an implicitly defined default constructor, each base
and member subobject will be default initialized or value initialized
according to the form of initialization indicated for the complete
object; if any of those initializations produces an error, then the
program is ill formed. Note that for a union with an implicitly defined
default constructor, the first member of the union will be value
initialized as the active member of that union when a union object is
value initialized.

\begin{emcppslisting}[emcppsbatch=e1]
struct B
{
    int i;
    B() : i() { }  // user-provided default constructor
};

struct C
{
    int i;
    C() { }  // user-provided default constructor
};

struct D : B { int j; };  // derived class with no user-provided constructors

int *pdi = new int;    // default initialization of dynamic (ù{\codeincomments{int}}ù) object, (ù{\codeincomments{*pdi}}ù) is uninitialized
int *pvi = new int();  // value   initialization of dynamic (ù{\codeincomments{int}}ù) object, (ù{\codeincomments{*pvi}}ù) is 0
B *pdb = new B;        // default initialization of dynamic (ù{\codeincomments{B}}ù) object, (ù{\codeincomments{b::i}}ù) is 0
B *pvb = new B();      // value   initialization of dynamic (ù{\codeincomments{B}}ù) object, (ù{\codeincomments{b::i}}ù) is 0
C *pda = new C;        // default initialization of dynamic (ù{\codeincomments{C}}ù) object, (ù{\codeincomments{a::i}}ù) is uninitialized
C *pva = new C();      // value   initialization of dynamic (ù{\codeincomments{C}}ù) object, (ù{\codeincomments{a::i}}ù) is uninitialized
D *pdc = new D;        // default initialization of dynamic (ù{\codeincomments{D}}ù) object, (ù{\codeincomments{c::j}}ù) is uninitialized
D *pvc = new D();      // value   initialization of dynamic (ù{\codeincomments{D}}ù) object, (ù{\codeincomments{c::j}}ù) is 0
\end{emcppslisting}
    

\noindent In the case of an object of type \lstinline!B!, both default and value
initialization will invoke the user-provided default constructor, which
initializes the subobject \lstinline!i! to \lstinline!0!. In the case of an
object of type \lstinline!C!, both default and value initialization will
invoke the user-provided default constructor, which does not initialize
the subobject \lstinline!i!. In the case of an object of type \lstinline!D!,
which has an implicitly defined default constructor, the initialization
of the subobject \lstinline!j! depends on whether the \lstinline!D! object is
initialized by default initialization or by value initialization.

Any attempt to read the value of an \emph{uninitialized} object will
result in \emcppsgloss{undefined behavior}. It is a diagnosable error to
default initialize a constant object that does not execute a
user-provided constructor to initialize each base and member. Note that
the top level object, like \lstinline!D! above, need not have a
user-provided constructor as long as all of its bases and members can
recursively apply this rule.

\begin{emcppslisting}[emcppsbatch=e1]
struct D2 : B { B j; };  // derived class with no user-provided constructors

const D  w;         // Error, (ù{\codeincomments{w.j}}ù) is not initialized.
const D  x = D();   // OK, (ù{\codeincomments{x}}ù) is value initialized.
const D2 y;         // OK, (ù{\codeincomments{y}}ù) is default initialized; sub-objects invoke default ctor.
const D2 z = D2();  // OK, (ù{\codeincomments{z}}ù) is value initialized.
\end{emcppslisting}
    

\noindent Objects of static storage duration at file, namespace, or function scope
(see \featureref{\locationa}{thread-safe-function-static-variables}) are
\emcppsgloss[zero initialized]{\emph{zero} initialized} before any other initialization takes
place. Note that \emcppsgloss[default initialized]{\emph{default} initialized} static storage
duration pointer objects are \emcppsgloss[zero initialized]{\emph{zero} initialized} to have a
\emph{null} address value (see \featureref{\locationa}{null-pointer-literal-(nullptr)}), even if that
representation on the host platform is not numerically zero:

\begin{emcppslisting}
struct A
{
    int i;
};

struct B
{
    int i;
    B() : i(42) { }
};

A globalA;
    // Zero initialization also zero initializes (ù{\codeincomments{globalA::i}}ù).
    // Default initialization provides no further initializations.

B globalB;
    // zero initialization initializes globalB.i.
    // After that, default constructor is invoked.

int globalI;
    // Zero initialization initializes globalI.
\end{emcppslisting}
    

\noindent Note the implication that default initialization for a static storage
duration object will always initialize an object ready for use, either
calling the default constructor of a type with a user-provided default
constructor or zero-initializing scalars. 

\begin{table}[h!]
\begin{center}
\begin{threeparttable}
\caption{Helpful summary of C++03 rules}\label{table-bracedinit-cpp3rules} \vspace{1.5ex}
{\small \begin{tabular}{c|c|c}\thickhline
\rowcolor[gray]{.9}    {\sffamily\bfseries Initialization Type} & {\sffamily\bfseries No Arguments} & {\sffamily\bfseries >= 1 Arguments}\\\hline
\emcppsgloss[with parentheses]{With Parentheses} & \emph{value} & \emph{direct} \\ 
 & \lstinline!int!~\lstinline!i!~\lstinline!=!~\lstinline!int();! & \lstinline!int!~\lstinline!i(23);! \\ \hline
\emcppsgloss[without parentheses]{Without Parentheses} & \emph{default} & \emph{copy} \\  
&  \lstinline!int!~\lstinline!i;! & \lstinline!int!~\lstinline!i!~\lstinline!=!~\lstinline!23;! \\ \thickhline
\end{tabular}
}
\end{threeparttable}
    \end{center}
\end{table}


\subsubsection[C++03 aggregate initialization]{C++03 aggregate initialization}\label{c++03-aggregate-initialization}

Aggregates are a special kind of object in C++03 that generally do not
use constructors but follow a different set of rules for initialization,
typically denoted by braces. There are two varieties of aggregates: (1)
arrays and (2) user-defined class types that have no nonpublic data
members that are not static, no base classes, no user-declared
constructors, and no virtual functions. Aggregates are very similar to a
classic C \lstinline!struct!, potentially with additional,
non-\lstinline!virtual! member functions. Note that members of an aggregate
are not themselves required to be an aggregate.

\begin{emcppslisting}[emcppsbatch=e2]
#include <string>  // (ù{\codeincomments{std::string}}ù)

int a[5];           // Arrays are aggregates.

struct A
{
    int         i;  // public data member
    std::string s;  // (ù{\codeincomments{A}}ù) is an aggregate even though (ù{\codeincomments{std::string}}ù) is not.

private:
    static int j;   // Private data member is static.
    void f();       // Member functions are OK, even if private.
};
\end{emcppslisting}
    

\noindent A quick note on terminology: Strictly speaking, arrays comprise
\emph{elements} and classes comprise \emph{members}, but for ease of
exposition in this text, we refer to both as \emph{members}.

When an aggregate is copied by either direct or copy initialization,
rather than calling the copy constructors, the corresponding members
(elements for an array) of each aggregate are copied using direct
initialization, which corresponds to the behavior of an implicitly
defined copy constructor for a class. Note that this process may be
applied recursively, if members are aggregates themselves. Further note
that in most cases, arrays do not copy because the argument supplied to
the copy operation will undergo \emcppsgloss[array to pointer decay]{array-to-pointer decay} and so
will no longer be an appropriate type to initialize from. However,
arrays as data members of classes follow the rules for aggregate
initialization and so will copy array data members. This array-copy
behavior is one of the motivations for the addition of the
\lstinline!std::array! template in C++11.

When an aggregate is \emph{default} initialized, each of its
members/elements is \emph{default} initialized. When an aggregate is
\emph{value} initialized, each of its members/elements is \emph{value}
initialized. This follows the usual rules for an implicitly defined
constructor for a class type and defines the corresponding behavior for
array initialization.

\begin{emcppslisting}
int n = 17;
int *pid = new int[n];   // default initialization of dynamic array object and its elements
int *piv = new int[n](); // value        "         "     "      "     "     "   "     "

struct A { /*...*/ };
A *pd = new A;           // default initialization of dynamic (ù{\codeincomments{A}}ù) object and its members
A *pv = new A();         // value        "         "     "     "    "     "   "     "
\end{emcppslisting}
    

\noindent Otherwise, an aggregate must be \emph{aggregate} initialized by a braced
list in the form\linebreak[4] 
\lstinline!=!~\lstinline!{!~\lstinline!list-of-values!~\lstinline!};!, where members
of the aggregate will be initialized by \emph{copy} initialization from
the corresponding value in the list of values; if the aggregate has more
members than are provided by the list, the remaining members are
\emph{value} initialized; it is an error to provide more values in the
list than there are members in the aggregate. Note that, because a union
has only one active member, a union will be initialized by no more than
a single value from the list; this becomes relevant for unions as data
members of an aggregate initialized by \emph{brace elision}:

\begin{emcppslisting}
union U
{
    int i;
    const char* s;
};

U x = {    };  // OK, value initializes (ù{\codeincomments{x.i}}ù) = 0
U y = { 1  };  // OK, initializes (ù{\codeincomments{x.i}}ù) = 1
U z = { "" };  // Error, cannot aggregate initialize (ù{\codeincomments{z.s}}ù)
\end{emcppslisting}
    

\noindent Let's review the various ways in which we might attempt to initialize an
object of aggregate type \lstinline!A! in the body of a function,
\lstinline!test!, i.e., defined at function scope:

\begin{emcppslisting}
struct A2 { int i; };  // aggregate with a single data member

void test()
{
           A2  a1;             // default init: (ù{\codeincomments{i}}ù) is not initialized!
    const  A2& a2 = A2();      // value init followed by copy init: (ù{\codeincomments{i}}ù) is 0.
           A2  a3 = A2();      // value init followed by copy init: (ù{\codeincomments{i}}ù) is 0.
           A2  a4();           // Oops, function declaration!
           A2  a5 = { 5 };     // aggregate initialization employing copy init
           A2  a6 = { };       //    "            "            "     value  "
           A2  a7 = { 5, 6 };  // Error, too many initializers for aggregate (ù{\codeincomments{A2}}ù)
    static A2  a8;             // default init after (ù{\codeincomments{i}}ù) is zero initialized.
}
\end{emcppslisting}
    

\noindent In the sample code above:
\begin{itemize}
\item{\lstinline!a1!: \lstinline!a1! is \emcppsgloss[default initialized]{\emph{default} initialized}, which means that each data member within the aggregate is itself independently \emcppsgloss[default initialized]{\emph{default} initialized}. For scalar types, such as an \lstinline!int!, the effect of default initialization at function scope is a no-op — i.e., \lstinline!a1.i! is not initialized. Any attempt to access the contents of \lstinline!a1.i! will result in \emcppsgloss{undefined behavior}.}
\item{\lstinline!a2! and \lstinline!a3!: In the cases of both \lstinline!a2! and \lstinline!a3!, a temporary of type \lstinline!A! is first \emcppsgloss[value initialized]{\emph{value} initialized} and then that temporary is used to \emcppsgloss[copy initialized]{\emph{copy} initialize} the named variable: Both \lstinline!a2.i! and \lstinline!a3.i! are initialized to the value \lstinline!0!.}
\item{\lstinline!a4!: Notice that we are not able to create a \emcppsgloss[value initialized]{\emph{value} initialized} local variable \lstinline!a4! by applying parentheses since that would interpreted as declaring a function taking no arguments and returning an object of type \lstinline!A! by value; see \intraref{use-cases-bracedinit}{} [\textbf{AUs: there is no section with this name ``Avoiding accidentally declaring a function taking no arguments"}] 
and \intraref{use-cases-bracedinit}{avoiding-the-most-vexing-parse}.}
\item{\lstinline!a5!, \lstinline!a6!, and \lstinline!a7!: C++03 supports \emcppsgloss{aggregate initialization} using braced syntax as illustrated by \lstinline!a5!, \lstinline!a6!, and \lstinline!a7! in the code snippet above. The local variable \lstinline!a5! is \emcppsgloss[copy initialization]{\emph{copy} initialized} such that \lstinline!a5.i! has the \emph{user supplied} value \lstinline!5! whereas \lstinline!a6! is \emcppsgloss[value initialized]{\emph{value} initialized} since there are no supplied initializers; hence, \lstinline!a6.i! is initialized to 0. Attempting to pass \lstinline!a7! two values to initialize a single data member results in a compile-time error. Note that had class \lstinline!A! held a second data member, the line initializing \lstinline!a5! would have resulted in \emcppsgloss[copy initialization]{\emph{copy} initialization} of the first and \emcppsgloss[value initialized]{\emph{value} initialization} of the second.}
\item{\lstinline!a8! has static storage duration therefore it is first \emph{zero} initialized (\lstinline!a8.i! is 0) then it is \emph{default} initialized, which is a no-op for the same reasons that \lstinline!a1! is not initialized at all.}
\end{itemize}

Finally, note that a scalar can be thought of as though it were an array
of a single element (though note that scalars never suffer
\emph{array-to-pointer decay}); in fact, if we were to take the address
of any scalar and add \lstinline!1! to it, the new pointer value would
represent the one-past-the-end iterator for that scalar's implied array
(of length \lstinline!1!). Similarly, scalars can be initialized using
aggregate initialization, just as if they were single-element arrays,
where the braced list for a scalar may contain zero or one elements.

\begin{emcppslisting}
int    i = { };       // OK, (ù{\codeincomments{i}}ù) is 0.
int    j = { 1 };     // OK, (ù{\codeincomments{i}}ù) is 1.
double k = { 3.14 };  // OK, (ù{\codeincomments{k}}ù) is 3.14.
\end{emcppslisting}
    

\subsubsection[Braced initialization in C++11]{Braced initialization in C++11}\label{braced-initialization-in-c++11}

Everything we've discussed so far, including braced initialization of
aggregates, is well defined in C++03. This same braced initialization
syntax --- modified slightly so as to preclude narrowing conversions
(see the next section) --- is extended in C++11 to work consistently and
uniformly in many new situations. This enhanced braced initialization
syntax is designed to better support the two dual initialization
categories discussed in \textbf{C++03 initialization syntax review}%%%%%%
 above
as well as entirely new capabilities including language-level support
for lists of initial values implemented using the C++ Standard Library's
\lstinline!std::initializer_list! class template. As the opportunity arose
by touching the rules for initialization, a few more potential errors,
such as narrowing conversions, become diagnosable by the compiler when
using braced initialization syntax.

\subsubsection[C++11 restrictions on narrowing conversions]{C++11 restrictions on narrowing conversions}\label{c++11-restrictions-on-narrowing-conversions}

\emcppsgloss[narrowing conversion]{Narrowing conversions} (a.k.a. \emcppsgloss[lossy conversion]{lossy conversions}) are a
notorious source of runtime errors. One of the important properties of
list initializations implemented using the C++11 braced-initialization
syntax is that error-prone narrowing conversions are no longer
permitted. Consider, for example, an \lstinline!int! array, \lstinline!a!,
initialized with various built-in (compile-time constant) \emph{literal}
values:

\begin{emcppslisting}[emcppserrorlines={4,5,6}]
int ai[] =  //      C++03    C++11
{
    5,      // (0)   OK       OK
    5.0,    // (1)   OK      Error, (ù{\codeincomments{double}}ù) to (ù{\codeincomments{int}}ù) conversion is not permitted.
    5.5,    // (2)   OK      Error, (ù{\codeincomments{double}}ù) to (ù{\codeincomments{int}}ù) conversion is not permitted.
    "5",    // (3)  Error    Error, no (ù{\codeincomments{const char*}}ù) to (ù{\codeincomments{int}}ù) conversion exists.
};
\end{emcppslisting}
    

\noindent In C++03, floating-point literals would be coerced to fit within an
integer even if the conversion was known to be lossy --- e.g., element
(2) in the code snippet above. By contrast, C++11 disallows \emph{any}
such implicit conversions in braced initializations even when the
conversion is known \emph{not} to be lossy --- e.g., element
\lstinline!ai[1]! above.

\emcppsgloss[narrowing conversion]{Narrowing conversions} within the integral and floating-point
type families, respectively, are generally disallowed except where it
can be verified at compile-time that overflow does not occur and, in the
case of integers and (classic) \lstinline!enum!s , the initializer value
can be represented exactly{\cprotect\footnote{As of C++20, implicit
conversion from either a pointer or pointer-to-member type to
  \lstinline!bool! is generally supported in braced initializations.}}:

\begin{emcppslisting}[emcppserrorlines={6,8,11}]
const unsigned long ulc = 1;  // compile-time integral constant: (ù{\codeincomments{1UL}}ù)

short as[] =  //       C++03     C++11                        Stored Value
{
     32767,   // (0)     OK        OK                        (ù{\codeincomments{as[0] == 32767}}ù)
     32768,   // (1)     OK      Error, overflow
    -32768,   // (2)     OK        OK                        (ù{\codeincomments{as[2] == -32768}}ù)
    -32769,   // (3)   Warning?  Error, underflow
    1UL,      // (4)     OK        OK                        (ù{\codeincomments{as[4] == 1}}ù)
    ulc,      // (5)     OK        OK                        (ù{\codeincomments{as[5] == 1}}ù)
    1.0       // (6)     OK      Error, narrowing
};
\end{emcppslisting}
    

\noindent Notice that both \emph{overflow} (1) and \emph{underflow} (3) are
rejected for integral values in C++11, whereas neither is ill formed in
C++03. An integral literal (4) (or an \emcppsgloss{integral constant} (5)) of
a wider type (e.g., \lstinline!unsigned!~\lstinline!long!) can be used to
initialize a smaller one (e.g., \lstinline!signed!~\lstinline!short!) provided
that the value can be represented exactly; however, even a floating
point literal that can be \emph{represented exactly} (6) is nonetheless
rejected in C++11 when used to initialize any integral scalar.

Floating-point initializers, on the other hand, need not be represented
precisely so long as overflow does not occur; if, however, what is being
initialized is a floating-point scalar and the initializer is integral,
then the value must be represented exactly:

\begin{emcppslisting}[emcppserrorlines={5,10}]
float af[] =     //       C++03   C++11                  Stored Value
{
     3L,        // (0)     OK     OK                   (ù{\codeincomments{af[0] == 3}}ù)
     16777216,  // (1)     OK     OK                   (ù{\codeincomments{af[1] == 1<<24}}ù)
     16777217,  // (2)     OK     Error, lossy
     0.75,      // (3)     OK     OK                   (ù{\codeincomments{af[1] == 0.75}}ù)
     2.4,       // (4)     OK     OK, but lossy        (ù{\codeincomments{af[2] != 2.4}}ù)
     0.4,       // (5)     OK     OK, but lossy        (ù{\codeincomments{af[3] != 0.4}}ù)
     1e-39,     // (6)     OK     OK, but underflow    (ù{\codeincomments{af[4] != 1e-39}}ù)
     1e+39,     // (7)     OK     Error, overflow
};
\end{emcppslisting}
    

\noindent In the example above elements (0) -- (2) represent initialization from
an integral type (\lstinline!int!), which requires that the initialized
value be represented exactly. Elements (3) -- (7) are instead
initialized from a floating-point type (\lstinline!double!) and therefore
are restricted only from overflow.

When an initializer is \emph{not} a \emcppsgloss{constant expression}, braced
initialization precludes any possibility of such \emph{narrowing}
initializations at run time --- e.g., initializing a \lstinline!float! with
a double or a \lstinline!long!~\lstinline!double!, a \lstinline!double! with a
\lstinline!long!~\lstinline!double!, or \emph{any} floating-point type with an
integral one. By the same token, an integral type (e.g., \lstinline!int!)
is not permitted to be initialized by non-\emcppsgloss{constant expression}
integer value of any other potentially larger integral type (e.g.,
\lstinline!long!) --- even if the number of bits in the representation for
the two types on the current platform is the same. Finally,
non-\emcppsgloss{constant expression} of integral type (e.g., \lstinline!short!)
cannot be used to initialize an unsigned version of the same type (e.g.,
\lstinline!unsigned!~\lstinline!short!) and vice versa.

To illustrate the constraints imposed on
non-\emcppsgloss[constant expression]{constant-expressions} described above, consider a simple
aggregate class, \lstinline!S!, comprising an \lstinline!int!, \lstinline!i!, and
a \lstinline!double!, \lstinline!d!:

\begin{emcppslisting}[emcppsbatch=e3]
struct S  // aggregated class
{
    int    i;  // *integral* scalar type
    double j;  // *floating-point* scalar type
};
\end{emcppslisting}
    

\noindent A function, \lstinline!test!, declaring a variety of arithmetic parameter
types illustrates restrictions imposed by C++11 braced initialization on
narrowing initializations that were well formed in C++03:

\begin{emcppslisting}[emcppsbatch=e3,emcppserrorlines={5,6,7,8}]
void test(short s, int i, long j, unsigned u, float f, double d, long double e)
{                     //     C++03  C++11
    S s0 = { i, d };  // (0)  OK     OK
    S s1 = { s, f };  // (1)  OK     OK
    S s2 = { u, d };  // (2)  OK    Error, (ù{\codeincomments{u}}ù) causes narrowing.
    S s3 = { i, e };  // (3)  OK    Error, (ù{\codeincomments{e}}ù) causes narrowing.
    S s4 = { f, d };  // (4)  OK    Error, (ù{\codeincomments{f}}ù) causes narrowing.
    S s5 = { i, s };  // (5)  OK    Error, (ù{\codeincomments{s}}ù) causes narrowing (theoretically).
};
\end{emcppslisting}
    

\noindent In the \lstinline!test! function above, lines (0) and (1) are OK because
there is no possibility of narrowing on any conforming platform unlike
lines (2) through (5) --- despite the fact that, in practice, it is more
than likely that a \lstinline!double! will be able to represent exactly
every value representable by a \lstinline!short!~\lstinline!int!. Note that,
just as with the array example above, when the initializing value is a
\emcppsgloss{constant expression}, it is sufficient that that value be
representable exactly in the target type and produce the original value
when converted back.

\subsubsection[C++11 Aggregate initialization]{C++11 Aggregate initialization}\label{c++11-aggregate-initialization}

Aggregate initialization in C++11, including initialization of arrays,
is subject to the rules prohibiting narrowing conversions.

\begin{emcppslisting}
int  i   = { 1 };        // OK
long j   = { 2 };        // OK

int  a[] = { 0, 1, 2 };  // OK
int  b[] = { 0, i, j };  // Error, cannot narrow (ù{\codeincomments{j}}ù) from (ù{\codeincomments{long}}ù) to (ù{\codeincomments{int}}ù)

struct S { int a; };
S s1 = { 0  };  // OK
S s2 = { i  };  // OK
S s3 = { 0L };  // OK, (ù{\codeincomments{0L}}ù) is an integer constant expression.
S s4 = { j  };  // Error, narrowing
\end{emcppslisting}
    

\noindent In addition, the rules for \emcppsgloss{value initialization} now state that
members without a specific initializer value in the braced list are
``as-if'' \emcppsgloss{copy initialized} from \lstinline!{}!
{\cprotect\footnote{From C++ 14 onwards, if the member doesn't have an
initializer value, but has a default member initializer, it is
initialized from the default member initializer (see \featureref{\locationc}{aggregate-member-initialization-relaxation}).}}. This will result in an error when
initializing a member that has an \lstinline!explicit! default constructor
according to the new \emcppsgloss[copy list initialization]{copy \emph{list} initialization} rules in
the next section, which give a meaning for explicit constructors. Note
that if the member is of reference type and no initializer is provided,
the initialization is ill formed.

Regardless of whether the aggregate itself is initialized using a copy
initialization or direct initialization, the members of the aggregate
will be copy initialized from the corresponding initializer.

\begin{emcppslisting}[emcppsbatch=e4,emcppserrorlines={13,14,15}]
struct E { };                         // empty type
struct AE { int x; E y; E z; };       // aggregate comprising several empty objects
struct S { explicit S(int = 0) {} };  // class with (ù{\codeincomments{explicit}}ù) default constructor
struct AS{ int x; S y; S z; };        // aggregate comprising several (ù{\codeincomments{S}}ù) objects

AE aed;                    // OK
AE ae0 = {};               // OK
AE ae1 = { 0 };            // OK
AE ae2 = { 0, {} };        // OK
AE ae3 = { 0, {}, {} };    // OK

AS asd;                    // OK
AS as0 = {};               // OK in 03; Error in 11 calling explicit ctor for (ù{\codeincomments{S}}ù)
AS as1 = { 0 };            // OK in 03; Error in 11 calling explicit ctor for (ù{\codeincomments{S}}ù)
AS as2 = { 0, S() };       // OK in 03; Error in 11 calling explicit ctor for (ù{\codeincomments{S}}ù)
AS as3 = { 0, S(), S() };  // OK, all aggregate members have an initializer.
\end{emcppslisting}
    

\noindent To better support generalizing the syntax of brace initialization in a
style similar to aggregate initialization, an aggregate can make a copy
of itself through \emph{aggregate} initialization in C++11 as well as
through \emph{direct} initialization per C++03:

\begin{emcppslisting}[emcppsbatch=e4]
S x{};      // OK, value initialization
S y = {x};  // OK in C++11; copy initialization via aggregate initialization syntax
\end{emcppslisting}
    

\noindent Otherwise, initialization of aggregates in C++11 is exactly the same
where it would have a meaning in C++03 and is correspondingly extended
into new places where braced initialization is permitted, as documented
in the following subsections.

\subsubsection[Copy list initialization]{Copy list initialization}\label{copy-list-initialization}

For C++03, only aggregates and scalars could be initialized via
braced-initialization syntax:

\begin{emcppshiddenlisting}[emcppsbatch=e5]
struct Type {};
\end{emcppshiddenlisting}
\begin{emcppslisting}[emcppsbatch=e5]
Type var = { /*...*/ };  // C++03-style aggregate (only) initialization
\end{emcppslisting}
    

\noindent The first part of generalizing braced initialization syntax for C++11 is
to allow the same syntactic form used to initialize aggregates to be
used for \emph{all} user-defined types. This extended form of braced
initialization --- known as \emcppsgloss[copy list initialization]{copy \emph{list} initialization} ---
follows the rules of \emcppsgloss{copy initialization}:

\begin{emcppshiddenlisting}[emcppsbatch=e6]
struct Class { Class(int i); };
int val;
\end{emcppshiddenlisting}
\begin{emcppslisting}[emcppsbatch=e6]
Class var1 = val;      // (C++03) copy initialization
Class var2 = { val };  // (C++11) copy list initialization
\end{emcppslisting}
    

\noindent For a non-aggregate class type, C++11 allows the use of a braced list
provided that its sequence of values serves as a suitable argument to a
non-\lstinline!explicit! constructor of the class being initialized.
Importantly, this use of \emcppsgloss[copy list initialization]{\emph{copy} list initialization}
provides meaning to \lstinline!explicit! constructors when taking other
than a single argument. For example, consider a
\lstinline!struct!~\lstinline!S! having constructors with 0-3 parameters, only
that last of which is \lstinline!explicit!:

\begin{emcppslisting}[emcppsbatch=e7]
struct S
{
             S();                          // default cor
             S(int);                       // 1-value ctor
             S(int, const char*);          // 2-value ctor
    explicit S(int, const char*, double);  // 3-value ctor
};
\end{emcppslisting}
    

\noindent We can use \emcppsgloss[copy list initialization]{\emph{copy} list initialization} only if the selected
constructor is \emph{not} declared to be \lstinline!explicit!, e.g.,
\lstinline!s0!, \lstinline!s1!, and \lstinline!s2! but not \lstinline!s3!:

\begin{emcppslisting}[emcppsbatch=e7]
S s0 = { };                 // OK, copy list initialization
S s1 = { 1 };               // OK, copy list initialization
S s2 = { 1, "two" };        // OK, copy list initialization
S s3 = { 1, "two", 3.14 };  // Error, constructor is explicit
\end{emcppslisting}
    

\noindent Had we instead declared our default constructor or any of the others to
be \lstinline!explicit!, the corresponding \emph{copy} (or
\emph{copy}-\emph{list}) initialization above would have failed too.

Another important difference between C++11 \emcppsgloss[copy list initialization]{copy \emph{list} initialization} and C++03 \emcppsgloss{copy initialization} is that the
braced-list syntax considers all constructors, including those that are
declared to be \lstinline!explicit!. Consider a \lstinline!struct!~\lstinline!X!
having two overloaded single-argument constructors, i.e., (1) one taking
an \lstinline!int! and (2) the other a member template taking a single
(deduced) type, \lstinline!T!, by value:

\begin{emcppslisting}[emcppsbatch=e8]
struct Q  // class containing both (ù{\codeincomments{explicit}}ù) and implicit constructor overloads
{
    explicit Q(int);          // (1) value constructor taking a (ù{\codeincomments{int}}ù)
    template <class T> Q(T);  // (2) value constructor taking a (ù{\codeincomments{T}}ù)
};
\end{emcppslisting}
    

\noindent Employing \emcppsgloss[direct initialization]{\emph{direct} initialization} (e.g., \lstinline!x0! in
the code snippet below) selects the most appropriate constructor,
regardless of whether it is declared to be \lstinline!explicit!, and
successfully uses that one; employing \emcppsgloss[copy initialization]{\emph{copy} initialization} (e.g., \lstinline!x1!) drops explicit constructors from the
overload set before determining a best match; and employing \emcppsgloss[copy list initialization]{copy \emph{list} initialization} (e.g., \lstinline!x2!) again includes all
constructors in the overloads set but is \emcppsgloss{ill formed} if the
selected constructor is \lstinline!explicit!:

\begin{emcppslisting}[emcppsbatch=e8]
Q x0(0);     // OK, direct initialization calls (ù{\codeincomments{Q(int)}}ù).
Q x1 = 1;    // OK, copy initialization calls (ù{\codeincomments{Q(T)}}ù).
Q x2 = {2};  // Error, copy list initialization selects but cannot call (ù{\codeincomments{Q(int)}}ù).
Q x3{3};     // Same idea as (ù{\codeincomments{x0}}ù); direct list initialization calls (ù{\codeincomments{Q(int)}}ù).
\end{emcppslisting}
    

\noindent In other words, the presence of the \lstinline!=! coupled with the braced
notation (e.g., \lstinline!x2! in the code example above) forces the
compiler to choose the constructor \emph{as if} it were direct
initialization (e.g., \lstinline!x0!) but then forces a compilation failure
if the selected constructor turns out to be \lstinline!explicit!. This
``consider-but-fail-if-selected'' behavior of \emcppsgloss{copy list initialization} is analogous to that of functions declared using
\lstinline!=!~\lstinline!delete!; see \featureref{\locationa}{deleted-functions}. Using
braces but omitting the \lstinline!=! (e.g., \lstinline!x3!) puts us back in
the realm of \emph{direct} rather than \emph{copy} initialization; see
\intrarefsimple{direct-list-initialization}.

When initializing references, \emcppsgloss{copy list initialization} (braced
syntax) behaves similarly to \emcppsgloss{copy initialization} (no braces)
with respect to the generation of temporaries. For example, when using a
braced list to initialize an \romeovalue{lvalue} reference --- e.g.,
\lstinline!int&!~\lstinline!ri! or \lstinline!const!~\lstinline!int&!~\lstinline!cri!
in the code example below --- to a scalar of a type that exactly matches
it (e.g., \lstinline!int!~\lstinline!i!), no temporary is created (just as it
would not have been without the braces); otherwise, a temporary will be
created, provided that a viable conversion exists and is not narrowing:

\begin{emcppshiddenlisting}[emcppsbatch=e9]
#include <cassert>  // standard C (ù{\codeincomments{assert}}ù) macro
\end{emcppshiddenlisting}
\begin{emcppslisting}[emcppsbatch=e9]
void test()
{
    int  i = 2;               assert(i   == 2);
    int& ri = { i };          assert(ri  == 2);  // OK, no temporary created
    ri = 3;                   assert(i   == 3);  // original is affected

    const int& cri = { i };   assert(cri == 3);  // OK, no temporary created
    ri = 4;                   assert(cri == 4);  // other reference is affected

    short s = 5;              assert(s   == 5);
    const int& crs = { s };   assert(crs == 5);  // OK, temporary is created
    s = 6;                    assert(crs == 5);  // note temporary is unchanged

    long j = 7;               assert(j   == 7);
    const int& crj = { j };   // Error, narrowing conversion from (ù{\codeincomments{long}}ù) to (ù{\codeincomments{int}}ù)
}
\end{emcppslisting}
    

\noindent As evidenced by the C-style asserts above, no temporary is created when
initializing either \lstinline!ri! or \lstinline!cri! since modifying the
reference affects the underlying variable, and vice versa. The C++ type
of \lstinline!crs!, on the other hand, does \emph{not} match exactly that
of the type to which it is bound, a temporary \emph{is} created and
hence changing the underlying object does \emph{not} affect its
referenced value. Lastly, unlike \lstinline!s! (of type \lstinline!short!),
attempting to initialize a \lstinline!const! \romeovalue{lvalue} reference of
type \lstinline!int!, \lstinline!crj!, with \lstinline!j! (of type \lstinline!long!)
is a narrowing conversion and thus ill formed.

Another consideration involves the standard
\lstinline!typedef!~\lstinline!std::size_t! found in the standard header
\lstinline!<cstddef>!, which must have sufficient bits to represent the
unsigned difference between any two pointers (into contiguous memory)
and is typically, but not necessarily, an alias for an
\lstinline!unsigned!~\lstinline!long!:

\begin{emcppshiddenlisting}[emcppsbatch=e10]
#include <cstddef>  // (ù{\codeincomments{std::size\_t}}ù)
\end{emcppshiddenlisting}
\begin{emcppslisting}[emcppsbatch=e10,emcppserrorlines={3,4,5}]
std::size_t k = 8;  // alias to implementation-defined type, say, (ù{\codeincomments{unsigned long}}ù)

unsigned int&       ra1 = { k };  // Note: Only one of these three lines will
unsigned long&      ra2 = { k };  // compile on any given platform; the other two
unsigned long long& ra3 = { k };  // will necessarily be ill formed and not compile.
\end{emcppslisting}
    

\noindent Historically, a \lstinline!long! has always been of sufficient size to
\emcppsgloss{pun} a pointer value (BAD IDEA) yet, back in the day when
\lstinline!int! and \lstinline!long! were the same number of bytes on a given
platform, \lstinline!size_t! was often an alias to an
\lstinline!unsigned!~\lstinline!int! rather than an
\lstinline!unsigned!~\lstinline!long!. Moving forward, one might expect
\lstinline!size_t! to be an alias for an \lstinline!unsigned!~\lstinline!long!
on a 64-bit platform, but there is no such assurance in the C++ Standard
and \lstinline!unsigned!~\lstinline!long!~\lstinline!long! (see
\featureref{\locationa}{long-long}) is another viable option on
any standards-conforming platform.

Finally, \lstinline!const! \romeovalue{lvalue} references to scalars and
aggregates initialized via braced lists of literal values follow the
rules of aggregates (see \intrarefsimple{c++11-aggregate-initialization}); a temporary is materialized having the indicated value and bound
permanently to the reference with its lifetime extended coterminously:

\begin{emcppslisting}
const int& i0 = { };    // OK, (ù{\emphincomments{materialized}}ù) temporary is (ù{\emphincomments{value}}ù) initialized.
const int& i1 = { 5 };  // OK,       "           "       " (ù{\emphincomments{copy}}ù)      "
\end{emcppslisting}
    

\noindent In the example above, a temporary is \emph{value} initialized (to 0) and
bound to \lstinline!i0!; another temporary is then \emph{copy} initialized
(to 5) and bound to \lstinline!i1!.

Non-modifiable references to \emph{aggregate UDT}s exploit the
generalization of \emph{copy} and \emph{direct} list initialization.
Consider an aggregate \lstinline!A! that comprises three \lstinline!int! data
members, \lstinline!i!, \lstinline!j!, and \lstinline!k!:

\begin{emcppslisting}[emcppsbatch=e11]
struct A          // (ù{\codeincomments{struct A}}ù) is an aggregate data type.
{
    int i, j, k;  // This (ù{\codeincomments{struct}}ù) contains three data members of type (ù{\codeincomments{int}}ù).
};
\end{emcppslisting}
    

\noindent We can now use braced initialization to materialize a temporary object
of aggregate type \lstinline!A! using aggregate initialization.

\begin{emcppslisting}[emcppsbatch=e11]
const A& s0 = { };           // (ù{\codeincomments{i}}ù), (ù{\codeincomments{j}}ù), and (ù{\codeincomments{k}}ù) are  (ù{\emphincomments{value}}ù) initialized.
const A& s1 = { 1 };         // (ù{\codeincomments{i}}ù) (ù{\emphincomments{copy}}ù) and (ù{\codeincomments{j}}ù) and (ù{\codeincomments{k}}ù) are (ù{\emphincomments{value}}ù) initialized.
const A& s2 = { 1, 2 };      // (ù{\codeincomments{i}}ù) and (ù{\codeincomments{j}}ù) (ù{\emphincomments{copy}}ù) and (ù{\codeincomments{k}}ù) are (ù{\emphincomments{value}}ù) initialized.
const A& s3 = { 1, 2, 3 };   // (ù{\codeincomments{i}}ù),(ù{\codeincomments{j}}ù), and (ù{\codeincomments{k}}ù) are (ù{\emphincomments{copy}}ù) initialized.
\end{emcppslisting}
    

In the example above, each of the references, \lstinline!s0! thru
\lstinline!s3!, is initialized to a temporary \lstinline!struct! of type
\lstinline!A! holding the respective aggregate value \lstinline!{0,0,0}!,
\lstinline!{1,0,0}!, \lstinline!{1,2,0}!, and \lstinline!{1,2,3}!.

\subsubsection[Direct list initialization]{Direct list initialization}\label{direct-list-initialization}

Of the two dual forms of initialization, \emph{direct} versus
\emph{copy}, \emph{direct} initialization is the stronger since it
enables use of all accessible constructors, i.e., including those
declared to be \lstinline!explicit!. The next step in generalizing the use
of braced initialization is to allow use of a braced list without the
intervening \lstinline!=! character between the variable and the opening
brace to denote \emcppsgloss{direct initialization} too:

\begin{emcppshiddenlisting}[emcppsbatch=e12]
struct Class {};
\end{emcppshiddenlisting}
\begin{emcppslisting}[emcppsbatch=e12]
Class var1(/*...*/);  // C++03-style direct initialization
Class var2{/*...*/};  // C++11-style direct list initialization
\end{emcppslisting}
    

\noindent Note that C++ does \emph{not} similarly relax the rules to allow for
initialization of aggregates with parentheses.\footnote{C++20 finally allows for aggregates to be
initialized with parentheses.}

The syntax suggested in the previous example is known as \emcppsgloss{direct list initialization} and follows the rules of \emcppsgloss{direct initialization} rather than \emcppsgloss{copy initialization} in that all
constructors of the named \lstinline!type! are both considered and
accessible in the initial overload set:

\begin{emcppslisting}[emcppsbatch=e13]
struct Q  // class containing explicit constructor
{
    explicit Q(int);  // value constructor taking a (ù{\codeincomments{int}}ù)
    // ...
};

Q x(5);    // OK  direct initialization can call explicit constructors.
Q y{5};    // OK, direct list initialization can call explicit constructors.
Q z = {5}; // Error, copy list initialization can't call explicit constructors.
\end{emcppslisting}
    

\noindent Either form of direct initialization (shown for \lstinline!x! and
\lstinline!y! in the code example above) may invoke an \lstinline!explicit!
constructor of class \lstinline!Q!, whereas \emph{copy list} initialization
will necessarily result in a compile-time error.

However, following the rules of C++11 braced initialization, narrowing
conversions are rejected by direct \emph{list} initialization:

\begin{emcppslisting}[emcppsbatch=e13]
long a = 3L;

Q b(a);  // OK, direct initialization
Q c{a};  // Error, direct list initialization cannot use a narrowing conversion.
\end{emcppslisting}
    

\noindent Similarly, \lstinline!explicit! conversion operators (see
\featureref{\locationa}{explicit-conversion-operators}) can be considered when
\emcppsgloss[direct list initialization]{\emph{direct} list initialization} (or \emcppsgloss{direct initialization}) is employed on a scalar, but not so with
\emcppsgloss[copy list initialization]{\emph{copy} list initialization} (or \emcppsgloss{copy initialization}). Consider, for example, a class, \lstinline!W! that can
covert to either an \lstinline!int! or a \lstinline!long! where conversion to
\lstinline!int! is explicit and therefore must be \emph{direct}:

\begin{emcppslisting}[emcppsbatch=e14]
struct W
{
    explicit operator int()  const;  // used via direct initialization only
             operator long() const;  // used via direct or copy initialization
};
\end{emcppslisting}
    

\noindent Initializing a \lstinline!long! variable with an expression of type
\lstinline!W! can be accomplished via either \emph{direct} or \emph{copy}
initialization (e.g., \lstinline!jDirect! and \lstinline!jCopy!, respectively,
in the code snippet below), but initializing an \lstinline!int! variable
with such an expression can be accomplished only via \emph{direct}
initialization (e.g., \lstinline!iDirect!):

\begin{emcppslisting}[emcppsbatch=e14]
long jDirect {W()};  // OK, considers both operators, calls (ù{\codeincomments{operator long}}ù)
long jCopy = {W()};  // OK, considers implicit op only, calls (ù{\codeincomments{operator long}}ù)
int  iDirect {W()};  // OK, considers both operators, calls (ù{\codeincomments{operator int}}ù)
int  iCopy = {W()};  // Error, considers implicit op only, narrowing conversion
\end{emcppslisting}
    

\noindent In the example above, attempting to use \emcppsgloss[copy list initialization]{\emph{copy} list initialization} (e.g., \lstinline!iCopy!) forces the conversion to
\lstinline!long! as the only option, which results in a narrowing
conversion and an ill-formed program.

Note that, for \emcppsgloss{aggregate} types, even \emcppsgloss{direct list initialization} will not allow the explicit constructors of the
individual member types to be considered since such \emph{member-wise}
initialization is invariably \emcppsgloss[copy initialization]{\emph{copy} initialization}; see
\intrarefsimple{c++11-aggregate-initialization}.

We may use \emcppsgloss{direct list initialization} as part of \emcppsgloss{member initialization lists} for base classes and member data of a class (note
that there is no equivalent to allow \emcppsgloss{copy list initialization}
in such a context). Consider, for example, an aggregate class,
\lstinline!B!, a non-aggregate class, \lstinline!C!, and a derived class,
\lstinline!D!, that inherits from \lstinline!B! and has an object of type
\lstinline!C! as a data member, \lstinline!m!:

\begin{emcppslisting}
struct B { int i; };        // aggregate base type
struct C { C(); C(int); };  // non-aggregate member type

struct D : B  // class publicly derived from (ù{\codeincomments{B}}ù) containing (ù{\codeincomments{C}}ù)
{
    C m;  // non-aggregate data member

    D()      : B{},  m{}  { }  // direct initialized base/member objects
    D(int x) : B{x}, m{x} { }  //    "       "        "     "       "
};
\end{emcppslisting}
    

\noindent In the definition of class \lstinline!D! above, both constructors employ
\emcppsgloss{direct list initialization}; the first is also an example of
\emph{value} initialization for both (aggregate) class \lstinline!B! and
(non-aggregate) class \lstinline!C!. Note that in C++03, aggregate bases
and members could only be default initialized, value initialized, or
direct initialized, and not initialized to another value.

New expressions are another context in which \emcppsgloss{direct list initialization} (braces) or \emcppsgloss{direct initialization} (parentheses)
can occur and applies similarly to both \emcppsgloss{aggregate} and
non\emcppsgloss{aggregate} types. If no initializer is provided, the
allocated object is \emcppsgloss{default initialized}; if empty braces or
parentheses are supplied, the object is \emcppsgloss{value initialized};
otherwise, the object is initialized from the contents of the braced or
(where permitted) parenthesized list.

As an illustrative example, let's consider the scalar type \lstinline!int!
which itself can be \emcppsgloss{default initialized} (not initialized),
\emcppsgloss{value initialized} (to 0) via empty braces or parentheses, or
\emcppsgloss{direct initialized} via a single element within either
parentheses or braces:

\begin{emcppslisting}
int* s0  = new int;               // default initialized (no initializer)

int* t0 = new int();              // direct (value) initialized from (ù{\codeincomments{()}}ù)
int* t1 = new int{};              // direct (value) list initialized from (ù{\codeincomments{\{\}}}ù)

int* u0 = new int(7);             // direct initialized from (ù{\codeincomments{7}}ù)
int* u1 = new int{7};             // direct list initialized from (ù{\codeincomments{\{7\}}}ù)

int* v0 = new int[5];             // All 5 elements are default initialized.

int* w0 = new int[5]();           // All 5 elements are value initialized.
int* w1 = new int[5]{};           // Array is direct list initialized from (ù{\codeincomments{\{\}}}ù).

int* x0 = new int[5](9);          // Error, invalid initializer for an array
int* x1 = new int[5]{9};          // Array is direct list initialized from (ù{\codeincomments{\{9\}}}ù).

int* y1 = new int[5]{1,2,3};      // array direct list initialized from (ù{\codeincomments{\{1,2,3\}}}ù)

int* z1 = new int[5]{1,2,3,4,5};  // direct list initialized from (ù{\codeincomments{\{1,2,3,4,5\}}}ù)
\end{emcppslisting}
    

\noindent All the comments above apply to the object being created in the
\lstinline!new! expression; the pointer set to the address of the
dynamically allocated object is copy initialized in all cases. Note
that, in C++03, we could default initialize (e.g., \lstinline!v0!) or value
initialize (e.g., \lstinline!w0!) the elements of an array in a
\lstinline!new! expression but there was no way to initialize the elements
of such an array to anything other than their default value (e.g.,
\lstinline!x0!); as of C++11, direct list initialization with braces (e.g.,
\lstinline!x1!, \lstinline!y1!, \lstinline!z1!) makes this more flexible,
heterogeneous initialization of array elements in \lstinline!new!
expressions possible.

\subsubsection[Contrasting copy and direct list initialization]{Contrasting copy and direct list initialization}\label{contrasting-copy-and-direct-list-initialization}

The difference between \emcppsgloss[copy list initialization]{\emph{copy} list initialization} and
\emcppsgloss[direct list initialization]{\emph{direct} list initialization} can be seen in this example:

\begin{emcppslisting}
struct C
{
    explicit C() { }
    explicit C(int) { }
};

struct A  // aggregate of (ù{\codeincomments{C}}ù)
{
    C x;
    C y;
};

int main()
{
    C c1;           // OK, default initialization
    C c2{};         // OK, value initialization
    C c3{1};        // OK, direct list initialization
    C c4 = {};      // Error, copy list initialization cannot use explicit default ctor.
    C c5 = {1};     // Error, copy list initialization cannot use explicit ctor.

    C c6[5];        // OK, default initialization
    C c7[5]{};      // Error, aggregate initialization requires a non-(ù{\codeincomments{explicit}}ù) default ctor.
    C c8[5]{1};     // Error, aggregate initialization requires non-(ù{\codeincomments{explicit}}ù) ctors.
    C c9[5] = {};   // Error, aggregate initialization requires a non-(ù{\codeincomments{explicit}}ù) default ctor.
    C ca[5] = {1};  // Error, aggregate initialization requires non-(ù{\codeincomments{explicit}}ù) ctors.

    A a1;           // OK, default initialization
    A a2{};         // Error, aggregate initialization requires a non-(ù{\codeincomments{explicit}}ù) default ctor.
    A a3{1};        // Error, aggregate initialization requires non-(ù{\codeincomments{explicit}}ù) ctors.
    A a4 = {};      // Error, aggregate initialization requires a non-(ù{\codeincomments{explicit}}ù) default ctor.
    A a5 = {1};     // Error, aggregate initialization requires non-(ù{\codeincomments{explicit}}ù) ctors.
}
\end{emcppslisting}
    

\noindent Note that if the constructors for \lstinline!C! were not marked explicit,
then all of the variables in the example above would be safely
initialized. If only the \lstinline!int! constructor of \lstinline!C! were
explicit, then the initializations that did not depend on the
\lstinline!int! constructor would be valid:

\begin{emcppslisting}
struct C
{
    C() { }
    explicit C(int) { }
};

struct A  // aggregate of (ù{\codeincomments{C}}ù)
{
    C x;
    C y;
};

int main()
{
    C c1;           // OK, default initialization
    C c2{};         // OK, value initialization
    C c3{1};        // OK, direct list initialization
    C c4 = {};      // OK, copy list initialization
    C c5 = {1};     // Error, copy list initialization cannot use explicit ctor.

    C c6[5];        // OK, default initialization
    C c7[5]{};      // OK, value initialization
    C c8[5]{1};     // Error, aggregate initialization requires non-(ù{\codeincomments{explicit}}ù) ctors.
    C c9[5] = {};   // OK, copy list initialization
    C ca[5] = {1};  // Error, aggregate initialization requires non-(ù{\codeincomments{explicit}}ù) ctors.

    A a1;           // OK, default initialization
    A a2{};         // OK, value initialization
    A a3{1};        // Error, aggregate initialization requires non-(ù{\codeincomments{explicit}}ù) ctors.
    A a4 = {};      // OK, copy list initialization
    A a5 = {1};     // Error, aggregate initialization requires non-(ù{\codeincomments{explicit}}ù) ctors.
}
\end{emcppslisting}
    

\subsubsection[Integrating default member initialization with braced initialization]{Integrating default member initialization with braced initialization}\label{integrating-default-member-initialization-with-braced-initialization}

Another new feature for C++11 is \emph{default member initializers} for
data members in a class. This new syntax supports both copy list
initialization and value list initialization. However, initialization
with parentheses is not permitted in this context.

\begin{emcppslisting}
struct S
{
    int i = { 13 };

    S() { }                       // OK, i == 13.
    explicit S(int x) : i(x) { }  // OK, i == x.
};


struct W
{
    S a{};        // OK, by default (ù{\codeincomments{j.i == 13}}ù).
    S b{42};      // OK, by default (ù{\codeincomments{j.i == 42}}ù).
    S c = {42};   // Error, constructor for (ù{\codeincomments{S}}ù) is explicit.
    S d = S{42};  // OK, direct initialization of temporary for initializer
    S e(42);      // Error, fails to parse as a function declaration
    S f();        // OK, declares member function (ù{\codeincomments{f}}ù)
};
\end{emcppslisting}
    

\subsubsection[List initialization where the list itself is a single argument to a constructor]{List initialization where the list itself is a single argument to a constructor}\label{list-initialization-where-the-list-itself-is-a-single-argument-to-a-constructor}

Another new form of initialization for C++11 is \emcppsgloss{list initialization} with a braced list of arguments to populate a container.
See \featureref{\locationc}{initlist} for details. If a braced list of arguments are
all of the same type, then the compiler will look for a constructor
taking an \lstinline!std::initializer_list<T>! argument, where \lstinline!T!
is that common type. Similarly, if a braced list of values can be
implicitly converted to a common type, then a constructor for an
\lstinline!std::initializer_list! of that common type will be preferred.
When initializing from a nonempty braced initializer list, a matching
initializer list constructor always wins overload resolution. However,
\emph{value} initializing from a pair of empty braces will prefer a
default constructor.

\begin{emcppshiddenlisting}[emcppsbatch=e15]
#include <initializer_list>  // (ù{\codeincomments{std::initializer\_list}}ù)
\end{emcppshiddenlisting}
\begin{emcppslisting}[emcppsbatch=e15]
struct S
{
  S() {}
  S(std::initializer_list<int>) {}
  S(int, int);
};

S a;             // default initialization with default constructor
S b();           // function declaration!
S c{};           // value initialization with default constructor
S d = {};        // copy list initialization with (ù{\codeincomments{std::initializer\_list}}ù)
S e{1,2,3,4,5};  // direct list initialization with (ù{\codeincomments{std::initializer\_list}}ù)
S f{1,2};        // direct list initialization with (ù{\codeincomments{std::initializer\_list}}ù)
S g = {1,2};     // copy list initialization with (ù{\codeincomments{std::initializer\_list}}ù)
S h(1,2);        // direct initialization with two (ù{\codeincomments{int}}ù)s
\end{emcppslisting}
    

\subsubsection[Omitting the type name when braced initializing a temporary]{Omitting the type name when braced initializing a temporary}\label{omitting-the-type-name-when-braced-initializing-a-temporary}

In addition to supporting new forms of initialization, C++11 allows for
braced lists to implicitly construct an object where the type is known
by context, such as for function arguments and return values. This use
of a braced list without explicitly specifying a type is just like
constructing a temporary object by copy initialization, hence using copy
list initialization, for the implicit type. As such construction is copy
list initialization, it will reject explicit constructors:

\begin{emcppslisting}
struct S
{
    S(int, int) {}
    explicit S(const char*, const char*) {}
};

S foo(bool b)
{
    if (b)
    {
        return S{ "hello", "world" };  // OK, direct list initialization of temporary
        return { "hello", "world" };   // Error, copy list initialization cannot call explicit ctor.
    }
    else
    {
        return {0, 0};  // OK, (ù{\codeincomments{int}}ù) constructor is not explicit.
    }
}

void bar(S s) { }

int main()
{
   bar( S{0,0} );  // OK, direct list initialization, then copy initialization
   bar(  {0,0} );  // OK, copy list initialization
   bar( S{"Hello", "world"} );  // OK, direct list initialization
   bar(  {"Hello", "world"} );  // Error, copy list initialization cannot use explicit ctor.
}
\end{emcppslisting}
    

\subsubsection[Initializing variables in conditional expressions]{Initializing variables in conditional expressions}\label{initializing-variables-in-conditional-expressions}

As a final tweak to make initialization consistent across the language,
initializing a variable in the condition of a \lstinline!while! or
\lstinline!if! statement in C++03 supported only copy initialization and
required use of the \lstinline!=! token. For C++11, those rules are relaxed
to allow any valid form of braced initialization. Conversely, the
declaration of a control variable in a \lstinline!for! loop has supported
all forms of initialization permitted for a variable declaration since
the original C++ standard{\cprotect\footnote{Note that GCC would
traditionally accept the C++11-only syntaxes, even when using
  C++98/03.}}:

\begin{emcppslisting}
void f()
{
   for (int i = 0; ; ) {}    // OK in all versions of C++
   for (int i = {0}; ; ) {}  // OK (ù{\emphincomments{for aggregates}}ù) in C++03 and all types from C++11
   for (int i{0}; ; ) {}     // OK from C++11, direct list initialization
   for (int i{}; ; ) {}      // OK from C++11, value initialization
   for (int i(0); ; ) {}     // OK in all versions of C++
   for (int i(); ; ) {}      // OK in all versions of C++
   for (int i; ; ) {}        // OK in all versions of C++

   if (int i = 0) {}    // OK in all versions of C++
   if (int i = {0}) {}  // OK from C++11, copy list initialization
   if (int i{0}) {}     // OK from C++11, direct list initialization
   if (int i{}) {}      // OK from C++11, value initialization
   if (int i(0)) {}     // Error in all versions of C++
   if (int i()) {}      // Error in all versions of C++
   if (int i) {}        // Error in all versions of C++

   while (int i = 0) {}    // OK in all versions of C++
   while (int i = {0}) {}  // OK from C++11, copy list initialization
   while (int i{0}) {}     // OK from C++11, direct list initialization
   while (int i{}) {}      // OK from C++11, value initialization
   while (int i(0)) {}     // Error in all versions of C++
   while (int i()) {}      // Error in all versions of C++
   while (int i) {}        // Error in all versions of C++
}
\end{emcppslisting}
    

\subsubsection[Default initialization and \lstinline!=!\,\lstinline!default!]{Default initialization and {\SubsubsecCode =}\,{\SubsubsecCode default}}\label{default-initialization-and-=-default}

Another new feature for C++11 is the notion of defaulted constructors,
defined by \lstinline!=!~\lstinline!default! (see \featureref{\locationa}{Defaulted-Special-Member-Functions}) to have
the same definition as the implicitly defined constructor. This is
especially useful when you want to provide constructors for your class
without losing the \emcppsgloss{triviality} otherwise associated with the
implicit constructors, notably for the default constructor that would no
longer be declared as soon as another constructor is declared.

One important property of \lstinline!=!~\lstinline!default! constructors is
that, while they are user \emph{declared}, they are not user
\emph{provided} as long as this definition occurs within the class
definition itself:

\begin{emcppslisting}[emcppsbatch=e16]
struct Trivial
{
    int i;
    Trivial() = default;            // user declared but not user provided
};

struct NonTrivial
{
    int j;
    NonTrivial();                    // user declared
};

NonTrivial::NonTrivial() = default;  // user provided
\end{emcppslisting}
    

\noindent Following the rules derived from C++03, a class with no user-provided
default constructor may behave differently under \emph{default}
initialization compared to \emph{value} initialization:

\begin{emcppslisting}[emcppsbatch=e16]
void demo()
{
    const Trivial    a;    // Error, (ù{\codeincomments{a.i}}ù) not initialized
    const Trivial    b{};  // OK, (ù{\codeincomments{b.i}}ù) = 0.
    const NonTrivial c;    // OK, but (ù{\codeincomments{c.j}}ù) never initialized
    const NonTrivial d{};  // OK, but (ù{\codeincomments{d.j}}ù) never initialized
}
\end{emcppslisting}
    

\noindent Note that we use function local variables for this example to avoid
confusion with \emph{zero} initialization for global variables.

\subsubsection[Copy initialization and scalars]{Copy initialization and scalars}\label{copy-initialization-and-scalars}

With the addition of explicit conversion operators to C++11 (see \featureref{\locationa}{explicit-conversion-operators}), it becomes possible for \emph{copy}
initialization and \emph{copy list} initialization to fail for scalars
and similarly for \emph{direct list} initialization:

\begin{emcppslisting}
struct S
{
    explicit operator int() const { return 1; }
};

S one{};

int a(one);     // OK, (ù{\codeincomments{a}}ù) = 1.
int b{one};     // OK, (ù{\codeincomments{b}}ù) = 1.
int c = {one};  // Error, copy list initialization used with
                // with explicit conversion operator.
int d = one;    // Error, copy initialization used with
                // with explicit conversion operator.

class C {
    int x;
    int y;

public:
    C(const S& value) : x(value)  // OK, (ù{\codeincomments{x}}ù) = 1
                      , y{value}  // OK, (ù{\codeincomments{y}}ù) = 1
    {
    }
};
\end{emcppslisting}
    

\subsection[Use Cases]{Use Cases}\label{use-cases-bracedinit}

\subsubsection[Defining a value-initialized variable]{Defining a value-initialized variable}\label{defining-a-value-initialized-variable}

The C++ parser has a pitfall where an attempt to value initialize a
variable turns out to be a function declaration:

\begin{emcppslisting}[emcppsbatch=e17]
struct S{};

S s1();      // Oops! function declaration
S s2 = S();  // variable declaration using value initialization and then copy initialization
\end{emcppslisting}
    

\noindent The declaration of \lstinline!s1! looks like an attempt to value initialize
a local variable of type \lstinline!S!, but, in fact, it is a forward
declaration for a function \lstinline!s1! that takes no arguments and
returns an \lstinline!S! object by value. This is particularly surprising
for folks who did not realize we could declare (but not define) a
function within the body of another function, a feature retained from
the original C Standard. Clearly, there would be an ambiguity in the
grammar at this point unless the language provided a rule to resolve the
ambiguity, and the grammar opts in favor of the function declaration in
all circumstances, including at function local scope. Whilst this rule
would be essential at namespace/class scope, otherwise functions taking
no arguments could not be so easily declared, the same rule also applies
at function local scope, first for consistency and second for
compatibility with pre-existing C code that we might want to compile
more strictly\footnote{While C and C++ both enforce type safety, C++
enforces strict type safety, where all declared types are distinct; C
enforces structural conformance, where two distinct structs with the
same sequence of members are treated as the same type.} with a C++ compiler.

By switching from parentheses to braces, there is no more risk of
confusion between a vexing parse and a variable declaration:

\begin{emcppslisting}[emcppsbatch=e17]
S s{};  // object of type (ù{\codeincomments{S}}ù)
\end{emcppslisting}
    
\noindent As a digression, it is worth noting that \lstinline!S! is an empty type.
Just as it is ill-formed to rely on default initialization for a
\lstinline!const! object of a trivial type such as an \lstinline!int! or an
aggregate of just an \lstinline!int!, it was also, prior to Defect Report
CWG 253 for C++17 and the introduction of
\emcppsgloss[const default constructible]{const-default-constructible} types, ill-formed to rely on
default initialization for a \lstinline!const! object of an empty type.
Hence, it is often desirable to value initialize such objects, running
into the vexing parse. As this Defect Report was resolved at the end of
2016, and applies retroactively to earlier dialects, most current
compilers no longer enforce this restriction, and some compilers
(notably GCC) had already stopped enforcing this rule several years
previously:

\begin{emcppslisting}[emcppsbatch=e17]
const S cs1;        // Error on some compilers (as described above)
const S cs2{};      // OK, value initialization
const S cs3 = {};   // OK, aggregate initialization
const S cs4 = S();  // OK, copy initialization
\end{emcppslisting}
    

\subsubsection[Avoiding the most vexing parse]{Avoiding the most vexing parse}\label{avoiding-the-most-vexing-parse}

Value initializing function arguments can lead to another pitfall, often
called \emph{the most vexing parse}. C++ will parse the intended value
initialization of a function argument as the declaration of an unnamed
parameter of a function type instead, which would otherwise not be legal
but for the language rule that such a parameter implicitly decays to a
pointer to a function of that type:

\begin{emcppslisting}[emcppsbatch=e17]
struct V { V(const S&) { } };

void foo()
{
    V v1(S());    // most vexing parse, declares function (ù{\codeincomments{v1}}ù) taking a function pointer
    V v2((S()));  // workaround, object of type (ù{\codeincomments{V}}ù) due to non-redundant parentheses on argument

    S x = S();    // declare a variable of type (ù{\codeincomments{S}}ù)
    V v3(x);      // workaround, object of type (ù{\codeincomments{V}}ù) but argument is now named, with longer lifetime
}
\end{emcppslisting}
    

\noindent In the example above, \lstinline!v1! is the forward declaration of a
function in the surrounding namespace that returns an object of type
\lstinline!V! and has an (unnamed) parameter of type
pointer-to-function-returning-\lstinline!S!-and-taking-no-arguments,
\lstinline!S(*)()!. That is, the declaration is equivalent to:

\begin{emcppslisting}[emcppsbatch=e17]
V v1(S(*)());
\end{emcppslisting}
    

\noindent This most vexing of parses can be disambiguated by having the arguments
clearly form an expression, not a type. One simple way to force the
argument to be parsed as an expression is to add an otherwise redundant
pair of parentheses. Note that declaring the constructor of \lstinline!V!
as \lstinline!explicit! in the hopes of forcing a compile error is no help
here since the declaration of \lstinline!v1! is not interpreted as a
declaration of an object of type \lstinline!V!, so the \lstinline!explicit!
constructor is never considered.

With the addition of generalized braced initialization in C++11, a
coding convention to prefer empty braces, rather than parentheses, for
all value initializations avoids the question of the most vexing parse
arising:

\begin{emcppslisting}[emcppsbatch=e17]
V v4(S{});  // direct initialize object of type (ù{\codeincomments{V}}ù) with value initialized temporary
\end{emcppslisting}
    

\noindent Note that the most vexing parse can also apply to constructors taking
multiple arguments, but the issue arises less often since any one
supplied argument clearly being an expression, rather than a function
type, resolves the whole parse:

\begin{emcppslisting}[emcppsbatch=e17]
struct W { W(const S&, const S&) { } };

W w1( S(),  S());  // most vexing parse, declares function (ù{\codeincomments{w1}}ù) taking two function pointers
W w2((S()), S());  // workaround, object of type (ù{\codeincomments{V}}ù) due to non-redundant parentheses on argument
W w3( S{},  S());  // workaround, even a single use of (ù{\codeincomments{S\{\}}}ù) disambiguates further use of (ù{\codeincomments{S()}}ù)
\end{emcppslisting}
    

\subsubsection[Uniform initialization in generic code]{Uniform initialization in generic code}\label{uniform-initialization-in-generic-code}

One of the design concerns facing an author of generic code is which
form of syntax to choose to initialize objects of a type dependent on
template parameters. Different C++ types behave differently and accept
different syntaxes, so providing a single consistent syntax for all
cases is not possible. Consider the following example of a simple test
harness for a unit testing framework:

\begin{emcppslisting}
#include <initializer_list>  // (ù{\codeincomments{std::initializer\_list}}ù)

template <class T, class U>
bool run_test(bool (*test)(const T&), std::initializer_list<U> iL)
{
    for (const auto& val : iL)
    {
        T obj = val;      // initialize the test value
        if (!test(obj))
        {
            return false;
        }
    }

    return true;
}
\end{emcppslisting}
    

\noindent In this example, a test function is provided for an object of parameter
type \lstinline!T! along with an \lstinline!initializer_list! of test values.
The \lstinline!for! loop will construct a test object with each test value,
in turn, and call the test function, returning early if any value fails.
The question is which syntax to use to create the test object
\lstinline!obj!.

\begin{itemize}
\item{As written, the example uses \emph{copy} initialization --- \lstinline!T!~\lstinline!obj!~\lstinline!=!~\lstinline!val;! --- and so will fail to compile if a non-\lstinline!explicit! constructor cannot be found or if \lstinline!T! is an aggregate that is not \lstinline!U!.}
\item{If we switched to \emph{direct} initialization --- \lstinline!T!~\lstinline!obj(val);! --- then explicit constructors would also be considered.}
\item{If we switched to \emph{direct list} initialization --- \lstinline!T!~\lstinline!obj{val};! --- then aggregates would be supported as well as explicit constructors but not narrowing conversions;\linebreak[4] \lstinline!initializer_list! constructors are also considered and preferred.}
\item{If we switched to \emph{copy list} initialization --- \lstinline!T!~\lstinline!obj!~\lstinline!=!~\lstinline!{val};! --- then aggregates would be supported, but it would be an error if an explicit constructor is the best match, rather than considering the non-\lstinline!explicit! constructors for the best viable match, and it would be an error to rely on a narrowing conversion; \lstinline!initializer_list! constructors are also considered and preferred.}
\end{itemize}

Table \ref{table-bracedinit-inittypes} summarizes the different initialization types and highlights the
options and trade-offs.
\begin{table}[h!]
\begin{center}
\begin{threeparttable}
\caption{Summary of the different initialization types}\label{table-bracedinit-inittypes} \vspace{1.5ex}
{\small \begin{tabular}{c|c|c|c|c|c}\thickhline
\rowcolor[gray]{.9}    {\sffamily\bfseries Initialization} & {\sffamily\bfseries Syntax } & {\sffamily\bfseries Aggregate} & {\sffamily\bfseries Explicit} & {\sffamily\bfseries Narrowing} & {\sffamily\bfseries \lstinline!initializer_list!} \\ 
 \rowcolor[gray]{.9}    {\sffamily\bfseries Type} & & {\sffamily\bfseries Support} & {\sffamily\bfseries Constructor} & & {\sffamily\bfseries Constructor} \\
\rowcolor[gray]{.9}   & & &  {\sffamily\bfseries Used} & & {\sffamily\bfseries Used}\\ \hline
\emcppsgloss[copy]{Copy} & \lstinline!T!~\lstinline!obj!~\lstinline!=!~\lstinline!val;! & only if \lstinline!U!  & no & allow & no \\ \hline 
\emcppsgloss[direct]{Direct} & \lstinline!T!~\lstinline!obj(val);! & only if \lstinline!U!  & yes & allow & no \\ \hline 
\emcppsgloss[direct list]{Direct List} & \lstinline!T!~\lstinline!obj{val};! & yes  & yes & error & yes \\ \hline 
\emcppsgloss[copy list]{Copy List} & \lstinline!T!~\lstinline!obj!~\lstinline!=!~\lstinline!{val}! & yes  & error if  & error & yes \\ 
& & & best match & & \\ \thickhline 
\end{tabular}
}
\end{threeparttable}
    \end{center}
\end{table}
In general, there is no one true, universal syntax for initialization in
generic (template) code. The library author should make an intentional
choice among the trade-offs described in this section and document that
as part of their contract.

\subsubsection[Uniform initialization in factory functions]{Uniform initialization in factory functions}\label{uniform-initialization-in-factory-functions}

One of the design concerns facing an author of generic code is which
form of syntax to choose to initialize objects of a type dependent on
template parameters. Different C++ types behave differently and accept
different syntaxes, so providing a single consistent syntax for all
cases is not possible. Here we present the different trade-offs to
consider when writing a factory function that takes an arbitrary set of
parameters to create an object of a user-specified type:

\begin{emcppslisting}
#include <utility>  // (ù{\codeincomments{std::forward}}ù)

template <class T, class... ARGS>
T factory1(ARGS&&... args)
{
    return T(std::forward<ARGS>(args)...);
}

template <class T, class... ARGS>
T factory2(ARGS&&... args)
{
    return T{std::forward<ARGS>(args)...};
}

template <class T, class... ARGS>
T factory3(ARGS&&... args)
{
    return {std::forward<ARGS>(args)...};
}
\end{emcppslisting}
    

\noindent All three factory functions are defined using \emcppsgloss{perfect forwarding} (see \featureref{\locationc}{forwardingref}) but support
different subsets of C++ types and may interpret their arguments
differently.

\lstinline!function1! returns a value created by direct initialization but,
because it uses parentheses, cannot return an aggregate unless (as a
special case) the \lstinline!args! list is empty or contains exactly one
argument of the same type \lstinline!T!; otherwise, the attempt to
construct the return value will parse as an error.{\cprotect\footnote{Note
that C++20 will allow aggregates to be initialized with parentheses as
well as with braces, which will result in this form being accepted for
  aggregates as well.}}

\lstinline!function2! returns an object created by \emcppsgloss{direct list initialization}. Hence, \lstinline!function2! supports the same types as
\lstinline!function1!, plus aggregates. However, due to the use of braced
initialization, \lstinline!function2! will reject any types in
\lstinline!ARGS! that require narrowing conversion when passed to the
constructor (or to initialize the aggregate member) of the return value.
Also, if the supplied arguments can be converted into a homogeneous
\lstinline!std::initializer_list! that matches a constructor for
\lstinline!T!, then that constructor will be selected, rather than the
constructor best matching that list of arguments, despite
\lstinline!function2! being called using parentheses (as for any function
call).

\lstinline!function3! behaves the same as \lstinline!function2!, except that
it uses \emph{copy list initialization} so will also produce a compile
error if the selected constructor for the return value is declared as
\lstinline!explicit!.

There is no one true form of initialization that works best in all
circumstances for such a factory function, and it is for library
developers to choose (and document in their contract) the form that best
suits their needs. Note that the Standard Library runs into this same
problem when implementing factory functions like
\lstinline!std::make_shared! or the \lstinline!emplace! function of any
container. The Standard Library consistently chooses parentheses
initialization like \lstinline!function1! in the code example above, and so
these functions do not work for aggregates prior to C++20.

\subsubsection[Uniform member initialization in generic code]{Uniform member initialization in generic code}\label{uniform-member-initialization-in-generic-code}

With the addition of general braced initialization to C++11, class
authors should consider whether constructors should use \emph{direct}
initialization or \emph{direct list} initialization to initialize their
bases and members. Note that as copy initialization and copy list
initialization are not options, whether or not the constructor for a
given base or member is \lstinline!explicit! will never be a concern.

Prior to C++11, writing code that initialized aggregate subobjects
(including arrays) with a set of data in the constructor's member
initializer list was not really possible. We could only \emph{default}
initialize, \emph{value} initialize, or \emph{direct} initialize from
another aggregate of the same type.

Starting with C++11, we are able to initialize aggregate members with a
list of values, using aggregate initialization in place of direct list
initialization for members that are aggregates:

\begin{emcppshiddenlisting}[emcppsbatch=e18]
#include <string>  // (ù{\codeincomments{std::string}}ù)
\end{emcppshiddenlisting}
\begin{emcppslisting}[emcppsbatch=e18]
struct S
{
    int         i;
    std::string str;
};

class C
{
    int j;
    int a[3];
    S   s;

public:
    C(int x, int y, int z, int n, const std::string t)
    : j(0)
    , a{ x, y, z }  // Ill-formed in C++03, OK in C++11
    , s{ n, t }     // Ill-formed in C++03, OK in C++11
    {
    }
};
\end{emcppslisting}
    

\noindent Note that as the initializer for \lstinline!C.j! shows in the code example
above, there is no requirement to consistently use either braces or
parentheses for all member initializers.

As with the case of factory functions, the class author must make a
choice for constructors between adding support for initializing
aggregates vs.~reporting errors for narrowing conversion. Since member
initialization supports only \emph{direct} list initialization, there is
never a concern regarding \lstinline!explicit! conversions in this context:

\begin{emcppshiddenlisting}[emcppsbatch=e19]
#include <utility>  // (ù{\codeincomments{std::forward}}ù)
\end{emcppshiddenlisting}
\begin{emcppslisting}[emcppsbatch=e19]
template <class T>
class Wrap
{
    T data;

    template <class... ARGS>
    Wrap(ARGS&&... args)
    : data(std::forward<ARGS>(args)...)
        // must be empty list or copy for aggregate (ù{\codeincomments{T}}ù)
    {
    }
};

template <class T>
class WrapAggregate
{
    T data;

    template <class... ARGS>
    WrapAggregate(ARGS&&... args)
    : data{std::forward<ARGS>(args)...}  // no narrowing conversions
    {
    }
};
\end{emcppslisting}
    

\noindent Again, there is no universal best answer, and an explicit choice should
be made and documented so that consumers of the class know what to
expect.

\subsection[Potential Pitfalls]{Potential Pitfalls}\label{potential-pitfalls-bracedinit}

\subsubsection[Inadvertently calling initializer-list constructors]{Inadvertently calling initializer-list constructors}\label{inadvertently-calling-initializer-list-constructors}

Classes with an \lstinline!std::initializer_list! constructors (see
\featureref{\locationc}{initlist}) follow some special rules to disambiguate
overload resolution, which contain subtle pitfalls for the unwary. This
pitfall describes how overload resolution might (or might not) select
those constructors in surprising ways.

When an object is initialized by braced initialization, the compiler
will first look to find an \lstinline!std::initializer_list! constructor
that could be called, with the exception that if the braced list is
empty, a default constructor (if available) would have priority:

\begin{emcppslisting}
#include <initializer_list>  // (ù{\codeincomments{std::initializer\_list}}ù)

struct S {
  explicit S() {}
  explicit S(int) {}
  S(std::initializer_list<int> iL) { if (0 == iL.size()) {throw 13;} }
};

S a{};            // OK, value initialization
S b = {};         // Error, default constructor is (ù{\codeincomments{explicit}}ù)
S c{1};           // OK, (ù{\codeincomments{std::initializer\_list}}ù)
S d = {1};        // OK, (ù{\codeincomments{std::initializer\_list}}ù)
S e{1, 2, 3};     // OK, (ù{\codeincomments{std::initializer\_list}}ù)
S f = {1, 2, 3};  // OK, (ù{\codeincomments{std::initializer\_list}}ù)
\end{emcppslisting}
    

\noindent In the presence of initializer list constructors, the overload
resolution to select which constructor to call will be a two-step
process. First, all initializer-list constructors are considered, and
only if no matching \lstinline!std::initializer_list! constructor has been
found, non--initializer-list constructors will be considered. This
process has some possibly surprising consequences since implicit
conversions are allowed when performing the overload matching. It is
possible that an \lstinline!std::initializer_list! constructor requiring
an implicit conversion will be selected over a non--initializer-list
constructor that does not require a conversion:

\begin{emcppslisting}
#include <initializer_list>  // (ù{\codeincomments{std::initializer\_list}}ù)

struct S
{
    S(std::initializer_list<int>); // #1
    S(int i, char c);              // #2
};

S s1{1, 'a'};  // calls #1, even though #2 would be a better match
\end{emcppslisting}
    

\noindent In the example above, due to braced initialization preferring
initializer-list constructors and because \lstinline!S! has an
\lstinline!initializer_list! constructor that can match the initializer of
\lstinline!s1!, the constructor that would have been a better match
otherwise is not considered.

The other possibly surprising consequence is related to narrowing
conversion being checked for only \emph{after} the constructor has been
selected. This means that an \lstinline!initializer_list! constructor that
matches but requires a narrowing conversion will cause an error even in
the presence of a non\lstinline!initializer_list! constructor that would
be a match without requiring a narrowing conversion:

\begin{emcppslisting}
#include <initializer_list>  // (ù{\codeincomments{std::initializer\_list}}ù)

struct S
{
    S(std::initializer_list<int>); // #1
    S(int i, double d);            // #2
};

S s2{1, 3.2}; // Error, narrowing conversion when attempting to call #1, 
              // even though invoking #2 would be well formed
\end{emcppslisting}
    

\noindent In the example above, due to braced initialization first selecting a
constructor and then checking for narrowing conversion, the
non-initializer-list constructor, which would not require a narrowing
conversion, is not considered.

Both of these situations can be resolved by using parentheses or other
forms of initialization than brace lists, which do not prefer
initializer-list constructors:

\begin{emcppslisting}
#include <initializer_list>  // (ù{\codeincomments{std::initializer\_list}}ù)

struct S
{
    S(std::initializer_list<int>); // #1
    S(int i, char c);              // #2
    S(int i, double d);            // #3
};

S s3(1, 'c'); // calls #2
S s4(1, 3.2); // calls #3
\end{emcppslisting}
    
\noindent This problem often comes up when talking about \lstinline!std::vector!:

\begin{emcppshiddenlisting}[emcppsbatch=e20]
#include <vector>     // (ù{\codeincomments{std::vector}}ù)
\end{emcppshiddenlisting}
\begin{emcppslisting}[emcppsbatch=e20]
std::vector<std::size_t> v1{5u, 13u};  // Possible bug here.
  // If trying to construct a vector of 5 (ù{\codeincomments{size\_t}}ù) with value 13,
  // The (ù{\codeincomments{std::initializer\_list}}ù) constructor is preferred over exact match,
  // so we actually construct a vector with 2 values, 5 and 13.

std::vector<std::size_t> v2(5u, 13u);  // OK, calls the normal constructor
\end{emcppslisting}
    

\subsubsection[Classes with default member initializers lose aggregate status]{Classes with default member initializers lose aggregate status}\label{classes-with-default-member-initializers-lose-aggregate-status}

An aggregate class is a class with no user-provided constructors, no
base classes, no virtual functions, and all public data members. Braced
initialization of an aggregate matches each member of the brace list to
the corresponding member of the aggregate class in the order of
declaration. However, if any of the members has a \featureref{\locationc}{Default-Member-Initializers}, then the class ceases to be an aggregate in
C++11, and braced initialization will fail to compile because no
matching constructor will be found. C++14 fixes this oversight, so this
pitfall should occur only when supporting code across multiple versions
of the language, which is typically more of a concern for library
maintainers than application developers:

\begin{emcppslisting}
struct S
{
    int a;
    int b;
    int c;
};

struct A  // not an aggregate in C++11 (aggregate in C++14, see next section)
{
    int a{1};
    int b{2};
    int c{3};
};

S s1 = {};         // OK, aggregate initialization, value initializes each member
S s2 = {1, 2, 3};  // OK, aggregate initialization

A a1 = {};         // OK, value initialization with implicit default ctor in C++11
A a2 = {4, 5, 6};  // Error, no matching constructor in C++11
\end{emcppslisting}
    

\subsubsection[Implicit move and named return value optimization may be disabled in \lstinline!return! statements]{Implicit move and named return value optimization may be disabled in {\SubsubsecCode return} statements}\label{implicit-move-and-named-return-value-optimization-may-be-disabled-in-return-statements}

Using extra braces in a return statement around a value may disable the
named return value optimization or an implicit move into the returned
object.

Named return value optimization (NRVO) is an optimization that compilers
are allowed to perform when the operand of a return statement is just
the name (id-expression) of a nonvolatile local variable (an object of
automatic storage duration that is not a parameter of the function or a
catch clause) and the type of that variable, ignoring cv-qualification,
is the same as the function return type. In such cases, the compiler is
allowed to elide the copy implied by the return expression and
initialize the return value directly where the local variable is
defined. Naturally this applies only to functions returning objects, not
pointers or references. Note that this optimization is allowed to change
the meaning of programs that may rely on observable side effects on the
elided copy constructor. Most modern compilers are capable of performing
this optimization in at least simple circumstances, such as where there
is only one return expression for the whole function.

In the example below, we see that the \lstinline!no_brace()! function
returns using the name of a local variable from within that function. As
we call \lstinline!no_brace()! we can observe (with a compiler that
performs the optimization) that only one object of the \lstinline!S! class
is created, using its default constructor. There is no copy, no move,
and no other object created. Essentially the local variable, \lstinline!a!,
inside the \lstinline!no_brace()! function is created directly in the
memory region of the variable \lstinline!m1! of the \lstinline!main()!
function.

In the \lstinline!braced()! function, we use the exact same local variable,
but in the return statement we put braces around its name; therefore,
the operand of the return is no longer a name (id-expression), and so
the rules that allow NRVO do not apply. By calling \lstinline!braced()!, we
see that now two copies, and so two objects, are created, the first
being \lstinline!a!, the local variable, using the default constructor, and
the second being \lstinline!m2!, which is created as a copy of \lstinline!a!,
demonstrating that NRVO is not in effect:

\begin{emcppslisting}
#include <iostream>  // (ù{\codeincomments{std::cout}}ù)

struct S
{
    S()          { std::cout << "S()\n"; }
    S(const S &) { std::cout << "S(copy)\n"; }
    S(S &&)      { std::cout << "S(move)\n"; }
};

S no_brace()
{
    S a;
    return a;
}

S braced()
{
    S a;
    return { a };  // disables NRVO
}

int main()
{
    S m1 = no_brace();  // S()
    S m2 = braced();    // S(), S(copy)
}
\end{emcppslisting}
    

\noindent Implicit move (see \featureref{\locationc}{Rvalue-References}) in a return statement
is a more subtle operation, so much so that it required a defect
report{\cprotect\footnote{\cite{yasskin12}}} to actually
make it work as the original intention. We demonstrate implicit moves in
a return statement from a local variable by using two types. The class
type \lstinline!L! will be used for the local variable, whereas the class
type \lstinline!R!, which can be move- or copy-constructed from \lstinline!L!,
is used as the return type. Essentially, we are forcing a type
conversion in the return statement, one that may be a copy or a move.

The \lstinline!no_brace()! function just creates a local variable and
returns it. By calling the function, we observe that an \lstinline!L!
object is created, which is then moved into an \lstinline!R! object. Note
that the wording of the ISO standard allows this implicit move only if
the return statement's operand is a name (an id-expression).

The \lstinline!braced()! function is identical to the previous one, except
for adding curly braces around the operand of the return statement.
Calling the function shows that the \emph{move-from-\lstinline!L!} return
expression turned into a \emph{copy-from-\lstinline!L!} return expression
because a braced initializer is not a name of an object:

\begin{emcppslisting}
#include <iostream>  // (ù{\codeincomments{std::cout}}ù)

struct L
{
    L()        { std::cout << "L()\n"; }
};

struct R
{
    R(const L &) { std::cout << "R(L-copy)\n"; }
    R(L &&)      { std::cout << "R(L-move)\n"; }
};

R no_brace()
{
    L a;
    return a;
}

R braced()
{
    L a;
    return { a };  // disables implicit move from l
}

int main()
{
    R r1 = no_brace();  // L(), R(L-move)
    R r2 = braced();    // L(), R(L-copy)
}
\end{emcppslisting}
    

\subsubsection[Surprising behavior of aggregates having deleted constructors]{Surprising behavior of aggregates having deleted constructors}\label{surprising-behavior-of-aggregates-having-deleted-constructors}

Value initialization of aggregates is allowed with a braced initializer
list, even if the default constructor is deleted{\cprotect\footnote{Note
that C++20 finally addresses the issue so the presence of deleted
  constructors cause a class to no longer qualify as an aggregate.}}:

\begin{emcppslisting}
struct S
{
    int data;
    S() = delete; // don't want "empty"
};

S s{}; // surprisingly works (until C++20), and (ù{\codeincomments{0 == s.data}}ù)
\end{emcppslisting}
    
\noindent This surprising pitfall occurs for two reasons:
\begin{enumerate}
\item{A deleted constructor is \emph{user declared} but not \emph{user provided}, so it does not feature in the list of things that stop a class being an aggregate.}
\item{The rules state that aggregate initialization is not defined in terms of constructors but directly in terms of the initialization of its members.}
\end{enumerate}

\subsection[Annoyances]{Annoyances}\label{annoyances}

\subsubsection[Narrowing aggregate initialization may break C++03 code]{Narrowing aggregate initialization may break C++03 code}\label{narrowing-aggregate-initialization-may-break-c++03-code}

When compiling existing C++03 code with a C++11 compiler, previously
valid code may report errors for narrowing conversion in aggregate (and,
therefore, also array) initialization.

\begin{emcppslisting}
unsigned u = 128;           // (ù{\codeincomments{u}}ù) is computed to an (ù{\codeincomments{int}}ù)-friendly value
int ia[] = { 1, 2, u, 9 };  // OK in C++03, narrowing is allowed.
                            // Error in C++11, narrowing conversion.
\end{emcppslisting}
    

\noindent Suppose that the computation in the above code ensures that the value
\lstinline!u! holds at the point of initialization is in the range of
values an \lstinline!int! is able to represent. Yet, the code will not
compile in C++11 or later modes. Unfortunately each and every case has
to be fixed by applying the appropriate type cast or changing the types
involved to be ``compatible''.

\subsubsection[No easy way to allow narrowing conversions]{No easy way to allow narrowing conversions}\label{no-easy-way-to-allow-narrowing-conversions}

In generic code, curly braces have to be used if support for aggregates
is required, but, if our interface definition requires supporting
narrowing conversions (for example \lstinline!std::tuple!), there is no
direct way to enable them:

\begin{emcppslisting}
struct S
{
    short m;
};

class X
{
    S m;

public:
    template <class U>
    X(const U& a) : m{a}  // no narrowing allowed
    {
    }
};

int i;
X x(i);  // Error, would narrow in initializing S.m
\end{emcppslisting}
    

\noindent The workaround is to \lstinline!static_cast! to the target type if it is
known or to use parentheses and give up aggregate support in the generic
code.{\cprotect\footnote{C++20 enables the use of parentheses to
  initialize aggregates.}}

\subsubsection[Breaks macro-invocation syntax]{Breaks macro-invocation syntax}\label{breaks-macro-invocation-syntax}

The macro-invocation syntax of the C++ preprocessor (inherited from C)
``understands'' parentheses and thus ignores commas within parentheses
but does not understand any other list markers, such as braces for
braced initialization, square brackets, or the angle bracket notation of
templates. If we attempt to use commas in other contexts, the macro
parsing will interpret such commas as separators for multiple macro
arguments and will likely complain that the macro does not support that
many arguments:

\begin{emcppslisting}[emcppsbatch=e21]
#define MACRO(oneArg) /*...*/

struct C
{
    C(int, int, int);
};

struct S
{
    int i1, i2, i3;
};

MACRO(C x(a, b, c))         // OK, commas inside parentheses ignored
MACRO(S y{a, b, c})         // Error, 3 arguments but MACRO needs 1
MACRO(std::map<int, int> z) // Error, 2 arguments but MACRO needs 1
\end{emcppslisting}
    

\noindent As the example above demonstrates, on the first macro invocation, the
commas within the parentheses are ignored, and the macro is invoked with
one argument: \lstinline!Demo!~\lstinline!x(a,!~\lstinline!b,!~\lstinline!c)!.

In the second macro invocation, we attempt to use braced initialization,
but, because the syntax of the preprocessor does not recognize curly
braces as special delimiters, the commas are interpreted as separating
macro arguments, so we end up with three unusual arguments: first
\lstinline!Demo!~\lstinline!y{a!, second \lstinline!b!, and finally the third
\lstinline!c}!. This problematic interaction between braced initialization
and macros has existed forever, even back in C code when initializing
arrays or \lstinline!struct!s. However, with braced initialization becoming
used more widely in C++, it is much more likely that a programmer will
encounter this annoyance.

The third invocation of \lstinline!MACRO! in the example is just a reminder
that the same issue exists in C++ with the angle brackets of templates.

The workaround, as is so often the case with the C preprocessor, is more
use of the C preprocessor! We need to define macros to help us hide the
commas. Such macros will use the \emcppsgloss{variadic macros} C99
preprocessor feature that was adopted for C++11 to turn a
comma-separated list into a braced-initializer list (and similarly for a
template instantiation):

\begin{emcppslisting}[emcppsbatch=e21]
#define BRACED(...) { __VA_ARGS__ }
#define TEMPLATE(name, ...) name<__VA_ARGS__>

MACRO(X y BRACED(a, b, c));             // OK, (ù{\codeincomments{X y \{ a, b, c \}}}ù)
MACRO(TEMPLATE(std::map, int, int) z);  // OK, (ù{\codeincomments{std::map<int, int> z}}ù)
\end{emcppslisting}
    

\noindent A common way this annoyance might show up is using the Standard Library
\lstinline!assert! macro:

\begin{emcppshiddenlisting}[emcppsbatch=e21]
#include <cassert>  // standard C (ù{\codeincomments{assert}}ù) macro
\end{emcppshiddenlisting}
\begin{emcppslisting}[emcppsbatch=e21]
bool operator==(const C&, const C&);

void f(const C& x, int i, int j, int k)
{
   assert(C(i, j, k) == x);  // OK
   assert(C{i, j, k} == x);  // Error, too many arguments to (ù{\codeincomments{assert}}ù) macro
}
\end{emcppslisting}
    

\subsubsection[Default member initializer does not deduce array size]{Default member initializer does not deduce array size}\label{default-member-initializer-does-not-deduce-array-size}

Although the syntax looks the same, default member initializers using
braced-initializer lists do not deduce the size of an array member:

\begin{emcppslisting}
struct S
{
    char s[]{"Idle"};  // Error, must specify array size
};
\end{emcppslisting}
    

\noindent The rationale is that there is no guarantee that the default member
initializer will be used to initialize the member; hence, it cannot be a
definitive source of information about the size of such a member in the
object layout.

\subsubsection[No copy list initialization in member initializer lists]{No copy list initialization in member initializer lists}\label{no-copy-list-initialization-in-member-initializer-lists}

The syntax for base and member initializers allows for both direct
initialization with parentheses (since C++03) and direct list
initialization with braces (since C++11). However, there is no syntax
corresponding to copy list initialization, which would allow member
initializers to report errors for using an unintended explicit
constructor or conversion operator. It would seem relatively intuitive
to extend the syntax to support
\lstinline!=!~\lstinline!{!~\lstinline!...!~\lstinline!}! for member initializers to
support such use, but so far there have been no proposals to add this
feature to the language. That may be a sign that there is simply no
demand, and the authors of this book are the only ones annoyed since
this is the only part of the language that supports \emph{direct}
initializations without a corresponding syntax for \emph{copy}
initializations.

\begin{emcppshiddenlisting}[emcppsbatch=e22]
// --- Replace
    , c = (i,i)  // Error, copy list initialization is not allowed.
    , c(i,i)
// --- End
\end{emcppshiddenlisting}
\begin{emcppslisting}[emcppsbatch=e22]
class C
{
public:
    explicit C(int);
    C(int, int);
};

class X
{
    C a;
    C b;
    C c;

public:
    X(int i)
    : a(i)       // OK, direct initialization
    , b(i)       // OK, direct list initialization
    , c = (i,i)  // Error, copy list initialization is not allowed.
    {
    }
};
\end{emcppslisting}
    

\subsubsection[Accidental meaning for explicit constructors passed multiple arguments]{Accidental meaning for explicit constructors passed multiple arguments}\label{accidental-meaning-for-explicit-constructors-passed-multiple-arguments}

In C++03, marking a default or multi-argument constructor explicit,
typically as a result of supplying default arguments, had no useful
meaning, and compilers did not warn about them because they were
harmless. However, C++11 takes notice of the \lstinline!explicit! keyword
for such constructors when invoked by copy list initialization. This
design point is generally not considered when migrating code from C++03
to C++11 and may require programmers to invest more thought, and
potentially split constructors with multiple default arguments into
multiple constructors, applying \lstinline!explicit! to only the intended
overloads:

\begin{emcppslisting}
class C
{
public:
    explicit C(int = 0, int = 0, int = 0);
};

C c0 = {};       // Error, constructor is (ù{\codeincomments{explicit}}ù).
C c1 = {1};      // Error, constructor is (ù{\codeincomments{explicit}}ù).
C c2 = {1,2};    // Error, constructor is (ù{\codeincomments{explicit}}ù).
C c3 = {1,2,3};  // Error, constructor is (ù{\codeincomments{explicit}}ù).

class D
{
public:
    D();
    explicit D(int i) : D(i, 0) { }  // delegating constructor
    D(int, int, int = 0);
};

D d0 = {};       // OK
D d1 = {1};      // Error, constructor is (ù{\codeincomments{explicit}}ù).
D d2 = {1,2};    // OK
D d3 = {1,2,3};  // OK

C f(int i, C arg)
{
    switch (i)
    {
        case 0: return {};         // Error, constructor is (ù{\codeincomments{explicit}}ù).
        case 1: return {1};        // Error, constructor is (ù{\codeincomments{explicit}}ù).
        case 2: return {1, 2};     // Error, constructor is (ù{\codeincomments{explicit}}ù).
        case 3: return {1, 2, 3};  // Error, constructor is (ù{\codeincomments{explicit}}ù).
    }
}

D g(int i, D arg)
{
    switch (i)
    {
      case 0: return {};         // OK
      case 1: return {1};        // Error, constructor is (ù{\codeincomments{explicit}}ù).
      case 2: return {1, 2};     // OK
      case 3: return {1, 2, 3};  // OK
    }
}

void test()
{
    f(0, {});         // Error, constructor is (ù{\codeincomments{explicit}}ù).
    f(0, {1});        // Error, constructor is (ù{\codeincomments{explicit}}ù).
    f(0, {1, 2});     // Error, constructor is (ù{\codeincomments{explicit}}ù).
    f(0, {1, 2, 3});  // Error, constructor is (ù{\codeincomments{explicit}}ù).

    g(0, {});         // OK
    g(0, {1});        // Error, constructor is (ù{\codeincomments{explicit}}ù).
    g(0, {1, 2});     // OK
    g(0, {1, 2, 3});  // OK
}
\end{emcppslisting}
    

\noindent Note that this topic is deemed an annoyance, rather than a pitfall,
because it affects only newly written C++11 (or later) code using the
new forms of initialization syntax, so it does not break existing C++03
code recompiled with a more modern language dialect. However, also note
that many containers and other types in the C++ Standard Library
inherited such a design and have not been refactored into multiple
constructors (although some such refactoring occurs in later standards).

\subsubsection[Obfuscation due to opaque use of braced-list]{Obfuscation due to opaque use of braced-list}\label{obfuscation-due-to-opaque-use-of-braced-list}

Use of braced initializers for function arguments, omitting any hint of
the expected object type at the call site, requires deep familiarity
with functions being called in order to understand the actual types of
arguments being initialized, especially when overload resolution must
disambiguate several viable candidates. Such usage may produce more
fragile code as further overloads are added, silently changing the type
initialized by the brace list as a different function wins overload
resolution. Such code is also much harder for a subsequent maintainer,
or casual code reader, to understand:

\begin{emcppslisting}
#include <initializer_list>  // (ù{\codeincomments{std::initializer\_list}}ù)

struct C
{
    C(int, int) { }
};

int test(C, long) { return 0; }

int main()
{
    int a = test({1, 2}, 3);
    return a;
}
\end{emcppslisting}
    

\noindent This program compiles and runs, returning the intended result. However,
consider how the behavior changes if we add a second overload during
subsequent maintenance:

\begin{emcppslisting}[emcppsbatch=e23]
#include <initializer_list>  // (ù{\codeincomments{std::initializer\_list}}ù)

struct C
{
    C(int, int) { }
};

int test(C, long) { return 0; }

struct A  // additional aggregate class
{
    int x;
    int y;
};

int test(A, int) { return -1; }  // overload for the aggregate class

int callTest1()
{
    int a = test({1, 2}, 3);     // overload resolution prefers the aggregate
    return a;
}
\end{emcppslisting}
    

\noindent Because the overload for \lstinline!A! must now be considered, overload
resolution may pick a different result. If we are lucky, then the choice
of the \lstinline!A! and \lstinline!C! overloads becomes ambiguous, and an
error is diagnosed. However, in this case, there was an integer
promotion on the second argument, and the new \lstinline!A! overload is now
the stronger match, producing a different program result. If this
overload is added through maintenance of an included header file, this
code will have silently changed meaning without touching the file. If
the above flexibility is not the desired intent, the simple way to avoid
this risk is to always name the type of any temporary variables:

\begin{emcppslisting}[emcppsbatch=e23]
int callTest2()
{
    int a = test(C{1,2}, 3);  // Overload resolution prefers (ù{\codeincomments{struct C}}ù).
    return a;
}
\end{emcppslisting}
    

\subsubsection[\lstinline!auto! deduction and braced initialization]{{\SubsubsecCode auto} deduction and braced initialization}\label{auto-deduction-and-braced-initialization}

C++11 introduces type inference, where an object's type is deduced from
its initialization, using the \lstinline!auto! keyword (see \featureref{\locationc}{auto-feature}). When presented with a homogeneous, nonempty list using
\emph{copy} list initialization, \lstinline!auto! will deduce the type of
the supplied argument list as an \lstinline!std::initializer_list! of the
same type as the list values. When presented with a braced list of a
single value using \emph{direct} list initialization, \lstinline!auto! will
deduce the variable type as the same type as the list value:

\begin{emcppslisting}
#include <initializer_list>  // (ù{\codeincomments{std::initializer\_list}}ù)

auto g{1};         // OK, deduces (ù{\codeincomments{g}}ù) is (ù{\codeincomments{int}}ù)
auto h{1, 2, 3};     // Error, (ù{\codeincomments{auto}}ù) requires exactly one element in brace list
auto i = {1};      // OK, deduces (ù{\codeincomments{i}}ù) is (ù{\codeincomments{initializer\_list<int>}}ù)
auto j = {1, 2, 3};  // OK, deduces (ù{\codeincomments{j}}ù) is (ù{\codeincomments{initializer\_list<int>}}ù)
\end{emcppslisting}
    

\noindent Note that the declarations of \lstinline!i! and \lstinline!j! in the code
example above would also be errors if the \lstinline!<initializer_list>!
header had not been included to supply the
\lstinline!std::initializer_list! class template.

Finally, observe that for \lstinline!auto! deduction from \emph{direct}
list initialization, an \lstinline!initializer_list! constructor may still
be called in preference to copy constructors, even though the syntax
seems restricted to making copies:

\begin{emcppslisting}
#include <iostream>          // (ù{\codeincomments{std::cout}}ù)
#include <initializer_list>  // (ù{\codeincomments{std::initializer\_list}}ù)

struct S
{
    S() { }
    S(std::initializer_list<S>) { std::cout << "init list\n";}
    S(const S&) { std::cout << "copy\n";}
};

int main()
{
    S s;
    auto s2{s};  // (ù{\codeincomments{std::initializer\_list<S>}}ù) constructor is called after
                 // deduction. (Note: (ù{\codeincomments{s2}}ù) is deduced to be of type (ù{\codeincomments{S}}ù).)
}
\end{emcppslisting}
    

\subsubsection[Compound assignment but not arithmetic operators accept braced lists]{Compound assignment but not arithmetic operators accept braced lists}\label{compound-assignment-but-not-arithmetic-operators-accept-braced-lists}

Braced initializers can be used to provide arguments to the assignment
operator and additionally to compound assignment operators such as
\lstinline!+=!, where they are treated as calls to the overloaded operator
function for class types, or as \lstinline!+=!~\lstinline!T{value}! for a
scalar type \lstinline!T!.{\cprotect\footnote{Although valid, the two
  \lstinline!x!~\lstinline!+=!~\lstinline!{3}! and
  \lstinline!x!~\lstinline!*=!~\lstinline!{3}! lines in the example compile
  successfully on Clang but not on GCC or MSVC (applies to all versions
  at the time of writing). The C++11 standard currently states: 
  \begin{quote}
  A braced-init-list may appear on the right-hand side of
  \begin{itemize}
  \item[---~]{an assignment to a scalar, in which case the initializer list
  shall have at most a single element. The meaning of
  \lstinline!x={v}!, where \lstinline!T! is the scalar
  type of the expression \lstinline!x!, is that of
  \lstinline!x=T{v}!. The meaning of
  \lstinline!x={}! is
  \lstinline!x=T{}!}
  \end{itemize}
  \end{quote} 
  (\cite{cpp11}, paragraph~9, section~5.17, ``Assignment and Compound Assignment Operators," p.~126). There is currently a defect
  report due to clarify the Standard and explicitly state that this rule
  also applies to compound assignments (see \cite{miller12} and
  \cite{miller21}).}} Note
that assigning to scalars supports brace lists of no more than a single
element and does not support compound assignment for pointer types,
since the brace lists are converted to a pointer type, which cannot
appear on the right-hand side of a compound assignment operator.

While the intent of compounded assignment is to be semantically
equivalent to the expression
\lstinline!a!~\lstinline!=!~\lstinline!a!~\lstinline!+!~\lstinline!b! (or
\lstinline!*!~\lstinline!b!, or \lstinline!-!~\lstinline!b!, and so on), brace lists
cannot be used in regular arithmetic expressions since the grammar does
not support brace lists as arbitrary expressions:

\begin{emcppslisting}
#include <initializer_list>  // (ù{\codeincomments{std::initializer\_list}}ù)

struct S
{
    S(std::initializer_list<int>) { }
    S& operator+=(const S&) { return *this; }
};

S operator+(const S&, const S&) { return S{}; }

void demo()
{
    S s1{};               // OK, calls (ù{\codeincomments{initializer\_list}}ù) constructor
    s1 += {1,2,3};        // OK, equivalent to (ù{\codeincomments{s1.operator+=(\{1,2,3\})}}ù)
    s1 = s1 + {1, 2, 3};  // Error, expecting an expression, not an (ù{\codeincomments{std::initializer\_list}}ù)
    s1 = operator+(s1, {1,2,3}); // OK, braces are allowed as function argument.

    int x = 0;
    x += {3};    // OK, equivalent to (ù{\codeincomments{x += int\{3\};}}ù).[^cwg_1542].
    x *= {5};    // OK, equivalent to (ù{\codeincomments{x *= int\{5\};}}ù).[^cwg_1542].

    char y[4] = {1, 2, 3, 4};
    char*p = +y;
    p += {3};    // Error,  equivalent to (ù{\codeincomments{p += (char*)\{3\};}}ù)
}
\end{emcppslisting}
    

\subsection[See Also]{See Also}\label{see-also}

TODO: Add see also items. Pulled from the feature:
\begin{itemize}
\item{\seealsoref{deleted-functions}{\seealsolocationa}}
\item{\seealsoref{explicit-conversion-operators}{\seealsolocationa}}
\item{\seealsoref{thread-safe-function-static-variables}{\seealsolocationa}}
\item{\seealsoref{long-long}{\seealsolocationa}}
\item{\seealsoref{null-pointer-literal-(nullptr)}{\seealsolocationa}}
\item{\seealsoref{initlist}{\seealsolocationc}}
\item{\seealsoref{Rvalue-References}{\seealsolocationc}}
\item{Implicit move (unknown what this was intended to be)}
\item{\seealsoref{Default-Member-Initializers}{\seealsolocationc}}
\item{perfect forwarding (unknown what this was intended to be) }
\item{\seealsoref{variadictemplate}{\seealsolocationc}}
\item{\seealsoref{auto-feature}{\seealsolocationc}}
\end{itemize}

\subsection[Further Reading]{Further Reading}\label{further-reading}

TBD



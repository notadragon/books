
% 01 Feb, 2021 JMB - packet 4 compilation fixes


\emcppsFeature{
    short={Opaque \lstinline!enum!s},
    tocshort={Opaque {\TOCCode enum}s},
    long={Opaque Enumeration Declarations},
    rhshort={Opaque {\RHCode enum}s},
}{enumopaque}
\label{opaque-enumeration-declarations}
\setcounter{table}{0}
\setcounter{footnote}{0}
\setcounter{lstlisting}{0}
%\section[Opaque {\tt enum}s]{Opaque Enumeration Declarations}\label{enumopaque}\label{opaque-enumeration-declarations}


Enumerated types, such as an \lstinline!enum! or \lstinline!enum! class (see \featureref{\locationc}{enumclass}), whose underlying type (see \featureref{\locationc}{explicit-enumeration-underlying-type}) is well-specified, can be
declared without being defined, i.e., declared without its enumerators.

\subsection[Description]{Description}\label{description}

We identify two distinct forms of \emcppsgloss[opaque declaration]{opaque declarations}, i.e.,
declarations that are not also definitions:
\begin{enumerate}
\item{A \emcppsgloss{forward declaration} has some translation unit in which the full definition and that declaration both appear. This can be a declaration in a header file where the definition is in the same header or in the corresponding implementation file. It can also be a declaration that appears in the same implementation file as the corresponding definition.}
\item{A \emcppsgloss{local declaration} has no translation unit that includes both that declaration and the corresponding full definition.}
\end{enumerate}

A classic (C++03) C-style \lstinline!enum! cannot have \emcppsgloss[opaque declaration]{opaque declarations}, nor can its definition be repeated within the same
\emcppsgloss{translation unit} (TU):

\begin{emcppslisting}
enum E0;                 // Error, opaque declaration
enum    { e_A0, e_B0 };  // OK, anonymous classic (only) (ù{\codeincomments{enum}}ù)
enum E1 { e_A1, e_B1 };  // OK, definition
enum E1;                 // OK, redeclaration in same TU
enum E2 { e_A2, e_B2 };  // OK, definition
enum E2 { e_A2, e_B2 };  // Error, redefinition in same TU
\end{emcppslisting}

\noindent The underlying integral types used to represent objects of each of the
(classic) enumerations in the example above is \emcppsgloss{implementation defined}, making
all of them ineligible for \emcppsgloss{opaque declaration}. This restriction
on \emcppsgloss[opaque declaration]{opaque declarations} exists because the specific values of
the enumerators might affect the underlying type %(see \featureref{\locationc}{explicit-enumeration-underlying-type})
(e.g.,
size, alignment, \lstinline!signed!ness), and therefore the declaration
alone cannot be used to create objects of that type. A declaration that
specifies the underlying type or a full definition can, however, be used
to create objects of that type. Specifying an underlying
type %(see \featureref{\locationc}{explicit-enumeration-underlying-type})
explicitly makes \emcppsgloss{opaque declaration} possible:

\begin{emcppslisting}[emcppsbatch=e1]
enum    : char { e_A, e_B };     // OK, (anonymous) complete definition
enum E3 : char;                  // OK, forward declaration w/underlying type
enum E3 : char { e_A3, e_B3 };   // OK, compatible complete definition
enum E4 : short { e_A4, e_B4 };  // OK, complete definition
enum E4 : short;                 // OK, compatible opaque redeclaration
enum E4 : int;                   // Error, incompatible opaque redeclaration
enum E5 : int { e_A5, e_B5 };    // OK, complete definition
enum E5 : int { e_A5, e_B5 };    // Error, complete redefinition in same TU
\end{emcppslisting}

\noindent The modern (C++11) \lstinline!enum!~\lstinline!class!, %(see \featureref{\locationc}{enumclass}),
which
provides its enumerators with (1) stronger typing and (2) an enclosing
scope, also comes with a default \emcppsgloss{underlying type} of
\lstinline!int!, thereby making it eligible to be declared without a
definition (even without explicit qualification):

\begin{emcppslisting}[emcppsbatch=e1]
enum class E6;                 // OK, implicit underlying type ((ù{\codeincomments{int}}ù))
enum class E6 : int;           // OK, explicit matching underlying type
enum class E6 { e_A3, e_B3 };  // OK, compatible complete definition
enum class E7 { e_A4, e_B4 };  // OK, complete definition, (ù{\codeincomments{int}}ù) underlying type
enum class E7;                 // OK, compatible opaque redeclaration
enum class E7 : short;         // Error, incompatible opaque redeclaration
enum class E8 : long;          // OK, opaque declaration, (ù{\codeincomments{long}}ù) underlying type
enum class E8 : long { e_A5 }; // OK, compatible complete definition
enum class E9 { e_A6, e_B7 };  // OK, complete definition
enum class E9 { e_A6, e_B7 };  // Error, complete redefinition in same TU
enum class    { e_A, e_B };    // Error, anonymous (ù{\codeincomments{enum}}ù) classes are not allowed
\end{emcppslisting}

\noindent To summarize, each classical \lstinline!enum! type having an explicitly
specified \emcppsgloss{underlying type} and every modern \lstinline!enum!~\lstinline!class! type can be declared (e.g., for the first
time in a TU) as a \emcppsgloss{complete type}:

\begin{emcppslisting}[emcppsbatch=e1]
enum E10 : char;  static_assert(sizeof(E10)  == 1);
enum class E11;   static_assert(sizeof(E11) == sizeof(int));

E10 a;            static_assert(sizeof a == 1);
E11 b;            static_assert(sizeof b == sizeof(int));
\end{emcppslisting}

\noindent Typical usage of opaque enumerations often involves placing the
\emcppsgloss{forward declaration} within a header and sequestering the
complete definition within a corresponding \lstinline!.cpp! (or else a
second header), thereby \emcppsgloss{insulating} (at least some) clients from
changes to the enumerator list (see \intraref{use-cases-opaqueenum}{using-opaque-enumerations-within-a-header-file}):

\begin{emcppslisting}
// mycomponent.h:
// ...
enum E9 : char;   // forward declaration of (ù{\codeincomments{enum E9}}ù)
enum class E10;   // forward declaration of (ù{\codeincomments{enum class E10}}ù)


// mycomponent.cpp:
#include <mycomponent.h>
// ...
enum E9 : char { e_A9, e_B9, e_C9 };
    // complete definition compatible with forward declaration of (ù{\codeincomments{E9}}ù)

enum class E10 { e_A10, e_B10, e_C10 };
    // complete definition compatible with forward declaration of (ù{\codeincomments{E10}}ù)
\end{emcppslisting}

\noindent Note, however, that clients embedding \emph{local declarations} directly
in their code can be problematic; see \intraref{potential-pitfalls-opaqueenum}{redeclaring-an-externally-defined-enumeration-locally}.

\subsection[Use Cases]{Use Cases}\label{use-cases-opaqueenum}

\subsubsection[Using opaque enumerations within a header file]{Using opaque enumerations within a header file}\label{using-opaque-enumerations-within-a-header-file}

\emcppsgloss[physical design]{Physical design} involves two related but distinct notions of
information \emph{hiding}: \emcppsgloss{encapsulation} and \emcppsgloss{insulation}.
An implementation detail is \emph{encapsulated} if changing it (in a
semantically compatible way) does not require clients to rework their
code but might require them to recompile it.

An \emph{insulated} implementation detail, on the other hand, can be
altered compatibly \emph{without} forcing clients even to recompile.
The advantages of avoiding such \emcppsgloss[compile time coupling]{compile-time coupling} transcend
merely reducing compile time. For larger codebases in which various
layers are managed under different release cycles, making a change to an
\emph{insulated} detail can be done with a \lstinline!.o! patch and a
relink the same day, whereas an \emph{uninsulated} change might
precipitate a waterfall of releases spanning days, weeks, or even
longer.

As a first example of \emcppsgloss[opaque enumeration]{opaque-enumeration} usage, consider a
non-\emph{value-semantic} \emcppsgloss{mechanism} class, \lstinline!Proctor!,
implemented as a finite-state machine:

\begin{emcppslisting}[emcppsbatch=e2]
// proctor.h:
// ...
class Proctor
{
    int d_current;  // "opaque" but unconstrained (ù{\codeincomments{int}}ù) type (BAD IDEA)
    // ...

public:
    Proctor();
    // ...
};
\end{emcppslisting}

\noindent Among other private members, \lstinline!Proctor! has a data member,
\lstinline!d_current!, representing the current enumerated state of
the object. We anticipate that the implementation of the underlying
state machine will change regularly over time but that the
\lstinline!public! interface is relatively stable. We will, therefore, want
to ensure that all parts of the implementation that are likely to change
reside outside of the header. Hence, the complete definition of the
enumeration of the states (including the enumerator list itself) is
sequestered within the corresponding \lstinline!.cpp! file:

\begin{emcppslisting}[emcppsbatch=e2]
// proctor.cpp:
#include <proctor.h>

enum State { e_STARTING, e_READY, e_RUNNING, e_DONE };
Proctor::Proctor() : d_current(e_STARTING) { /* ... */ }
// ...
\end{emcppslisting}

\noindent Prior to C++11, enumerations could not be \emcppsgloss{forward declared}. To
avoid exposing (in a header file) enumerators that were used only
privately (in the \lstinline!.cpp! file), a completely unconstrained
\lstinline!int! would be used as a data member to represent the state. With
the advent of modern C++, we now have better options. First, we might
consider adding an explicit underlying type to the enumeration in the
\lstinline!.cpp! file:

\begin{emcppshiddenlisting}[emcppsbatch=e3]
// proctor.h:
// duplicate for second example cpp file below
class Proctor
{
    int d_current;
public:
    Proctor();
};
\end{emcppshiddenlisting}
\begin{emcppslisting}[emcppsbatch=e3]
// proctor.cpp:
#include <proctor.h>

enum State : int { e_STARTING, e_READY, e_RUNNING, e_DONE };
Proctor::Proctor() : d_current(e_STARTING) { /* ... */ }
// ...
\end{emcppslisting}

\noindent Now that the \emcppsgloss[component local]{component-local} \lstinline!enum! has an explicit
underlying type, we can \emcppsgloss{forward declare} it in the header file.
The existence of \lstinline!proctor.cpp!, which includes
\lstinline!proctor.h!, makes this declaration a \emph{forward declaration}
and not just an \emph{opaque declaration}. Compilation of
\lstinline!proctor.cpp! guarantees that the declaration and definition are
compatible. Having this \emph{forward declaration} improves (somewhat)
our type safety:

\begin{emcppslisting}[emcppsbatch=e4]
// proctor.h:
// ...
enum State : int;  // opaque declaration of enumeration (new in C++11)

class Proctor
{
    State d_current;  // opaque classical enumerated type (BETTER IDEA)
    // ...

public:
    Proctor();
    // ...
};
\end{emcppslisting}

\noindent But we can do even better. First we will want to nest the enumerated
\lstinline!State! type within the private section of the proctor to avoid
needless namespace pollution. What's more, because the numerical values
of the enumerators are not relevant, we can more closely model our
intent by nesting a more strongly typed \lstinline!enum!~\lstinline!class! instead:

\begin{emcppslisting}[emcppsbatch=e5]
// proctor.h:
// ...
class Proctor
{
    enum class State;  // forward (nested) declaration of type-safe enumeration
    State d_current;   // opaque (modern) enumerated data type (BEST IDEA)
    // ...

public:
    Proctor();
    // ...
};
\end{emcppslisting}

\noindent We would then declare the nested
\lstinline!enum!~\lstinline!class! %(see \featureref{\locationc}{enumclass})
accordingly in the
\lstinline!.cpp! file:

\begin{emcppslisting}[emcppsbatch=e5]
// proctor.cpp:
#include <proctor.h>

enum class Proctor::State { e_STARTING, e_READY, e_RUNNING, e_DONE };
Proctor::Proctor() : d_current(State::e_STARTING) { /* ... */ }
// ...
\end{emcppslisting}

\noindent Finally, notice that in this example we first \emph{forward declared}
the nested \lstinline!enum!~\lstinline!class! type within class scope and
then in a separate statement defined a data member of the opaque
enumerated type. We needed to do this in two statements because
simultaneously \emph{opaquely declaring} either a classic \lstinline!enum!
having an explicit underlying type %(see \featureref{\locationc}{explicit-enumeration-underlying-type})
or an
\lstinline!enum!~\lstinline!class! %(see \featureref{\locationc}{enumclass})
and also defining an object
of that type in a single statement is not possible:

\begin{emcppslisting}
enum E1 : int e1;  // Error, syntax not supported
enum class E2 e2;  // Error,    "    "     "
\end{emcppslisting}

\noindent Fully defining an enumeration and simultaneously defining an object of
the type in one stroke is, however, possible:

\begin{emcppslisting}
enum E3 : int { e_A, e_B } e3;  // OK, full type definition + object definition
enum class E4 { e_A, e_B } e4;  // OK,  "    "       "      "   "        "
\end{emcppslisting}

\noindent Providing such a full definition, however, would have run counter to our
intention to \emcppsgloss{insulate} the enumerator list of
\lstinline!Proctor::State! from clients \lstinline!#include!ing the header
file defining \lstinline!Proctor!.

\subsubsection[Cookie: Insulating all external clients from the enumerator list]{Cookie: Insulating all external clients from the enumerator list}\label{cookie:-insulating-all-external-clients-from-the-enumerator-list}

A commonly recurring \emcppsgloss{design pattern}, commonly known as the
``Memento pattern,"\footnote{\cite{gamma95}, Chapter 5, section ``Memento,'' pp.~283--???} manifests when a facility providing a service, often in a
multi-client environment, hands off a packet of opaque information ---
a.k.a. a \emcppsgloss{cookie} --- to a client to hold and then present back to
the facility to enable resuming operations where processing left off.
Since the information within the cookie will not be used substantively
by the client, any unnecessary compile-time coupling of clients with the
implementation of that cookie serves only to impede fluid
maintainability of the facility issuing the cookie. With respect
to not just \emph{encapsulating} but \emph{insulating} pure
implementation details that are held but not used substantively by
clients, we offer this Memento pattern as a possible use case
for \emcppsgloss[opaque enumeration]{opaque enumerations}.

Event-driven programming,\footnote{See also \cite{gamma95}, Chapter 5, section ``Observer,''  pp.~293--???} historically implemented using \emcppsgloss{callback functions}, introduces a style of programming that is decidedly
different from that to which we might have become accustomed. In this
programming paradigm, a higher-level agent (e.g., \lstinline!main!) would
begin by instantiating an \lstinline!Engine! that will be responsible for
monitoring for events and invoking provided callbacks when appropriate.
Classically, clients might have registered a function pointer and a
corresponding pointer to a client-defined piece of identifying data, but
here we will make use of a C++11 Standard Library type,
\lstinline!std::function!, which can encapsulate arbitrary callable
function objects and their associated state. This callback will be
provided one object to represent the event that just happened and
another object that can be used opaquely to reregister interest in the
same event again.

This opaque cookie and passing around of the client state might seem
like an unnecessary step, but often the event management involved in
software of this sort is wrapping the most often executed code in very
busy systems, and performance of each basic operation is therefore very
important. To maximize performance, every potential branch or lookup in
an internal data structure must be minimized, and allowing clients to
pass back the internal state of the engine when reregistering can
greatly reduce the engine's work to continue a client's processing of
events without tearing down and rebuilding all client state each time an
event happens. More importantly, event managers such as this often
become highly concurrent to take advantage of modern hardware, so
performant manipulation of their own data structures and well-defined
lifetime of the objects they interact with become paramount. This makes
the simple guarantee of, ``If you don't reregister, then the engine will
clean everything up; if you do, then the callback function will continue
its lifetime,'' a very tractable paradigm to follow.

\begin{emcppslisting}[emcppsbatch=e6]
// callbackengine.h:
#include <deque>          // (ù{\codeincomments{std::deque}}ù)
#include <functional>     // (ù{\codeincomments{std::function}}ù)

class EventData;       // information that clients will need to process an event
class CallbackEngine;  // the driver for processing and delivering events

class CallbackData
{
    // This class represents a handle to the shared state associating a
    // callback function object with a (ù{\codeincomments{CallbackEngine}}ù).

public:
    typedef std::function<void(const EventData&, CallbackEngine*,
        CallbackData)> Callback;
        // alias for a function object returning (ù{\codeincomments{void}}ù) and taking, as arguments,
        // the event data to be consumed by the client, the address of the
        // (ù{\codeincomments{CallbackEngine}}ù) object that supplied the event data, and the
        // callback data that can be used to reregister the client, should the
        // client choose to show continued interest in future instances of the
        // same event

    enum class State;  // GOOD IDEA
        // nested forward declaration of insulated enumeration, enabling
        // changes to the enumerator list without forcing clients to recompile

private:
    // ... (a smart pointer to an opaque object containing the state and the
    //      callback to invoke)

public:
    CallbackData(const Callback &cb, State init);

    // ... (constructors, other manipulators and accessors, etc.)

    State getState() const;
        // Return the current (ù{\codeincomments{state}}ù) of this callback.

    void setState(State state) const;
        // Set the current state to the specified (ù{\codeincomments{state}}ù).

    Callback& getCallback() const;
        // Return the (ù{\codeincomments{callback}}ù) function object specified at construction.
};

class CallbackEngine
{
private:
    // ... (other, stable (ù{\codeincomments{private}}ù) data members implementing this object)

    bool d_running;  // active state

    std::deque<CallbackData> d_pendingCallbacks;
        // The collection of clients currently registered for interest, or having
        // callbacks delivered, with this (ù{\codeincomments{CallbackEngine}}ù).
        //
        // Reregistering or skipping reregistering when
        // called back will lead to updating internal data structures based on
        // the current value of this (ù{\codeincomments{State}}ù).

public:
    // ...   (other public member functions, e.g., creators, manipulators)

    void registerInterest(CallbackData::Callback cb);
        // Register (e.g., from (ù{\codeincomments{main}}ù)) a new client with this manager object.

    void reregisterInterest(const CallbackData& callback);
        // Reregister (e.g., from a client) the specified (ù{\codeincomments{callback}}ù) with this
        // manager object, providing the (ù{\codeincomments{state}}ù) contained in the (ù{\codeincomments{CallbackData}}ù)
        // to enable resumption from the same state as processing left off.

    void run();
        // Start this object's event loop.

    // ...  (other public member functions, e.g., manipulators, accessors)
};
\end{emcppslisting}

\noindent A client would, in \lstinline!main!, create an instance of this
\lstinline!CallbackEngine!, define the appropriate functions to be invoked
when events happen, register interest, and then let the engine
\lstinline!run!:

\begin{emcppslisting}[emcppsbatch=e6]
// myapplication.cpp:
// ...
#include <callbackengine.h>

static void myCallback(const EventData&    event,
                       CallbackEngine*     engine,
                       const CallbackData& cookie);
    // Process the specified (ù{\codeincomments{event}}ù), and then potentially reregister the
    // specified (ù{\codeincomments{cookie}}ù) for interest in the same data.

int main()
{
   CallbackEngine e;  // Create a configurable callback engine object.

   //...     (Configure the callback engine, (ù{\codeincomments{e}}ù), as appropriate.)

   e.registerInterest(&myCallback);  // Even a stateless function pointer can
                                     // be used with (ù{\codeincomments{std::function}}ù).

   // ...create and register other clients for interest...

   e.run();    // Cede control to (ù{\codeincomments{e}}ù)'s event loop until complete.

   return 0;
}
\end{emcppslisting}

\noindent The implementation of \lstinline!myCallback!, in the example below, is then
free to reregister interest in the same event, save the cookie elsewhere
to reregister at a later time, or complete its task and let the
\lstinline!CallbackEngine! take care of properly cleaning up all now
unnecessary resources:

\begin{emcppshiddenlisting}[emcppsbatch=e6]
// myapplication.cpp:
struct EventProcessor {
    static int processEvent(const EventData &event);
    static void storeCallback(CallbackEngine *, const CallbackData&);
};
\end{emcppshiddenlisting}
\begin{emcppslisting}[emcppsbatch=e6,emcppsoutputfile=myapplication.cpp]
void myCallback(const EventData&     event,
                CallbackEngine      *engine,
                const CallbackData&  cookie)
{
    int status = EventProcessor::processEvent(event);

    if (status > 0)  // status is non-zero; continue interest in event
    {
        engine->reregisterInterest(cookie);
    }
    else if (status < 0)  // Negative status indicates (ù{\codeincomments{EventProcessor}}ù) wants
                          // to reregister later.
    {
        EventProcessor::storeCallback(engine,cookie);
                          // Call (ù{\codeincomments{reregisterInterest}}ù) later.
    }

    // Return flow of control to the (ù{\codeincomments{CallbackEngine}}ù) that invoked this
    // callback.  If (ù{\codeincomments{status}}ù) was zero, then this callback should be cleaned
    // up properly with minimal fuss and no leaks.
}
\end{emcppslisting}

\noindent What makes use of the \emcppsgloss{opaque enumeration} here especially apt is
that the internal data structures maintained by the
\lstinline!CallbackEngine! might be very subtly interrelated, and any
knowledge of a client's relationship to those data structures that can
be maintained through callbacks is going to reduce the amount of lookups
and synchronization that would be needed to correctly reregister a
client without that information. The otherwise wide contract on
\lstinline!reregisterInterest! means that clients have no need themselves
to directly know anything about the actual values of the \lstinline!State!
they might be in. More notably, a component like this is likely to be
very heavily reused across a large codebase, and being able to maintain
it while minimizing the need for clients to recompile can be a huge boon
to deployment times.

To see what is involved, we can consider the business end of the
\lstinline!CallbackEngine! implementation and an outline of what a
single-threaded implementation might involve:

\begin{emcppshiddenlisting}[emcppsbatch=e6]
// callbackengine.cpp:
class EventData
{
};
EventData getNextEvent();
\end{emcppshiddenlisting}
\begin{emcppslisting}[emcppsbatch=e6]
// callbackengine.cpp:
#include <callbackengine.h>

enum class CallbackData::State
{
    // Full (local) definition of the enumerated states for the callback engine.
    e_INITIAL,
    e_LISTENING,
    e_READY,
    e_PROCESSING,
    e_REREGISTERED,
    e_FREED
};

void CallbackEngine::registerInterest(CallbackData::Callback cb)
{
    // Create a (ù{\codeincomments{CallbackData}}ù) instance with a state of (ù{\codeincomments{e\_INITIAL}}ù) and
    // insert it into the set of active clients.
    d_pendingCallbacks.push_back(CallbackData(cb, CallbackData::State::e_INITIAL));
}

void CallbackEngine::run()
{
    // Update all client states to (ù{\codeincomments{e\_LISTENING}}ù) based on the events in which
    // they have interest.

    d_running = true;
    while (d_running)
    {
        // Poll the operating system API waiting for an event to be ready.
        EventData event = getNextEvent();

        // Go through the elements of (ù{\codeincomments{d\_pendingCallbacks}}ù) to deliver this
        // event to each of them.
        std::deque<CallbackData> callbacks = std::move(d_pendingCallbacks);

        // Loop once over the callbacks we are about to notify to update their
        // state so that we know they are now in a different container.
        for (CallbackData& callback : callbacks)
        {
            callback.setState(CallbackData::State::e_READY);
        }

        while (!callbacks.empty())
        {
            CallbackData callback = callbacks.front();
            callbacks.pop_front();

            // Mark the callback as processing and invoke it.
            callback.setState(CallbackData::State::e_PROCESSING);

            callback.getCallback()(event, this, callback);

            // Clean up based on the new (ù{\codeincomments{State}}ù).
            if (callback.getState() == CallbackData::State::e_REREGISTERED)
            {
                // Put the callback on the queue to get events again.
                d_pendingCallbacks.push_back(callback);
            }
            else
            {
                // The callback can be released, freeing resources.
                callback.setState(CallbackData::State::e_FREED);
            }
        }
    }
}

void CallbackEngine::reregisterInterest(const CallbackData& callback)
{
    if (callback.getState() == CallbackData::State::e_PROCESSING)
    {
        // This is being called reentrantly from (ù{\codeincomments{run()}}ù); simply update state.
        callback.setState(CallbackData::State::e_REREGISTERED);
    }
    else if (callback.getState() == CallbackData::State::e_READY)
    {
        // This callback is in the deque of callbacks currently having events
        // delivered to it; do nothing and leave it there.
    }
    else
    {
        // This callback was saved; set it to the proper state and put it in
        // the queue of callbacks.
        if (d_running)
        {
            callback.setState(CallbackData::State::e_LISTENING);
        }
        else
        {
            callback.setState(CallbackData::State::e_INITIAL);
        }

        d_pendingCallbacks.push_back(callback);
    }
}

\end{emcppslisting}

\noindent Note how the definition of \lstinline!CallbackData::State! is visible and
needed only in this implementation file. Also, consider that the set of
states might grow or shrink as this \lstinline!CallbackEngine! is optimized
and extended, and clients can still pass around the object containing
that state in a type-safe manner while remaining insulated from this
definition.

Prior to C++11, we could not have \emph{forward declared} this
enumeration, and so would have had to represent it in a
\emph{type}-\emph{unsafe} way --- e.g., as an \lstinline!int!. Thanks to
the modern \lstinline!enum!~\lstinline!class! (see \featureref{\locationc}{enumclass}), however, we can
conveniently \emcppsgloss{forward declare} it as a nested type and then,
separately, fully define it inside the \lstinline!.cpp! implementing other
noninline member functions of the \lstinline!CallbackEngine! class. In
this way, we are able to \emph{insulate} changes to the enumerator list
along with any other aspects of the implementation defined outside of
the \lstinline!.h! file without forcing any client applications to
recompile. Finally, the basic design of the hypothetical \lstinline!CallbackEngine!
in the previous code example could have been used for any number of
useful components: a parser or tokenizer, a workflow engine, or even a
more generalized event loop.

\subsubsection[Dual-Access: Insulating some external clients from the enumerator list]{Dual-Access: Insulating some external clients from the enumerator list}\label{dual-access:-insulating-some-external-clients-from-the-enumerator-list}

In previous use cases, the goal has been to \emcppsgloss{insulate} \emph{all}
external clients from the enumerators of an enumeration that is visible
(but not necessarily programmatically reachable) in the defining
component's header. Consider the situation in which a \emcppsgloss{component}
(\lstinline!.h!/\lstinline!.cpp! pair) itself defines an enumeration that will
be used by various clients within a single program, some of which will
need access to the enumerators.

When an \lstinline!enum!~\lstinline!class! or a classic \lstinline!enum! having
an explicitly specified underlying type (see \featureref{\locationc}{explicit-enumeration-underlying-type}) is specified in
a header for direct programmatic use, external clients are at liberty to
unilaterally redeclare it \emph{opaquely}, i.e., without its enumerator
list. A compelling motivation for doing so would be for a client who
doesn't make direct use of the enumerators to \emcppsgloss{insulate} itself
and/or its clients from having to recompile whenever the enumerator list
changes.

Embedding any such \emcppsgloss{local declaration} in client code, however,
would be highly problematic: If the underlying type of the declaration
(in one translation unit) were somehow to become inconsistent with that
of the definition (in some other translation unit), any program
incorporating both translation units would immediately become silently
\emcppsgloss[ill formed, no diagnostic required]{ill-formed, no diagnostic required (IFNDR)}; see \intraref{potential-pitfalls-opaqueenum}{redeclaring-an-externally-defined-enumeration-locally}. Unless a separate ``forwarding'' header file is
provided along with (and ideally included by) the header defining the
full enumeration, any client opting to exploit this
opacity feature of an enumerated type will have no alternative but to
redeclare the enumeration locally; see \intraref{potential-pitfalls-opaqueenum}{inciting-local-enumeration-declarations-an-attractive-nuisance}.

For example, consider an \lstinline!enum!~\lstinline!class!, \lstinline!Event!,
intended for public use by external clients:

\begin{emcppslisting}
// event.h:
// ...
enum class Event : char { /*... changes frequently ...*/ };
// ...             ^^^^
\end{emcppslisting}

\noindent Now imagine some client header file, \lstinline!badclient.h!, that makes
use of the \lstinline!Event! enumeration and chooses to avoid compile-time
coupling itself to the enumerator list by
embedding, for whatever reason, a \emcppsgloss{local declaration} of \lstinline!Event! instead:

\begin{emcppslisting}
// badclient.h:
// ...
enum class Event : char;  // BAD IDEA: local external declaration
// ...
struct BadObject
{
    Event d_currentEvent;  // object of locally declare enumeration
    // ...
};
// ...
\end{emcppslisting}

\noindent Imagine now that the number of events that can fit in a \lstinline!char! is
exceeded and we decide to change the definition to have an underlying
type of \lstinline!short!:

\begin{emcppslisting}
// event.h:
// ...
enum class Event : short { /*... changes frequently ...*/ };
// ...             ^^^^^
\end{emcppslisting}

\noindent Client code, such as in \lstinline!badclient.h!, that fails to include the
\lstinline!event.h! header will have no automatic way of knowing that it
needs to change, and recompiling the code for all cases where
\lstinline!event.h! isn't also included in the translation unit will not
fix the problem. Unless every such client is somehow updated manually, a
newly linked program comprising them will be \emcppsgloss{IFNDR} with the likely
consequence of either a crash or (worse) when the program runs and
misbehaves. When providing a programmatically accessible definition of
an enumerated type in a header where the \emcppsgloss{underlying type} is
specified either explicitly or implicitly, we can give external
clients a \emph{safe} alternative to local declaration by also providing
an auxiliary header containing \emph{just} the corresponding opaque
declaration:

\begin{emcppslisting}[emcppsbatch=e7]
// event.fwd.h:
// ...
enum class Event : char;
// ...
\end{emcppslisting}

\noindent Here we have chosen to treat the forwarding header file as part of the same event component as the principal header but with an injected descriptive suffix field, \lstinline!.fwd!; this approach, as opposed to, say, \lstinline!file_fwd.h!, \lstinline!filefwd.h!, or \lstinline!file.hh!, was chosen so as not to (1) encroach on a disciplined, component-naming scheme involving reserved use of underscores\footnote{\cite{lakos20}, section~2.4, pp.~297--333} or (2) confuse tools and scripts that expect header-file names to end with a \lstinline!.h! suffix.

In general, having a forwarding header always included in its
corresponding full header facilitates situations such as default
template arguments where the declaration can appear at most once in any
given translation unit; the only drawback being that the
comparatively small forwarding header file must now also be opened and
parsed if the full header file is included in a given translation
unit. To ensure consistency, we thus \lstinline!#include! this forwarding
header in the original header defining the full enumeration:

\begin{emcppslisting}[emcppsbatch=e7]
// event.h:
// ...                  // Ensure opaque declaration (included here) is
#include <event.fwd.h>  // consistent with complete definition (below).
// ...
enum class Event : char { /*... changes frequently ...*/ };
// ...
\end{emcppslisting}

\noindent In this way, every translation unit that includes the definition will
serve to ensure that the forward declaration and definition match;
hence, clients can incorporate safely only the presumably more stable
forwarding header:

\begin{emcppslisting}[emcppsbatch=e7]
// goodclient.h:
// ...
#include <event.fwd.h>  // GOOD IDEA: consistent opaque declaration
// ...
class Client
{
    Event d_currentEvent;
    // ...
};
\end{emcppslisting}

\noindent Note that we have consistently
employed angle brackets exclusively for all include directives used
throughout this book to maximize flexibility of deployment presuming a
  regimen for unique naming.\footnote{See \cite{lakos20}, section~1.5.1,
  pp.~201--203.}

  To illustrate real-world practical use of the opaque-enumerations
feature, consider the various components{\cprotect\footnote{See
  \cite{lakos20}, sections~1.6 and 1.11, pp.~209--216 and
  pp.~256--259, respectively.}} that might depend
on{\cprotect\footnote{\cite{lakos20}, section~1.9?, pp.~237--243  JOHN: Please consult the book and correct. Section 1.9 is pp 243--251. Section 1.8 is pp. 237--243.}} an \lstinline!Event! enumeration such as that above:
\begin{itemize}
\item{\textbf{\emcppsgloss[message]{\lstinline!message!}} — The component provides a \emph{value-semantic} \lstinline!Message! class consisting of just raw data,\cprotect\footnote{We sometimes refer to data that is meaningful only in the context of a higher-level entity as \emcppsgloss{dumb data}; see \cite{lakos20}, section~3.5.5, pp.~629--633.} including an \lstinline!Event! field representing the type of event. This component never makes direct use of any enumeration values and thus needs to include only \lstinline!event.fwd.h! and the corresponding opaque \emph{forward} declaration of the \lstinline!Event! enumeration.}
\item{\textbf{\emcppsgloss[sender]{\lstinline!sender!} and \emcppsgloss[receiver]{\lstinline!receiver!}} — These are a pair of components that, respectively, create and consume \lstinline!Message! objects. To populate a \lstinline!Message! object, a \lstinline!Sender! will need to provide a valid value for the \lstinline!Event! member. Similarly, to process a \lstinline!Message!, a \lstinline!Receiver! will need to understand the potential individual enumerated values for the \lstinline!Event! field. Both of these components will include the primary \lstinline!event.h! header and thus have the complete definition of \lstinline!Event! available to them.}
\item{\textbf{\emcppsgloss[messenger]{\lstinline!messenger!}} — The final component, a general engine capable of being handed \lstinline!Message! objects by a \lstinline!Sender! and then delivering those objects in an appropriate fashion to a \lstinline!Receiver!, needs a complete and usable definition of \lstinline!Message! objects — possibly copying them or storing them in containers before delivery — but has no need for understanding the possible values of the \lstinline!Event! member within those \lstinline!Message! objects. This component can participate fully and correctly in the larger system while being completely \emph{insulated} from the enumeration values of the \lstinline!Event! enumeration.}
\end{itemize}
tl;dr: By factoring out the \lstinline!Event! enumeration into its own
separate component and providing two distinct but compatible headers,
one containing the opaque declaration and the other (which includes the
first) providing the complete definition, we enable having different
components choose not to compile-time couple themselves with the
enumerator list without forcing them to (\emph{unsafely}) redeclare the
enumeration locally.

\subsection[Potential Pitfalls]{Potential Pitfalls}\label{potential-pitfalls-opaqueenum}

\subsubsection[Redeclaring an externally defined enumeration locally]{Redeclaring an externally defined enumeration locally}\label{redeclaring-an-externally-defined-enumeration-locally}

An opaque enumeration declaration enables the use of that
enumeration without granting visibility to its enumerators, reducing
physical coupling between components. Unlike a \emcppsgloss{forward class declaration}, an opaque enumeration declaration produces a complete
type, sufficient for substantive use (e.g., via the linker):

\begin{emcppshiddenlisting}[emcppsbatch=e8]
// client.cpp:
#include <cstdint>  // (ù{\codeincomments{std::uint8\_t}}ù)
\end{emcppshiddenlisting}
\begin{emcppslisting}[emcppsbatch=e8]
// client.cpp:
enum Event : std::uint8_t;
Event e;  // OK, (ù{\codeincomments{Event}}ù) is a complete type.
\end{emcppslisting}

\noindent The \emph{underlying type} specified in an opaque \lstinline!enum!
declaration must exactly match the full definition; otherwise a program
incorporating both is automatically \emcppsgloss{IFNDR}. Updating an
\lstinline!enum!'s underlying type to accommodate additional values can
lead to latent defects when these changes are not propagated to all
local declarations:

\begin{emcppshiddenlisting}[emcppsbatch=e9]
// library.h:
#include <cstdint>  // (ù{\codeincomments{std::uint16\_t}}ù)
\end{emcppshiddenlisting}
\begin{emcppslisting}[emcppsbatch=e9]
// library.h:
enum Event : std::uint16_t { /* now more than 256 events */ };
\end{emcppslisting}

\noindent Consistency of a local opaque \lstinline!enum! declaration's underlying
type with that of its complete definition in a separate translation unit
cannot be enforced by the compiler, potentially leading to a program
that is \emcppsgloss{IFNDR}. In the \lstinline!client.cpp! example shown above, if the opaque
declaration in \lstinline!client.cpp! is not somehow updated to reflect the
changes in \lstinline!event.h!, the program will compile, link, and run,
but its behavior has silently become undefined. The only robust solution
to this problem is for \lstinline!library.h! to provide two separate header
files; see \intrarefsimple{inciting-local-enumeration-declarations-an-attractive-nuisance}.

The problem with local declarations is by no means limited to opaque
enumerations. Embedding a local declaration for any object whose use
might be associated with its definition in a separate translation unit
via just the linker invites instability:

\noindent\begin{minipage}{.45\textwidth}
\begin{emcppslisting}
// main.cpp:
extern int x;  // BAD IDEA!
// ...
\end{emcppslisting}
\end{minipage}\hfill
\begin{minipage}{.45\textwidth}
\begin{emcppslisting}
// library.cpp:
int x;
// ...
\end{emcppslisting}
\end{minipage}

\noindent The definition of object \lstinline!x! (in the code snippets above) resides
in the \lstinline!.cpp! file of the library component while a supposed
declaration of \lstinline!x! is embedded in the file defining
\lstinline!main!. Should the type of just the definition of \lstinline!x!
change, both translation units will continue to compile but, when
linked, the resulting program will be \emcppsgloss{IFNDR}:

\noindent\begin{minipage}{.65\textwidth}
\begin{emcppslisting}
// main.cpp:
extern int x;  // ILL-FORMED PROGRAM
// ...
\end{emcppslisting}
\end{minipage}\hfill
\begin{minipage}{.35\textwidth}
\begin{emcppslisting}
// library.cpp:
double x;
// ...
\end{emcppslisting}
\end{minipage}

\noindent To ensure consistency across translation units, the time-honored
tradition is to place, in a header file managed by the supplier, a
declaration of each external-linkage entity intended for use outside of
the translation unit in which it is defined; that header is then
included by both the supplier and each consumer:

\noindent\begin{minipage}{.3\textwidth}
\begin{emcppslisting}[emcppsbatch=e10]
// main.cpp:
#include <library.h>
// ...
\end{emcppslisting}
\end{minipage}\hfill
\begin{minipage}{.3\textwidth}
\begin{emcppslisting}[emcppsbatch=e10]
// library.h:
// ...
extern int x;
// ...
\end{emcppslisting}
\end{minipage}
\begin{minipage}{.3\textwidth}
\begin{emcppslisting}[emcppsbatch=e10]
// library.cpp:
#include <library.h>
int x;
// ...
\end{emcppslisting}
\end{minipage}

\noindent In this way, any change to the definition of \lstinline!x! in
\lstinline!library.cpp! --- the supplier --- will trigger a compilation error
when \lstinline!library.cpp! is recompiled, thereby forcing a corresponding
change to the declaration in \lstinline!library.h!. When that happens,
typical build tools will take note of the change in the header file's
timestamp relative to that of the \lstinline!.o! file corresponding to
\lstinline!main.cpp! --- the consumer --- and indicate that it too needs to be
recompiled. Problem solved.

The maintainability pitfall associated with opaque enumerations,
however, is qualitatively more severe than for other external-linkage
types, such as a global \lstinline!int!: (1) the full definition for the
enumeration type itself needs to reside in a header for \emph{any}
external client to make use of its individual enumerators and (2)
typical components consist of just a \lstinline!.h!/\lstinline!.cpp! pair,
i.e., exactly one \lstinline!.h! file and usually just one \lstinline!.cpp!
file.{\cprotect\footnote{\cite{lakos20}, sections~2.2.11--2.2.13,
  pp.~280--281}}

Exposing, within a library header file, an opaquely declarable
enumeration that is programmatically accessible by external clients
without providing some maintainable way for those clients to keep their
elided declarations in sync with the full definition introduces what we
are calling an \emph{attractive nuisance}: the client is forced to
choose between (a) introducing the added risk and maintenance burden of
having to manually maintain consistency between the underlying types for
all its separate opaque uses and the one full definition or (b)
forgo use of this opaque-enumeration feature entirely, forcing
gratuitous compile-time coupling with
the unused and perhaps unstable enumerators. At even moderate scale, excessive
compile-time coupling can adversely affect projects in ways that are far
more insidious than just increased compile times during development ---
e.g., any emergency changes that might need to occur and be deployed
quickly to production without forcing all clients to recompile and then
be retested and then, eventually, be rereleased.\footnote{For a complete
real-world example of how compile-time coupling can delay a ``hot fix''
by weeks, not just hours, see \cite{lakos20}, section~3.10.5,
pp.~783--789.}

\subsubsection[Inciting local enumeration declarations: an attractive nuisance]{Inciting local enumeration declarations: an attractive nuisance}\label{inciting-local-enumeration-declarations-an-attractive-nuisance}

Whenever we, as library component authors, provide the complete
definition of an \lstinline!enum!~\lstinline!class! or a classic enumeration
with an explicitly specified underlying type and fail to provide a
corresponding header having just the opaque declaration, we confront our
clients with the unenviable conundrum of whether to needlessly
compile-time couple themselves and/or their clients with the details of
the enumerator list or to make the dubious choice to unilaterally
redeclare that enumeration locally.

The problems associated with local declarations of data whose types are
maintained in separate translation units is not limited to enumerations;
see \intrarefsimple{redeclaring-an-externally-defined-enumeration-locally}. The maintainability pitfall associated with
\emcppsgloss[opaque enumeration]{opaque enumerations}, however, is qualitatively more severe than
for other external-linkage types, such as a global \lstinline!int!, in that
the ability to elide the enumerators amounts to an \emph{attractive
nuisance} wherein a client --- wanting to do so and having access to
only a single header containing the unelided definition (i.e.,
comprising the enumeration name, underlying integral type, and
enumerator list) --- might be persuaded into providing an elided copy of
the \lstinline!enum!'s definition (i.e., one omitting just the enumerators)
locally!

Ensuring that library components that define
enumerations (e.g.,
\lstinline!enum!~\lstinline!class!~\lstinline!Event!) whose
enumerators can be elided also consistently provide a second
forwarding header file containing the opaque declaration of each such
enumeration (i.e., enumeration name and underlying integral type only)
would be one generally applicable way to sidestep this often
surprisingly insidious maintenance burden; see \intrarefsimple{dual-access:-insulating-some-external-clients-from-the-enumerator-list}. Note that the attractive
nuisance potentially exists even when the primary intent of the component is not to make the enumeration generally
available.\footnote{\cite{wight}}

\subsection[Annoyances]{Annoyances}\label{annoyances}

\subsubsection[Opaque enumerations are not completely type safe]{Opaque enumerations are not completely type safe}\label{opaque-enumerations-are-not-completely-type-safe}

Making an enumeration opaque does not stop it from being used to create
an object that is initialized opaquely to a zero value and then
subsequently used (e.g., in a function call):

\begin{emcppslisting}
enum Bozo : int;  // forward declaration of enumeration (ù{\codeincomments{Bozo}}ù)
void f(Bozo);     // forward declaration of function (ù{\codeincomments{f}}ù)

void g()
{
    Bozo clown{};
    f(clown);      // OK, who knows if zero is a valid value?!
}
\end{emcppslisting}

\noindent Though creating a zero-valued enumeration variable by default is not
new, allowing one to be created without even knowing what enumerated
values are valid is arguably dubious.

\subsection[See Also]{See Also}\label{see-also}

\begin{itemize}
\item{\seealsoref{explicit-enumeration-underlying-type}{\locationc}Discusses the underlying integral representation for enumeration variables and their values.}
\item{\seealsoref{enumclass}{\locationc}Introduces an implicitly scoped, more strongly typed enumeration.}
\end{itemize}

\subsection[Further Reading]{Further Reading}\label{further-reading}

\begin{itemize}
\item{For more on internal versus external linkage, see \cite{lakos20}, section~1.3.1, pp.~154--159.}
\item{For more on the use of header files to ensure consistency across translation units, see \cite{lakos20}, section~1.4, pp.~190--201, especially Figure~1-35, p.~197.}
\item{For more on the use of \lstinline!#include! directives and \lstinline!#include! guards, see \cite{lakos20}, section~1.5, pp.~201--209.}
\item{For a complete delineation of inherent properties that belong to every well-conceived \lstinline!.h!/\lstinline!.cpp! pair, see \cite{lakos20}, sections~1.6 and 1.11, pp.~219--216 and 256--259, respectively.}
\item{For an introduction to physical dependency, see \cite{lakos20}, section~1.8, pp.~237--243.}
\item{For a suggestion on how to achieve unique naming of files, see \cite{lakos20}, section~2.4, pp.~297--333.}
\item{For a thorough treatment of \emcppsgloss{architectural insulation}, see \cite{lakos20}, sections~3.10--3.11, pp.~773--835.}
\end{itemize}


%%%% conversion clean-up not quite finished


Function-scope \lstinline!static! objects are now guaranteed to be
initialized safely (i.e., free of race conditions) even in the presence
of multiple concurrent threads.

\subsection[Description]{Description}\label{description-functionstatic}

When a variable is declared within the body of a function, we say that
the variable is declared at \romeogloss{function scope} (a.k.a.
\romeogloss{local scope}). An object (e.g., \lstinline!iLocal!) that is
declared \lstinline!static! within the body of a function (e.g.,
\lstinline!f!) will be initialized the first time the \romeogloss{flow of
control} passes through the \romeogloss{definition} of that object:

\begin{lstlisting}[language=C++]
#include <cassert>  // standard (ù{\codeincomments{assert}}ù) macro

int f(int i) // function returning the first argument with which it is called
{
    static int iLocal = i;  // object initialized once only, on the first call
    return iLocal;          // the same (ù{\codeincomments{iLocal}}ù) value is returned on every call
}

int main()
{
    int a = f(10);  assert(a == 10);  // Initialize and return (ù{\codeincomments{iLocal}}ù).
    int b = f(20);  assert(b == 10);  // Return (ù{\codeincomments{iLocal}}ù).
    int c = f(30);  assert(c == 10);  // Return (ù{\codeincomments{iLocal}}ù).

    return 0;
}
\end{lstlisting}
    
\noindent In the simple example above, the function \lstinline!f! initializes its
\lstinline!static! object \lstinline!iLocal! with its argument \lstinline!i! only
the first time it is called and then always returns the same value
(e.g., 10). Hence, when that function is called repeatedly with distinct
arguments while initializing, respectively, \lstinline!a!, \lstinline!b!, and
\lstinline!c!, all three of these variables are initialized to the same
value, 10, used the first time \lstinline!f! was invoked (i.e., to
initialize \lstinline!a!). Although the function-scope \lstinline!static!
object, \lstinline!iLocal!, was created after \lstinline!main! was entered, it
will not be destroyed until after \lstinline!main! exits.

A function such as \lstinline!f! might also be called before \lstinline!main!
is entered:

\begin{lstlisting}[language=C++]
#include <cassert>  // standard (ù{\codeincomments{assert}}ù) macro

int a = f(10);  // Initialize and return (ù{\codeincomments{iLocal}}ù).
int b = f(20);  // Return (ù{\codeincomments{iLocal}}ù).
int c = f(30);  // Return (ù{\codeincomments{iLocal}}ù).

int main()
{
    assert(a == 10);  assert(b == 10);  assert(c == 10);  // all the same
    return 0;
}
\end{lstlisting}
    
\noindent In this variant, the function-scope \lstinline!static! object,
\lstinline!iLocal!, is created \emph{before} \lstinline!main! is entered. As
with the previous example, however, the \lstinline!static! object
\lstinline!iLocal! is again not destroyed until after \lstinline!main! exits.

The rule for the initialization of \lstinline!static! objects at function
scope becomes more obtuse when the functions themselves are recursive
but is nonetheless well defined:

\begin{lstlisting}[language=C++]
int fx(int i)  // self-recursive after creating function-(ù{\codeincomments{static}}ù) variable, (ù{\codeincomments{dx}}ù)
{
    static int dx = i;     // Create (ù{\codeincomments{dx}}ù) first.
    if (i) { fx(i - 1); }  // Recurse second.
    return dx;             // Return (ù{\codeincomments{dx}}ù) third.
}

int fy(int i)  // self-recursive before creating function-(ù{\codeincomments{static}}ù) variable,(ù{\codeincomments{dy}}ù)
{
    if (i) { fy(i - 1); }  // Recurse first.
    static int dy = i;     // Create (ù{\codeincomments{dy}}ù) second.
    return dy;             // Return (ù{\codeincomments{dy}}ù) third.
}

int main()
{
    int x = fx(5);  assert(x == 5);  // (ù{\codeincomments{dx}}ù) is initialized before recursion.
    int y = fy(5);  assert(y == 0);  // (ù{\codeincomments{dy}}ù) is initialized after recursion.
    return 0;
}
\end{lstlisting}
    
\noindent If the self-recursion takes place \emph{after} the \lstinline!static!
variable is initialized (e.g., \lstinline!fx! above), then the
\lstinline!static! object (e.g., \lstinline!dx!) is initialized on the
\emph{first} recursive call; if the recursion occurs \emph{before}
(e.g., \lstinline!fy! above), the initialization (e.g., of \lstinline!dy!)
occurs on the \emph{last} recursive call.

As with all other initialization, control flow does not continue
\emph{past} the \romeogloss{definition} of a \lstinline!static! object until
after the initialization is complete, making recursive \lstinline!static!
initialization from within a single thread pointless:

\begin{lstlisting}[language=C++]
int fz(int i)  // The behavior is undefined unless (ù{\codeincomments{i}}ù) is 0.
{
    static int dz = i ? fz(i - 1) : 0;  // Initialize recursively. (BAD IDEA)
    return dz;
}

int main()  // Program is ill-formed
{
    int x = fz(5);  // broken! (e.g., due to possible deadlock)
}
\end{lstlisting}
    
\noindent In the ill-fated example above, the second recursive call of \lstinline!fz!
to initialize \lstinline!dz! has undefined behavior because the function is
re-entered before it was able to complete the initialization of the
\lstinline!static! object; hence, control flow cannot continue to the
\lstinline!return! statement in \lstinline!fz!. Given a likely implementation
with a non-recursive mutex or similar lock, the program is likely to
deadlock{\cprotect\footnote{TODO {[} {]} JM: @JSL - was this example
tried? i find deadlock an unlikely outcome. i get an exception with
g++. please add a reference or platforms where it deadlocks. JSL: I
agree with jeff M. This need to be documented. I tried it on GCC 7.4.0
(C) 2017. This is a TBD during the COPY EDITING PHASE, if not now.
Lori: Now or during revisions would be best. VR: I talked to John, he
suggested Nina should try and verify this on multiple platforms AFTER
  copyediting. TBD.}} since only one thread of control is allowed to
``grab the lock'' to enter the \romeogloss{critical section} that
initializes a function-scope \lstinline!static!
object.{\cprotect\footnote{Prior to standardization (see \cite{ellis90},
section~6.7, p.~92.), C++ allowed control to flow past a
\lstinline!static! function-scope variable even during a recursive call
made as part of the initialization of that variable. This would result
in the rest of such a function executing with a zero-initialized and
possibly partially constructed local object. Even modern compilers,
such as GCC with \lstinline!-fno-threadsafe-statics!, allow turning off
the locking and protection from concurrent initialization and
retaining some of the pre-C++98 behavior. This optional behavior is,
however, fraught with peril and unsupported in any standard version of
  C++.}}

\subsubsection[Logger example]{Logger example}\label{logger-example}

Let's now consider a more realistic{\cprotect\footnote{In a large-scale
production environment, we would avoid evaluating any expression whose
result is intended to be logged unless the logging level for that
specific logging statement is enabled. An imminently useful,
full-featured logger, known as the {ball} logger, can be found in the
{ball} package of the {bal} package group of Bloomberg's open-source
  BDE libraries ({bde14} subdirectory \lstinline!/groups/ball/bal!).}},
real-world example in which a single object --- e.g.,
\lstinline!localLogger! below --- is used widely throughout a program (see
also \intraref{use-cases-functionstatic}{meyers-singleton}):

\begin{lstlisting}[language=C++]
Logger& getLogger()  // ubiquitous pattern commonly known as a "Meyers Singleton"
{
    static Logger localLogger("log.txt");  // function-local (ù{\codeincomments{static}}ù) definition
    return localLogger;
}

int main()
{
    getLogger() << "hello";
        // OK, invokes (ù{\codeincomments{Logger}}ù)s constructor for the first (and only) time.

    getLogger() << "world";
        // OK, uses the previously constructed (ù{\codeincomments{Logger}}ù) instance.
}
\end{lstlisting}
    
\noindent All function-local \lstinline!static! objects, such as \lstinline!localLogger!
in the example above, will be destroyed automatically only on normal
program termination, either after the \lstinline!main! function returns
normally or when the \lstinline!std::exit! function is
called.{\cprotect\footnote{Programs can terminate in several other ways,
such as a call to \lstinline!std::quick_exit!, \lstinline!_Exit!, or
\lstinline!std::abort!, that explicitly do \emph{not} destroy
  \lstinline!static! storage-duration objects.}} The order of destruction
of these objects will be the reverse of their order of construction.
Objects that initialize concurrently have no guaranteed relationship on
the order in which they are destroyed.

The destruction of \romeogloss{function-scope} \lstinline!static! objects is
and always has been guaranteed to be safe \emph{provided} (1) no threads
are running after returning from \lstinline!main! and (2)
\romeogloss{function-scope} \lstinline!static! objects do not depend on each
other during destruction; see \intraref{potential-pitfalls-functionstatic}{depending-on-order-of-destruction-of-local-objects-after-main-returns}.

\subsubsection[Multithreaded contexts]{Multithreaded contexts}\label{multithreaded-contexts}

Historically, initialization of \romeogloss{function-scope}
\lstinline!static!-duration objects was not guaranteed to be safe in a
\romeogloss{multithreading context} because it was subject to \romeogloss{data
races} if the function was called concurrently from multiple threads.
One common but unreliable pre-C++11 workaround was the
\emph{double-checked lock pattern}; see {\intraref{{Appendix: C++03
Double-Checked Lock Pattern}}}, below.

To illustrate how defects might have been introduced by multithreading
\emph{prior} to C++11, suppose that we have a simple type,
\lstinline!MyString!, that always allocates dynamic memory on construction:

\begin{lstlisting}[language=C++]
#include <cstring>  // (ù{\codeincomments{std::size\_t}}ù), (ù{\codeincomments{std::memcpy}}ù), (ù{\codeincomments{std::strlen}}ù)

class MyString
{
    char* d_string_p;  // pointer holding dynamically allocated memory address

public:
    MyString(const char* s)                                     // (1)
    {                                                           // (2)
        const std::size_t size = std::strlen(s) + 1;            // (3)
        d_string_p = static_cast<char*>(::operator new(size));  // (4)
        std::memcpy(d_string_p, s, size);                       // (5)
    }                                                           // (6)
};
\end{lstlisting}
    
\noindent Let's say that we want to create a \lstinline!static! object of this
\lstinline!MyString! class in a function, \lstinline!f!, that might be invoked
concurrently from multiple threads:

\begin{lstlisting}[language=C++]
void f()
{
    static const MyString s("example");  // function-scope, (ù{\codeincomments{static}}ù)-duration
    // ...
}
\end{lstlisting}
    
\noindent Let's now imagine that \lstinline!f! is called, for the first time, from
two separate threads concurrently. Suppose that the first thread gets
through the \lstinline!MyString! constructor, in the example above, up to
\emph{but not including} line (4) before it is suspended by the
operating system. After that, the second thread --- because there was no
lock prior to C++11 --- makes it all the way past line (6) before it too
is suspended. When the operating system eventually resumes execution of
the first thread, the dynamic allocation and assignment on line (4)
\romeogloss{leaks} the memory for the previously constructed
\lstinline!MyString!. What's more, when the second destruction of the
string eventually occurs (after exiting \lstinline!main!),
\romeogloss{undefined behavior} will inevitably result, if it hasn't
already.

In practice, however, \romeogloss{undefined behavior} (prior to C++11) might
have manifested even earlier. When the second thread re-uses the storage
claimed by the object in the first thread, it effectively ends the
lifetime of one \lstinline!static!~\lstinline!S! object to start the lifetime
of the other one. After that, any attempt to access the original
\lstinline!s! object would be \romeogloss{undefined behavior}, because its
lifetime has ended, even though its destructor did not run. Hence,
\romeogloss{undefined behavior} could manifest long before the second
destructor is run at the end of the program.

As of C++11, a conforming compiler is now required to ensure that
initialization of \romeogloss{function-scope} !static!-duration
objects is performed safely even when the function is called
concurrently from multiple threads. Importantly, however, this same
guarantee is \emph{not} extended for other \romeogloss{static-duration}
objects such as those at file or namespace scope:

\begin{lstlisting}[language=C++]
static S global(3);         // runtime-initialized, file-scope (ù{\codeincomments{static}}ù)

S& f1()                     // (ù{\codeincomments{f1}}ù) is not thread safe.
{
    return global;          // (ù{\codeincomments{global}}ù) might be in any state.
}

S& f2()                     // (ù{\codeincomments{f2}}ù) is thread safe.
{
    static S local(3);      // runtime-initialized, function-scope (ù{\codeincomments{static}}ù)
    return local;
}
\end{lstlisting}
    
\noindent Continuing our \lstinline!logger! example from {\intraref{{Description}}}:
{\intrarefsub{{Logger example}}}, suppose that, to initialize a global
facility, we are potentially calling a function, such as
\lstinline!getLogger!, concurrently from multiple threads using, say, the
C++11 \lstinline!std::thread! library utility.{\cprotect\footnote{The C++11
standard library provides copious utilities and abstractions related
to multithreading. For starters, \lstinline!std::thread! is a portable
wrapper for a platform-specific thread handle provided by the
operating system. When constructing an \lstinline!std::thread! object
with a \romeogloss{callable object} \lstinline!functor!, a new thread
invoking \lstinline!functor! will be spawned. Note that
\lstinline!std::thread!'s destructor will \emph{not} \romeogloss{join} the
thread --- it is safe to destroy an active \lstinline!std::thread! object
\emph{only} if the \lstinline!std::thread::join! member function has
already been invoked. When the \lstinline!std::thread! object's
\lstinline!join! member function is invoked, that function might need to
block the caller until the \emph{native} thread managed by the
  \lstinline!std::thread! object being joined finishes its execution.}})
Such use prior to the C++11 thread-safety guarantees could, in
principle, have led to a race condition during the initialization of
\lstinline!localLogger!, which was defined as a local \lstinline!static!
object in \lstinline!getLogger!:

\begin{lstlisting}[language=C++]
#include <thread>  // (ù{\codeincomments{std::thread}}ù)

void useLogger() { getLogger() << "example"; }  // concurrently called function

void main()
{
    std::thread t0(&useLogger);
    std::thread t1(&useLogger);
        // Spawn two new threads, each of which invokes (ù{\codeincomments{useLogger}}ù).

    // ...

    t0.join();  // Wait for (ù{\codeincomments{t0}}ù) to complete execution.
    t1.join();  // Wait for (ù{\codeincomments{t1}}ù) to complete execution.
}
\end{lstlisting}
    
\noindent As of C++11, the example above has no data races provided that
\lstinline!Logger::operator<<(const!~\lstinline!char*)! is designed properly
for multithreaded use, even if the
\lstinline!Logger::Logger(const!~\lstinline!char*!~\lstinline!logFilePath)!
constructor (i.e., the one used to configure the singleton instance of
the logger) were not. That is to say, the implicit \romeogloss{critical
section} that is guarded by the compiler includes evaluation of the
initializer, which is why a recursive call to initialize a
function-scope \lstinline!static! variable is undefined behavior and is
likely to result in deadlock; see {\intraref{{Description}}}, above.
Such use of file-scope \lstinline!static!s, however, is not foolproof; see \intraref{potential-pitfalls-functionstatic}{depending-on-order-of-destruction-of-local-objects-after-main-returns}.

\subsection[Use Cases]{Use Cases}\label{use-cases-functionstatic}

\subsubsection[Meyers Singleton]{Meyers Singleton}\label{meyers-singleton}

The guarantees surrounding access across translation units to runtime
initialized objects at file or namespace scope are few and dubious ---
especially when that access might occur prior to entering \lstinline!main!.
Consider a library component, \lstinline!libcomp!, that defines a
file-scope \lstinline!static! singleton, \lstinline!globalS!, that is
initialized at run time:

\begin{lstlisting}[language=C++]
// libcomp.h
#ifndef INCLUDED_LIBCOMP
#define INCLUDED_LIBCOMP

struct S { /*... */ };
S& getGlobalS();  // access to global singleton object of type (ù{\codeincomments{S}}ù)

#endif
\end{lstlisting}

%%% ask if these are supposed to be one.     

\begin{lstlisting}[language=C++]
// libcomp.cpp
#include "libcomp.h"
#include <iostream>

static S globalS;
S& getGlobalS() { return globalS; }  // access into this translation unit
\end{lstlisting}
    
\noindent The interface in the \lstinline!libcomp.h! file comprises the definition of
\lstinline!S! along with the declaration of an accessor function,
\lstinline!getGlobalS!. Any function wishing to access the singleton
\lstinline!globalS! object sequestered within the \lstinline!libcomp.cpp! file
would \emph{presumably} do so safely via the global
\lstinline!getGlobalS()! accessor function. Now consider the
\lstinline!main.cpp! file in the example below, which implements
\lstinline!main! and also makes use of \lstinline!globalS! prior to entering
\lstinline!main!:

\begin{lstlisting}[language=C++]
// main.cpp
#include <libcomp.h>  // (ù{\codeincomments{getGlobalS()}}ù)

bool globalInitFlag = getGlobalS().isInitialized();

#include <cassert>  // standard (ù{\codeincomments{assert}}ù) macro

int main()
{
    assert(globalInitFlag);   // Error! or at least potentially so
    return 0;
}
\end{lstlisting}
    
\noindent Depending on the compiler or the link line, it is entirely possible that
the call from \lstinline!main.o! into \lstinline!libcomp.o! will occur and
return \emph{prior} to the initialization of
\lstinline!globalS!.{\cprotect\footnote{For example, compiling the two
files separately with GCC version~4.7.0 (c.~2017) and linking the
\lstinline!.o! files may generate an assertion error depending on the
order of the \lstinline!.o! files on the link line:

\begin{lstlisting}[language=C++, basicstyle={\ttfamily\footnotesize}]
$ g++ main.o libcomp.o
$ ./a.exe               // Running this program produces no assertion failure.

$ g++ libcomp.o main.o
$ ./a.exe               // Running this program produces an assertion failure.

    assertion "globalInitFlag" failed: file "main.cpp", line 9, function: int main()
    Aborted (core dumped)
\end{lstlisting}
      }} Nothing in the Standard says that \lstinline!static! objects at
file or namespace scope in separate translation units will be
initialized just because a function located within that translation unit
happens to be called.

An effective pattern for helping to ensure that a ``global'' object
\emph{is} initialized before it is used from a separate translation unit
--- especially when that use might occur prior to entering \lstinline!main!
--- is simply to move the \lstinline!static! object at file or namespace
scope inside the scope of the function accessing it, making it a
function-scope \lstinline!static! instead:

\begin{lstlisting}[language=C++]
S& getGlobalS()  // access into this translation unit
{
    static S globalS;  // singleton is now function-scope (ù{\codeincomments{static}}ù)
    return globalS;
}
\end{lstlisting}
    
\noindent This pattern, commonly known as the \romeogloss{Meyers Singleton} after
legendary author Scott Meyers, who popularized it, ensures that the
singleton object will \emph{necessarily} be initialized on the first
call to the accessor function that envelopes it, irrespective of when
and where that call is made. Moreover, that singleton object is
guaranteed to live past the end of \lstinline!main!. The \romeogloss{Meyers
Singleton} pattern also gives us a chance to catch and respond to
exceptions thrown when constructing the \lstinline!static! object, rather
than immediately terminating, as would be the case if declared as a
\lstinline!static! global variable. Much more importantly, however, the
\romeogloss{Meyers Singleton} pattern automatically inherits the benefits of
effortless race-free initialization of \emph{reusable} program-wide
singleton objects whose first invocation might be before \lstinline!main!
in some programs and after additional threads have already been started
after entering \lstinline!main! in other programs.

As discussed in {\intraref{{Description}}}, the augmentation of a
thread-safety guarantee for the runtime initialization of
\romeogloss{function-scope} \lstinline!static! objects in C++11 minimizes the
effort required to create a thread-safe singleton regardless of whether
such safety guarantees turn out to be needed:

\begin{lstlisting}[language=C++]
Logger& getLogger()
{
    static Logger logger("log.txt");
    return logger;
}
\end{lstlisting}
    
\noindent Note that, prior to C++11, the simple function-scope \lstinline!static!
implementation would not be safe if concurrent threads were vying to
initialize the logger; see {\intraref{{Appendix: C++03 Double-Checked
Lock Pattern}}}.

The \romeogloss{Meyers Singleton} is also seen in a slightly different form
where the singleton type's constructor is made \lstinline!private! to
prevent more than just the one singleton object from being created:


%%%% note ~ in code 
\begin{lstlisting}[language=C++]
class Logger
{
private:
    Logger(const char* logFilePath);  // Configure the singleton; the logger
    ~Logger();                        // suppresses copy construction too.

public:
    static Logger& getInstance()
    {
        static Logger localLogger("log.txt");
        return localLogger;
    }
};
\end{lstlisting}
    
\noindent This variant of the function-scope-\lstinline!static! singleton pattern
prevents users from manually creating rogue \lstinline!Logger! objects; the
only way to get one is to invoke the logger's \lstinline!static!
\lstinline!Logger::getInstance()! member function:

\begin{lstlisting}[language=C++]
void client()
{
    Logger::getInstance() << "Hi";  // OK
    Logger myLogger("myLog.txt");   // Error: (ù{\codeincomments{Logger::Logger(const char*)}}ù) is (ù{\codeincomments{private}}ù).
}
\end{lstlisting}
    
\noindent This formulation of the singleton pattern, however, conflates the type
of the singleton object with its use and purpose as a singleton. Once we
find a use of a singleton object, finding another and perhaps even a
third is not uncommon. Consider, for example, an application on an early
model of mobile phone where we want to refer to the phone's camera.
Let's presume that a \lstinline!Camera! class is a fairly involved and
sophisticated mechanism. Initially we use the variant of the Meyers
Singleton pattern where at most one \lstinline!Camera! object can be
present in the entire program.

The next generation of the phone, however, turns out to have more than
one camera, say, a front \lstinline!Camera! and a back \lstinline!Camera!. Our
brittle, \emph{ToasterToothbrush}-like{[}\^{}toaster{]} design doesn't
admit the dual-singleton use of the same fundamental \lstinline!Camera!
type. A more finely factored solution would be to implement the
\lstinline!Camera! type separately and then to provide a thin wrapper,
e.g., perhaps using the \romeogloss{strong-\lstinline!typedef! idiom} (see
{\intraref{{inheriting constructors}}}), corresponding to each singleton
use:

{[}\^{}toaster{]} See \cite{lakos20}, section~0.3, pp.~13--20, specifically
Figure~0-9, p.~16.

\begin{lstlisting}[language=C++]
class PrimaryCamera
{
    Camera& d_camera_r;
    PrimaryCamera(Camera& camera) d_camera_r(camera) { }  // implicit constructor

public:
    static PrimaryCamera& getInstance()
    {
        static Camera localCamera(/*...*/);
        return localCamera;
    }
};
\end{lstlisting}
    
\noindent With this design, adding a second and even a third singleton that is
able to reuse the underlying \lstinline!Camera! mechanism is facilitated.

Although this function-scope-\lstinline!static! approach is vastly superior
to the file-scope-\lstinline!static! one, it does have its limitations. In
particular, when one global facility object, such as a logger, is used
in the destructor of another function-scope static object, the logger
object may possibly have already been destroyed when it is
used.{[}\^{}aa\_ft{]} One approach is to construct the logger object by
explicitly allocating it and never deleting it:

{[}\^{}aa\_ft{]} An amusing workaround, the so-called \emph{Phoenix
Singleton}, is proposed in \cite{alexandrescu01}, section~6.6, pp.~137--139.

\begin{lstlisting}[language=C++]
Logger& getLogger()
{
    static Logger& localLogger = *new Logger("log.txt");  // dynamically allocated
    return localLogger;  // Return a reference to the logger (on the heap).
}
\end{lstlisting}
    
\noindent A distinct advantage of this approach, once an object is created, it
\emph{never} goes away before the process ends. The disadvantage is
that, for many classic and current profiling tools (e.g., \emph{Purify},
\emph{Coverity}), this intentionally never-freed dynamic allocation is
indistinguishable from a \romeogloss{memory leak}. The ultimate workaround
is to create the object itself in \lstinline!static! memory, in an
appropriately sized and aligned region of memory{\cprotect\footnote{Note
that any memory that \lstinline!Logger! itself manages would still come
from the global heap and be recognized as memory leaks. If available,
we could leverage a polymorphic-allocator implementation such as
\lstinline!std::pmr! in C++17. We would first create a fixed-size array
of memory having \lstinline!static! storage duration. Then we would
create a \lstinline!static! memory-allocation mechanism (e.g.,
\lstinline!std::pmr::monotonic_buffer_resource!). Next we would use
placement \lstinline!new! to construct the logger within the static
memory pool using our static allocation mechanism and supply that same
mechanism to the \lstinline!Logger! object so that it could get all its
  internal memory from that static pool as well; see \cite{lakos22}.}}:

\begin{lstlisting}[language=C++]
#include <new>

Logger& getLogger()
{
    static std::aligned_storage<sizeof(Logger), alignof(Logger)>::type buffer;
    static Logger& localLogger = *new(&buffer) Logger("log.txt");  // allocate in place
    return localLogger;
}
\end{lstlisting}
    
\noindent In this final incarnation of a decidedly non-Meyers Singleton pattern,
we first reserve a block of memory of sufficient size and the correct
alignment for \lstinline!Logger! using \lstinline!std::aligned_storage!. Next
we use that storage in conjunction with placement \lstinline!new! to create
the logger directly in that static memory. Notice that this allocation
is not from the dynamic store, so typical profiling tools will not track
and will not provide a false warning when we fail to destroy this object
at program termination time. Now we can return a reference to the logger
object embedded safely in static memory knowing that it will be there
for all eternity.

Finally, cyclic initialization dependencies among global objects are
simply not accommodated, and if such is needed, the design is fatally
flawed regardless; see \intraref{potential-pitfalls-functionstatic}{relying-on-initialization-order-of-static-objects}.

\subsubsection[Thread-safe initialization of global objects]{Thread-safe initialization of global objects}\label{thread-safe-initialization-of-global-objects}

Providing a global object (e.g., for logging or monitoring purposes) can
sometimes be convenient for an application because such objects are
accessible from any other part of the program without having to pass
them as explicit arguments. Similarly to the \lstinline!Logger! example
introduced in {\intraref{{Description}}} (above), consider a
\lstinline!MetricsCollector! class whose purpose is to collect runtime
performance metrics for the program:

%%%% note ~ in code
\begin{lstlisting}[language=C++]
class MetricsCollector  // used to collect runtime performance metrics
{
private:
    void startBenchmark(const std::string& name);
    void endBenchmark();

public:
    struct BenchmarkGuard { /* ... */ };
        // RAII guard that invokes (ù{\codeincomments{startBenchmark}}ù) on construction and
        // (ù{\codeincomments{endBenchmark}}ù) on destruction

    BenchmarkGuard benchmark(const std::string& name);
        // Create a (ù{\codeincomments{BenchmarkGuard}}ù) instance that will start a benchmark for
        // the specified (ù{\codeincomments{name}}ù) on construction and end the benchmark on
        // destruction.

    ~MetricsCollector();
        // Flush the collected metrics to disk on destruction.
};
\end{lstlisting}
    
\noindent Assuming that \lstinline!startBenchmark! and \lstinline!endBenchmark! are
designed to avoid race conditions, all that's left to do is create a
function returning a local \lstinline!static! object of type
\lstinline!MetricsCollector! (but see \intrarefsimple{potential-pitfalls-functionstatic}):

\begin{lstlisting}[language=C++]
MetricsCollector& getMetricsCollector()  // Meyers Singleton pattern again
{
    static MetricsCollector metricsCollector;  // function-local (ù{\codeincomments{static}}ù) object
    return metricsCollector;
}
\end{lstlisting}
    
\noindent The \lstinline!getMetricsCollector! function in the code snippet above
guarantees safe initialization of the \lstinline!MetricsCollector!
instance, initializing it exactly once on first invocation, but see \intraref{potential-pitfalls-functionstatic}{depending-on-order-of-destruction-of-local-objects-after-main-returns}.
Collecting metrics from any function scope, without requiring the
function to accept an explicit \lstinline!MetricsCollector! parameter, is
now also possible. By creating an instance of the \romeogloss{RAII} type
\lstinline!BenchmarkGuard!, the elapsed run time of the surrounding scope
will be measured and collected:

\begin{lstlisting}[language=C++]
void DataService::OnGetValueRequest(const std::string& key)
{
    MetricsCollector::BenchmarkGuard guard =
                          getMetricsCollector().benchmark("OnGetValueRequest");
    sendResponse(getValueFromKey(key));
}
\end{lstlisting}
    
\noindent Assuming the program terminates normally, \lstinline!MetricsCollector!'s
destructor will be executed automatically at the end of the program,
flushing the collected data to disk.

\subsection[Potential Pitfalls]{Potential Pitfalls}\label{potential-pitfalls-functionstatic}

\subsubsection[Relying on initialization order of \tt{static} objects]{Relying on initialization order of {\ParaCode static} objects}\label{relying-on-initialization-order-of-static-objects}

Despite C++11's guarantee that each individual function-scope
\lstinline!static! initialization will occur at most once, almost no
guarantees are made on the order those initializations happen, which
makes function-scope \lstinline!static! objects that have interdependencies
across translation units an abundant source insidious errors. For
objects that undergo \romeogloss{constant initialization} have no issue:
such objects will never be accessible at run time before having their
initial values. Objects that are not constant
initialized{\cprotect\footnote{C++20 added a new keyword,
\lstinline!constinit!, that can be placed on a variable declaration to
\emph{require} that the variable in question undergoes constant
initialization and thus can never be accessed at run time prior to the
  start of its lifetime.}} will instead be \romeogloss{zero initialized}
until their constructors run, which itself might lead to conspicuous (or
perhaps latent) undefined behavior. When used as global variables,
function-scope \lstinline!static! objects that do any form of dynamic
allocation or maintain any form of invariants can be especially error
prone. This problem is made even more acute when these objects are
created and accessed before entering \lstinline!main!.

As a demonstration of what can happen when we depend on the relative
order of initialization of \lstinline!static! variables at file or
namespace scope used before \lstinline!main!, consider the
\romeogloss{cyclically dependent} pair of source files, \lstinline!a.cpp! and
\lstinline!b.cpp!:

\begin{lstlisting}[language=C++]
// a.cpp
extern int setB(int);      // declaration (only) of setter in other TU
static int *p = new int;   // runtime initialization of file-scope (ù{\codeincomments{static}}ù)
int setA(int i)            // Initialize this (ù{\codeincomments{static}}ù) variable; then that one.
{
    *p = i;                // Populate this (ù{\codeincomments{static}}ù)-owned heap memory.
    setB(i);               // Invoke setter to populate the other one.
    return 0;              // Return successful status.
}

// b.cpp
static int *p = new int;   // runtime initialization of file-scope (ù{\codeincomments{static}}ù)
int setB(int i)            // Initialize this (ù{\codeincomments{static}}ù) variable.
{
    *p = i;                // Populate this (ù{\codeincomments{static}}ù)-owned heap memory.
    return 0;              // Return successful status.
}

extern int setA(int);      // declaration (only) of setter in other TU
int x = setA(5);           // Initialize all of the (ù{\codeincomments{static}}ù) variables.
int main()                 // main program entry point
{
    return 0;              // Return successful status.
}
\end{lstlisting}
    
\noindent These two translation units will be initialized before \lstinline!main! is
entered in some order, but --- regardless of that order --- the program
in the example above will likely wind up dereferencing a null pointer
before entering \lstinline!main!:

\begin{lstlisting}[language=C++]
$ g++ a.cpp b.cpp main.cpp
$ ./a.exe
  Segmentation fault (core dumped)
\end{lstlisting}
    
\noindent Suppose we were to instead move the file-scope \lstinline!static! pointers,
corresponding to both \lstinline!setA! and \lstinline!setB!, inside their
respective function bodies:

\begin{lstlisting}[language=C++]
// a.cpp
extern int setB(int);  // declaration (only) of setter in other TU
int setA(int i)        // Initialize this (ù{\codeincomments{static}}ù) variable; then that one.
{
    static int *p = new int;  // runtime initialization of function-scope (ù{\codeincomments{static}}ù)
    *p = i;                   // Populate this (ù{\codeincomments{static}}ù)-owned heap memory.
    setB(i);                  // Invoke setter to populate the other one.
    return 0;                 // Return successful status.
}

// b.cpp (same idea)
\end{lstlisting}
    
\noindent Now the program reliably executes without incident:

\begin{lstlisting}[language=C++]
$ g++ a.cpp b.cpp main.cpp
$ ./a.exe
$
\end{lstlisting}
    
\noindent In other words, even though no order exists in which the translation
units as a whole could have been initialized prior to entering
\lstinline!main! such that the \emph{file}-scope \lstinline!static! variables
would be valid before they were used, by instead making them
\emph{function}-scope \lstinline!static!, we are able to guarantee that
each variable is itself initialized before it is used, regardless of
translation-unit-initialization order.

Note that, had the variable initializations themselves been cyclic, the
behavior would again be undefined and likely result in deadlock, even
when implemented using a Meyers Singleton:

\begin{lstlisting}[language=C++]
// a.cpp
extern int setB(int);  // declaration (only) of setter in other TU
int setA(int i)        // Initialize this (ù{\codeincomments{static}}ù) variable to that one.
{
    static int *p =
            new int(setB(i)); // runtime initialization of function-scope (ù{\codeincomments{static}}ù)
    *p = i;                   // Populate this (ù{\codeincomments{static}}ù)-owned heap memory.
    setB(i);                  // Invoke setter to populate the other one.
    return 0;                 // Return successful status.
}

// b.cpp (same idea as (ù{\codeincomments{a.cpp}}ù), above)
\end{lstlisting}
    
\noindent In other words, avoid mutual recursion, as well as self-recursion,
during the initialization of function-scope \lstinline!static! objects.

\subsubsection[Depending on order-of-destruction of local objects after \tt{main} returns]{Depending on order-of-destruction of local objects after {\ParaCode main} returns}\label{depending-on-order-of-destruction-of-local-objects-after-main-returns}

Within any given translation unit, the relative order of initialization
of objects at file or namespace scope having static storage duration is
well defined and predictable. As soon as we have a way to reference an
object outside of the current translation unit, before \lstinline!main! is
entered, we are at risk of using the object before it has been
initialized. Provided the initialization itself is not cyclic in nature,
we can make use of function-scope \lstinline!static! objects (see \intraref{use-cases-functionstatic}{meyers-singleton}) to
ensure that no such uninitialized use occurs, even across translation
units before \lstinline!main! is entered. The relative order of destruction
of such function-scope \lstinline!static! variables --- even when they
reside within the same translation unit --- is not generally known, and
reliance on such order can easily lead to \romeogloss{undefined behavior} in
practice.

This specific problem occurs when a \lstinline!static! object at file,
namespace, or function scope uses (or might use) in its destructor
another \lstinline!static! object that is either (1) at file or namespace
scope and resides in a separate translation unit or (2) any other
function-scope \lstinline!static! object (i.e., including one in the same
translation unit). For example, suppose we have implemented a low-level
logging facility as a Meyers Singleton:

\begin{lstlisting}[language=C++]
Logger& getLogger()
{
    static Logger local("log.txt");
    return local;
}
\end{lstlisting}
    
\noindent Now suppose we implement a higher-level file-manager type that depends
on the function-scope \lstinline!static! logger object:

%%% note ~ in code
\begin{lstlisting}[language=C++]
struct FileManager
{
    FileManager()
    {
         getLogger() << "Starting up file manager...";
         // ...
    }

    ~FileManager()
    {
        getLogger() << "Shutting down file manager...";
        // ...
    }
};
\end{lstlisting}
    
\noindent Now, consider a Meyers Singleton implementation for
\lstinline!FileManager!:

\begin{lstlisting}[language=C++]
FileManager& getFileManager()
{
    static FileManager fileManager;
    return fileManager;
}
\end{lstlisting}
    
\noindent Whether \lstinline!getLogger! or \lstinline!getFileManager! is called first
doesn't really matter; if \lstinline!getFileManager! is called first, the
logger will be initialized as part of \lstinline!FileManager!'s
constructor. However, whether the \lstinline!Logger! or
\lstinline!FileManager! object is destroyed first \emph{is} important:

\begin{itemize}
\item{If the \lstinline!FileManager! object is destroyed prior to the \lstinline!Logger! object, the program will have well-defined behavior.}
\item{Otherwise, the program will have \romeogloss{undefined behavior} because the destructor of \lstinline!FileManager! will invoke \lstinline!getLogger!, which will now return a reference to a previously destroyed object.}
\end{itemize}

As a practical matter, the constructor of the \lstinline!FileManager! logs
makes it virtually certain that the logger's function-local
\lstinline!static! will be initialized before that of the file manager;
hence, since destruction occurs in reverse relative order of creation,
the logger's function-local \lstinline!static! will be destroyed after that
of the file manager. But suppose that \lstinline!FileManager! didn't always
log at construction and was created before anything else logged. In that
case, we have no reason to think that the logger would be around for the
\lstinline!FileManager! to log during its destruction after \lstinline!main!.

In the case of low-level, widely used facilities, such as a logger, a
conventional Meyers Singleton is counter-indicated. The two most common
alternatives elucidated at the end of \intraref{use-cases-functionstatic}{meyers-singleton} involve never ending the lifetime of
the mechanism at all. It is worth noting that truly global objects ---
such as \lstinline!cout!, \lstinline!cerr!, and \lstinline!clog! --- from the
Standard \lstinline!iostream! Library are typically not implemented using
conventional methods and are in fact treated specially by the runtime.

\subsection[Annoyances]{Annoyances}\label{annoyances}

\subsubsection[Overhead in single-threaded applications]{Overhead in single-threaded applications}\label{overhead-in-single-threaded-applications}

A single-threaded application invoking a function containing a
\romeogloss{function-scope} \romeogloss{\lstinline!static!-duration} variable might
have unnecessary synchronization overhead, such as an \romeogloss{atomic}
load operation. For example, consider a program that invokes a free
function, \lstinline!getS!, returning a function-scope \lstinline!static!
object, \lstinline!local!, of user-defined type \lstinline!S!, having an
\romeogloss{user-provided} (inline) default constructor:

\begin{lstlisting}[language=C++]
struct S  // user-defined type
{
    S() { }  // inline default constructor
};

S& getS()  // free function returning (ù{\codeincomments{local}}ù) object
{
    static S local;  // function-scope local object
    return local;
}

int main()
{
    getS();    // Initialize the file-scope (ù{\codeincomments{static}}ù) singleton.
    return 0;  // successful status
}
\end{lstlisting}
    
\noindent Although it is clearly visible to the compiler that \lstinline!getS()! is
invoked by only one thread, the generated assembly instructions might
still contain \romeogloss{atomic} operations or other forms of
synchronization and the call to \lstinline!getS()! might not be generated
inlined.{\cprotect\footnote{Both GCC 10.x and Clang 10.x, using the
\lstinline!-Ofast! optimization level, generate assembly instructions for
an \romeogloss{acquire/release memory barrier} and fail to inline the call
to \lstinline!getS!. Using \lstinline!-fno-threadsafe-statics! reduces the
number of operations performed considerably but still does not lead to
the compilers' inlining of the function call. Both popular compilers
will, however, reduce the program to just two x86 assembly
instructions if the \romeogloss{user-provided} constructor of \lstinline!S!
  is either removed or defaulted (see \featureref{\locationa}{defaulted-special-member-functions});
  doing so will turn \lstinline!S! into a \romeogloss{trivially-constructible}
  type, implying that no code needs to be executed during
  initialization:

  \begin{lstlisting}[language=C++, basicstyle={\ttfamily\footnotesize}]
  xor eax, eax  ; zero out 'eax' register
  ret           ; return from 'main'
  \end{lstlisting}
      
\noindent A sufficiently smart compiler might, however, not generate
  synchronization code in a single-threaded context or else provide a
  flag to control this behavior.

  VR: TODO: Talked to John. We should benchmark/measure the runtime
  impact of this after copyediting.}}

\subsection[See Also]{See Also}\label{see-also}

None so far.

\subsection[Further Reading]{Further Reading}\label{further-reading}

None so far.

\subsection[Appendix: C++03 Double-Checked Lock Pattern]{Appendix: C++03 Double-Checked Lock Pattern}\label{appendix:-c++03-double-checked-lock-pattern}

Prior to the introduction of the \romeogloss{function-scope} \lstinline!static!
object initialization guarantees discussed in \intrarefsimple{description-functionstatic}
(above), preventing multiple initializations of \lstinline!static! objects
and use before initialization of those same objects was still needed.
Wrapping access in a mutex was often a significant performance cost, so
using the unreliable, double-checked lock pattern was often attempted to
avoid the overhead:

\begin{lstlisting}[language=C++]
Logger& getInstance()
{
    static volatile Logger* loggerPtr = 0;  // Hack: used to simulate *atomics*

    if (!loggerPtr)  // Does the logger need to be initialized?
    {
        std::mutex m;
        std::lock_guard<std::mutex> guard(m);  // Lock the mutex.

        if (!loggerPtr)  // We are first, as the logger is still uninitialized.
        {
            static Logger logger("log.txt");
            loggerPtr = &logger;
        }
    }                    // Either way, the lock (ù{\codeincomments{guard}}ù) unlocks the mutex here.

    return *loggerPtr;
}
\end{lstlisting}
    
\noindent In this example, we are using a \lstinline!volatile! pointer as a weak
substitute for an atomic variable, but many implementations would
provide non-portable extensions to support atomic types. In addition to
being difficult to write, this decidedly complex workaround would often
prove unreliable. The problem is that, even though the logic appears
sound, architectural changes in widely used CPUs allowed for the CPU
itself to optimize and reorder the sequence of instructions. Without
additional support, the hardware would not see the dependency that the
second test of \lstinline!!loggerPtr! has on the locking behavior of the
mutex and would do the read of \lstinline!loggedPtr! prior to acquiring the
lock. By reordering the instructions or whatever, the hardware
would then allow multiple threads to acquire the lock, thinking they are
threads that need to initialize the \lstinline!static! variable.

To solve this subtle issue, concurrency library authors are expected to
issue ordering hints such as \romeogloss{fences} and \romeogloss{barriers}. A
well-implemented threading library would provide atomics equivalent to
the modern \lstinline!std::atomic! that would issue the correct
instructions when accessed and modified. The C++11 Standard makes the
compiler aware of these concerns and provides portable \emph{atomics}
and support for threading that enables users to handle such issues
correctly. The above \lstinline!getInstance! function could be corrected by
changing the type of \lstinline!loggerPtr! to
\lstinline!std::atomic<Logger*>!. Prior to C++11, despite being
complicated, the same function would reliably implement the Meyers
Singleton in C++98 on contemporary hardware.

So the final recommended solution for portable thread-safe
initialization in modern C++ is to simply let the compiler do the work
and to use the simplest implementation that gets the job done, e.g., a
Meyers Singleton:

\begin{lstlisting}[language=C++]
Logger& getInstance()
{
    static Logger logger("log.txt");
    return logger;
}
\end{lstlisting}
    
\noindent See \intraref{use-cases-functionstatic}{meyers-singleton}.


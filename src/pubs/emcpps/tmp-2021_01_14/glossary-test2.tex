\cleardoublepage % This command ensures that each chapter starts on a right-hand page 

\chapter*{Glossary}\label{Glossary}

% A new command, gloss, handles the glossary entry. \gloss{word to be defined}{definition}

\gloss{ABI}{}

\gloss{access modifier}{}

\gloss{access specifiers}{}

\gloss{acquire/release memory barrier}{}

\gloss{aggregate}{}

\gloss{aggregate initialization}{}

\gloss{algebra}{}

\gloss{alias template}{}

\gloss{alignment}{}

\gloss{alignment requirements}{}

\gloss{API}{}

\gloss{argument-dependent lookup (ADL)}{}

\gloss{arithmetic type}{}

\gloss{array type}{}

\gloss{atomic}{}

\gloss{automatic variables}{}

\gloss{barriers}{}

\gloss{basic source character set}{}

\gloss{benchmark test}{}

\gloss{B0}{}

\gloss{boilerplate code}{}

\gloss{brace elision}{}

\gloss{bytes}{}

\gloss{C-style functions}{}

\gloss{cache hit}{}

\gloss{cache line}{}

\gloss{cache miss}{}

\gloss{callback functions}{}

\gloss{callable object}{}

\gloss{cast}{}

\gloss{CI}{}

\gloss{Class member access expression}{TODO (include any expression that is used to refer to a class member, such as \texttt{object.member}, \texttt{object->member}, \texttt{object.*member}.)}

\gloss{closures}{}

\gloss{code bloat}{}

\gloss{compile-time constant}{}

\gloss{compile-time coupling}{}

\gloss{Compile-time dispatch}{TODO}

\gloss{complete type}{}

\gloss{component}{}

\gloss{component-local}{}

\gloss{Concepts}{}

\gloss{concrete class}{}

\gloss{conditionally supported}{}

\gloss{Constant expression}{An expression that can be evaluated at compile time.  Mention \texttt{constexpr} and state that \texttt{const} variables that are initialized from a compile-time constants are themselves required to be compile-time constants.  New info to me in June 2020, worthwhile to have. }

\gloss{constant initialization}{}

\gloss{contextual convertibility to {\tt bool}}{}

\gloss{Contextual keyword}{A \textit{contextual keyword} is a special identifier that acts like a \textit{keyword} when used in particular contexts. \texttt{override} is an example as it can be used as a regular identifier outside of member-function declarators.}

\gloss{continuous refactoring}{}

\gloss{contract}{}

\gloss{conventional string literals}{}

\gloss{converting constructors}{}

\gloss{conversion operators}{}

\gloss{copy elision}{}

\gloss{copy initialization}

\gloss{Copy semantics}{TODO}

\gloss{critical section}{}

\gloss{\textbf{curiously recurring template pattern (CRTP)}}{}

\gloss{cv-qualifiers}{}

\gloss{cyclically dependent}{}

\gloss{data member}{}

\gloss{data races}{}

\gloss{Declaration}{TODO}

\gloss{declared interface}{}

\gloss{Declared type}{TODO The type of the *entity* named by the given expression.}

\gloss{declaring}{}

\gloss{defensive}{}

\gloss{defining}{}

\gloss{definition}{}

\gloss{delegating constructor}{}

\gloss{deleted function}{}

\gloss{dependent type}{}

\gloss{design pattern}{}

\gloss{diffusion}{}

\gloss{direct initialization}{}

\gloss{direct mapped}{}

\gloss{duck typing}{}

\gloss{dumb data}{}

\gloss{emplacement}{}

\gloss{encapsulation}{}

\gloss{Entity}{TODO}

\gloss{excess-\textit{n}}{}

\gloss{Expression SFINAE}{TODO}

\gloss{explicit}{}

\gloss{{\tt explicit} specifier}{}

\gloss{extended alignment}{}

\gloss{false sharing}{}

\gloss{fences}{}

\gloss{flow of control}{}

\gloss{forward declaration}{}

\gloss{forward declared}{}

\gloss{forwarding reference}{}

\gloss{fragmentation}{}

\gloss{full specialization}{}

\gloss{fully associative}{}

\gloss{fully constructed}{fully constructed}

\gloss{function object}{}

\gloss{function scope}{}

\gloss{fundamental alignment}{}

\gloss{fundamental integral types}{}

\gloss{Fundamental type}{TODO}

\gloss{garbage value}{}

\gloss{golden output}{}

\gloss{header-only library}{}

\gloss{hide or hiding}{Function-name \textbf{hiding} occurs when a member function in a derived class has the same name as one in the base class, but it is not overriding it due to a difference in the function signature or because the member function in the base class is not \texttt{virtual}. The hidden member function will \textbf{not} participate in dynamic dispatch; the member function of the base class will be invoked instead when invoked via a pointer or reference to the base class . The same code would have invoked the derived class's implementation had the member function of the base class had been \textbf{overridden} rather than \textbf{hidden}.}

\gloss{higher-order function}{}

\gloss{Hyrum's law}{}

\gloss{Id-expression}{TODO are most commonly \textbf{Identifiers}; other forms include overloaded operator names (in function notation), names of user-defined-conversion or literal operators, and destructor names, and ??template names followed by their argument lists??.}

\gloss{ill formed}{TODO (\texttt{[temp.res]p8})}

\gloss{ill formed, no diagnostic required (IFNDR)}{}

\gloss{imperative}{}

\gloss{implementation-defined}{}

\gloss{implementation inheritance}{}

\gloss{incomplete type}{}

\gloss{inheriting constructors}{}

\gloss{{\tt inline}~{\tt namespace}}{}

\gloss{in-process}{}

\gloss{instantiation time}{}

\gloss{insulate}{}

\gloss{insulating}

\gloss{Insulation}{TODO}

\gloss{Integer literal}{TODO}

\gloss{integral constant expression}{}

\gloss{integral promotion}{}

\gloss{integral type}{}

\gloss{interface inheritance}{}

\gloss{invocable}{}

\gloss{join}{}

\gloss{lambda expression}{}

\gloss{lambda-introducer (adj)}{}

\gloss{leaks}{}

\gloss{linkage}{}

\gloss{list initialization}{}

\gloss{literal type}{}

\gloss{local class}{}

\gloss{local declaration}{}

\gloss{local scope}{}

\gloss{locality of reference}{}

\gloss{long-distance friendship}{}

\gloss{lvalue}{}

\gloss{lvalue reference}{}

\gloss{mangled names}{}

\gloss{mantissa}{}

\gloss{maximal alignment}{}

\gloss{maximally aligned}{}

\gloss{mechanism}{}

\gloss{member initialization lists}{}

\gloss{member initializer list}{}

\gloss{memory leak}{}

\gloss{metafunction}{}

\gloss{mixed-mode builds}{}

\gloss{mix-in}{}

\gloss{modules}{}

\gloss{monotonic allocator}{}

\gloss{most vexing parse}{}

\gloss{move operations}{}

\gloss{Move semantics}{TODO}

\gloss{multithreading contexts}{}

\gloss{Meyers Singleton}{}

\gloss{name mangling}{}

\gloss{natural alignment}{}

\gloss{naturally aligned}{}

\gloss{{\tt new} handler}{}

\gloss{nibbles}{}

\gloss{nonprimitive functionality}{}

\gloss{non-trivial constructor}{}

\gloss{non-trivial special member function}{TODO}

\gloss{null address}{}

\gloss{object invariants}{}

\gloss{ODR}{}

\gloss{ODR-used}{}

\gloss{one definition rule}{}

\gloss{opaque declarations}{}

\gloss{opaque enumeration}{}

\gloss{Overriding}{TODO}

\gloss{parameter pack}{}

\gloss{partial class template specialization}{}

\gloss{partial implementation}{}

\gloss{partially constructed}{}

\gloss{perfectly forwarded}{}

\gloss{physical design}{}

\gloss{Placement}{TODO}

\gloss{placement {\tt new}}{TODO}

\gloss{POD type}{TODO}

\gloss{pointer to member}{}

\gloss{polymorphic memory resource}{}

\gloss{precondition}{}

\gloss{predicate function}{}

\gloss{protocol}{}

\gloss{\romeovalue{prvalue}}{}

\gloss{qualified name}{}

\gloss{RAII}{``Resource Acquisition is Initialization"}

\gloss{Range}{TODO}

\gloss{raw string literals}{}

\gloss{Redundant check}{TODO}

\gloss{reference collapsing}{}

\gloss{Reference type}{TODO}

\gloss{ref-qualifiers}{}

\gloss{regular type}{}

\gloss{return value optimization (RVO)}{}

\gloss{\romeovalue{rvalue}}{}

\gloss{safe-bool-idiom}{}

\gloss{set associative}{}

\gloss{SFINAE}{TODO}

\gloss{SHA}{}

\gloss{shadowed}{}

\gloss{side effects}{}

\gloss{Signature}{TODO}

\gloss{signed integer overflow}{}

\gloss{slicing}{}

\gloss{Special member function}{TODO}

\gloss{standard conversion}{}

\gloss{standard-layout types}{}

\gloss{static data space}{}

\gloss{\lstinline!static! duration}{}

\gloss{{\ttfamily std::unique\_ptr}}{}

\gloss{String literal}{TODO}

\gloss{strong \lstinline!typedef!}{}

\gloss{strong-\lstinline!typedef! idiom}{}

\gloss{Structural inheritance}{TODO}

\gloss{Sum type}{Abstract data type allowing the representation of one of multiple possible alternative types. Each alternative has its own type (and state), and only one alternative can be ``active" at any given point in time. Sum types automatically keep track of which choice is ``active," and properly implement value-sematic special member functions (even for non-trivial types). They can be implemented efficiently as a C++ \texttt{class} using a C++ \texttt{union} and a separate (integral) discriminator. This sort of implementation is commonly referred to as a discriminating (or ``tagged") union.}

\gloss{synthetization}{}

\gloss{template-head}{}

\gloss{Template instantiation time}{TODO}

\gloss{Template instantiation}{TODO}

\gloss{template template parameter}{}

\gloss{test driver}{}

\gloss{thrashing}{}

\gloss{thread pool}{}

\gloss{TLB}{}

\gloss{translation unit (TU)}{}

\gloss{trivial copy constructor}{}

\gloss{trivial operation}{}

\gloss{trivially-constructible}{}

\gloss{trivially copyable}{}

\gloss{Trivial type}{TODO}

\gloss{type alias}{}

\gloss{type deduction}{}

\gloss{typedef}{}

\gloss{type expression}{}

\gloss{type inference}{}

\gloss{type list}{}

\gloss{Type trait}{TODO}

\gloss{UDT}{}

\gloss{Undefined behavior}{TODO}

\gloss{underlying type}{}

\gloss{user-defined type (UDT)}{}

\gloss{user-provided}{}

\gloss{user-provided special member function}{}

\gloss{{\tt using}-declaration}{}

\gloss{{\tt using} directive}{}

\gloss{value}{}

\gloss{value category}{}

\gloss{value constructor}{}

\gloss{value-semantic}{}

\gloss{value-semantic type (VST)}{}

\gloss{variable}{}

\gloss{variadic pack}{}

\gloss{vocabulary type}{}

\gloss{well formed}{}

\gloss{working set}{}

\gloss{zero initialized}{}


% 01 Feb, 2021 JMB - packet 4 compilation fixes
% 18 Feb 2021, handing off to Josh for revisions


\emcppsFeature{
    short={Function \lstinline!static! '11},
    tocshort={Function {\TOCCode static} '11},
    long={Threadsafe Function-Scope {\SecCode static} Variables},
    toclong={Threadsafe Function-Scope \lstinline!static! Variables},
    rhshort={Function {\RHCode static} '11},
}{thread-safe-function-static-variables}
\setcounter{table}{0}
\setcounter{footnote}{0}
\setcounter{lstlisting}{0}
%\section[Function {\tt static} '11]{Threadsafe Function-Scope {\SecCode static} Variables}\label{thread-safe-function-static-variables}


Initialization of function-scope \lstinline!static! objects is now guaranteed to be
free of data races in the presence
of multiple concurrent threads.

\subsection[Description]{Description}\label{description-functionstatic}

A variable declared at function (a.k.a. local) scope has automatic \romeogloss{storage duration}, 
except when it is marked \lstinline!static!, in which case it has static \romeogloss{storage duration}.
Variables having automatic \romeogloss{storage duration} are allocated on the stack and initialized each time the \romeogloss{flow of control}
passes through the \romeogloss{definition} of that object.  In contrast, variables with static \romeogloss{storage duration} (e.g., \lstinline!iLocal!)
defined at function scope (e.g., \lstinline!f!) are instead allocated once per program, and are initialized
only the first time the \romeogloss{flow of control} passes
through the \romeogloss{definition} of that object:

\begin{emcppslisting}
#include <cassert>  // standard C (ù{\codeincomments{assert}}ù) macro

int f(int i) // function returning the first argument with which it is called
{
    static int iLocal = i;  // object initialized once only, on the first call
    return iLocal;          // the same (ù{\codeincomments{iLocal}}ù) value is returned on every call
}

int main()
{
    int a = f(10);  assert(a == 10);  // Initialize and return (ù{\codeincomments{iLocal}}ù).
    int b = f(20);  assert(b == 10);  // Return (ù{\codeincomments{iLocal}}ù).
    int c = f(30);  assert(c == 10);  // Return (ù{\codeincomments{iLocal}}ù).

    return 0;
}
\end{emcppslisting}

\noindent In the simple example above, the function, \lstinline!f!, initializes its
\lstinline!static! object, \lstinline!iLocal!, with its argument, \lstinline!i!, only
the first time it is called and then always returns the same value
(e.g., 10). Hence, when that function is called repeatedly with distinct
arguments to initialize the \lstinline!a!, \lstinline!b!, and
\lstinline!c! variables, all three of them are initialized to the same
value, 10, supplied to the first invocation of \lstinline!f!. Although the function-scope \lstinline!static!
object, \lstinline!iLocal!, was created after \lstinline!main! was entered, it
will not be destroyed until after \lstinline!main! exits.

\subsubsection[Concurrent Initialization]{Concurrent Initialization}\label{concurrent-initialization}

Historically, initialization of \romeogloss{function-scope}
\romeogloss{\lstinline!static! storage-duration} objects was not guaranteed to be safe in a
\romeogloss{multithreading context} because it was subject to \romeogloss{data races}   % Hmm. I wonder if "because" is the right word.  The reason is rather that pre-C++11 C++ didn't have a proper memory model to express this at all (and was oblivious to threads).  I'd replace 'because' with 'and'
if the function was called concurrently from multiple threads.   These \romeogloss{data races}
around initialization can lead to the initializer being invoked multiple times, object
construction running concurrently on the same object, and control flow continuing past
the variable definition before initialization had completed at all.  All of these
variations would result in critical software flaws.
One common but unreliable pre-C++11 workaround was the % Do we really want to say "unreliable" instead of "non-portable"?  Reasons: 1) DCLP is fine with atomics 2) still useful in other scenarios 3) "unreliable" was just due to misuse of volatile, and 4) required non-portable barriers/fences/atomics/etc (which is the thing making it non-portable)
\emph{double-checked lock pattern}; see \intrarefsimple{appendix:-c++03-double-checked-lock-pattern}.

As of C++11, a conforming compiler is now required to ensure that
initialization of \romeogloss{function-scope} \romeogloss{\lstinline!static! storage-duration}
objects is performed safely, and exactly once, before execution continues past the initializer, even when the function is called
concurrently from multiple threads. 

\subsubsection[Destruction]{Destruction}\label{destruction}

romeogloss{Automatic} objects within a local scope are destroyed when control
leaves the scope in which they are declared
In contrast, \lstinline!static! local objects that have been initialized are  % There was no 'on the one hand' to "invoke" OTOH - just repeating what was said to me on multiple occasions of me using OTOH
not destroyed until normal program termination,  either after the \lstinline!main! function returns
normally or when the \lstinline!std::exit! function is
called. 
The order of destruction
of these objects will be the reverse of the order in which they completed construction.
Note that programs can terminate in several other ways,
such as a call to \lstinline!std::quick_exit!, \lstinline!_Exit!, or
\lstinline!std::abort!, that explicitly do \emph{not} destroy
  \romeogloss{\lstinline!static! storage-duration} objects.


\subsubsection[Logger example]{Logger example}\label{logger-example}

Let's now consider a 
real-world example in which a single object --- e.g.,
\lstinline!localLogger! in the example below --- is used widely throughout a program (see
also \intraref{use-cases-functionstatic}{meyers-singleton}):

\begin{emcppshiddenlisting}[emcppsbatch=e3]
struct Logger {
  Logger(const char *f) {}
};
template <typename T>
void operator<<(Logger&,const T&);
\end{emcppshiddenlisting}
\begin{emcppslisting}[emcppsbatch=e3]
Logger& getLogger()  // ubiquitous pattern commonly known as "Meyers Singleton"
{
    static Logger localLogger("log.txt");  // function-local (ù{\codeincomments{static}}ù) definition
    return localLogger;
}

int main()
{
    getLogger() << "hello";
        // OK, invokes (ù{\codeincomments{Logger}}ù)s constructor for the first (and only) time

    getLogger() << "world";
        // OK, uses the previously constructed (ù{\codeincomments{Logger}}ù) instance
}
\end{emcppslisting}

Here we have an example of the ``Singleton pattern''\footnote{\cite{gamma95}, Chapter 3, section
``Singleton'', pp.-127--???} being used to create the shared \lstinline!Logger! instance
and provide access to it through the \lstinline!getLogger()! function.  The \lstinline!static! local
instance of \lstinline!Logger!, \lstinline!localLogger!, will be initialized exactly once and then
destroyed after normal program termination.  In C++03, it would not be safe to call
this function concurrently from multiple threads.  % If have a pure single-threaded application, this function is safe to call everywhere in C++03.  I think "pre-main" is a distraction.  Also, what if we spawn multiple threads from global variables - that might be before main and still unsafe :)
Conversely, C++11 \emph{guarantees} that the initialization  
of \lstinline!localLogger! will happen exactly once even when multiple threads call
\lstinline!getLogger! concurrently.

% This next paragraph is a big mess.  What's happening there?  (1) I'm strongly against saying the first sentence in the main text - it comes out of nowhere, and is not related to anything we talked about before. (2) The footnote is fine, I guess. (3) Last sentence is incomplete and disconnected - was it supposed to be removed?
\noindent In a large-scale production environment, we would avoid evaluating any expression whose result is
intended to be logged unless the logging level for that specific logging statement is enabled.{\cprotect\footnote{An
eminently useful, full-featured logger, known as the \texttt{ball} logger, can be found in the
\texttt{ball} package of the \texttt{bal} package group of Bloomberg's open-source
  BDE libraries (\cite{bde14}, subdirectory \texttt{/groups/bal/ball}).}}) All function-local \lstinline!static! objects, such as \lstinline!localLogger!
in the example above, will be destroyed automatically only on normal
program termination, 


% I am against including most of the next section.  We are analyzing scenarios of "what could really happens when UB is present".  Any data race is UB.  Period.  Done.
% We can show where the data race occurs, but analyzing line-by-line is a wrong thing to do IMO.  All that is sufficient is that two threads might write to d_string_p.  That's it.
% Otherwise we might give someone the impression that we think that one can perform such analysis to confirm that "there's not really a data race there" and just move on.  Which is obviously wrong - they turn on -O2, stuff gets reordered and program dies...  Also, apparently, "race condition" (alongside "blacklist", "slave drive", etc.) is now a "problematic term", so we should use "data races" instead...
\subsubsection[Multithreaded contexts]{Multithreaded contexts}\label{multithreaded-contexts}

To illustrate how defects might have been introduced by multithreading
\emph{prior} to C++11, suppose that we have a simple type,
\lstinline!MyString!, that always allocates dynamic memory on construction:

\begin{emcppslisting}[emcppsbatch=e4]
#include <cstring>  // (ù{\codeincomments{std::size\_t}}ù), (ù{\codeincomments{std::memcpy}}ù), (ù{\codeincomments{std::strlen}}ù)

class MyString
{
    char* d_string_p;  // pointer holding dynamically allocated memory address

public:
    MyString(const char* s)                                     // (1)
    {                                                           // (2)
        const std::size_t size = std::strlen(s) + 1;            // (3)
        d_string_p = static_cast<char*>(::operator new(size));  // (4)
        std::memcpy(d_string_p, s, size);                       // (5)
    }                                                           // (6)
};
\end{emcppslisting}

\noindent Let's say that we want to create a \lstinline!static! object of this
\lstinline!MyString! class in a function, \lstinline!f!, that might be invoked
concurrently from multiple threads:

\begin{emcppslisting}[emcppsbatch=e4]
void f()
{
    static const MyString str("s");  // function-scope, (ù{\codeincomments{static}}ù) storage-duration
    // ...
}
\end{emcppslisting}

\noindent Let's now imagine that \lstinline!f! is called from
two separate threads concurrently, without having been called before. Suppose that the first thread gets
through the \lstinline!MyString! constructor, in the example above, up to
\emph{but not including} line (4) before it is suspended by the
operating system. After that, a second thread might begin initializing \lstinline!str! again --- because
no guards existed prior to C++11 to prevent this --- and make it all the way past line (6) before it too
is suspended. When the operating system eventually resumes execution of
the first thread, the dynamic allocation and assignment on line (4)
\romeogloss{leaks} the memory for the previously constructed
\lstinline!MyString!. 

In practice, however, \romeogloss{undefined behavior} (prior to C++11) might
have manifested even earlier. When the second thread re-uses the storage
claimed by the object in the first thread, it effectively ends the
lifetime of one \lstinline!static!~\lstinline!S! object to start the lifetime
of the other one. After that, any attempt to access the original
\lstinline!s! object would be \romeogloss{undefined behavior}, because its
lifetime has ended, even though its destructor did not run. 

The C++11 Standard Library provides copious utilities and abstractions related
to multithreading. One part of that, \lstinline!std::thread!, is a portable
wrapper for a platform-specific thread handle provided by the
operating system. When constructing an \lstinline!std::thread! object
with a \romeogloss{callable object} a new thread
invoking that \romeogloss{callable object} will be spawned.   Prior to destroying such
\lstinline!std::thread! objects it is also neccessary to invoke the
\lstinline!join! member function on the thread object, which will block until
the background thread of execution completes invoking its \romeogloss{callable object}.

This threading facility from the standard library can be used
with our earlier \lstinline!Logger! example from \intraref{description-functionstatic}{logger-example},
to concurrently attempt to access the \lstinline!getLogger! function:

\begin{emcppshiddenlisting}[emcppsbatch={e6,e15}]
struct Logger {
  Logger(const char *f) {}
};
template <typename T>
void operator<<(Logger&,const T&);
Logger& getLogger();
\end{emcppshiddenlisting}
\begin{emcppslisting}[emcppsbatch=e6]
#include <thread>  // (ù{\codeincomments{std::thread}}ù)

void useLogger() { getLogger() << "example"; }  // concurrently called function

int main()
{
    std::thread t0(&useLogger);
    std::thread t1(&useLogger);
        // Spawn two new threads, each of which invokes (ù{\codeincomments{useLogger}}ù).

    // ...

    t0.join();  // Wait for (ù{\codeincomments{t0}}ù) to complete execution.
    t1.join();  // Wait for (ù{\codeincomments{t1}}ù) to complete execution.

    return 0;
}
\end{emcppslisting}

Such use prior to the C++11 thread-safety guarantees (with pre-C++11 threading libraries) could
have led to a race condition during the initialization of
\lstinline!localLogger!, which was defined as a local \lstinline!static!
object in \lstinline!getLogger!:

\noindent As of C++11, the example above has no data races provided that \linebreak%%%%%%
\lstinline!Logger::operator<<(const!~\lstinline!char*)! is designed properly
for multithreaded use, even though the
\lstinline!Logger::Logger(const!~\lstinline!char*!~\lstinline!logFilePath)!
constructor (i.e., the one used to configure the singleton instance of
the logger) is not. That is to say, the implicit \romeogloss{critical section}
that is guarded by the compiler includes evaluation of the
initializer, which is why a recursive call to initialize a
function-scope \lstinline!static! variable is undefined behavior and is
likely to result in deadlock; see \intrarefsimple{dangerous-recursive-initialization}.
Such use of function-scope \lstinline!static!s, however, is not foolproof;
see \intraref{potential-pitfalls-functionstatic}{depending-on-order-of-destruction-of-local-objects-after-main-returns}.

The destruction of \romeogloss{function-scope} \lstinline!static! objects is
and always has been guaranteed to be safe \emph{provided} (1) no threads
are running after returning from \lstinline!main! and (2)
\romeogloss{function-scope} \lstinline!static! objects do not depend on each
other during destruction; see \intraref{potential-pitfalls-functionstatic}{depending-on-order-of-destruction-of-local-objects-after-main-returns}.

\subsection[Use Cases]{Use Cases}\label{use-cases-functionstatic}

\subsubsection[Meyers Singleton]{Meyers Singleton}\label{meyers-singleton}

The guarantees surrounding access across \romeogloss{translation units} to runtime
initialized objects at file or namespace scope are few and dubious ---
especially when that access might occur prior to entering \lstinline!main!.
Consider a library component, \lstinline!libcomp!, that defines a
file-scope \lstinline!static! singleton, \lstinline!globalS!, that is
initialized at run time:

\begin{emcppshiddenlisting}[emcppsbatch=e7]
// --- Replace
struct S { /*... */ };
struct S {
  bool isInitialized();
};
// --- End
\end{emcppshiddenlisting}
\begin{emcppslisting}[emcppsbatch=e7]
// libcomp.h
#ifndef INCLUDED_LIBCOMP
#define INCLUDED_LIBCOMP

struct S { /*... */ };
S& getGlobalS();  // access to global singleton object of type (ù{\codeincomments{S}}ù)

#endif
\end{emcppslisting}

%%% ask if these are supposed to be one.  JMB: They should be separate

\begin{emcppslisting}[emcppsbatch=e7]
// libcomp.cpp
#include <libcomp.h>

static S globalS;
S& getGlobalS() { return globalS; }  // access into this translation unit
\end{emcppslisting}

\noindent The interface in the \lstinline!libcomp.h! file comprises the definition of
\lstinline!S! along with the declaration of an accessor function,
\lstinline!getGlobalS!. Any function wishing to access the singleton
\lstinline!globalS! object sequestered within the \lstinline!libcomp.cpp! file
would \emph{presumably} do so safely via the global
\lstinline!getGlobalS()! accessor function. Now consider the
\lstinline!main.cpp! file in the example below, which implements
\lstinline!main! and also makes use of \lstinline!globalS! prior to entering
\lstinline!main!:

\begin{emcppslisting}[emcppsbatch=e7]
// main.cpp
#include <cassert>    // standard C (ù{\codeincomments{assert}}ù) macro
#include <libcomp.h>  // (ù{\codeincomments{getGlobalS()}}ù)

bool globalInitFlag = getGlobalS().isInitialized();

int main()
{
    assert(globalInitFlag);   // Bug, or at least potentially so
    return 0;
}
\end{emcppslisting}

\noindent Depending on the compiler or the link line, the call
initializing \lstinline!globalInitFlag! may occur and return \emph{prior}
to the initialization of  \lstinline!globalS!.  C++ does not guarantee that objects at
file or namespace scope in separate \romeogloss{translation units} will be
initialized just because a function located within that \romeogloss{translation unit}
happens to be called.

An effective pattern for helping to ensure that a non-local object
\emph{is} initialized before it is used from a separate \romeogloss{translation unit}
--- especially when that use might occur prior to entering \lstinline!main!
--- is simply to move the \lstinline!static! object at file or namespace
scope inside the scope of the function accessing it, making it a
function-scope \lstinline!static! instead:

\begin{emcppshiddenlisting}[emcppsbatch=e8]
struct S {
};
\end{emcppshiddenlisting}
\begin{emcppslisting}[emcppsbatch=e8]
S& getGlobalS()  // access into this translation unit
{
    static S globalS;  // singleton is now function-scope (ù{\codeincomments{static}}ù)
    return globalS;
}
\end{emcppslisting}

\noindent Commonly known as the \romeogloss{Meyers Singleton}, for the
author Scott Meyers who popularized it, this pattern ensures that the
singleton object will \emph{necessarily} be initialized on the first
call to the accessor function that envelopes it, irrespective of when
and where that call is made. Moreover, that singleton object will also
live past the end of \lstinline!main!. The \romeogloss{Meyers
Singleton} pattern also gives us a chance to catch and respond to
exceptions thrown when constructing the \lstinline!static! object, rather
than immediately terminating the program, as would be the case if declared as a
\lstinline!static! global variable. Much more importantly, however, since C++11, the
\romeogloss{Meyers Singleton} pattern automatically inherits the benefits of
effortless race-free initialization of \emph{reusable} program-wide
singleton objects.  The \romeogloss{Meyers Singleton} can be safely used 
both in the programs where the singleton initialization might happen before \lstinline!main!
and those where it might happen after additional threads have already been started.  % Again, I removed "after main started" because meyers singleton is safe even if we spawn threads at global scope.

As discussed in \intrarefsimple{description-functionstatic}, the augmentation of a
thread-safety guarantee for the runtime initialization of
\romeogloss{function-scope} \lstinline!static! objects in C++11 minimizes the
effort required to create a thread-safe singleton.  Note that, prior to C++11,
the simple function-scope \lstinline!static!
implementation would not be safe if concurrent threads were trying to
initialize the logger; see \intrarefsimple{appendix:-c++03-double-checked-lock-pattern}.

The \romeogloss{Meyers Singleton} is also seen in a slightly different form
where the singleton type's constructor is made \lstinline!private! to
prevent more than just the one singleton object from being created:

%%%% note ~ in code
\begin{emcppslisting}[emcppsbatch=e10]
class Logger
{
private:
    Logger(const char* logFilePath);  // Configure the singleton,
    ~Logger();                        // suppresses copy construction too

public:
    static Logger& getInstance()
    {
        static Logger localLogger("log.txt");
        return localLogger;
    }
};
\end{emcppslisting}
\begin{emcppshiddenlisting}[emcppsbatch=e10]
template <typename T>
void operator<<(Logger&,const T&);
\end{emcppshiddenlisting}

\noindent This variant of the function-scope-\lstinline!static! singleton pattern
prevents users from manually creating rogue \lstinline!Logger! objects; the
only way to get one is to invoke the logger's \lstinline!static!
\lstinline!Logger::getInstance()! member function:

\begin{emcppslisting}[emcppsbatch=e10]
void client()
{
    Logger::getInstance() << "Hi";  // OK
    Logger myLogger("myLog.txt");   // Error, (ù{\codeincomments{Logger}}ù) constructor is (ù{\codeincomments{private}}ù).
}
\end{emcppslisting}

\noindent This formulation of the singleton pattern, however, conflates the type
of the singleton object with its use and purpose as a singleton. Once we
find a use of a singleton object, finding another and perhaps even a
third is not uncommon.  

Consider, for example, an application on an early
model of mobile phone where we want to refer to the phone's camera.
Let's presume that a \lstinline!Camera! class is a fairly involved and
sophisticated mechanism. Initially we use the variant of the Meyers
Singleton pattern where at most one \lstinline!Camera! object can be
present in the entire program. The next generation of the phone, however, turns out to have more than
one camera, say, a front \lstinline!Camera! and a back \lstinline!Camera!. Our
brittle, \emph{ToasterToothbrush}-like\footnote{See \cite{lakos20}, section~0.3, pp.~13--20, specifically  % Err.  Will *anybody* who didn't read John's books/seen his specific talks understand this ToasterToothbrush?!
Figure~0-9, p.~16.} design doesn't
admit the dual-singleton use of the same fundamental \lstinline!Camera!
type. A more finely factored solution would be to implement the
\lstinline!Camera! type separately and then to provide a thin wrapper,
e.g., perhaps using the \romeogloss{strong-\lstinline!typedef! idiom} (see \featureref{\locationa}{inheriting-constructors}), corresponding to each singleton
use:

\begin{emcppshiddenlisting}[emcppsbatch=e11]
struct Camera {
  Camera();
};    
\end{emcppshiddenlisting}
\begin{emcppslisting}[emcppsbatch=e11]
class PrimaryCamera
{
private:
    Camera& d_camera_r;
    PrimaryCamera(Camera& camera)  // implicit constructor
      : d_camera_r(camera) { }  

public:
    static PrimaryCamera getInstance()
    {
        static Camera localCamera{/*...*/};
        return localCamera;
    }
};
\end{emcppslisting}

\noindent With this design, adding a second and even a third singleton that is
able to reuse the underlying \lstinline!Camera! mechanism is facilitated.

Although this function-scope-\lstinline!static! approach is vastly superior
to the file-scope-\lstinline!static! one, it does have its limitations. In
particular, when one global facility object, such as a logger, is used
in the destructor of another function-scope static object, the logger
object may possibly have already been destroyed when it is
used.\footnote{An amusing workaround, the so-called \emph{Phoenix
Singleton}, is proposed in \cite{alexandrescu01}, section~6.6, pp.~137--139.} One approach is to construct the logger object by
explicitly allocating it and never deleting it:

\begin{emcppshiddenlisting}[emcppsbatch={e12,e13,e16,e17}]
struct Logger {
  Logger(const char *f) {}
};
\end{emcppshiddenlisting}
\begin{emcppslisting}[emcppsbatch=e12]
Logger& getLogger()
{
    static Logger& l = *new Logger("log.txt");  // dynamically allocated
    return l;  // Return a reference to the logger (on the heap).
}
\end{emcppslisting}

\noindent A distinct advantage of this approach is that once an object is created, it
\emph{never} goes away before the process ends. The disadvantage is
that, for many classic and current profiling tools (e.g., \emph{Purify},
\emph{Coverity}), this intentionally never-freed dynamic allocation is
indistinguishable from a \romeogloss{memory leak}. The ultimate workaround
is to create the object itself in \lstinline!static! memory, in an
appropriately sized and aligned region of memory{\cprotect\footnote{Note
that any memory that \lstinline!Logger! itself manages would still come
from the global heap and be recognized as memory leaks. If available,
we could leverage a polymorphic-allocator implementation such as
\lstinline!std::pmr! in C++17. We would first create a fixed-size array
of memory having \romeogloss{\lstinline!static! storage duration}. Then we would
create a \lstinline!static! memory-allocation mechanism (e.g.,
\lstinline!std::pmr::monotonic_buffer_resource!). Next we would use
placement \lstinline!new! to construct the logger within the static
memory pool using our static allocation mechanism and supply that same
mechanism to the \lstinline!Logger! object so that it could get all its
  internal memory from that static pool as well; see \cite{lakos22}.}}:

\begin{emcppslisting}[emcppsbatch=e13]
#include <new>  // placement (ù{\codeincomments{new}}ù)

Logger& getLogger()
{
    static std::aligned_storage<sizeof(Logger), alignof(Logger)>::type buf;
    static Logger& logger = *new(&buf) Logger("log.txt");  // allocate in place
    return logger;
}
\end{emcppslisting}

\noindent In this final incarnation of a decidedly non-Meyers-Singleton pattern,
we first reserve a block of memory of sufficient size and the correct
alignment for \lstinline!Logger! using \linebreak[4]%%%%%
\lstinline!std::aligned_storage!. Next
we use that storage in conjunction with placement \lstinline!new! to create
the logger directly in that static memory. Notice that this allocation
is not from the dynamic store, so typical profiling tools will not track
and will not provide a false warning when we fail to destroy this object
at program termination time. Now we can return a reference to the logger
object embedded safely in static memory knowing that it will be there
for all eternity.

\subsection[Potential Pitfalls]{Potential Pitfalls}\label{potential-pitfalls-functionstatic}

\subsubsection[\tt{static} Storage-Duration Objects are not Guaranteed to be Initialized]{{SubsubsecCode static} Storage-Duration Objects are not Guaranteed to be Initialized}\label{static-storage-duration-objects-are-not-guaranteed-to-be-initialized}

Despite C++11's guarantee that each individual function-scope
\lstinline!static! initialization will occur at most once and before control can reach
a point where the variable can be referenced, almost no similar
guarantees are made of non-local objects of \romeogloss{\lstinline!static! storage-duration} objects.
This makes any interdependencies in the initialization of such objects, especially across
\romeogloss{translation units} (TUs), an abundant source of insidious
errors.

Objects that undergo \romeogloss{constant initialization} have no issue:
such objects will never be accessible at run time before having their
initial values. Objects that are not constant
initialized{\cprotect\footnote{C++20 added a new keyword,
\lstinline!constinit!, that can be placed on a variable declaration to
\emph{require} that the variable in question undergo constant
initialization and thus can never be accessed at run time prior to the
  start of its lifetime.}} will instead be \romeogloss{zero initialized}
until their constructors run, which itself might lead to conspicuous (or
perhaps latent) undefined behavior.

As a demonstration of what can happen when we depend on the relative
order of initialization of variables at file or
namespace scope used before \lstinline!main!, consider the
\romeogloss{cyclically dependent} pair of source files, \lstinline!a.cpp! and
\lstinline!b.cpp!:

\begin{emcppslisting}
// a.cpp
extern int setB(int);  // declaration (only) of setter in other TU
int *a = new int;      // runtime initialization of file-scope variable
int setA(int i)        // Initialize (ù{\codeincomments{a}}ù) variable; then (ù{\codeincomments{b}}ù).
{
    *a = i;            // Populate the allocated heap memory.
    setB(i);           // Invoke setter to populate the other one.
    return 0;          // Return successful status.
}

// b.cpp
int *b = new int;      // runtime initialization of file-scope variable
int setB(int i)        // Initialize (ù{\codeincomments{b}}ù)
{
    *b = i;            // Populate the allocated heap memory.
    return 0;          // Return successful status.
}

extern int setA(int);  // declaration (only) of setter in other TU
int x = setA(5);       // Initialize (ù{\codeincomments{a}}ù) and (ù{\codeincomments{b}}ù).
int main()             // main program entry point
{
    return 0;          // Return successful status.
}
\end{emcppslisting}

\noindent These two \romeogloss{translation units} will be initialized before \lstinline!main! is
entered in some order, but --- regardless of that order --- the program
in the example above will wind up dereferencing a null pointer
before entering \lstinline!main!:

\begin{lstlisting}[language=bash]
$ g++ a.cpp b.cpp main.cpp
$ ./a.out
  Segmentation fault (core dumped)
\end{lstlisting}

\noindent Suppose we were to instead move the file-scope \lstinline!static! pointers,
corresponding to both \lstinline!setA! and \lstinline!setB!, inside their
respective function bodies:

\begin{emcppslisting}
// a.cpp
extern int setB(int);  // declaration (only) of setter in other TU
int setA(int i)        // Initialize this (ù{\codeincomments{static}}ù) variable; then that one.
{
    static int *p = new int;  // runtime init. of function-scope (ù{\codeincomments{static}}ù)
    *p = i;                   // Populate this (ù{\codeincomments{static}}ù)-owned heap memory.
    setB(i);                  // Invoke setter to populate the other one.
    return 0;                 // Return successful status.
}

// b.cpp (make analagous changes)
\end{emcppslisting}

\noindent Now the program reliably executes without incident:

\begin{lstlisting}[language=bash]
$ g++ a.cpp b.cpp main.cpp
$ ./a.out
$
\end{lstlisting}

\noindent In other words, even though no order exists in which the \romeogloss{translation units}
as a whole could have been initialized prior to entering
\lstinline!main! such that the \emph{file}-scope variables
would be valid before they were used, by instead making them
\emph{function}-scope \lstinline!static!, we are able to guarantee that
each variable is itself initialized before it is used, regardless of
translation-unit-initialization order.

While on the surface it may seem as though local and non-local objects of \lstinline!static! storage
duration are effectively interchangeable, this is clearly not the case.  Even when
clients cannot directly access the non-local object due to giving it
\romeogloss{internal linkage} by marking it \lstinline!static! or putting it in an \romeogloss{unnamed namespace},
the initialization behaviors make such objects behave very differently.

\subsubsection[Dangerous Recursive Initialization]{Dangerous Recursive Initialization}\label{dangerous-recursive-initialization}

As with all other initialization, control flow does not continue
\emph{past} the \romeogloss{definition} of a \lstinline!static! local object until
after the initialization is complete, making recursive \lstinline!static!
initialization --- or any initializer that might eventually call back to the same function --- dangerous:

\begin{emcppslisting}
int fz(int i)  // The behavior is undefined unless (ù{\codeincomments{i}}ù) is 0.
{
    static int dz = i ? fz(i - 1) : 0;  // Initialize recursively. (BAD IDEA)
    return dz;
}

int main()  // The program is ill-formed.
{
    int x = fz(5);  // Bug, e.g., due to possible deadlock
}
\end{emcppslisting}

\noindent In the example above, the second recursive call of \lstinline!fz!
to initialize \lstinline!dz! has undefined behavior because the control flow reached the
same definition again before the initialization of the
\lstinline!static! object was completed; hence, control flow cannot continue to the
\lstinline!return! statement in \lstinline!fz!. Given a likely implementation
with a nonrecursive mutex or similar lock, the program can potentially deadlock,
though many implementations provide better diagnostics with an exception or
assertion violation when this form of error is encountered.
{\cprotect\footnote{Prior to standardization (see \cite{ellis90}, section~6.7, p.~92),
C++ allowed control to flow past a
\lstinline!static! function-scope variable even during a recursive call
made as part of the initialization of that variable. This would result
in the rest of such a function executing with a zero-initialized and
possibly partially constructed local object. Even modern compilers,
such as GCC with \lstinline!-fno-threadsafe-statics!, allow turning off
the locking and protection from concurrent initialization and
retaining some of the pre-C++98 behavior. This optional behavior is,
however, fraught with peril and unsupported in any standard version of
  C++.}}

% For Lori: 
%@book{ellis90,
%  author = {Margaret A. Ellis and Bjarne Stroustrup},
%  title = {{The Annotated C++ Reference Manual}},
%  address = {Reading, MA},
%  publisher = {Addison-Wesley},
%  year = {1990},
%}

\subsubsection[Subtleties with Recursion]{Subtleties with Recursion}\label{subtleties-with-recursion}

Even when not recursing within the initializer itself, the rule for the
initialization of \lstinline!static! objects at function
scope becomes more subtle for self-recursive functions.
Notably, the initialization happens based
on when flow of control first passes the variable definition and \emph{not}
based on the first invocation of the containing function.  Due to this, when a recursive call
happens in relation to the definition of a \lstinline!static! local variable
impacts which values might be used for the initialization:

\begin{emcppshiddenlisting}[emcppsbatch=e2]
#include <cassert>  // standard C (ù{\codeincomments{assert}}ù) macro
\end{emcppshiddenlisting}
\begin{emcppslisting}[emcppsbatch=e2]
int fx(int i)  // self-recursive after creating function-(ù{\codeincomments{static}}ù) variable, (ù{\codeincomments{dx}}ù)
{
    static int dx = i;     // Create (ù{\codeincomments{dx}}ù) first.
    if (i) { fx(i - 1); }  // Recurse second.
    return dx;             // Return (ù{\codeincomments{dx}}ù) third.
}

int fy(int i)  // self-recursive before creating function-(ù{\codeincomments{static}}ù) variable,(ù{\codeincomments{dy}}ù)
{
    if (i) { fy(i - 1); }  // Recurse first.
    static int dy = i;     // Create (ù{\codeincomments{dy}}ù) second.
    return dy;             // Return (ù{\codeincomments{dy}}ù) third.
}

int main()
{
    int x = fx(5);  assert(x == 5);  // (ù{\codeincomments{dx}}ù) is initialized before recursion.
    int y = fy(5);  assert(y == 0);  // (ù{\codeincomments{dy}}ù) is initialized after recursion.
    return 0;
}
\end{emcppslisting}

\noindent If the self-recursion takes place \emph{after} the \lstinline!static!
variable is initialized (e.g., \lstinline!fx! in the example above), then the
\lstinline!static! object (e.g., \lstinline!dx!) is initialized on the
\emph{first} recursive call; if the recursion occurs \emph{before}
(e.g., \lstinline!fy! in the example above), the initialization (e.g., of \lstinline!dy!)
occurs on the \emph{last} recursive call.


\subsubsection[Depending on order-of-destruction of local objects after {\tt main} returns]{Depending on order-of-destruction of local objects after {\SubsubsecCode main} returns}\label{depending-on-order-of-destruction-of-local-objects-after-main-returns}

Within any given \romeogloss{translation unit}, the relative order of initialization
of objects at file or namespace scope having \romeogloss{static storage duration} is
well defined and predictable. As soon as we have a way to reference an
object outside of the current \romeogloss{translation unit}, before \lstinline!main! is
entered, we are at risk of using the object before it has been
initialized. Provided the initialization itself is not cyclic in nature,
we can make use of function-scope \lstinline!static! objects (see \intraref{use-cases-functionstatic}{meyers-singleton}) to
ensure that no such uninitialized use occurs, even across \romeogloss{translation units}
before \lstinline!main! is entered. The relative order of destruction
of such function-scope \lstinline!static! variables --- even when they
reside within the same \romeogloss{translation unit} --- is not clearly known at compile time,
as it will be the reverse of the order in which they are initialized, and
reliance on such order can easily lead to \romeogloss{undefined behavior} in
practice.

This specific problem occurs when a \lstinline!static! object at file,
namespace, or function scope uses (or might use) in its destructor
another \lstinline!static! object that is either (1) at file or namespace
scope and resides in a separate \romeogloss{translation unit} or (2) any other
function-scope \lstinline!static! object (i.e., including one in the same
\romeogloss{translation unit}). For example, suppose we have implemented a low-level
logging facility as a Meyers Singleton:

\begin{emcppslisting}[emcppsbatch=e15]
Logger& getLogger()
{
    static Logger local("log.txt");
    return local;
}
\end{emcppslisting}

\noindent Now suppose we implement a higher-level file-manager type that depends
on the function-scope \lstinline!static! logger object:

%%% note ~ in code
\begin{emcppslisting}[emcppsbatch=e15]
struct FileManager
{
    FileManager()
    {
         getLogger() << "Starting up file manager...";
         // ...
    }

    ~FileManager()
    {
        getLogger() << "Shutting down file manager...";
        // ...
    }
};
\end{emcppslisting}

\noindent Now, consider a Meyers Singleton implementation for
\lstinline!FileManager!:

\begin{emcppslisting}[emcppsbatch=e15]
FileManager& getFileManager()
{
    static FileManager fileManager;
    return fileManager;
}
\end{emcppslisting}

\noindent Whether \lstinline!getLogger! or \lstinline!getFileManager! is called first
doesn't really matter; if \lstinline!getFileManager! is called first, the
logger will be initialized as part of \lstinline!FileManager!'s
constructor. However, whether the \lstinline!Logger! or
\lstinline!FileManager! object is destroyed first \emph{is} important:

\begin{itemize}
\item{If the \lstinline!FileManager! object is destroyed prior to the \lstinline!Logger! object, the program will have well-defined behavior.}
\item{Otherwise, the program will have \romeogloss{undefined behavior} because the destructor of \lstinline!FileManager! will invoke \lstinline!getLogger!, which will now return a reference to a previously destroyed object.}
\end{itemize}

Logging in the the constructor of the \lstinline!FileManager! 
makes it certain that the logger's function-local
\lstinline!static! will be initialized before that of the file manager;
hence, since destruction occurs in reverse relative order of creation,
the logger's function-local \lstinline!static! will be destroyed after that
of the file manager. But suppose that \lstinline!FileManager! didn't always
log at construction and was created before anything else logged. In that
case, we have no reason to think that the logger would be around for the
\lstinline!FileManager! to log during its destruction after \lstinline!main!.

In the case of low-level, widely used facilities, such as a logger, a
conventional Meyers Singleton is counter-indicated. The two most common
alternatives discussed at the end of \intraref{use-cases-functionstatic}{meyers-singleton} involve never ending the lifetime of
the mechanism at all. It is worth noting that truly global objects ---
such as \lstinline!cout!, \lstinline!cerr!, and \lstinline!clog! --- from the
Standard \lstinline!iostream! Library are typically not implemented using
conventional methods and are in fact treated specially by the runtime system.

\subsection[Annoyances]{Annoyances}\label{annoyances}

\subsubsection[Overhead in single-threaded applications]{Overhead in single-threaded applications}\label{overhead-in-single-threaded-applications}

A single-threaded application invoking a function containing a
\romeogloss{function-scope} \romeogloss{\lstinline!static! storage-duration} variable might
have unnecessary synchronization overhead, such as an \romeogloss{atomic}
load operation. For example, consider a program that invokes a free
function, \lstinline!getS!, returning a function-scope \lstinline!static!
object, \lstinline!local!, of user-defined type, \lstinline!S!, having a
\romeogloss{user-provided} (inline) default constructor:  % I don't believe anyone is comfortable reading sentences like this.  Don't care enough to fight this/suggest better version.

\begin{emcppslisting}
struct S  // user-defined type
{
    S() { }  // inline default constructor
};

S& getS()  // free function returning (ù{\codeincomments{local}}ù) object
{
    static S local;  // function-scope local object
    return local;
}

int main()
{
    getS();    // Initialize the file-scope (ù{\codeincomments{static}}ù) singleton.
    return 0;  // successful status
}
\end{emcppslisting}

\noindent Although it is clearly visible to the compiler that \lstinline!getS()! is
invoked by only one thread, the generated assembly instructions might
still contain \romeogloss{atomic} operations or other forms of
synchronization and the call to \lstinline!getS()! might not be 
inlined.{\cprotect\footnote{Both GCC 10.x and Clang 10.x, using the
\lstinline!-Ofast! optimization level, generate assembly instructions for
an \romeogloss{acquire/release memory barrier} and fail to inline the call
to \lstinline!getS!. Using \lstinline!-fno-threadsafe-statics! reduces the
number of operations performed considerably but still does not lead to
the compilers' inlining of the function call. Both popular compilers
will, however, reduce the program to just two x86 assembly
instructions if the \romeogloss{user-provided} constructor of \lstinline!S!
  is either removed or defaulted (see \featureref{\locationa}{defaulted-special-member-functions});
  doing so will turn \lstinline!S! into a \romeogloss{trivially-constructible}
  type, implying that no code needs to be executed during
  initialization:

  \begin{lstlisting}[language=bash,style=footcodeplain]
  xor eax, eax  ; zero out 'eax' register
  ret           ; return from 'main'
  \end{lstlisting}

\noindent A sufficiently smart compiler might, however, not generate
  synchronization code in a single-threaded context or else provide a
  flag to control this behavior.
  }}

\subsection[See Also]{See Also}\label{see-also}

None so far.

\subsection[Further Reading]{Further Reading}\label{further-reading}

\begin{itemize}
\item{\cite{meyers04}}
\item{\cite{stroustrup20}}
\end{itemize}

\subsection[Appendix: C++03 Double-Checked Lock Pattern]{Appendix: C++03 Double-Checked Lock Pattern}\label{appendix:-c++03-double-checked-lock-pattern}

Prior to the introduction of the \romeogloss{function-scope} \lstinline!static!
object initialization guarantees discussed in \intrarefsimple{description-functionstatic}, preventing multiple initializations of \lstinline!static! objects
and use before initialization of those same objects was still needed.
Guarding access using a \lstinline!mutex! was often a significant performance cost, so
using the unreliable, double-checked lock pattern was often attempted to
avoid the overhead:

\begin{emcppshiddenlisting}[emcppsbatch=e16]
#include <mutex>  // (ù{\codeincomments{std::mutex}}ù), (ù{\codeincomments{std::lock\_guard}}ù)
\end{emcppshiddenlisting}
\begin{emcppslisting}[emcppsbatch=e16]
Logger& getInstance()
{
    static Logger* volatile loggerPtr = 0;  // hack, used to simulate *atomics*

    if (!loggerPtr)  // Does the logger need to be initialized?
    {
        static std::mutex m;
        std::lock_guard<std::mutex> guard(m);  // Lock the mutex.

        if (!loggerPtr)  // We are first, as the logger is still uninitialized.
        {
            static Logger logger("log.txt");
            loggerPtr = &logger;
        }
    }                    // Either way, the lock (ù{\codeincomments{guard}}ù) unlocks the mutex here.

    return *loggerPtr;
}
\end{emcppslisting}

\noindent In this example, we are using a \lstinline!volatile! pointer as a weak  % How about we say "incorrect" or "wrong" substitute? I mean it's not weak - it's just bad...
substitute for an atomic variable, but many implementations would
provide nonportable extensions to support atomic types. In addition to
being difficult to write, this decidedly complex workaround would often
prove unreliable. The problem is that, even though the logic appears
sound, architectural changes in widely used CPUs allowed for the CPU
itself to optimize and reorder the sequence of instructions. Without
additional support, the hardware would not see the dependency that the
second test of \lstinline!loggerPtr! has on the locking behavior of the
mutex and would do the read of \lstinline!loggedPtr! prior to acquiring the
lock. By reordering the instructions or whatever, the hardware  % or whatever?
would then allow multiple threads to acquire the lock, thinking they are
threads that need to initialize the \lstinline!static! variable.

To solve this subtle issue, concurrency library authors are expected to
issue ordering hints such as \romeogloss{fences} and \romeogloss{barriers}. A
well-implemented threading library would provide atomics equivalent to
the modern \lstinline!std::atomic! that would issue the correct
instructions when accessed and modified. The C++11 Standard makes the
compiler aware of these concerns and provides portable \emph{atomics}
and support for threading that enables users to handle such issues
correctly. The above \lstinline!getInstance! function could be corrected by
changing the type of \lstinline!loggerPtr! to
\lstinline!std::atomic<Logger*>!. Prior to C++11, despite being
complicated, the same function would reliably implement the Meyers
Singleton in C++03 on contemporary hardware.

\enlargethispage*{2ex} %%%%%% just to get that final } on this page so external reviewers don't freak out
So the final recommended solution for portable thread-safe
initialization in modern C++ is to simply let the compiler do the work
and to use the simplest implementation that gets the job done, e.g., a
Meyers Singleton (see \intraref{use-cases-functionstatic}{meyers-singleton}):

\begin{emcppslisting}[emcppsbatch=e17]o
Logger& getInstance()
{
    static Logger logger("log.txt");
    return logger;
}
\end{emcppslisting}



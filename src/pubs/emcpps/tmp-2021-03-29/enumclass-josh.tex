% 01 Feb, 2021 JMB - packet 4 compilation fixes
% 10 Feb 2021, cleaned up a bit before sending for revisions
% 4 March 2021, revisions entered and proofed
% 5 March 2021, glossary entries updated
% 5 March 2021, sent to copyediting
% 13 March 2021, copyedits in and proofed



\emcppsFeature{
    short={\lstinline!enum!~\lstinline!class!},
    tocshort={{\TOCCode enum}~{\TOCCode class}},
    long={Strongly Typed, Scoped Enumerations},
    rhshort={{\RHCode enum}~{\RHCode class}},
}{enumclass}
\setcounter{table}{0}
\setcounter{footnote}{0}
\setcounter{lstlisting}{0}
%\section[{\tt enum} {\tt class}]{Strongly Typed Scoped Enumerations}\label{enumclass}

An \lstinline!enum!~\lstinline!class! is an alternative enumeration type that provides simultaneously (1) an enclosing scope for its enumerators and (2) stronger typing compared to a classic \lstinline!enum!.

\subsection[Description]{Description}\label{description-enumclass}

C++11 introduces a novel enumeration construct, \lstinline!enum!~\lstinline!class! (or, equivalently, \lstinline!enum!~\lstinline!struct!):

\begin{emcppslisting}
enum class  Ec { A, B, C }; // scoped enumeration, (ù{\codeincomments{Ec}}ù), containing three enumerators
\end{emcppslisting}

The enumerators of the \lstinline!enum!~\lstinline!class!~\lstinline!Ec! (above) --- namely, \lstinline!A!, \lstinline!B!, and \lstinline!C! --- do not automatically become part of the enclosing scope and must be qualified to be referenced:

\begin{emcppslisting}
Ec e0 = A;      // Error, (ù{\codeincomments{A}}ù) not found
Ec e1 = Ec::A;  // OK
\end{emcppslisting}

Moreover, attempting to use an expression of type \lstinline!enum!~\lstinline!class!~\lstinline!E! as, say, an \lstinline!int! or in an arithmetic context will be flagged as an error, thus necessitating an explicit cast:

\begin{emcppslisting}
int  i0 = Ec::B;                    // Error, conversion to (ù{\codeincomments{int}}ù) not supported
int  i1 = static_cast<int>(Ec::B);  // OK, (ù{\codeincomments{i1}}ù) is (ù{\codeincomments{1}}ù).
int  i2 = 1 + Ec::B;                // Error, conversion to (ù{\codeincomments{int}}ù) not supported
int  i3 = -Ec::B;                   // Error, unsupported arithmetic operations

bool b0 = Ec::B != 2;               // Error, comparison with (ù{\codeincomments{int}}ù) unsupported
bool b1 = Ec::B != Ec::C;           // OK, (ù{\codeincomments{b1}}ù) is (ù{\codeincomments{'true'}}ù).
\end{emcppslisting}

The \lstinline!enum!~\lstinline!class! \emph{complements}, but does not replace, the classical, C-style \lstinline!enum!:

\begin{emcppslisting}
enum E { e_Enumerator0 /*= value0 */, /*...,*/ e_EnumeratorN /* = valueN */ };
    // Classic, C-style enum: enumerators are neither type safe nor scoped.
\end{emcppslisting}

For examples where the classic \lstinline!enum! shines, see \intraref{potential-pitfalls-enumclass}{strong-typing-of-an-enum-class-can-be-counterproductive} and \intraref{annoyances-enumclass}{scoped-enumerations-do-not-necessarily-add-value}.

Still, innumerable practical situations occur in which enumerators that are both scoped and more type safe would be preferred; see \intrarefsimple{introducing-the-c++11-enum-class} and \intrarefsimple{use-cases-enumclass}.

%Classic, C-style enumerations are useful and continue to fulfill
%important engineering needs:
%
%\begin{emcppslisting}
%enum EnumName { e_Enumerator0 /*= value0 */, e_EnumeratorN /* = valueN */ };
%    // classic, C-style (ù{\codeincomments{enum}}ù): enumerators are neither type-safe nor scoped
%\end{emcppslisting}
%
%\noindent For more examples where the classic \lstinline!enum! shines, see \intraref{potential-pitfalls-enumclass}{strong-typing-of-an-enum-class-can-be-counterproductive} and \intraref{annoyances-enumclass}{scoped-enumerations-do-not-necessarily-add-value}. 
%%\textit{\titleref{potential-pitfalls-enumclass}: \titleref{strong-typing-of-an-enum-class-can-be-counterproductive}} on page~\pageref{strong-typing-of-an-enum-class-can-be-counterproductive} and \textit{\titleref{annoyances-enumclass}: \titleref{scoped-enumerations-do-not-necessarily-add-value}} on page~\pageref{scoped-enumerations-do-not-necessarily-add-value}. 
%Still,
%innumerable practical situations occur in which enumerators that are
%both scoped and more type-safe would be preferred; see \intrarefsimple{introducing-the-c++11-enum-class}.
%%\textit{\titleref{introducing-the-c++11-enum-class}} on page~\pageref{introducing-the-c++11-enum-class}.

\subsubsection[Drawbacks and workarounds relating to unscoped C++03 enumerations]{Drawbacks and workarounds relating to unscoped C++03 enumerations}\label{drawbacks-and-workarounds-relating-to-unscoped-c++03-enumerations}

Since the enumerators of a classic \lstinline!enum! leak out into the
enclosing scope, if two unrelated enumerations that happen to use the
same enumerator name appear in the same scope, an ambiguity could ensue:

\begin{emcppslisting}
enum Color { e_RED, e_ORANGE, e_YELLOW };    // OK
enum Fruit { e_APPLE, e_ORANGE, e_BANANA };  // Error, (ù{\codeincomments{e\_ORANGE}}ù) is redefined.
\end{emcppslisting}

\noindent Note that
we use a lowercase, single-letter prefix, such as \lstinline!e_!, to
ensure that the uppercase enumerator name is less likely to collide
  with a legacy macro, which is especially useful in header files. The problems associated with the use of unscoped enumerations is
exacerbated when those enumerations are placed in their own respective
header files in the global or some other large namespace scope, such as
\lstinline!std!, for general reuse. In such cases, latent defects will
typically not manifest unless and until the two enumerations are
included in the same translation unit.

If the only issue were the leakage of the enumerators into the enclosing
scope, then the long-established workaround of enclosing the enumeration
within a \lstinline!struct! would suffice:

\begin{emcppslisting}[emcppsbatch=e1]
struct Color { enum Enum { e_RED, e_ORANGE, e_YELLOW };  };   // OK (scoped)
struct Fruit { enum Enum { e_APPLE, e_ORANGE, e_BANANA }; };  // OK (scoped)
\end{emcppslisting}

\noindent Employing the C++03 workaround in the above code snippet implies that
when passing such an explicitly scoped, classical \lstinline!enum! into a
function, the distinguishing name of the \lstinline!enum! is subsumed by
its enclosing \lstinline!struct! and the \lstinline!enum! name itself, such as
\lstinline!Enum!, becomes \emcppsgloss{boilerplate code}:

\begin{emcppslisting}[emcppsbatch=e1]
int enumeratorValue1 = Color::e_ORANGE;  // OK
int enumeratorValue2 = Fruit::e_ORANGE;  // OK

void colorFunc(Color::Enum color);  // enumerated (scoped) (ù{\codeincomments{Color}}ù) parameter
void fruitFunc(Fruit::Enum fruit);  // enumerated (scoped) (ù{\codeincomments{Fruit}}ù) parameter
\end{emcppslisting}

\noindent Hence, adding \emph{just} scope to a classic, C++03 \lstinline!enum! is
easily doable and might be exactly what is indicated; see \intraref{potential-pitfalls-enumclass}{strong-typing-of-an-enum-class-can-be-counterproductive}. 
%\textit{\titleref{potential-pitfalls-enumclass}: \titleref{strong-typing-of-an-enum-class-can-be-counterproductive}} on page~\pageref{strong-typing-of-an-enum-class-can-be-counterproductive}.

\subsubsection[Drawbacks relating to weakly typed, C++03 enumerators]{Drawbacks relating to weakly typed, C++03 enumerators}\label{drawbacks-relating-to-weakly-typed,-c++03-enumerators}

Historically, C++03 enumerations have been employed to represent at
least two distinct concepts:

\begin{enumerate}
\item{A collection of related, but not necessarily unique, named integral values}
\item{A pure, perhaps ordered, set of named entities in which cardinal value has no relevance}
\end{enumerate}

\noindent It will turn out that the modern \lstinline!enum!~\lstinline!class! feature,
which we will discuss in \intraref{description-enumclass}{introducing-the-c++11-enum-class}, 
%\textit{\titleref{description-enumclass}: \titleref{introducing-the-c++11-enum-class}}, 
is more closely aligned with this second
concept.

A classic enumeration, by default, has an implementation-defined
\emcppsgloss{underlying type (UT)} (see \featureref{\locationc}{explicit-enumeration-underlying-type}),
%``\titleref{explicit-enumeration-underlying-type}" on page~\pageref{explicit-enumeration-underlying-type}), 
which it uses to represent
variables of that enumerated type as well as the values of its
enumerators. Although implicit conversion \emph{to} an enumerated type is
never permitted, when implicitly converting \emph{from} a classic
\lstinline!enum! type to some arithmetic type, the \lstinline!enum! promotes
to integral types in a way similar to how its underlying type would
promote using the rules of \emcppsgloss{integral promotion} and
\emcppsgloss{standard conversion}:

\begin{emcppslisting}
void f()
{
    enum A { e_A0, e_A1, e_A2 };  // classic, C-style C++03 (ù{\codeincomments{enum}}ù)
    enum B { e_B0, e_B1, e_B2 };  //    "       "       "     "

    A a;  // Declare object (ù{\codeincomments{a}}ù) to be of type (ù{\codeincomments{A}}ù).
    B b;  //   "       "    (ù{\codeincomments{b}}ù)  " "  "       (ù{\codeincomments{B}}ù).

    a = e_B2;  // Error, cannot convert (ù{\codeincomments{e\_B2}}ù) to (ù{\codeincomments{enum}}ù) type (ù{\codeincomments{A}}ù)
    b = e_B2;  // OK, assign the value (ù{\codeincomments{e\_B2}}ù) (numerically 2) to (ù{\codeincomments{b}}ù).
    a = b;     // Error, cannot convert (ù{\codeincomments{enum type B}}ù) to (ù{\codeincomments{enum}}ù) type (ù{\codeincomments{A}}ù)
    b = b;     // OK, self-assignment
    a = 1;     // Error, invalid conversion from (ù{\codeincomments{int 1}}ù) to (ù{\codeincomments{enum}}ù) type (ù{\codeincomments{A}}ù)
    a = 0;     // Error, invalid conversion from (ù{\codeincomments{int 0}}ù) to (ù{\codeincomments{enum}}ù) type (ù{\codeincomments{A}}ù)

    bool     v = a;     // OK
    char     w = e_A0;  // OK
    int      i = e_B0;
    unsigned y = e_B1;  // OK
    float    x = b;     // OK
    double   z = e_A2;  // OK
    char*    p = e_B0;  // Error, unable to convert (ù{\codeincomments{e\_B0}}ù) to (ù{\codeincomments{char*}}ù)
    char*    q = +e_B0; // Error, invalid conversion of (ù{\codeincomments{int}}ù) to (ù{\codeincomments{char*}}ù)
}
\end{emcppslisting}

\noindent Notice that, in this example, the final two diagnostics for the
attempted initializations of \lstinline!p! and \lstinline!q!, respectively,
differ slightly. In the first, we are trying to initialize a pointer,
\lstinline!p!, with an enumerated type, \lstinline!B!. In the second, we have
creatively used the built-in unary-plus operator to explicitly promote
the enumerator to an integral type before attempting to assign it to a
pointer, \lstinline!q!. Even though the numerical value of the enumerator
is \lstinline!0! and such is known at compile time, implicit
conversion to a pointer type from anything but the literal integer
constant \lstinline!0! is not
permitted. Excluding esoteric user-defined
types, only a literal \lstinline!0! or, as of C++11, a value of type
\lstinline!std::nullptr_t! is implicitly convertible to an arbitrary
  pointer type; see \featureref{\locationa}{null-pointer-literal-(nullptr)}.
%  ``\titleref{null-pointer-literal-(nullptr)}" on page~\pageref{null-pointer-literal-(nullptr)}.

C++ fully supports comparing values of \emph{classic} \lstinline!enum!
types with values of arbitrary \emcppsgloss{arithmetic type} as well as those
of the same enumerated type; the operands of a comparator will be
promoted to a sufficiently large integer type, and the comparison will be
done with those values. Comparing values having distinct enumerated
types, however, is deprecated and will typically elicit a
warning.{\cprotect\footnote{As of C++20, attempting to compare two values of distinct classically enumerated
types is a compile-time error. Note that explicitly converting at least one of them to an
integral type --- for example, using built-in unary plus --- both
makes our intentions clear and avoids warnings.

\begin{emcppshiddenlisting}[emcppsbatch=e2]
    enum A { e_A0, e_A1, e_A2 };
    enum B { e_B0, e_B1, e_B2 };
\end{emcppshiddenlisting}
\begin{emcppslisting}[emcppsbatch=e2,style=footcode]
void test()
{
  if (e_A0 < 0)       { /* ... */ }  // OK, comparison with integral type
  if (1.0 != e_B1)    { /* ... */ }  // OK, comparison with arithmetic type
  if (A() <= e_A2)    { /* ... */ }  // OK, comparison with same enumerated type
  if (e_A0 == e_B0)   { /* ... */ }  // warning, deprecated (error as of C++20)
  if ( e_A0 == +e_B0) { /* ... */ }  // OK, unary (ù{\fncodeincomments{+}}ù) converts to integral type
  if (+e_A0 ==  e_B0) { /* ... */ }  // OK,   "        "     "     "      "
  if (+e_A0 == +e_B0) { /* ... */ }  // OK,   "        "     "     "      "
}
\end{emcppslisting}
      }}

\subsubsection[Introducing the C++11 scoped enumerations]{Introducing the C++11 scoped enumerations}\label{introducing-the-c++11-enum-class}

With the advent of modern C++, we now have a new, alternative
enumeration construct, \lstinline!enum!~\lstinline!class!, that simultaneously
addresses strong type safety and lexical scoping, two distinct and often
desirable properties:

\begin{emcppslisting}
enum class Name { e_Enumerator0 /* = value0 */, e_EnumeratorN /* = valueN */ };
    // (ù{\codeincomments{enum class}}ù) enumerators are both type-safe and scoped
\end{emcppslisting}

\noindent Another major distinction is that the default
\emcppsgloss[underlying type (UT)]{underlying type} for a C-style \lstinline!enum! is
\emcppsgloss{implementation defined}, whereas, for an
\lstinline!enum!~\lstinline!class!, it is always an \lstinline!int!. See \intraref{description-enumclass}{enum-class-and-underlying-type} and \intraref{potential-pitfalls-enumclass}{external-use-of-opaque-enumerators-enumclass}. 
%\textit{\titleref{description-enumclass}: \titleref{enum-class-and-underlying-type}} on page~\pageref{enum-class-and-underlying-type} and
%\textit{\titleref{potential-pitfalls-enumclass}: \titleref{external-use-of-opaque-enumerators-enumclass}} on page~\pageref{external-use-of-opaque-enumerators-enumclass}.

%The enumerators within an \lstinline!enum!~\lstinline!class! are all scoped by
%its name, while classic enumerations leak the enumerators into the
%enclosing scope:
%
%\begin{emcppslisting}
%enum Vehicle  { e_CAR,   e_TRAIN, e_PLANE };
%enum Geometry { e_POINT, e_LINE,  e_PLANE };  // Error, (ù{\codeincomments{e\_PLANE}}ù) is redefined.
%\end{emcppslisting}

\noindent Unlike unscoped enumerations, \lstinline!enum!~\lstinline!class! does not leak
its enumerators into the enclosing scope and can therefore help avoid
collisions with other enumerations having like-named enumerators defined
in the same scope:

\begin{emcppslisting}[emcppsbatch=e3]
enum       VehicleUnscoped  { e_CAR, e_TRAIN, e_PLANE };
struct     VehicleScopedExplicitly { enum Enum { e_CAR, e_TRAIN, e_PLANE }; };
enum class VehicleScopedImplicitly { e_CAR, e_BOAT, e_PLANE };
\end{emcppslisting}

\noindent Just like an unscoped \lstinline!enum! type, an object of a scoped enumeration type is passed as a parameter to a function
using the enumeration name itself:

\begin{emcppslisting}[emcppsbatch=e3]
void f1(VehicleUnscoped value);          // unscoped enumeration passed by value
void f2(VehicleScopedImplicitly value);  // scoped enumeration passed by value
\end{emcppslisting}

If we use the approach for
adding scope to enumerators that is described in \intraref{description-enumclass}{drawbacks-relating-to-weakly-typed,-c++03-enumerators}, 
%\textit{\titleref{description-enumclass}: \titleref{drawbacks-relating-to-weakly-typed,-c++03-enumerators}} on page~\pageref{drawbacks-relating-to-weakly-typed,-c++03-enumerators}, 
the name of the enclosing \lstinline!struct! together with a
consistent name for the enumeration, such as \lstinline!Enum!, has to be used to indicate an
enumerated type:

\begin{emcppslisting}[emcppsbatch=e3,]
void f3(VehicleScopedExplicitly::Enum value);
    // classically scoped (ù{\codeincomments{enum}}ù) passed by value
\end{emcppslisting}

\noindent Qualifying the enumerators of a scoped enumeration is the same,
irrespective of whether the scoping is explicit or implicit:

\begin{emcppslisting}[emcppsbatch=e3]
void g()
{
    f3(VehicleScopedExplicitly::e_PLANE);
        // call (ù{\codeincomments{f3}}ù) with an explicitly scoped enumerator

    f2(VehicleScopedImplicitly::e_PLANE);
        // call (ù{\codeincomments{f2}}ù) with an implicitly scoped enumerator
}
\end{emcppslisting}

\noindent Apart from implicit scoping, the modern, C++11
scoped enumeration deliberately does \emph{not} support
implicit conversion, in any context, to its \emcppsgloss[underlying type (UT)]{underlying type}:

\begin{emcppslisting}[emcppsbatch=e3]
void h()
{
    int i1 = VehicleScopedExplicitly::e_PLANE;
       // OK, scoped C++03 (ù{\codeincomments{enum}}ù) (implicit conversion)
 
    int i2 = VehicleScopedImplicitly::e_PLANE;
        // Error, no implicit conversion to underlying type

    if (VehicleScopedExplicitly::e_PLANE > 3) {} // OK
    if (VehicleScopedImplicitly::e_PLANE > 3) {} // Error, implicit conversion
}
\end{emcppslisting}

\noindent Enumerators of an \lstinline!enum!~\lstinline!class! do, however, admit
equality and ordinal comparisons within their own type:

\begin{emcppslisting}[emcppsbatch=e4]
enum class E { e_A, e_B, e_C };  // By default, enumerators increase from 0.

static_assert(E::e_A < E::e_C, "");  // OK, comparison between same-type values
static_assert(0 == E::e_A, "");      // Error, no implicit conversion from (ù{\codeincomments{E}}ù)
static_assert(0 == static_cast<int>(E::e_A), "");  // OK, explicit conversion

void f(E v)
{
    if (v > E::e_A) { /* ... */ }  // OK, comparing values of same type, (ù{\codeincomments{E}}ù)
}
\end{emcppslisting}

\noindent Note that incrementing an enumeration variable from one strongly typed
enumerator's value to the next requires an explicit cast; see \intraref{potential-pitfalls-enumclass}{strong-typing-of-an-enum-class-can-be-counterproductive}. 
%\textit{\titleref{potential-pitfalls-enumclass}: \titleref{strong-typing-of-an-enum-class-can-be-counterproductive}} on page~\pageref{strong-typing-of-an-enum-class-can-be-counterproductive}.

\subsubsection[\lstinline!enum! \lstinline!class! and underlying type]{{\SubsubsecCode enum} {\SubsubsecCode class} and underlying type}\label{enum-class-and-underlying-type}

Since C++11, both scoped and unscoped enumerations permit explicit
specification of their integral \emcppsgloss[underlying type (UT)]{underlying type} (see \featureref{\locationc}{explicit-enumeration-underlying-type}):

\begin{emcppslisting}
enum Ec : char { e_X, e_Y, e_Z };
    // underlying type is (ù{\codeincomments{char}}ù)

static_assert(1 == sizeof(Ec),     "");
static_assert(1 == sizeof Ec::e_X, "");

enum class Es : short { e_X, e_Y, e_Z };
    // underlying type is (ù{\codeincomments{short int}}ù)

static_assert(sizeof(short) == sizeof(Es),     "");
static_assert(sizeof(short) == sizeof Es::e_X, "");
\end{emcppslisting}

\noindent Unlike a classic \lstinline!enum!, which has an
\emcppsgloss[implementation defined]{implementation-defined} default \emcppsgloss[underlying type (UT)]{underlying type}, the
default \emcppsgloss[underlying type (UT)]{underlying type} for an \lstinline!enum!~\lstinline!class! is
always \lstinline!int!:

\begin{emcppslisting}
enum class Ei { e_X, e_Y, e_Z };
    // When not specified, the underlying type of an (ù{\codeincomments{enum class}}ù) is (ù{\codeincomments{int}}ù).

static_assert(sizeof(int) == sizeof(Ei),     "");
static_assert(sizeof(int) == sizeof Ei::e_X, "");
\end{emcppslisting}

\noindent Note that, because the default \emcppsgloss[underlying type (UT)]{underlying type} of an
\lstinline!enum!~\lstinline!class! is specified by the Standard, eliding the
enumerators of an \lstinline!enum!~\lstinline!class! in
a local redeclaration is \emph{always} possible; see \intraref{potential-pitfalls-enumclass}{external-use-of-opaque-enumerators-enumclass} and \featureref{\locationc}{enumopaque}. 
% \textit{\titleref{potential-pitfalls-enumclass}: \titleref{external-use-of-opaque-enumerators-enumclass}} on page~\pageref{external-use-of-opaque-enumerators-enumclass} and ``\titleref{enumopaque}" on page~\pageref{enumopaque}.

\subsection[Use Cases]{Use Cases}\label{use-cases-enumclass}

\subsubsection[Avoiding unintended implicit conversions to arithmetic types]{Avoiding unintended implicit conversions to arithmetic types}\label{avoiding-unintended-implicit-conversions-to-arithmetic-types}

Suppose that we want to represent the result of selecting one of a fixed
number of alternatives from a drop-down menu as a simple unordered set
of uniquely valued named integers. For example, this might be the case
when configuring a product, such as a vehicle, for purchase:

\begin{emcppslisting}
struct Transmission
{
    enum Enum { e_MANUAL, e_AUTOMATIC };  // classic, C++03 scoped (ù{\codeincomments{enum}}ù)
};
\end{emcppslisting}

\noindent Although automatic promotion of a classic enumerator to \lstinline!int!
works well when typical use of the enumerator involves knowing its
cardinal value, such promotions are less than ideal when cardinal values
have no role in intended usage:

\begin{emcppshiddenlisting}[emcppsbatch=e5]
void attachDoor(int i);
\end{emcppshiddenlisting}
\begin{emcppslisting}[emcppsbatch=e5]
class Car { /* ... */ };

struct Transmission
{                                         // explicitly scoped
    enum Enum { e_MANUAL, e_AUTOMATIC };  // classic (ù{\codeincomments{enum}}ù)
};                                        // (BAD IDEA)

int buildCar(Car* result, int numDoors, Transmission::Enum transmission)
{
    int status = Transmission::e_MANUAL;    // Bug, accidental misuse

    for (int i = 0; i < transmission; ++i)  // Bug, accidental misuse
    {
         attachDoor(i);
    }

    return status;
}
\end{emcppslisting}

\noindent As shown in the example above, it is never correct for a value of type
\lstinline!Transmission::Enum! to be assigned to, compared with, or otherwise
modified like an integer; hence, \emph{any} such use would necessarily
be considered a mistake and, ideally, flagged by the compiler as an
error. The stronger typing provided by \lstinline!enum!~\lstinline!class!
achieves this goal:

\begin{emcppslisting}[emcppsignore={Fails to build with all Declarations marked Error}]
class Car { /* ... */ };

enum class Transmission { e_MANUAL, e_AUTOMATIC };  // modern (ù{\codeincomments{enum class}}ù) (GOOD IDEA)

int buildCar(Car* result, int numDoors, Transmission transmission)
{
    int status = Transmission::e_MANUAL;    // Error, incompatible types

    for (int i = 0; i < transmission; ++i)  // Error, incompatible types
    {
         attachDoor(i);
    }

    return status;
}
\end{emcppslisting}

\noindent By deliberately choosing the \lstinline!enum!~\lstinline!class! over the
\emph{classic} \lstinline!enum! above, we automate the detection of many common
kinds of accidental misuse. Secondarily, we slightly simplify the interface of the function signature by removing the extra \lstinline!::Enum! boilerplate qualifications required of an explicitly
scoped, less-type-safe, classic \lstinline!enum!, but see \intraref{potential-pitfalls-enumclass}{strong-typing-of-an-enum-class-can-be-counterproductive}.
%\textit{\titleref{potential-pitfalls-enumclass}: \titleref{strong-typing-of-an-enum-class-can-be-counterproductive}} on page~\pageref{strong-typing-of-an-enum-class-can-be-counterproductive}.

In the event that the numeric value of a strongly typed
enumerator is needed (e.g., for serialization), it can be extracted
explicitly via a \lstinline!static_cast!:

\begin{emcppshiddenlisting}[emcppsbatch=e6]
class Car { /* ... */ };

enum class Transmission { e_MANUAL, e_AUTOMATIC };  // modern (ù{\codeincomments{enum class}}ù) (GOOD IDEA)
\end{emcppshiddenlisting}
\begin{emcppslisting}[emcppsbatch=e6]
const int manualIntegralValue    = static_cast<int>(Transmission::e_MANUAL);
const int automaticIntegralValue = static_cast<int>(Transmission::e_AUTOMATIC);
static_assert(0 == manualIntegralValue,    "");
static_assert(1 == automaticIntegralValue, "");
\end{emcppslisting}

\subsubsection[Avoiding namespace pollution]{Avoiding namespace pollution}\label{avoiding-namespace-pollution}

Classic, C-style enumerations do not provide scope for their
enumerators, leading to unintended latent name collisions:

\begin{emcppslisting}
// vehicle.h:
// ...
enum Vehicle  { e_CAR, e_TRAIN, e_PLANE };  // classic, C-style (ù{\codeincomments{enum}}ù)
// ...

// geometry.h:
// ...
enum Geometry { e_POINT, e_LINE, e_PLANE };  // classic, C-style (ù{\codeincomments{enum}}ù)
// ...

// client.cpp:
#include <vehicle.h>  // OK
#include <geometry.h> // Error, (ù{\codeincomments{e\_PLANE}}ù) redefined
// ...
\end{emcppslisting}

\noindent The common workaround is to wrap the \lstinline!enum! in a \lstinline!struct!
or \lstinline!namespace!:

\begin{emcppslisting}
// vehicle.h:
// ...
struct Vehicle {                            // explicitly scoped
    enum Enum { e_CAR, e_TRAIN, e_PLANE };  // classic, C-style (ù{\codeincomments{enum}}ù)
};
// ...

// geometry.h:
// ...
struct Geometry {                            // explicitly scoped
    enum Enum { e_POINT, e_LINE, e_PLANE };  // classic, C-style (ù{\codeincomments{enum}}ù)
};
// ...

// client.cpp:
#include <vehicle.h>    // OK
#include <geometry.h>   // OK, enumerators are scoped explicitly.
// ...
\end{emcppslisting}

\noindent If implicit conversions of enumerators to integral types are not
required, we can achieve the same scoping effect with much more type
safety and slightly less boilerplate --- i.e., without the
\lstinline!::Enum! when declaring a variable --- by employing
\lstinline!enum!~\lstinline!class! instead:

\begin{emcppslisting}
// vehicle.h:
// ...
enum class Vehicle { e_CAR, e_TRAIN, e_PLANE };
// ...

// geometry.h:
// ...
enum class Geometry { e_POINT, e_LINE, e_PLANE };
// ...

// client.cpp:
#include <vehicle.h>  // OK
#include <geometry.h> // OK, enumerators are scoped implicitly.
// ...
\end{emcppslisting}

\subsubsection[Improving overloading disambiguation]{Improving overloading disambiguation}\label{improving-overloading-disambiguation}

Stronger type safety of scoped enumerations might prevent mistakes when calling overloaded functions, especially when the overload set accepts multiple arguments. As an illustration of the compounding of such maintenance
difficulties, suppose that we have a widely used, named type,
\lstinline!Color!, and the numeric values of its enumerators are small,
unique, and irrelevant. Imagine we have chosen to represent
\lstinline!Color! as an unscoped \lstinline!enum!:

\begin{emcppslisting}[emcppsbatch=e7]
struct Color
{                                           // explicitly scoped
    enum Enum { e_RED, e_BLUE /*, ...*/ };  // classic, C-style (ù{\codeincomments{enum}}ù)
};                                          // (BAD IDEA)
\end{emcppslisting}

\noindent Suppose further that we have provided two overloaded functions, each
having two parameters, with one signature's parameters including the
enumeration \lstinline!Color!:

\begin{emcppslisting}[emcppsbatch=e7]
void clearScreen(int pattern, int orientation);          // (0)
void clearScreen(Color::Enum background, double alpha);  // (1)
\end{emcppslisting}

\noindent Depending on the types of the arguments supplied, one of the 
functions will be selected or else the call will be ambiguous and the
program will fail to compile{\cprotect\footnote{GCC~10.2 incorrectly diagnoses both ambiguity errors as warnings, although it
states in the warning that it is an error:

\begin{emcppslisting}[language=bash,style=footcodeplain]
warning: ISO C++ says that these are ambiguous, even though the worst conversion for the
         first is better than the worst conversion for the second:

note: candidate 1: void clearScreen(int, int)
void clearScreen(int pattern, int orientation);
     ^~~~~~~~~~~
note: candidate 2: void clearScreen(Color::Enum, double)
void clearScreen(Color::Enum background, double alpha;
     ^~~~~~~~~~~
\end{emcppslisting}
      }}:

\begin{emcppslisting}[emcppsbatch=e7]
void f0()
{
    clearScreen(1           , 1           );  // calls (0) above
    clearScreen(1           , 1.0         );  // calls (0) above
    clearScreen(1           , Color::e_RED);  // calls (0) above

    clearScreen(1.0         , 1           );  // calls (0) above
    clearScreen(1.0         , 1.0         );  // calls (0) above
    clearScreen(1.0         , Color::e_RED);  // calls (0) above

    clearScreen(Color::e_RED, 1           );  // Error, ambiguous call
    clearScreen(Color::e_RED, 1.0         );  // calls (1) above
    clearScreen(Color::e_RED, Color::e_RED);  // Error, ambiguous call
}
\end{emcppslisting}

\noindent Now suppose that we had instead defined our \lstinline!Color! enumeration
as a modern \lstinline!enum!~\lstinline!class!:

\begin{emcppslisting}[emcppsbatch=e8]
enum class Color { e_RED, e_BLUE /*, ...*/ };

void clearScreen(int pattern, int orientation);    // (2)
void clearScreen(Color background, double alpha);  // (3)
\end{emcppslisting}

\noindent The function that will be called from a given set of arguments becomes
clear:

\begin{emcppslisting}[emcppsbatch=e8]
void f1()
{
    clearScreen(1           , 1           );  // calls (2) above
    clearScreen(1           , 1.0         );  // calls (2) above
    clearScreen(1           , Color::e_RED);  // Error, no matching function

    clearScreen(1.0         , 1           );  // calls (2) above
    clearScreen(1.0         , 1.0         );  // calls (2) above
    clearScreen(1.0         , Color::e_RED);  // Error, no matching function

    clearScreen(Color::e_RED, 1           );  // calls (3) above
    clearScreen(Color::e_RED, 1.0         );  // calls (3) above
    clearScreen(Color::e_RED, Color::e_RED);  // Error, no matching function
}
\end{emcppslisting}

\noindent Returning to our original, classic-\lstinline!enum! design, suppose that we
find we need to add a third parameter, \lstinline!bool!~\lstinline!z!, to the
second overload:

\begin{emcppshiddenlisting}[emcppsbatch=e9]
struct Color
{
    enum Enum { e_RED, e_BLUE /*, ...*/ };
};
\end{emcppshiddenlisting}
\begin{emcppslisting}[emcppsbatch=e9]
void clearScreen(int pattern, int orientation);                  // (0)
void clearScreen(Color::Enum background, double alpha, bool z);  // (4) classic
\end{emcppslisting}

\noindent If our plan is that any existing client calls involving
\lstinline!Color::Enum! will now be flagged as errors, we are going to be
very disappointed:

\begin{emcppslisting}[emcppsbatch=e9]
void f2()
{
    clearScreen(Color::e_RED, 1.0);  // calls (0) above
}
\end{emcppslisting}

\noindent In fact, every combination of arguments above --- all nine of them ---
will call function (0) above, often with no warnings at all:

\begin{emcppslisting}[emcppsbatch=e9]
void f3()
{
    clearScreen(1           , 1           );  // calls (0) above
    clearScreen(1           , 1.0         );  // calls (0) above
    clearScreen(1           , Color::e_RED);  // calls (0) above

    clearScreen(1.0         , 1           );  // calls (0) above
    clearScreen(1.0         , 1.0         );  // calls (0) above
    clearScreen(1.0         , Color::e_RED);  // calls (0) above

    clearScreen(Color::e_RED, 1           );  // calls (0) above
    clearScreen(Color::e_RED, 1.0         );  // calls (0) above
    clearScreen(Color::e_RED, Color::e_RED);  // calls (0) above
}
\end{emcppslisting}

\noindent Finally, let's suppose again that we have used
\lstinline!enum!~\lstinline!class! to implement our \lstinline!Color!\linebreak[4]
\mbox{enumeration}:

\begin{emcppshiddenlisting}[emcppsbatch=e10]
enum class Color { e_RED, e_BLUE /*, ...*/ };
\end{emcppshiddenlisting}
\begin{emcppslisting}[emcppsbatch=e10]
void clearScreen(int pattern, int orientation);            // (2)
void clearScreen(Color background, double alpha, bool z);  // (5) modern

void f4()
{
    clearScreen(Color::e_RED, 1.0);  // Error, no matching function
}
\end{emcppslisting}

\noindent And in fact, the \emph{only} calls that succeed unmodified are precisely
those that do not involve the enumeration \lstinline!Color!, as desired:

\begin{emcppslisting}[emcppsbatch=e10]
void f5()
{
    clearScreen(1           , 1           );  // calls (2) above
    clearScreen(1           , 1.0         );  // calls (2) above
    clearScreen(1           , Color::e_RED);  // Error, no matching function

    clearScreen(1.0         , 1           );  // calls (2) above
    clearScreen(1.0         , 1.0         );  // calls (2) above
    clearScreen(1.0         , Color::e_RED);  // Error, no matching function

    clearScreen(Color::e_RED, 1           );  // Error, no matching function
    clearScreen(Color::e_RED, 1.0         );  // Error, no matching function
    clearScreen(Color::e_RED, Color::e_RED);  // Error, no matching function
}
\end{emcppslisting}

\noindent Bottom line: Having a \emph{pure} enumeration be strongly typed --- such as
\lstinline!Color!, used widely in function signatures --- can help to expose accidental misuse but, again, see \intraref{potential-pitfalls-enumclass}{strong-typing-of-an-enum-class-can-be-counterproductive}.
%\textit{\titleref{potential-pitfalls-enumclass}: \titleref{strong-typing-of-an-enum-class-can-be-counterproductive}} on page~\pageref{strong-typing-of-an-enum-class-can-be-counterproductive}.

Note that strongly typed enumerations help to avoid accidental misuse by
requiring an explicit \emph{cast} should conversion to an arithmetic
type be desired:

\begin{emcppslisting}[emcppsbatch=e10]
void f6()
{
    clearScreen(Color::e_RED, 1.0);                   // Error, no match
    clearScreen(static_cast<int>(Color::e_RED), 1.0); // OK, calls (2) above
    clearScreen(Color::e_RED, 1.0, false);            // OK, calls (5) above
}
\end{emcppslisting}


\subsubsection[Encapsulating implementation details within the enumerators themselves]{Encapsulating implementation details within the enumerators themselves}\label{encapsulating-implementation-details-within-the-enumerators-themselves}

In rare cases, providing a pure, ordered enumeration having unique (but
not necessarily contiguous) numerical values that exploit lower-order
bits to categorize and make readily available important
individual properties might offer an advantage, such as in performance. Note that in order to preserve the ordinality of the enumerators
overall, the higher-level bits must encode their relative order. The
lower-level bits are then available for arbitrary use in the
  implementation.

For example, suppose that we have a \lstinline!MonthOfYear! enumeration that encodes in the least-significant bit the months
that have 31 days  and an accompanying \lstinline!inline! function to quickly determine whether a given enumerator represents such a month:

\begin{emcppslisting}
#include <type_traits>  // (ù{\codeincomments{std::underlying\_type}}ù)

enum class MonthOfYear : unsigned char  // optimized to flag long months
{
    e_JAN = ( 1 << 4) + 0x1,
    e_FEB = ( 2 << 4) + 0x0,
    e_MAR = ( 3 << 4) + 0x1,
    e_APR = ( 4 << 4) + 0x0,
    e_MAY = ( 5 << 4) + 0x1,
    e_JUN = ( 6 << 4) + 0x0,
    e_JUL = ( 7 << 4) + 0x1,
    e_AUG = ( 8 << 4) + 0x1,
    e_SEP = ( 9 << 4) + 0x0,
    e_OCT = (10 << 4) + 0x1,
    e_NOV = (11 << 4) + 0x0,
    e_DEC = (12 << 4) + 0x1
};

bool hasThirtyOneDays(MonthOfYear month)
{
    return static_cast<std::underlying_type<MonthOfYear>::type>(month) & 0x1;
}
\end{emcppslisting}

\noindent In the example above, we are using a new cross-cutting
feature of all enumerated types that allows the client defining the
type to specify its underlying type precisely. In this case, we have
chosen an \lstinline!unsigned!~\lstinline!char! to maximize the number of
flag bits while keeping the overall size to a single byte. Three bits
remain available. Had we needed more flag bits, we could have just as
easily used a larger underlying type, such as
  \lstinline!unsigned!~\lstinline!short!; see \featureref{\locationc}{explicit-enumeration-underlying-type}.
  %``\titleref{explicit-enumeration-underlying-type}" on page~\pageref{explicit-enumeration-underlying-type}.

\noindent In case \lstinline!enum!s are used for encoding purposes, the public clients are not intended to make use of the
cardinal values; hence clients are well advised to treat them as
implementation details, potentially subject to change without notice.
Representing this enumeration using the modern
\lstinline!enum!~\lstinline!class!, instead of an explicitly scoped classic
\lstinline!enum!, deters clients from making any use (apart from same-type
comparisons) of the cardinal values assigned to the enumerators. Notice
that implementors of the \lstinline!hasThirtyOneDays! function will require
a verbose but efficient \lstinline!static_cast! to resolve the
cardinal value of the enumerator and thus make the requested
determination as efficiently as possible.

\subsection[Potential Pitfalls]{Potential Pitfalls}\label{potential-pitfalls-enumclass}

\subsubsection[Strong typing of an \lstinline!enum! \lstinline!class! can be counterproductive]{Strong typing of an {\SubsubsecCode enum} {\SubsubsecCode class} can be counterproductive}\label{strong-typing-of-an-enum-class-can-be-counterproductive}

The additive value in using a scoped enumeration is governed \emph{solely} by whether the stronger typing of its enumerators, and \emph{not} the implicit scoping, would be beneficial in typical anticipated usage.
If the expectation is that the client will
never need to know the specific values of the enumerators, then use
of the modern \lstinline!enum!~\lstinline!class! is often just what's needed.
But if the cardinal values themselves are ever needed during typical
use, extracting them will require the client to perform an explicit
cast. Beyond mere inconvenience, encouraging clients to use casts
invites defects.

Suppose, for example, we have a function, \lstinline!setPort!, from an
external library that takes an integer port number:

\begin{emcppslisting}[emcppsbatch=e11]
int setPort(int portNumber);
    // Set the current port; return (ù{\codeincomments{0}}ù) on success and a nonzero value otherwise.
\end{emcppslisting}

\noindent Suppose further that we have used the modern
\lstinline!enum!~\lstinline!class! feature to implement an enumeration,
\lstinline!SysPort!, that identifies well-known ports on our system:

\begin{emcppslisting}[emcppsbatch=e11]
enum class SysPort { e_INPUT = 27, e_OUTPUT = 29, e_ERROR = 32, e_CTRL = 6 };
    // enumerated port values used to configure our systems
\end{emcppslisting}

\noindent Now suppose we want to call the function \lstinline!setPort! using one of these
enumerated values:

\begin{emcppslisting}[emcppsbatch=e11]
void setCurrentPortToCtrl()
{
    setPort(SysPort::e_CTRL);  // Error, cannot convert (ù{\codeincomments{SysPort}}ù) to (ù{\codeincomments{int}}ù)
}
\end{emcppslisting}

\noindent Unlike the situation for a \emph{classic} \lstinline!enum!, no implicit
conversion occurs from an \lstinline!enum!~\lstinline!class! to its underlying
integral type, so anyone using this enumeration will be forced to
somehow explicitly \emcppsgloss{cast} the enumerator to some arithmetic type.
There are, however, multiple choices for performing this cast:

\begin{emcppslisting}[emcppsbatch=e11]
#include <type_traits>  // (ù{\codeincomments{std::underlying\_type}}ù)

void test()
{
    setPort(int(SysPort::e_CTRL));                                       // (1)
    setPort((int)SysPort::e_CTRL);                                       // (2)
    setPort(static_cast<int>(SysPort::e_CTRL));                          // (3)
    setPort(static_cast<std::underlying_type<SysPort>::type>(            // (4)
                                                         SysPort::e_CTRL));
    setPort(static_cast<int>(                                            // (5)
             static_cast<std::underlying_type<SysPort>::type>(SysPort::e_CTRL)));
}
\end{emcppslisting}

\noindent Any of the above casts would work in this case, but consider a future
where a platform changed \lstinline!setPort! to take a \lstinline!long! and
the control port was changed to a value that cannot be represented as an
\lstinline!int!:

\begin{emcppslisting}
int setPort(long portNumber);
enum class SysPort : unsigned { e_INPUT = 27, e_OUTPUT = 29, e_ERROR = 32,
                                e_CTRL = 0x80000000 };
    // enumerated port values used to configure our systems
\end{emcppslisting}

\noindent Only casting method (4) above will pass the correct value for
\lstinline!e_CTRL! to this new \lstinline!setPort! implementation. The other
variations will all pass a negative number for the port, which would
certainly not be the intention of the user writing this code. A classic
C-style \lstinline!enum! would have avoided any manually written cast
entirely and the proper value would propagate into \lstinline!setPort! even
as the range of values used for ports changes:

\begin{emcppshiddenlisting}[emcppsbatch=e12]
#include <type_traits>  // (ù{\codeincomments{std::is\_same}}ù)
int setPort(long portNumber);
\end{emcppshiddenlisting}
\begin{emcppslisting}[emcppsbatch=e12]
struct SysPort  // explicit scoping for a classic, C-style (ù{\codeincomments{enum}}ù)
{
    enum Enum { e_INPUT = 27, e_OUTPUT = 29, e_ERROR = 32,
                e_CTRL = 0x80000000 };

    // Note that the underlying type of (ù{\codeincomments{Enum}}ù) is implicit and will be
    // large enough to represent all of these values.
    static_assert(
        std::is_same<std::underlying_type<Enum>::type,unsigned>::value, "");
};

void setCurrentPortToCtrl()
{
    setPort(SysPort::e_CTRL);  // OK, (ù{\codeincomments{SysPort::Enum}}ù) promotes to (ù{\codeincomments{long}}ù).
}
\end{emcppslisting}

\noindent When the intended client will depend on the cardinal values of the
enumerators during routine use, we can avoid tedious, error-prone, and
repetitive casting by instead employing a classic, C-style
\lstinline!enum!, possibly nested within a \lstinline!struct! to achieve
explicit scoping of its enumerators. The subsections that follow
highlight specific cases in which classic, C-style, C++03
\lstinline!enum!s are appropriate.

\subsubsection[Misuse of \lstinline!enum! \lstinline!class! for collections of named constants]{Misuse of {\SubsubsecCode enum} {\SubsubsecCode class} for collections of named constants}\label{misuse-of-enum-class-for-collections-of-named-constants}

When constants are truly independent, we are often encouraged to avoid
enumerations altogether, preferring instead individual constants; see \featureref{\locationc}{constexprvar}. 
%``\titleref{Default-Member-Initializers}" on page~\pageref{Default-Member-Initializers}. 
On the other hand, when the constants all participate within a coherent
theme, the expressiveness achieved using a \emph{classic} \lstinline!enum!
to aggregate those values is compelling. Another
advantage of an enumerator over an individual constant is that the
enumerator is guaranteed to be a \emcppsgloss[compile time constant]{compile-time constant} (see \featureref{\locationc}{constexprvar})
%  ``\titleref{constexprvar}" on page~\pageref{constexprvar}) 
  and a \romeovalue{prvalue} (see \featureref{\locationc}{Rvalue-References}), 
%  ``\titleref{Rvalue-References}" on page~\pageref{Rvalue-References}), 
  which never needs static storage
  and cannot have its address taken.

For example, suppose we want to collect the coefficients for various
numerical suffixes representing \emph{thousands}, \emph{millions}, and
\emph{billions} using an enumeration:

\begin{emcppslisting}[emcppsbatch=e13]
enum class S0 { e_K = 1000, e_M = e_K * e_K, e_G = e_M * e_K };  // (BAD IDEA)
\end{emcppslisting}

\noindent A client trying to access one of these enumerated values would need to
cast it explicitly:

\begin{emcppslisting}[emcppsbatch=e13]
void client0()
{
    int distance = 5 * static_cast<int>(S0::e_K);  // casting is error-prone
    // ...
}
\end{emcppslisting}

\noindent By instead making the enumeration an explicitly scoped, \emph{classic}
\lstinline!enum! nested within a \lstinline!struct!, no casting is needed
during typical use:

\begin{emcppslisting}
struct S1  // scoped
{
    enum Enum { e_K = 1000, e_M = e_K * e_K, e_G = e_M * e_K };
        // *classic* (ù{\codeincomments{enum}}ù) (GOOD IDEA)
};

void client1()
{
    int distance = 5 * S1::e_K;  // no casting required during typical use
    // ...
}
\end{emcppslisting}

\noindent If the intent is that these constants will be specified and used in a
purely local context, we might choose to drop the enclosing scope, along
with the name of the enumeration itself: 
%; see \featureref{\locationa}{local-types-as-template-arguments}:
%``\titleref{local-types-as-template-arguments}" on page~\pageref{local-types-as-template-arguments}:

\begin{emcppslisting}
void client2()
{
    enum { e_K = 1000, e_M = e_K * e_K, e_G = e_M * e_K };  // function scoped

    double salary = 95 * e_K;
    double netWorth = 0.62 * e_M;
    double companyRevenue = 47.2 * e_G;
    // ...
}
\end{emcppslisting}

\noindent We sometimes use the
lowercase prefix \lstinline!k_! instead of \lstinline!e_! to indicate
salient \emcppsgloss[compile time constant]{compile-time constants} that are not considered part
of an enumerated set, irrespective of whether they are implemented as
enumerators:

\begin{emcppslisting}[language=C++]
enum { k_NUM_PORTS = 500, k_PAGE_SIZE = 512 };     // compile-time constants
static const double k_PRICING_THRESHOLD = 0.03125; // compile-time constant
\end{emcppslisting}

\subsubsection[Misuse of \lstinline!enum! \lstinline!class! in association with bit flags]{Misuse of {\SubsubsecCode enum} {\SubsubsecCode class} in association with bit flags}\label{misuse-of-enum-class-in-association-with-bit-flags}

Using \lstinline!enum!~\lstinline!class! to implement enumerators that are
intended to interact closely with arithmetic types will typically
require the definition of arithmetic and bitwise operator overloads
between values of the same enumeration and between the enumeration and
arithmetic types, leading to yet more code that needs to be written,
tested, and maintained. This is often the case for bit flags. Consider, for example, an
enumeration used to control a file system:

\begin{emcppslisting}[emcppsbatch=e14]
enum class Ctrl { e_READ = 0x1, e_WRITE = 0x2, e_EXEC = 0x4 };  // (BAD IDEA)
    // low-level bit flags used to control file system

void chmodFile(int fd, int access);
    // low-level function used to change privileges on a file
\end{emcppslisting}

\noindent We could conceivably write a series of functions to combine the
individual flags in a type-safe manner:

\begin{emcppslisting}[emcppsbatch=e14]
#include <type_traits>  // (ù{\codeincomments{std::underlying\_type}}ù)

int flags() { return 0; }
int flags(Ctrl a) { return static_cast<std::underlying_type<Ctrl>::type>(a); }
int flags(Ctrl a, Ctrl b) { return flags(a) | flags(b); }
int flags(Ctrl a, Ctrl b, Ctrl c) { return flags(a, b) | flags(c); }

void setRW(int fd)
{
    chmodFile(fd, flags(Ctrl::e_READ, Ctrl::e_WRITE));  // (BAD IDEA)
}
\end{emcppslisting}

\noindent Alternatively, a \emph{classic}, C-style \lstinline!enum! nested within a
\lstinline!struct! achieves what's needed:

\begin{emcppslisting}
struct Ctrl // scoped
{
    enum Enum { e_READ = 0x1, e_WRITE = 0x2, e_EXEC = 0x4 };  // classic (ù{\codeincomments{enum}}ù)
        // low-level bit flags used to control file system (GOOD IDEA)
};

void chmodFile(int fd, int access);
    // low-level function used to change privileges on a file

void setRW(int fd)
{
    chmodFile(fd, Ctrl::e_READ | Ctrl::e_WRITE);  // (GOOD IDEA)
}
\end{emcppslisting}


\subsubsection[Misuse of \lstinline!enum! \lstinline!class! in association with iteration]{Misuse of {\SubsubsecCode enum} {\SubsubsecCode class} in association with iteration}\label{misuse-of-enum-class-in-association-with-iteration}

Sometimes the relative values of enumerators are considered important as
well. For example, let's again consider enumerating the months of the
year (grouped by astronomical seasons in the Northern temperate zone):

\begin{emcppslisting}[emcppsbatch={e15,e16}]
enum class MonthOfYear  // modern, strongly typed enumeration
{
    e_JAN, e_FEB, e_MAR,  // winter
    e_APR, e_MAY, e_JUN,  // spring
    e_JUL, e_AUG, e_SEP,  // summer
    e_OCT, e_NOV, e_DEC   // autumn
};
\end{emcppslisting}

\noindent If all we need to do is compare the ordinal values of the enumerators,
there's no problem:

\begin{emcppslisting}[emcppsbatch=e15]
bool isSummer(MonthOfYear month)
{
    return MonthOfYear::e_JUL <= month && month <= MonthOfYear::e_SEP;
}
\end{emcppslisting}

\noindent Although the \lstinline!enum!~\lstinline!class! features allow for relational
and equality operations between like-typed enumerators, no arithmetic
operations are supported directly, which becomes problematic when we
need to iterate over the enumerated values:

\begin{emcppslisting}[emcppsbatch=e15,emcppsignore={Entire for block is marked Error}]
void doSomethingWithEachMonth()
{
    for (MonthOfYear i =  MonthOfYear::e_JAN;
                     i <= MonthOfYear::e_DEC;
                   ++i)  // Error, no match for (ù{\codeincomments{++}}ù)
    {
        // ...
    }
}
\end{emcppslisting}

\noindent To make this code compile, an explicit cast from and to the enumerated
type will be required:

\begin{emcppslisting}[emcppsbatch=e15]
void doSomethingWithEachMonth()
{
    for (MonthOfYear i =  MonthOfYear::e_JAN;
                     i <= MonthOfYear::e_DEC;
                     i = static_cast<MonthOfYear>(static_cast<int>(i) + 1))
    {
        // ...
    }
}
\end{emcppslisting}

\noindent Alternatively, an auxiliary, helper function could be supplied to allow
clients to bump the enumerator:

\begin{emcppslisting}[emcppsbatch=e16]
MonthOfYear nextMonth(MonthOfYear value)
{
    return static_cast<MonthOfYear>((static_cast<int>(value) + 1) % 12);
}

void doSomethingWithEachMonth()
{
    for (MonthOfYear i =  MonthOfYear::e_JAN;
                     i <= MonthOfYear::e_DEC;
                     i = nextMonth(i))
    {
        // ...
    }
}
\end{emcppslisting}

\noindent If, however, the cardinal value of the \lstinline!MonthOfYear! enumerators
is likely to be relevant to clients, an explicitly scoped \emph{classic}
\lstinline!enum! should be considered as a viable alternative:

\begin{emcppslisting}
struct MonthOfYear  // explicit scoping for (ù{\codeincomments{enum}}ù)
{
    enum Enum
    {
        e_JAN, e_FEB, e_MAR,  // winter
        e_APR, e_MAY, e_JUN,  // spring
        e_JUL, e_AUG, e_SEP,  // summer
        e_OCT, e_NOV, e_DEC   // autumn
    };
};

bool isSummer(MonthOfYear::Enum month)  // must now pass nested (ù{\codeincomments{Enum}}ù) type
{
    return MonthOfYear::e_JUL <= month && month <= MonthOfYear::e_SEP;
}

void doSomethingWithEachMonth()
{
    for (int i =  MonthOfYear::e_JAN;  // iteration variable is now an (ù{\codeincomments{int}}ù)
             i <= MonthOfYear::e_DEC;
           ++i)  // OK, convert to underlying type
    {
        // ... (might require cast back to enumerated type)
    }
}
\end{emcppslisting}

\noindent Note that such code presumes that the enumerated values will (1) remain
in the same order and (2) have contiguous numerical values irrespective
of the implementation choice.

\subsubsection[External use of opaque enumerators]{External use of opaque enumerators}\label{external-use-of-opaque-enumerators-enumclass}

Since scoped enumerations have an \emcppsgloss{underlying
type (UT)} of \lstinline!int! by default, clients are always able to (re)declare
it, as a \emcppsgloss{complete type}, without its enumerators. Unless the
opaque form of an \lstinline!enum!~\lstinline!class!'s definition is exported
in a header file separate from the one implementing the publicly
accessible full definition, external clients wishing to exploit the
opaque version will experience an \emph{attractive nuisance} in that
they can provide it locally, along with its \emcppsgloss[underlying type (UT)]{underlying type}, if
any.

If the underlying type of the full definition were to subsequently
change, any program incorporating the original elided definition locally
and also the new, full one from the header would become silently \emcppsgloss{ill formed, no diagnostic required (IFNDR)}; see \featureref{\locationc}{enumopaque}.
%``\titleref{enumopaque}" on page~\pageref{enumopaque}.

\subsection[Annoyances]{Annoyances}\label{annoyances-enumclass}

\subsubsection[Scoped enumerations do not necessarily add value]{Scoped enumerations do not necessarily add value}\label{scoped-enumerations-do-not-necessarily-add-value}

When the enumeration is local, say, within the scope of a given
function, forcing an additional scope on the enumerators is superfluous.
For example, consider a function that returns an integer status
\lstinline!0! on success and a nonzero value otherwise:

\begin{emcppslisting}[emcppserrorlines={5,7}]
int f()
{
    enum { e_ERROR = -1, e_OK = 0 } result = e_OK;
    // ...
    if (/* error 1 */) { result = e_ERROR; }
    // ...
    if (/* error 2 */) { result = e_ERROR; }
    // ...
    return result;
}
\end{emcppslisting}

\noindent Use of \lstinline!enum!~\lstinline!class! in this context would require
potentially needless qualification --- and perhaps even casting ---
where it might not be warranted:

\begin{emcppslisting}[emcppserrorlines={5,7}]
int f()
{
    enum class RC { e_ERROR = -1, e_OK = 0 } result = RC::e_OK;
    // ...
    if (/* error 1 */) { result = RC::e_ERROR; } // undesirable qualification
    // ...
    if (/* error 2 */) { result = RC::e_ERROR; } // undesirable qualification
    // ...
    return static_cast<int>(result);  // undesirable explicit cast
}
\end{emcppslisting}

\subsection[See Also]{See Also}\label{see-also}

\begin{itemize}
\item{\seealsoref{enumopaque}{\seealsolocationc}illustrates how sometimes it is useful to entirely insulate individual enumerators from clients.}
\item{\seealsoref{explicit-enumeration-underlying-type}{\seealsolocationc}shows how, absent implicit conversion to integrals, \lstinline!enum! class values may use \lstinline!static_cast! in conjunction with their underlying type.}
\end{itemize}

\subsection[Further Reading]{Further Reading}\label{further-reading}

\begin{itemize}
\item{\cite{miller19}}
\item{\cite{meyers15}}
\end{itemize}



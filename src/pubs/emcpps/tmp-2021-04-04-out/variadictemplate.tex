% 3 April 2021, cleanup and updated commands; off to Josh for code review
% 5 April 2021 JMB, code cleanup, responded to AU questions

\emcppsFeature{
    short={Variadic Templates},
    long={Variable-Argument-Count Templates},
}{variadictemplate}
\label{variadic-templates}
\setcounter{table}{0}
\setcounter{footnote}{0}
\setcounter{lstlisting}{0}
%\section[Variadic Templates]{Variable-Argument-Count Templates}\label{variadictemplate}
%\subsection[Variadic Templates]{Variadic Templates}\label{variadic-templates}

\noindent\textbf{By Andrei Alexandrescu}\\[.5ex]


Variadic templates provide language-level support for specifying
templates that accept an arbitrary number of template arguments.

\subsection[Description]{Description}\label{description-variadic}

Experience with C++03 revealed a recurring need to specify a class or
function that accepts an arbitrary number of arguments. The C++03
workarounds often require considerable boilerplate and hardcoded
limitations that impede usability. Consider, for example, a function
\lstinline!concat! taking zero or more
\lstinline!const!~\lstinline!std::string&!, \lstinline!const!~\lstinline!char*!, or
\lstinline!char! arguments and returning an \lstinline!std::string! that is
the concatenation of that argument sequence:

\begin{emcppshiddenlisting}[emcppsbatch=e1]
#include <string>  // (ù{\codeincomments{std::string}}ù)
template <typename...Args>
std::string concat(Args&&... args) { return ""; }
\end{emcppshiddenlisting}
\begin{emcppslisting}[emcppsbatch=e1]
#include <string>  // (ù{\codeincomments{std::string}}ù)

std::string d = "d";
std::string str0 = concat();                // (ù{\codeincomments{str0 == ""}}ù) (by definition)
std::string str1 = concat("apple");         // (ù{\codeincomments{str1 == "apple"}}ù)
std::string str2 = concat('b', "ccd");      // (ù{\codeincomments{str2 == "bccd"}}ù)
std::string str3 = concat(d, 'e', "fg");    // (ù{\codeincomments{str3 == "defg"}}ù)
\end{emcppslisting}
    

\noindent One advantage of using a variadic function, such as \lstinline!concat!,
instead of repeatedly using the \lstinline!+! operator is that the
\lstinline!concat! function can build the destination string exactly once,
whereas each invocation of \lstinline!+! creates and returns a new
\lstinline!std::string! object.

A simpler example is a variadic function, \lstinline!add!, that calculates
the sum of zero or more integer values supplied to it:

\begin{emcppshiddenlisting}[emcppsbatch=e2]
template <typename...Args>
int add(Args&&... args) { return 0; }
\end{emcppshiddenlisting}
\begin{emcppslisting}[emcppsbatch=e2]
int v0 = add();         // (ù{\codeincomments{v0}}ù) ==  0 (by definition)
int v1 = add(3);        // (ù{\codeincomments{v1}}ù) ==  3
int v2 = add(-6, 2);    // (ù{\codeincomments{v2}}ù) == -4
int v4 = add(7, 1, 4);  // (ù{\codeincomments{v3}}ù) == 12
// ...
\end{emcppslisting}
    

\noindent Historically, variadic functions, such as \lstinline!concat! and
\lstinline!add! (above), were implemented as a suite of related
non-variadic functions accepting progressively more arguments, up to
some arbitrary limit (e.g., 20) chosen by the implementer:

\begin{emcppslisting}
int add();
int add(int);
int add(int, int);
int add(int, int, int);
// ...
// ... declarations from 4 to 19 (ù{\codeincomments{int}}ù) parameters elided
// ...
int add(int, int, int, /* 16 more (ù{\codeincomments{int}}ù) parameters elided, */ int);
\end{emcppslisting}
    

\noindent Given the existence of an identity value (zero for addition), an
alternative approach would be to have a single \lstinline!add! function but
with each of the parameters defaulted:

\begin{emcppslisting}
int add(int=0, int=0, /* 17 more defaulted parameters omitted */ int=0);
\end{emcppslisting}
    

\noindent However, \lstinline!concat! cannot use the same approach because each of
its arguments may be a \lstinline!char!, a \lstinline!const!~\lstinline!char*!,
or an \lstinline!std::string! (or types convertible thereto), and no single
type accommodates all of these possibilities. To accept an arbitrary mix
of arguments of the allowed types with maximal efficiency, the
brute-force approach would require the definition of an exponential
number of overloads taking any combination of \lstinline!char!,
\lstinline!const!~\lstinline!char*!, and
\lstinline!const!~\lstinline!std::string&!, again up to some
implementation-chosen maximum number of parameters, \(N\).

With such an approach, the number of required overloads is \(O(3^{N})\),
which means that accommodating a maximum of just \(5\) arguments would
require \(283\) overloads and \(10\) arguments would require \(88,573\)
overloads!{\cprotect\footnote{The \lstinline!std::string_view! standard
library type introduced with C++17 would help here because it accepts
conversion from both \lstinline!const!~\lstinline!char*! and
\lstinline!std::string! and incurs no significant overhead. However,
\lstinline!std::string_view! cannot be initialized from a single
\lstinline!char!, so we'd be looking at $O(2^{N})$ instead of
  $O(3^{N})$ --- not a dramatic improvement.}} Defining a suite of
$N$ function \emph{templates} instead is one approach to avoiding this
combinatorial explosion of overloads:

\begin{emcppslisting}
#include <string>  // (ù{\codeincomments{std::string}}ù)

std::string concat();                                    // 0 arguments

template <typename T1>
std::string concat(const T1&);                           // 1 argument

template <typename T1, typename T2>
std::string concat(const T1&, const T2&);                // 2 arguments

template <typename T1, typename T2, typename T3>
std::string concat(const T1&, const T2&, const T3&);     // 3 arguments

// ...
// ... similar declarations taking up to, say, 20 parameters
// ...
\end{emcppslisting}
    

\noindent Using conventional function templates, we can drastically reduce the
volume of source code required, albeit with some manageable increase in
implementation complexity.

Each of the $N + 1$ templates can be written to accept any combination
of its $M$ arguments $(0 \leq M \leq N)$ such that each parameter
will independently bind to a \lstinline!const!~\lstinline!char*!, an
\lstinline!std::string!, or a \lstinline!char! with no unnecessary conversions
or extra copies at run time. Of the exponentially many possible
\lstinline!concat! template instantiations, the compiler generates --- on
demand --- only those overloads that are actually invoked.

With the introduction of variadic templates in C++11, we are now able to
represent variadic functions such as \lstinline!add! or \lstinline!concat!
with just a single template that expands automatically to accept any
number of arguments of any appropriate types --- all by, say,
\lstinline!const! \romeovalue{lvalue} reference:

\begin{emcppshiddenlisting}[emcppsbatch=e3]
#include <string>  // (ù{\codeincomments{std::string}}ù)
\end{emcppshiddenlisting}
\begin{emcppslisting}[emcppsbatch=e3]
template <typename... Ts>
std::string concat(const Ts&...);
     // Return a string that is the concatenation of a sequence of zero or
     // more character or string arguments --- each of potentially distinct
     // C++ type and passed by (ù{\codeincomments{const}}ù) (ù{\emphincomments{lvalue}}ù) reference.
\end{emcppslisting}
    

\noindent A variadic function template will typically be implemented with
\emcppsgloss{recursion} to the same function with fewer parameters. Such
function templates will typically be accompanied by an overload
(templated or not) that implements the lower limit, in our case, the
overload having exactly zero parameters:

\begin{emcppslisting}[emcppsbatch=e3]
std::string concat();
    // Return an empty string ("") of length 0.
\end{emcppslisting}
    

\noindent The non-template overload above declares \lstinline!concat! taking no
parameters. Importantly, this overload will be preferred for calls of
\lstinline!concat! with no arguments because it's a better match than the
variadic declaration, even though the variadic declaration would also
accept zero arguments.

Having to write just two overloads to support any number of arguments
has clear advantages over writing dozens of overloaded templates: (1)
there is no hard-coded limit on argument count, and (2) the source is
dramatically smaller, more regular, and easier to maintain and extend
--- e.g., it would be easy to add support for efficiently passing by
forwarding reference (see \featureref{\locationc}{forwardingref}). A
second-order effect should be noted as well. The costs of defining
variadic functions with C++03 technology are large enough to discourage
such an approach in the first place, unless overwhelming efficiency
motivation exists; with C++11, the low cost of defining variadics often
makes them the simpler, better, and more efficient choice altogether.

Variadic \emph{class} templates are another important motivating use
case for this language feature.

A tuple is a generalization of \lstinline!std::pair! that, instead of
comprising just two objects, can store an arbitrary number of objects of
heterogeneous types:

\begin{emcppshiddenlisting}[emcppsbatch=e4]
#include <string>  // (ù{\codeincomments{std::string}}ù)
template <typename...>
struct Tuple {
    template<typename... Args>
    Tuple(Args&&...) {}
};
\end{emcppshiddenlisting}
\begin{emcppslisting}[emcppsbatch=e4]
Tuple<int, double, std::string> tup1(1, 2.0, "three");
    // (ù{\codeincomments{tup1}}ù) holds an (ù{\codeincomments{int}}ù), a (ù{\codeincomments{double}}ù), and an (ù{\codeincomments{std::string}}ù)

Tuple<int, int> tup2(42, 69);
    // (ù{\codeincomments{tup2}}ù) holds two (ù{\codeincomments{int}}ù)s
\end{emcppslisting}
    

\noindent \lstinline!Tuple! provides a container for a specified set of types, in a
manner similar to a \lstinline!struct!, but without the inconvenience of
needing to introduce a new \lstinline!struct! definition with its own name.
As shown in the example above, the tuples are also initialized correctly
according to the specified types (e.g., \lstinline!tup2! contains two
integers initialized, respectively, with \lstinline!42! and \lstinline!69!).

In C++03, an approximation to a tuple could be improvised by composing
an \lstinline!std::pair! with itself:

\begin{emcppslisting}
#include <utility>  // (ù{\codeincomments{std::pair}}ù)
std::pair<int, std::pair<double, long>> v;
    // Define a holder of an (ù{\codeincomments{int}}ù), a (ù{\codeincomments{double}}ù), and an (ù{\codeincomments{long}}ù), accessed as
    // (ù{\codeincomments{v.first}}ù), (ù{\codeincomments{v.second.first}}ù), and (ù{\codeincomments{v.second.second}}ù), respectively.
\end{emcppslisting}
    

\noindent Composite use of \lstinline!std:pair! types could, in theory, be scaled to
arbitrary depth; defining, initializing, and using such types, however,
is not always practical. Another approach commonly used in C++03 and
similar to the one suggested for the \lstinline!add! function template
above is to define a template class, e.g., \lstinline!Cpp03Tuple!, having
many parameters (e.g, 9), each defaulted to a special marker type (e.g.,
\lstinline!None!), indicating that the parameter is not used:

\begin{emcppslisting}
struct None { };  // empty "tag" used as a special "not used" marker in (ù{\codeincomments{Tuple}}ù)

template <typename T1 = None, typename T2 = None, typename T3 = None,
          typename T4 = None, typename T5 = None, typename T6 = None,
          typename T7 = None, typename T8 = None, typename T9 = None>
class Cpp03Tuple;
    // (ù{\codeincomments{struct}}ù)-like class containing up to 9 data members of arbitrary types
\end{emcppslisting}
    

\noindent \lstinline!Cpp03Tuple! may be used to store, access, and modify up to 9
values together, e.g.,\linebreak[4]%%%%%%%
\mbox{\lstinline!Cpp03Tuple<int,!~\lstinline!int,!~\lstinline!std::string>!} would
consist of two \lstinline!int!s and an \lstinline!std::string!.

\lstinline!Cpp03Tuple!'s implementation uses a variety of
\emcppsgloss[metaprogram]{metaprogramming} tricks to detect which of the 9 type slots are
used. This is the approach taken by
\lstinline!boost::tuple!,{\cprotect\footnote{https://github.com/boostorg/tuple/blob/develop/include/boost/tuple/tuple.hpp}}
an industrial-strength tuple implemented using C++03-era technology. In
contrast, the variadic-template-based declaration (and definition) of a
modern C++ tuple is much simpler:

\begin{emcppslisting}
template <typename... Ts>
class Cpp11Tuple;  // class template storing an arbitrary sequence of objects
\end{emcppslisting}
    

\noindent C++11 introduced the standard library class template
\lstinline!std::tuple!, declared in a manner similar to
\lstinline!Cpp11Tuple!.

An \lstinline!std::tuple! can be used, for example, to return multiple
values from a function. Suppose we want to define a function,
\lstinline!minAverageMax!, that --- given a \emcppsgloss{range} of double values
--- returns, along with its cardinality, its minimum, average, and
maximum values. The interface for such a function in C++03 might have
involved multiple output parameters passed, e.g., by non\lstinline!const!
\romeovalue{lvalue} reference:

\begin{emcppslisting}
#include <cstddef>  // (ù{\codeincomments{std::size\_t}}ù)

template <typename Iterator>
void minAverageMax(std::size_t& numValues,   // (out only) number of inputs
                   double& minimum,          // (out only) minimum value
                   double& average,          // (out only) average value
                   double& maximum,          // (out only) maximum value
                   Iterator b, Iterator e);  // input range
    // Load into the specified (ù{\codeincomments{numValues}}ù), (ù{\codeincomments{minimum}}ù), (ù{\codeincomments{average}}ù), and (ù{\codeincomments{maximum}}ù)
    // the corresponding values extracted from the specified range (ù{\codeincomments{[b, e)}}ù).
\end{emcppslisting}
    

\noindent Alternatively, one could have define a separate \lstinline!struct! (e.g.,
\lstinline!MinAverageMaxRes!) and incorporate that into the interface of
the \lstinline!minAverageMax! function:

\begin{emcppslisting}
#include <cstddef>  // (ù{\codeincomments{std::size\_t}}ù)

struct MinAverageMaxRes  // used in conjunction with (ù{\codeincomments{minAverageMax}}ù) (below)
{
    std::size_t count;  // number of input values
    double min;         // minimum value
    double average;     // average value
    double max;         // maximum value
};

template <typename Iterator>
MinAverageMaxRes minAverageMax(Iterator b, Iterator e);
\end{emcppslisting}
    

\noindent Adding a helper \emcppsgloss{aggregate} such as \lstinline!MinAverageMax!
(above) works but demands a fair amount of boilerplate coding that might
not be reusable or otherwise worth naming. The C++11 library abstraction
\lstinline!std::tuple! allows code to define such simple aggregates ``on
the fly'' (as needed):

\begin{emcppslisting}[emcppsbatch=e5]
#include <tuple>    // (ù{\codeincomments{std::tuple}}ù)
#include <cstddef>  // (ù{\codeincomments{std::size\_t}}ù)

typedef std::tuple<std::size_t, double, double, double> MinAverageMaxRes;
    // type alias for a standard tuple of four specific scalar values.

template <typename Iterator>
MinAverageMaxRes minAverageMax(Iterator b, Iterator e);
    // Return the cardinality, min, average, and max of the range (ù{\codeincomments{[b, e]}}ù).
\end{emcppslisting}
    

\noindent We can now use our \lstinline!minAverageMax! function to extract the
relevant fields from a vector of \lstinline!double! values:

\begin{emcppslisting}[emcppsbatch=e5]
#include <vector>  // (ù{\codeincomments{std::vector}}ù)

void test(const std::vector<double>& v)
{
    MinAverageMaxRes res = minAverageMax(v.begin(), v.end());  // calculate
    std::size_t num = std::get<0>(res);  // fetch slot 0, the number of values
    double      min = std::get<1>(res);  // fetch slot 1, the minimum value
    double      ave = std::get<2>(res);  // fetch slot 2, the average value
    double      max = std::get<3>(res);  // fetch slot 3, the maximum value
    // ...
    std::get<2>(res) = 0.0;              // store 0 in slot 2 (just FYI)
    // ...
}
\end{emcppslisting}
    

\noindent Note that elements in a tuple are accessed in a numerically indexed
manner (beginning with slot 0) using the standard function template
\lstinline!std::get! for both reading and writing.

There are other motivating uses of variadic templates, such as allowing
generic code to forward arguments to other functions, notably
constructors, without the need to know in advance the number of
arguments required. Related artifacts added to the C++ standard library
include \lstinline!std::make_shared!, \lstinline!std::make_unique!, and the
\lstinline!emplace_back! member function of \lstinline!std::vector! (see
\intraref{use-cases-variadic}{object-factories} \textbf{ [AUs: There is no subsection called ``Factory functions." Did you mean the Object factories section?  Response: Yes, it should be object factories]} ).

There is a lot to unpack here. We will begin our journey by
understanding variadic \emph{class} templates as \emcppsgloss[generic type]{generic types}
that provide a solid basis for understanding variadic \emph{function}
templates. In practice, however, variadic \emph{function} templates are
arguably more frequently applicable outside of advanced metaprogramming;
see \intrarefsimple{variadic-function-templates}.

\subsubsection[Variadic class templates]{Variadic class templates}\label{variadic-class-templates}

Suppose we want to create a class template \lstinline!C! that can take zero
or more template type arguments. C++11 introduces new syntax --- based
on the ellipsis (\lstinline!...!) token --- that supports such variadic
parameter lists:

\begin{emcppslisting}
template <typename... Ts> class C;
    // The class template (ù{\codeincomments{C}}ù) can be instantiated with a sequence of zero or
    // more template arguments of arbitrary type. Because this is only a
    // declaration, the parameter name, (ù{\codeincomments{Ts}}ù) (for "types"), isn't used.
\end{emcppslisting}
    

\noindent The declaration above introduces a class template \lstinline!C! that can
accept an arbitrary sequence of type parameters optionally represented
here (for documentation purposes) by the identifier \lstinline!Ts! (for
``Types'').

First we point out that the ellipsis (\lstinline!...!), just like
\lstinline!++! or \lstinline!==!, is parsed as a separate token; hence, any
whitespace around the ellipsis is optional. The common style, and the
one used in the C++ Standard documents, follows the typographic
convention in written prose: \lstinline!...! abuts to the left and is
followed by a single space as in the declaration of \lstinline!C! above.

Whether we use \lstinline!typename! (as we do throughout this book) or
\lstinline!class! to introduce a \emcppsgloss{template type parameter} is
entirely a matter of style:

\begin{emcppslisting}
template <typename... Ts> class C;  // style used throughout this book
template <class... Ts> class C;     // style used in the C++ Standard
\end{emcppslisting}
    

\noindent Note that, as with non-variadic template parameters, providing a name to
represent the supplied template ``parameters'' (a.k.a. \emcppsgloss{template
parameter pack}, see below) is optional:

\begin{emcppslisting}
template <typename... Ts> class C;  // with    name identifying parameter pack
template <typename...> class C;     // without name identifying parameter pack
\end{emcppslisting}
    

\noindent When an ellipsis token (\lstinline!...!) appears \emph{after}
\lstinline!typename! or \lstinline!class! and before the optional
type-parameter name (e.g., \lstinline!Ts!), it introduces a
\emcppsgloss{template parameter pack}:

\begin{emcppslisting}
template <typename... Ts>  // (ù{\codeincomments{Ts}}ù) names a template parameter pack.
class C;
\end{emcppslisting}
    

\noindent We call entities such as \lstinline!Ts! \emcppsgloss[template parameter pack]{template parameter packs}
(as opposed to \emcppsgloss[template parameter pack]{parameter packs}) to distinguish them from
\emcppsgloss[function parameter pack]{function parameter packs} (see \intrarefsimple{variadic-function-templates}), \emcppsgloss[non-type parameter pack]{non-type parameter packs} (see
\intrarefsimple{non-type-template-parameter-packs} \textbf{[AUs: There is no section called ``Non-type parameter packs"  Response: non-type template parameter packs is the correct intraref]}), and \emcppsgloss[template template parameter pack]{template
template parameter packs} (see \intrarefsimple{template-parameter-packs}
The phrase \emcppsgloss{parameter pack} is a conflation
of the four and also a casual reference to either of them whenever there
is no ambiguity.

This syntactic form of \lstinline!...! is used primarily in
\emcppsgloss[declaration]{declarations} (including those associated with
\emcppsgloss[definition]{definitions}):

\begin{emcppslisting}
template <typename... Ts>
class C { /*...*/ };  // definition of class (ù{\codeincomments{C}}ù)
\end{emcppslisting}
    

\noindent The same \lstinline!...! token, when it appears to the \emph{right} of an
existing \emcppsgloss{template parameter pack} (e.g., \lstinline!Ts!), is used
to \emph{unpack} it:

\begin{emcppslisting}[emcppsbatch=e6]
#include <vector>  // (ù{\codeincomments{std::vector}}ù)

template <typename... Ts> class C  // definition of class (ù{\codeincomments{C}}ù)
{
    std::vector<Ts...> d_data;
        // using (ù{\codeincomments{...}}ù) to unpack a template parameter pack
};
\end{emcppslisting}
    

\noindent In the example above, the \emph{unpacking} results in a comma-separated
list of the types with which \lstinline!C! was instantiated. The
\lstinline!...! token is used after the \emcppsgloss{template parameter pack}
name \lstinline!Ts! to recreate the sequence of arguments originally passed
to the instantiation of \lstinline!C!. Referring to our example above, we
might choose to create an object, \lstinline!x!, of type \lstinline!C<int>!:

\begin{emcppslisting}[emcppsbatch=e6]
C<int> x;  // has data member, (ù{\codeincomments{d\_data}}ù), of type (ù{\codeincomments{std::vector<int>}}ù)
\end{emcppslisting}
    

\noindent We might, instead, consider creating an object, \lstinline!y!, that also
passes \lstinline!std::allocator<char>! to \lstinline!C!'s instantiation:

\begin{emcppslisting}[emcppsbatch=e6]
C<char, std::allocator<char>> y;
    // (ù{\codeincomments{y.d\_data}}ù) has type (ù{\codeincomments{std::vector<char, std::allocator<char>>}}ù).
\end{emcppslisting}
    

\noindent And so on. That is, \lstinline!class!~\lstinline!C! can be instantiated with
any sequence of types that is supported by the \lstinline!d_data! member
variable.

An instantiation such as \lstinline!C<float,!~\lstinline!double>! would
correspondingly attempt to instantiate
\lstinline!std::vector<float,!~\lstinline!double>!, which is in error and
would cause the instantiation of \lstinline!C! to fail. Several other cases
and patterns of \emph{unpacking} of \emcppsgloss[template parameter pack]{template parameter packs}
exist and are described in detail in \intrarefsimple{template-parameter-packs}.

Continuing our pedagogical discussion, let's \emcppsgloss{define} an empty
variadic class template, \lstinline!D!:

\begin{emcppslisting}[emcppsbatch=e7]
template <typename...> class D { };  // empty variadic-class-template definition
\end{emcppslisting}
    

\noindent We can now create explicit instantiations of class template \lstinline!D!
by providing it with any number of \emph{type} arguments:

\begin{emcppslisting}[emcppsbatch=e7]
D<>               d0;  // instantiation of (ù{\codeincomments{D}}ù) with no type arguments
D<int>            d1;  // instantiation of (ù{\codeincomments{D}}ù) with a single (ù{\codeincomments{int}}ù) argument
D<int, int>       d2;  // instantiation of (ù{\codeincomments{D}}ù) with two (ù{\codeincomments{int}}ù) arguments
D<int, const int> d3;  // Note that (ù{\codeincomments{d3}}ù) is a distinct type from (ù{\codeincomments{d2}}ù).
D<double, char>   d4;  // instantiation of (ù{\codeincomments{D}}ù) with a (ù{\codeincomments{double}}ù) and (ù{\codeincomments{char}}ù)
D<char, double>   d5;  // Note that (ù{\codeincomments{d5}}ù) is a distinct type from (ù{\codeincomments{d4}}ù).
D<D<>, D<int>>   d6;   // instantiation of (ù{\codeincomments{D}}ù) with two UDT arguments
\end{emcppslisting}
    

\noindent The number and order of arguments are part of the instantiated type, so
each of the objects \lstinline!d0! through \lstinline!d6! above has a distinct
C++ type:

\begin{emcppslisting}[emcppsbatch=e7]
void f(const D<double, char>&);  // (1) overload of function (ù{\codeincomments{f}}ù)
void f(const D<char, double>&);  // (2) overload of function (ù{\codeincomments{f}}ù)

void test()
{
    f(d4);                           // invokes overload (1)
    f(d5);                           // invokes overload (2)
}
\end{emcppslisting}
    

\noindent The sections that follow examine in full detail how to
\begin{itemize}
\item{declare variadic \emph{class} and \emph{function} templates using \emcppsgloss[parameter pack]{parameter packs}}
\item{make use of variadic argument lists in the implementation of class definitions and function bodies}
\end{itemize}

\subsubsection[Template parameter packs]{Template parameter packs}\label{template-parameter-packs}

A \emcppsgloss{template parameter pack} is the name representing a list of
zero or more parameters following \lstinline!class...! or
\lstinline!typename...! within a variadic template declaration.

Let's take a closer look at just the \emph{declaration} of a variadic
class template, \lstinline!C!:

\begin{emcppslisting}[emcppsbatch=e8]
template <typename... Ts> class C { };
\end{emcppslisting}
    

\noindent Here, the identifier \lstinline!Ts! names a \emcppsgloss{template parameter
pack}, which --- as we saw previously --- can bind to any sequence of
explicitly supplied types including the empty sequence:

\begin{emcppslisting}[emcppsbatch=e8]
C<> c0;             // OK, instantiation of (ù{\codeincomments{C}}ù) with no type arguments
C<int> c1;          // OK, instantiation of (ù{\codeincomments{C}}ù) with a single (ù{\codeincomments{int}}ù) argument
C<float, bool> c2;  // OK, instantiation of (ù{\codeincomments{C}}ù) with two type arguments
\end{emcppslisting}
    

\noindent Passing an argument to \lstinline!C! that is not a type, however, is not
permitted:

\begin{emcppslisting}
C<128> cx0;           // Error, expecting type template argument, (ù{\codeincomments{128}}ù) provided
C<std::vector> cx1;   // Error, expecting type argument, template name provided
C<int, 42, int> cx2;  // Error, expecting type argument in second position
\end{emcppslisting}
    

\noindent Template parameter packs can appear together with simple template
parameters, with one restriction: \emcppsgloss[primary class template declaration]{Primary class template
declarations} allow at most one variadic parameter pack at the end of
the template parameter list. (Recall that in standard C++ terminology,
the \emcppsgloss{primary declaration} of a class template is the first
declaration introducing the template's name; all specializations and
partial specializations of a class template require the presence of a
primary declaration.)

\begin{emcppslisting}[emcppserrorlines={10,13}]
template <typename... Ts>
class C0  { };  // OK

template <typename T, typename... Ts>
class C1  { };  // OK

template <typename T, typename U, typename... Ts>
class C2  { };  // OK

template <typename... Ts, typename... Us>
class Cx0 { };  // Error, more than one parameter pack

template <typename... Ts, typename T>
class Cx1 { };  // Error, parameter pack must be the last template parameter
\end{emcppslisting}
    

\noindent There is no way to specify a default for a parameter pack; however a
parameter pack can follow a defaulted parameter:

\begin{emcppslisting}[emcppserrorlines={1,4}]
template <typename... Ts = int>
class Cx2 { };  // Error, a parameter pack cannot have a default.

template <typename T = int, typename... Ts = char>
class Cx3 { };  // Error, a parameter pack cannot have a default.

template <typename T = int, typename... Ts>
class C3  { };  // OK

C3<> c31;                   // OK, (ù{\codeincomments{T=int, Ts=<>}}ù)
C3<char> c32;               // OK, (ù{\codeincomments{T=char, Ts=<>}}ù)
C3<char, double, int> c33;  // OK, (ù{\codeincomments{T=char, Ts=<double, int>}}ù)
\end{emcppslisting}
    

\noindent What can we do with a \emcppsgloss{template parameter pack}? Template
parameter packs are of a so-called \emph{kind} distinct from other C++
entities. They are not types, values, or anything else found in C++03.
As such, parameter packs are not subject to any of the usual operations
one might expect:

\begin{emcppslisting}
template <typename... Ts>
class C
{
    C<Ts>* next;        // Error, cannot use unexpanded parameter pack (ù{\codeincomments{Ts}}ù)
    Ts memberVariable;  // Error, cannot use unexpanded parameter pack (ù{\codeincomments{Ts}}ù)
    typedef Ts Ts1;     // Error, cannot use unexpanded parameter pack (ù{\codeincomments{Ts}}ù)
    using Ts2 = Ts;     // Error, cannot use unexpanded parameter pack (ù{\codeincomments{Ts}}ù)
};
\end{emcppslisting}
    

\noindent There is no way to use a parameter pack in unexpanded form. Once
introduced, the name of a parameter pack can occur only as part of a
\emcppsgloss{pack expansion}. We've already encountered the simple
\emcppsgloss{pack expansion} \lstinline!Ts...!, which expands to the list of
types to which \lstinline!Ts! is bound. That expansion is only allowed in
certain contexts where multiple values would be allowed:

\begin{emcppslisting}
template <typename... Ts>
class C
{
    C<Ts...>* d_next;        // OK, instantiate (ù{\codeincomments{C}}ù) in definition of member
    C<Ts...> f0();           // OK, instantiate (ù{\codeincomments{C}}ù) in member function signature
    void f1(C<Ts...>&);      // OK, instantiate (ù{\codeincomments{C}}ù) in member function signature
    Ts... d_memberVariable;  // Error, expansion as a member type
    typedef Ts... Ts1;       // Error, expansion as a typedef type
    using Ts2 = Ts...;       // Error, expansion as a using declaration argument
};
\end{emcppslisting}
    

\noindent Note that the code above remains invalid even if \lstinline!Ts! contains a
single type, e.g., in the instantiation \lstinline!C<int>!. \emcppsgloss[pack expansion]{Pack
expansion} is not textual and not allowed everywhere; it is allowed only
in certain well-defined contexts. The first such context, as showcased
with the member variable \lstinline!next! in the code example above, is
inside a \emcppsgloss{template argument list}. Note how the pattern may be
surrounded by other parameters or expansions:

\begin{emcppslisting}
#include <map>  // (ù{\codeincomments{std::map}}ù)

template <typename... Ts>
class C
{
    void arbitraryMemberFunction()      // for illustration purposes
    {
        C<Ts...>                   v0;  // OK, same type as (ù{\codeincomments{*this}}ù)
        C<int, Ts...>              v1;  // OK, expand after another argument
        C<Ts..., char>             v2;  // OK, expand before another argument
        C<char, Ts..., int>        v3;  // OK, expand in between
        C<void, Ts..., Ts...>      v4;  // OK, two expansions
        C<char, Ts..., int, Ts...> v5;  // OK, no need for them to be adjacent
        C<void, C<Ts...>, int>     v6;  // OK, expansion nested within
        C<Ts..., C<Ts...>, Ts...>  v7;  // OK, mix of expansions
        std::map<Ts...>            v8;  // OK, works with non-variadic template
    }
};
\end{emcppslisting}
    

\noindent The examples above illustrate how \emcppsgloss{pack expansion} is not done
textually, like a macro expanded by the C preprocessor. A simple textual
expansion of \lstinline!C<char,!~\lstinline!Ts...,!~\lstinline!int>! would be
\lstinline!C<char,!~\lstinline!,!~\lstinline!int>! if \lstinline!Ts! were empty
(i.e., inside the instantiation \lstinline!C<>!). \emcppsgloss[parameter pack expansion]{Parameter pack
expansion} is syntactic and ``knows'' to eliminate any spurious commas,
caused by the expansion of empty \emcppsgloss[parameter pack]{parameter packs}.

Within the context of a template argument list, \lstinline!Ts...! is not
the only pattern that can be expanded; any template instantiation using
\lstinline!Ts! (e.g.~\lstinline!C<Ts>...!) can be expanded as a unit. The
result is a list of template instantiations using each of the types in
\lstinline!Ts!, in turn. Note that, in the example below, the expansions
\lstinline!C<Ts...>! and \lstinline!C<Ts>...! are both valid but produce
different results:

\begin{emcppslisting}[emcppsbatch=e9]
#include <vector>  // (ù{\codeincomments{std::vector}}ù)

template <typename... Ts> class D
{
    void memberFunction()
    {
        D<Ts...> v0;               // OK, same type as (ù{\codeincomments{*this}}ù)
        D<D<Ts...>> v1;            // OK, expand to (ù{\codeincomments{D<D<T0, T1>, ...>}}ù)
        D<D<Ts>...>  v2;           // OK, expand to (ù{\codeincomments{D<D<T0>, D<T1>, ...>}}ù)
        D<std::vector<Ts>...> v3;  // OK, expand to (ù{\codeincomments{C1<std::vector<T0>, ...>}}ù)
    }
};
\end{emcppslisting}
    

\noindent The second important \emcppsgloss{parameter pack expansion context} for type
parameter packs is in a \emcppsgloss{base specifier list}. All patterns that
form a valid base specifier are allowed:

\begin{emcppslisting}[emcppsbatch=e9]
template <typename... Ts>   // zero or more arguments
class D1 : public Ts...     // publicly inherit (ù{\codeincomments{T0}}ù), (ù{\codeincomments{T1}}ù), ...
{ /*...*/ };

template <typename... Ts>
class D2 : public D<Ts>...  // publicly inherit (ù{\codeincomments{D<T0>}}ù), (ù{\codeincomments{D<T1>}}ù), ...
{ /*...*/ };

template <typename... Ts>
class D3 : public D<Ts...>  // publicly inherit (ù{\codeincomments{D<T0, T1, ...>}}ù)
{ /*...*/ };
\end{emcppslisting}
    

\noindent The access control specifiers --- \lstinline!public!, \lstinline!protected!,
and \lstinline!private! --- can be applied as usual, though, within a
single expansion pattern, the access specifier must be the same for all
expanded elements:

\begin{emcppslisting}[emcppsbatch=e9]
template <typename... Ts>
class D4 : private Ts...   // privately inherit (ù{\codeincomments{T0}}ù), (ù{\codeincomments{T1}}ù), ...
{ /*...*/ };

template <typename... Ts>
class D5 : public Ts..., private D<int, Ts>...
    // publicly inherit (ù{\codeincomments{T0}}ù), (ù{\codeincomments{T1}}ù), ...
    // and privately inherit (ù{\codeincomments{D<int, T0>}}ù), (ù{\codeincomments{D<int, T1>}}ù), ...
{ /*...*/ };
\end{emcppslisting}
    

\noindent Pack expansions can be freely mixed with simple base specifiers:

\begin{emcppslisting}
class AClass1 { /*...*/ };  // arbitrary class definition
class AClass2 { /*...*/ };  // arbitrary class definition

template <typename... Ts>
class D6 : protected AClass1, public Ts...                   // OK
{ /*...*/ };

template <typename... Ts>
class D7 : protected AClass1, private Ts..., public AClass2  // OK
{ /*...*/ };
\end{emcppslisting}
    

\noindent If the parameter pack being expanded (e.g., \lstinline!Ts!, in the code
snippet above) is empty, the expansion does not introduce any base
class. Notice, again, how the expansion mechanism is semantic, not
textual, e.g., in the instantiation \lstinline!D7<>! the fragment
\lstinline!private!~\lstinline!Ts...,! disappears entirely, leaving
\lstinline!D7<>! with \lstinline!AClass1! as a \lstinline!protected! base and
\lstinline!AClass2! as a \lstinline!public! base.

To recap, the two essential parameter expansion contexts for
\emcppsgloss[template parameter pack]{template parameter packs} are inside a \emcppsgloss{template argument
list} and in a \emcppsgloss{base specifier list}.

\subsubsection[Specialization of variadic class templates]{Specialization of variadic class templates}\label{specialization-of-variadic-class-templates}

Recall from prior to C++11 that after a class template is introduced by
a \emcppsgloss{primary class template declaration}, it is possible to create
\emcppsgloss[specialization]{specializations} and \emcppsgloss[partial specialization]{partial specializations} of that
class template. We can declare \emcppsgloss[specialization]{specializations} of a variadic
class template by supplying zero or more arguments to its parameter
pack:

\begin{emcppslisting}
template <typename... Ts> class C0;  // primary class template declaration

template <> class C0<>;              // specialize (ù{\codeincomments{C0}}ù) for (ù{\codeincomments{Ts=<>}}ù)
template <> class C0<int>;           // specialize (ù{\codeincomments{C0}}ù) for (ù{\codeincomments{Ts=<int>}}ù)
template <> class C0<int, void>;     // specialize (ù{\codeincomments{C0}}ù) for (ù{\codeincomments{Ts=<int, void>}}ù)
\end{emcppslisting}
    

\noindent Similar specializations can be applied to class templates that have
other template parameters preceding the \emcppsgloss{template parameter
pack}. The nonpack template parameters must be matched exactly by the
arguments, followed by zero or more arguments for the parameter pack:

\begin{emcppslisting}
template <typename T, typename... Ts>
class C1;                              // primary class template declaration

template <> class C1<int>;             // Specialize (ù{\codeincomments{C1}}ù) for (ù{\codeincomments{T=int}}ù), (ù{\codeincomments{Ts=<>}}ù).
template <> class C1<int, void>;       // Specialize for (ù{\codeincomments{T=int}}ù), (ù{\codeincomments{Ts=<void>}}ù).
template <> class C1<int, void, int>;  // Specialize for (ù{\codeincomments{T=int}}ù), (ù{\codeincomments{Ts=<void, int>}}ù).
template <> class C1<>;                // Error, too few template arguments
\end{emcppslisting}
    

\noindent \emcppsgloss[partial specialization]{Partial specializations} of a class template may take multiple
parameter packs because some of the types involved in the partial
specialization may themselves use parameter packs. Consider, for
example, a variadic class template, \lstinline!Tuple!, defined as having
exactly one parameter pack:

\begin{emcppslisting}[emcppsbatch=e10]
template <typename... Ts> class Tuple  // variadic class template
{ /*...*/ };
\end{emcppslisting}
    

\noindent Further assume a primary declaration of a variadic class template ,
\lstinline!C2!, also having one type parameter pack. We also introduce
definitions in addition to declarations so we can instantiate
\lstinline!C2! later:

\begin{emcppslisting}[emcppsbatch=e10]
template <typename... Ts> class C2
    // (0) primary declaration of variadic class template (ù{\codeincomments{C2}}ù)
{ /*...*/ };
\end{emcppslisting}
    

\noindent This simple setup allows a variety of partial specializations. First, we
can partially specialize \lstinline!C2! for exactly two \lstinline!Tuple!s
instantiated with the same exact types:

\begin{emcppslisting}[emcppsbatch=e10]
template <typename... Ts>
class C2<Tuple<Ts...>, Tuple<Ts...>>  // (1) two identical (ù{\codeincomments{Tuple}}ù)s
{ /*...*/ };
\end{emcppslisting}
    

\noindent We can also partially specialize \lstinline!C2! for exactly two
\lstinline!Tuple!s but with potentially different type arguments:

\begin{emcppslisting}[emcppsbatch=e10]
template <typename... Ts, typename... Us>
class C2<Tuple<Ts...>, Tuple<Us...>>  // (2) any two (ù{\codeincomments{Tuple}}ù)s
{ /*...*/ };
\end{emcppslisting}
    

\noindent Furthermore, we can partially specialize \lstinline!C2! for any
\lstinline!Tuple! followed by zero or more types:

\begin{emcppslisting}[emcppsbatch=e10]
template <typename... Ts, typename... Us>
class C2<Tuple<Ts...>, Us...>  // (3) any (ù{\codeincomments{Tuple}}ù) followed by 0 or more types
{ /*...*/ };
\end{emcppslisting}
    

\noindent The possibilities are endless; let us show one more partial
specialization of \lstinline!C2! with three template parameter packs that
will match two arbitrary \lstinline!Tuple!s followed by zero or more
arguments:

\begin{emcppslisting}[emcppsbatch=e10]
template <typename... Ts, typename... Us, typename... Vs>
class C2<Tuple<Ts...>, Tuple<Us...>, Vs...>
    // (4) Specialize (ù{\codeincomments{C2}}ù) for (ù{\codeincomments{Tuple<Ts...>}}ù) in the first position,
    // (ù{\codeincomments{Tuple<Us...>}}ù) in the second position, followed by zero or more
    // arguments.
{ /*...*/ };
\end{emcppslisting}
    

\noindent Now that we have definitions for the primary template \lstinline!C2! and
four partial specializations of it, let's take a look at a few variable
definitions that instantiate \lstinline!C2!. \emcppsgloss[partial ordering of class template specialization]{Partial ordering of
class template specializations}{\cprotect\footnote{\cite{iso14},
section~14.5.5.2, "Partial ordering of class template specializations," [temp.class.order], pp. 339--340.}} will decide the
best match for each instantiation and also deduce the appropriate
template parameters:

\begin{emcppslisting}[emcppsbatch=e10]
C2<int>                           c2a;  // uses (0), (ù{\codeincomments{Ts=<int>}}ù)
C2<Tuple<int>, Tuple<int>>        c2b;  // uses (1), (ù{\codeincomments{Ts=<int>}}ù)
C2<Tuple<int, char>, Tuple<char>> c2c;  // uses (2), (ù{\codeincomments{Ts=<int,char>}}ù), (ù{\codeincomments{Us=<char>}}ù)
C2<Tuple<int, int>, char>         c2d;  // uses (3), (ù{\codeincomments{Ts=<int,int>}}ù), (ù{\codeincomments{Us=<char>}}ù)
C2<Tuple<int>, Tuple<char>, void> c2e;  // uses (4), (ù{\codeincomments{Ts=<int>}}ù), (ù{\codeincomments{Us=<char>}}ù), (ù{\codeincomments{Vs=<void>}}ù)
\end{emcppslisting}
    

\noindent Notice how partial ordering chooses (2) instead of (4) for the
definition of \lstinline!c2c!, although both (2) and (4) are a match; a
matching non-variadic template is always a better match than one
involving deduction of a parameter pack.

Even in a partial specialization, if a template argument of the
specialization is a \emcppsgloss{pack expansion}, it must be in the last
position:

\begin{emcppslisting}[emcppsbatch=e10,emcppserrorlines={1,2,5,6}]
template <typename... Ts>
class C2<Ts..., int>;
    // Error, template argument (ù{\codeincomments{int}}ù) can't follow pack expansion (ù{\codeincomments{Ts...}}ù).

template <typename... Ts>
class C2<Tuple<Ts>..., int>;
    // Error, template argument (ù{\codeincomments{int}}ù) can't follow pack expansion (ù{\codeincomments{Tuple<Ts>...}}ù).

template <typename... Ts>
class C2<Tuple<Ts...>, int>;
    // OK, pack expansion (ù{\codeincomments{Ts...}}ù) is inside another template.
\end{emcppslisting}
    

\noindent Parameter packs are a terse and very flexible placeholder for defining
partial specialization --- a ``zero or more types fit here'' wildcard.
The primary class template does not even need to be variadic. Consider,
for example, a non-variadic class template, \lstinline!Map!, fashioned
after the \lstinline!std::map! class template:

\begin{emcppslisting}[emcppsbatch=e11]
template <typename Key, typename Value> class Map;  // similar to (ù{\codeincomments{std::map}}ù)
\end{emcppslisting}
    

\noindent We would then want to partially specialize another non-variadic class
template, \lstinline!C3!, for all maps, regardless of keys and values:

\begin{emcppslisting}[emcppsbatch=e11]
template <typename T> class C3;  // (1) primary declaration; (ù{\codeincomments{C3}}ù) not variadic

template <typename K, typename V>
class C3<Map<K, V>>;
    // (2a) Specialize (ù{\codeincomments{C3}}ù) for all (ù{\codeincomments{Map}}ù)s, C++03 style.
\end{emcppslisting}
    

\noindent Variadics offer a terser, more flexible alternative:

\begin{emcppslisting}[emcppsbatch=e11]
template <typename... Ts>
class C3<Map<Ts...>>;
    // (2b) Specialize (ù{\codeincomments{C3}}ù) for all (ù{\codeincomments{Map}}ù)s, variadic style.
    // Note: (ù{\codeincomments{Map}}ù) works with pack expansion even though it's not variadic.
\end{emcppslisting}
    

\noindent The most important advantage of (2b) over (2a) is flexibility. In
maintenance, \lstinline!Map! may acquire additional template parameters,
such as a predicate and an allocator. This requires surgery on
\lstinline!C3!'s specialization (2a), whereas (2b) will continue to work
unchanged because \lstinline!Map<Ts...>! will accommodate any additional
template parameters \lstinline!Map! may have.

An application must use either the non-variadic (2a) or the variadic
(2b) partial specialization but not both. If both are present, (2a) is
always preferred because an exact match is always more specialized than
one that deduces a parameter pack.

\subsubsection[Variadic alias templates]{Variadic alias templates}\label{variadic-alias-templates}

\emcppsgloss[alias template]{Alias templates} (since C++11) are a new way to associate a name
with a family of types without needing to define forwarding glue code.
For full details on the topic, see \featureref{\locationa}{alias-declarations-and-alias-templates}. Here,
we focus on the applicability of \emcppsgloss[template parameter pack]{template parameter packs} to
alias templates.

Consider, for example, the \lstinline!Tuple! artifact --- briefly discussed
in {Description} --- that can store an arbitrary number of objects of
heterogeneous types:

\begin{emcppslisting}[emcppsbatch=e12]
template <typename... Ts> class Tuple;  // declare (ù{\codeincomments{Tuple}}ù)
\end{emcppslisting}
    

\noindent Suppose we want to build a simple abstraction on top of \lstinline!Tuple!
--- a ``named tuple'' that has an \lstinline!std::string! as its first
element, followed by anything a \lstinline!Tuple! may store:

\begin{emcppslisting}[emcppsbatch=e12]
#include <string>  // (ù{\codeincomments{std::string}}ù)

template <typename... Ts>
using NamedTuple = Tuple<std::string, Ts...>;
    // introduce alias for (ù{\codeincomments{Tuple}}ù) of (ù{\codeincomments{std::string}}ù) and anything
\end{emcppslisting}
    

\noindent In general, \emcppsgloss[alias template]{alias templates} take \emcppsgloss[template parameter pack]{template parameter
packs} following the same rules as \emcppsgloss{primary class template
declaration}: An alias template may be defined to take at most one
template parameter pack in the last position. Alias templates do not
support specialization or partial specialization.

\subsubsection[Variadic function templates]{Variadic function templates}\label{variadic-function-templates}

The simplest example of a variadic function template accepts a
\emcppsgloss{template parameter pack} in its \emcppsgloss{template parameters
list} but does not use any of its template parameters in its
\emcppsgloss{parameter declaration}:

\begin{emcppslisting}[emcppsbatch=e13]
template <typename... Ts>
int f0a();     // does not use (ù{\codeincomments{Ts}}ù) in parameter list

template <typename... Ts>
int f0b(int);  // uses (ù{\codeincomments{int}}ù) but not (ù{\codeincomments{Ts}}ù) in parameter list

template <typename T, class... Ts>
int f0c();     // does not use (ù{\codeincomments{T}}ù) or (ù{\codeincomments{Ts}}ù) in parameter list
\end{emcppslisting}
    

\noindent The only way to call the functions shown in the code snippet above is by
passing them template argument lists explicitly:

\begin{emcppslisting}[emcppsbatch=e13]
int a1 = f0a<int, char, int>();  // (ù{\codeincomments{Ts=<int, char, int>}}ù)
int a2 = f0b<double, void>(42);  // (ù{\codeincomments{Ts=<double, void>}}ù)
int a3 = f0c<int, void, int>();  // (ù{\codeincomments{T=int}}ù), (ù{\codeincomments{Ts=<void, int>}}ù)
int e1 = f0a();                  // Error, cannot deduce (ù{\codeincomments{Ts}}ù)
int e2 = f0b(42);                // Error, cannot deduce (ù{\codeincomments{Ts}}ù)
int e3 = f0c();                  // Error, cannot deduce (ù{\codeincomments{T}}ù) and (ù{\codeincomments{Ts}}ù)
\end{emcppslisting}
    

\noindent The notation \lstinline!f0a<int,!~\lstinline!char,!~\lstinline!int>()! means to
explicitly instantiate template function \lstinline!f0a! with the specified
type arguments and to call that instantiation.

Invoking any of the instantiations shown above will, of course, require
that the corresponding definition of the function template exists
somewhere within the program:

\begin{emcppslisting}
template <typename...> void f0a() { /*...*/ }  // variadic template definition
\end{emcppslisting}
    

\noindent This definition will typically be part of or reside alongside its
declaration in the same header or source file, but see
\featureref{\locationc}{explicit-template-instantiations}.

Such functions are rarely encountered in practice; most of the time a
template function would use its template parameters in the function
parameter list. They have only pedagogical value; as the joke goes, the
keys were lost in the living room but we're looking for them in the
hallway because the light is better. To take a look in the living room,
let's now consider a different kind of variadic function template ---
one that not only accepts an arbitrary number of template arguments, but
also accepts an arbitrary number of \emph{function} arguments working in
tandem with the template arguments.

\subsubsection[Function parameter packs]{Function parameter packs}\label{function-parameter-packs}

The syntax for declaring a variadic function template that accepts an
arbitrary number of function arguments makes two distinct uses of the
ellipsis (\lstinline!...!) token. The first use is to introduce the
template parameter pack \lstinline!Ts!, as already shown. Then, to make the
argument list of a function template variadic, we introduce a
\emcppsgloss{function parameter pack} by placing the \lstinline!...! to the left
of the function parameter name:

\begin{emcppslisting}
template <typename... Ts>  // template parameter pack (ù{\codeincomments{Ts}}ù)
int f1a(Ts... values);     // function parameter pack (ù{\codeincomments{values}}ù)
   // (ù{\codeincomments{f1a}}ù) is a variadic function template taking an arbitrary sequence of
   // function arguments by value (explanation follows), each independently of
   // arbitrary heterogeneous type.
\end{emcppslisting}
    

\noindent A function parameter pack is a function parameter that accepts zero or
more function arguments. Syntactically, a function parameter pack is
similar to a regular function parameter declaration, with two
distinctions:
\begin{itemize}
\item{The type in the declaration contains at least one \emcppsgloss{template parameter pack}}
\item{The ellipsis \lstinline!...! is inserted right before the function parameter name, if present, or replaces the parameter name, if absent}
\end{itemize}
Therefore, the declaration of \lstinline!f1a! above has a \emcppsgloss{template
parameter pack} \lstinline!Ts! and a \emcppsgloss{function parameter pack}
\lstinline!values!. The function parameter declaration
\lstinline!Ts...!~\lstinline!values! indicates that \lstinline!values! may accept
zero or more arguments of various types, all by value. Replacing the
parameter declaration with
\lstinline!const!~\lstinline!Ts&...!~\lstinline!values! would result in pass by
\lstinline!const! reference. Just as with non-variadic function templates,
variadic template parameter lists are permitted to include any legal
combination of \emcppsgloss[qualifier]{qualifiers} (\lstinline!const! and
\lstinline!volatile!) and \emcppsgloss[declarator operator]{declarator operators} (i.e.~pointer
\lstinline!*!, reference \lstinline!&!, forwarding reference \lstinline!&&!,
and array \lstinline![]!):

\begin{emcppslisting}
template <typename... Ts> void f1b(Ts&...);
   // accepts any number and types of arguments by reference

template <typename... Ts> void f1c(const Ts&...);
   // accepts any number and types of arguments by reference to (ù{\codeincomments{const}}ù)

template <typename... Ts> void f1d(Ts* const*...);
   // accepts any number and types of arguments by pointer to (ù{\codeincomments{const}}ù)
   // pointer to non(ù{\codeincomments{const}}ù) object

template <typename... Ts> void f1e(Ts&&...);
   // accepts any number and types of arguments by forwarding reference

template <typename... Ts> void f1f(const volatile Ts*&...);
   // accepts any number and types of arguments by reference to pointer to
   // (ù{\codeincomments{const volatile}}ù) objects
\end{emcppslisting}
    

\noindent To best understand the syntax of variadic template declarations, it is
important to distinguish the distinct --- and indeed complementary ---
roles of the two occurrences of the \lstinline!...! token. First, as
discussed in \intrarefsimple{template-parameter-packs},
\lstinline!typename...!~\lstinline!Ts! introduces a \emcppsgloss{template parameter
pack} called \lstinline!Ts! that matches an arbitrary sequence of types.
The second use of \lstinline!...! is, instead, a \emcppsgloss{pack expansion}
that transforms the pattern --- whether it's \lstinline!Ts...!,
\lstinline!const!~\lstinline!Ts&...!, \lstinline!Ts*!~\lstinline!const*...! etc,
--- into a comma-separated parameter list for the function, where the
C++ type of each successive parameter is determined by the corresponding
type in \lstinline!Ts!. The resulting construct is a \emcppsgloss{function
parameter pack}.

Conceptually, a single variadic template function declaration can be
thought of as a multitude of similar declarations with zero,
one,\ldots{} parameters fashioned after the variadic declaration:

\begin{emcppslisting}
template <typename... Ts> void f1c(const Ts&...);
    // variadic, any number of arguments, any types, all by (ù{\codeincomments{const \&}}ù)

void f1c();
    // pseudo-equivalent for variadic (ù{\codeincomments{f1c}}ù) called with 0 arguments

template <typename T0> void f1c(const T0&);
    // pseudo-equivalent for variadic (ù{\codeincomments{f1c}}ù) called with 1 argument

template <typename T0, typename T1>
void f1c(const T0&, const T1&);
    // pseudo-equivalent for variadic (ù{\codeincomments{f1c}}ù) called with 2 arguments

template <typename T0, typename T1, typename T2>
void f1c(const T0&, const T1&, const T2&);
    // pseudo-equivalent for variadic (ù{\codeincomments{f1c}}ù) called with 3 arguments

/* ... and so on ad infinitum ... */
\end{emcppslisting}
    

\noindent A good intuitive model would be that the \emcppsgloss{pack expansion} in the
function parameter list is like an ``elastic'' list of parameter
declarations that expands or shrinks appropriately. Note that the types
in a parameter pack may all be different from one another, but their
\emcppsgloss[qualifier]{qualifiers} (\lstinline!const! and/or \lstinline!volatile!) and
\emcppsgloss[declarator operator]{declarator operators} (i.e.~pointer \lstinline!*!, reference
\lstinline!&!, \romeovalue{rvalue} reference \lstinline!&&!, and array \lstinline![]!) are
the same.

The name of the pack may be missing from the declaration, which,
combined with the parameter declaration syntax coming all the way from
C, does allow for some obscure constructs:  \textbf{[AUs: The below example is not valid C++, though clang will accept it with a warning when not being pedantic. I suggest finding an alternative example that actually works or excising these two paragraphs as fluff.  ]}

\begin{emcppslisting}[emcppsignore={Need to figure this one out}]
template<typename... Ts> void fpf(Ts (*...)(int));
    // mystery declaration
\end{emcppslisting}
    

\noindent To read such a declaration, add a name, keeping in mind that the
\lstinline!...! in a function parameter pack always comes immediately to
the left of where the name would be:

\begin{emcppslisting}
template <typename... Ts> void fpf(Ts (*...pFunctions)(int));
    // Aha, the function parameter pack is (ù{\codeincomments{pFunctions}}ù)!
    // The function (ù{\codeincomments{fpf}}ù) takes zero or more pointers to functions taking one
    // (ù{\codeincomments{int}}ù), each returning some arbitrary type.
\end{emcppslisting}
    

\noindent A variadic function template may take additional template parameters as
well as additional function parameters:

\begin{emcppslisting}
template <typename... Ts> void f2a(int, Ts...);
    // one (ù{\codeincomments{int}}ù) followed by zero or more arbitrary arguments by (ù{\codeincomments{const \&}}ù)

template <typename T, typename... Ts> void f2b(T, const Ts&...);
    // first by value, zero or more by (ù{\codeincomments{const \&}}ù)

template <typename T, typename U, typename... Ts> void f2c(T, const U&, Ts...);
    // first by value, second by (ù{\codeincomments{const \&}}ù), zero or more by value
\end{emcppslisting}
    

\noindent There are restrictions on such declarations; see \intrarefsimple{the-rule-of-greedy-matching} and \intrarefsimple{the-rule-of-fair-matching}.

Note that inside the function parameters declaration, \lstinline!...! can
be used only in conjunction with a template parameter pack. Attempting
to use \lstinline!...! where there's no parameter pack to expand could lead
to inadvertent use of the old C-style variadics:

\begin{emcppslisting}
template <typename T, typename... Ts>
void good(T, Ts...);                   // variadic template

template <typename T, typename... Ts>
void oops(T, T...);                    // old C-style variadic
\end{emcppslisting}
    

\noindent Such a mistake may be caused by a simple typo in the declaration of
\lstinline!oops!, leading to a variety of puzzling compile-time or
link-time errors; see \intraref{potential-pitfalls-variadic}{accidental-use-of-c-style-ellipsis}.

It is possible to use the parameter pack name (e.g., \lstinline!Ts!) as a
parameter to a user-defined type:

\begin{emcppslisting}[emcppsbatch=e14]
template <typename> struct S1;  // declaration only

template <typename... Ts>       // parameter pack named (ù{\codeincomments{Ts}}ù)
int fs1(S1<Ts>...);
    // **Pack expansion** for explicit instantiation of (ù{\codeincomments{S1}}ù) accepts any number of
    // independent explicit instantiations of (ù{\codeincomments{S1}}ù) by value.
\end{emcppslisting}
    

\noindent The parameter pack name \lstinline!Ts! acts as though it were a separate
type parameter for each function argument, thereby allowing a different
instantiation for \lstinline!S1! at each parameter position. To invoke
\lstinline!fs1! on arguments of user-defined type \lstinline!S1!, however,
\lstinline!S1! will need to be a \emcppsgloss{complete type} --- i.e., its
definition must precede the point of invocation of the function in the
current translation unit:

\begin{emcppslisting}[emcppsbatch=e14]
int s1a = fs1(S1<int>());             // Error, (ù{\codeincomments{S1}}ù) declared but not defined

template <typename T>
struct S1 { /*...*/ };                // introduce definition for (ù{\codeincomments{S1}}ù)

int s1b = fs1();                       // (ù{\codeincomments{Ts}}ù) is the empty pack.
int s1c = fs1(S1<const char*>());      // (ù{\codeincomments{Ts}}ù)=<(ù{\codeincomments{const char*}}ù)>
int s1d = fs1(S1<int>(), S1<bool>());  // (ù{\codeincomments{Ts}}ù)=<(ù{\codeincomments{int,bool}}ù)>
\end{emcppslisting}
    

\noindent More complex setups are possible as well. For example, we can write a
variadic function template that operates on instantiations of
user-defined-type templates that take two independent type parameters:

\begin{emcppslisting}[emcppsbatch=e15]
template <typename, typename>
struct S2;                  // two-parameter class template declaration

template <typename... Ts>   // parameter pack named (ù{\codeincomments{Ts}}ù)
int fs2(S2<Ts, Ts>...);
    // The function (ù{\codeincomments{fs2}}ù) takes by value any number of explicit instantiations
    // of (ù{\codeincomments{S2}}ù) as long as they use the same type in both positions.
\end{emcppslisting}
    

\noindent Calls to \lstinline!fs2! work only if we supply instantiations of
\lstinline!S2! having the same type for both template parameters:

\begin{emcppslisting}[emcppsbatch=e15]
template <typename, typename> struct S2 { /*...*/ };  // (ù{\codeincomments{S2}}ù)'s definition

int s2a = fs2();                                      // OK
int s2b = fs2(S2<char, char>());                      // OK
int s2c = fs2(S2<int, int>(), S2<bool, bool>());      // OK
int s2d = fs2(S2<char, int>());                       // Error
int s2e = fs2(S2<char, const char>());                // Error
\end{emcppslisting}
    

\noindent The problem with the last two calls above is that the instantiations
\lstinline!S2<char,!~\lstinline!int>! and
\lstinline!S2<char,!~\lstinline!const!~\lstinline!char>! violate the requirement
that the two types in the instantiation of \lstinline!S2! are identical, so
there is no way to provide or deduce some \lstinline!Ts! in a way that
would make the call work.

\subsubsection[Variadic member functions]{Variadic member functions}\label{variadic-member-functions}

Member functions may be variadic in two orthogonal ways: The class they
are part of may be variadic, and they may be variadic themselves. The
simplest case features a variadic member function of a non-template
class:

\begin{emcppslisting}
struct S3                                 // non-variadic non-template class
{
    template <typename... Ts> int f(Ts...);  // OK
};

int s3 = S3().f(1, "abc");                // (ù{\codeincomments{Ts}}ù)=<(ù{\codeincomments{int, const char*}}ù)>
\end{emcppslisting}
    

\noindent Expectedly, a non-variadic \emcppsgloss{class template} may declare variadic
member functions as well:

\begin{emcppslisting}
template <typename T>
struct S4                                            // class template
{
    template <typename... Ts> int f1(Ts...);            // OK
    template <typename... Ts> int f2(T, const Ts&...);  // OK
};

int s3b = S4<int>().f1(1, false, true);              // (ù{\codeincomments{Ts=<int, bool, bool>}}ù)
int s3c = S4<int>().f2(1, false, true);              // (ù{\codeincomments{Ts=<bool, bool>}}ù)
\end{emcppslisting}
    

\noindent A \emcppsgloss{variadic class template} may define regular \emcppsgloss[member function]{member
functions}, member functions that take their own template parameters,
and \emcppsgloss[variadic member function template]{variadic member function templates}:

\begin{emcppslisting}
template <typename... Ts>
struct S5
{
    int f1();       // non-template member function of variadic class

    template <typename T>
    int f2(T);      // template member function of variadic class

    template <typename... Us>
    int f3(Us...);  // variadic template member function of variadic class
};

int s5a = S5<int, char>().f1();
    // (ù{\codeincomments{Ts=<int, char>}}ù)

int s5b = S5<char, int>().f2(2.2);
    // (ù{\codeincomments{Ts=<int, char>}}ù), (ù{\codeincomments{T=double}}ù)

int s5c = S5<int, char>().f3(1, 2.2);
    // (ù{\codeincomments{Ts=<int, char>}}ù), (ù{\codeincomments{Us=<int, double>}}ù)
\end{emcppslisting}
    

\noindent Although in a sense all member functions of a \emcppsgloss{variadic class
template} (e.g., \lstinline!S5!, above) are variadic, the class's template
parameter pack (e.g., \lstinline!Ts!, above) is fixed at the time the class
is instantiated. The only truly variadic function is \lstinline!f3! because
it takes its own template parameter pack, \lstinline!Us!.

A member function of a variadic class may use the template parameter
pack of the class in which it is defined:

\begin{emcppslisting}
template <typename... Ts>
struct S6                  // variadic class template
{
    int f1(const Ts&...);  // OK, not truly variadic; (ù{\codeincomments{Ts}}ù) is fixed

    template <typename T>
    int f2(T, Ts...);      // OK, also not truly variadic; (ù{\codeincomments{Ts}}ù) is fixed

    template <typename... Us>
    int f3(Ts..., Us...);  // OK, variadic template member function
};

int s6a = S6<int, char>().f1(1, 'a');
    // (ù{\codeincomments{Ts=<int, char>}}ù)

int s6b = S6<char, int>().f2(true, 'b', 2);
    // (ù{\codeincomments{Ts=<int, char>}}ù), (ù{\codeincomments{T=bool}}ù)

int s6c = S6<int, char>().f3(1, 2.2, "asd", 123.456);
    // (ù{\codeincomments{Ts=<int, char>}}ù), (ù{\codeincomments{Us=<const char*, int, double>}}ù)
\end{emcppslisting}
    

\noindent Notice how, in the initialization of \lstinline!s6c!, the type arguments
\lstinline!Ts! of class template \lstinline!S6! must be chosen explicitly,
whereas the variadic template \lstinline!f3! need not have \lstinline!Us!
specified because they are deduced from the argument types. This takes
us to the important topic of \emcppsgloss{template argument deduction}.

\subsubsection[Template argument deduction]{Template argument deduction}\label{template-argument-deduction}

A popular feature of C++ ever since templates were incorporated into the
language prestandardization has been the ability of function templates
to determine their template arguments from the types of arguments
provided. Consider, for example, designing and using a function,
\lstinline!print!, that outputs its argument to the console. In most cases,
just letting \lstinline!print! deduce its template argument from the
function argument's type has brevity, correctness, and efficiency
advantages:

\begin{emcppslisting}
#include <string>  // (ù{\codeincomments{std::string}}ù)

template <typename T> void print(const T& value);  // prints (ù{\codeincomments{x}}ù) to (ù{\codeincomments{stdout}}ù)

void testPrint0(const std::string& s)
{
    print<const char*>("Hi");
        // verbose:   specifies template argument *and* function argument
        // redundant: function argument's type *is* the template argument

    print<int>(3.14);
        // Error-prone: Mismatch may cause incorrect results (prints (ù{\codeincomments{3}}ù)).

    print<std::string>("Oops");
        // inefficient: may incur additional expensive implicit conversions

    print("Hi");
    print(3.14);
    print(s);
        // all good: let (ù{\codeincomments{print}}ù) deduce template argument from function argument
}
\end{emcppslisting}
    

\noindent What makes the shorter form of the call work is the magic of C++
\emcppsgloss{template argument deduction}, which, unsurprisingly, works with
variadic template parameters as well. A detailed description of all
rules for \emcppsgloss{template argument deduction}, including those
inherited from C++03, is outside the scope of this
book.\footnote{Please insert a cite to Scott Meyers'
``Effective Modern C++'' (which is already in your bib file), with the
addition: Chapter 1: ``Deducing Types'', pages 9--35. \textbf{[AUs: We have several editions of the Meyers book in our bib; which one did you intend?  Response: meyers15b and meyers15 are the same book, which this should be referring to.  ]}} Here, we focus on the additions to the
rules brought about by variadic function templates.

With that in mind, imagine we set out to redesign the API of
\lstinline!print! (in the code example above) to output any number of
arguments to the console:

\begin{emcppslisting}[emcppsbatch=e16]
#include <string>  // (ù{\codeincomments{std::string}}ù)

template <typename... Ts>                // template parameter pack (ù{\codeincomments{Ts}}ù)
void print(const Ts&... values);         // prints each of (ù{\codeincomments{values}}ù) to (ù{\codeincomments{stdout}}ù)

void testPrint1(const std::string& s)  // arbitrary function
{
    print<const char*, int, std::string>("Hi", 3.14, "Oops");
        // verbose:     specifies template arguments *and* function arguments
        // Redundant:   Function arguments' types *are* the template arguments.
        // Error-prone: Mismatch may cause incorrect results (prints (ù{\codeincomments{3}}ù)).
        // inefficient: may incur additional expensive implicit conversions

    print("Hi", 3.14, s);
        // All good: Deduce template arguments from function arguments.
}
\end{emcppslisting}
    

\noindent The compiler will independently deduce each type in \lstinline!Ts! from the
respective types of the function's argument \lstinline!values!:

\begin{emcppslisting}[emcppsbatch=e16]
void testPrint2()  // arbitrary function
{
    print();               // OK, (ù{\codeincomments{Ts=<>}}ù)
    print(42, true);       // OK, (ù{\codeincomments{Ts=<int, bool>}}ù)
    print(42.2, "hi", 5);  // OK, (ù{\codeincomments{Ts=<double, const char*, int>}}ù)
}
\end{emcppslisting}
    

\noindent As shown in the first line of \lstinline!test2! (above), a \emcppsgloss{template
parameter pack} may be specified in its entirety when instantiating a
function template:

\begin{emcppslisting}[emcppsbatch=e16]
void testPrint3()  // arbitrary function
{
    print<>();                    // OK, exact match
    print<int, bool>(42, true);   // OK, exact match
    print<int, bool>('a', 'b');   // OK, arguments convertible to parameters
}
\end{emcppslisting}
    

\noindent Interestingly, we can specify only the first few types of the template
parameter pack and let the others be deduced, mixing together
\emcppsgloss{explicit template argument specification} and \emcppsgloss{template
argument deduction}:

\begin{emcppslisting}[emcppsbatch=e16]
void testPrint4()  // arbitrary function
{
    print<>(5, 'a');                 // OK, (ù{\codeincomments{Ts=<int, char>}}ù)
    print<unsigned int>(42, true);   // OK, (ù{\codeincomments{Ts=<unsigned int, bool>}}ù)
    print<int, int>('a', "ab", 1);   // Error, cannot deduce (ù{\codeincomments{Ts}}ù)
}
\end{emcppslisting}
    

\noindent Such a mix of explicit and implicit may be interesting but is not new;
it has been the case for function templates since C++ was first
standardized. The new element here is that we get to specify a fragment
of a template parameter pack.

In the general case, a function may mix \emcppsgloss[template parameter pack]{template parameter
packs} with other template parameters in a variety of ways. It may also
mix \emcppsgloss[function parameter pack]{function parameter packs} with other function parameters in
a variety of ways.

\subsubsection[The Rule of Greedy Matching]{The Rule of Greedy Matching}\label{the-rule-of-greedy-matching}

The Rule of Greedy Matching for \emcppsgloss[template parameter pack]{template parameter packs} (but
not \emcppsgloss[function parameter pack]{function parameter packs}) states that once a
\emcppsgloss{template parameter pack} starts matching one explicitly
specified template argument, it also matches all template arguments
following it. There's no way to tell a \emcppsgloss{template parameter pack}
it matched enough. Template parameter packs are \emph{greedy}.

Consequently, there is no syntactic way to explicitly specify any
template argument following one that matches a template parameter pack;
the first pack gobbles all remaining arguments up. Put succinctly: all
\emcppsgloss[template parameter]{template parameters} following a \emcppsgloss{template parameter
pack} can \emph{never} be explicitly specified as template arguments.

Notice that the rule applies only once a pack starts matching, i.e., it
has matched at least one item; indeed there are a few legitimate cases
in which a parameter list makes no match at all, which we'll discuss
soon.

Using the Rule of Greedy Matching allows us to navigate with relative
ease a variety of combinations of pack and nonpack template parameters.

In the simplest and overwhelmingly most frequently encountered
situation, the function takes one template parameter pack and one
function parameter pack, both in the last position:

\begin{emcppslisting}[emcppsbatch=e17]
template <typename T1, typename T2, typename... Ts>  // (ù{\codeincomments{...}}ù) in last position
int f1(T1, T2, const Ts&...);                        // (ù{\codeincomments{...}}ù) in last position
\end{emcppslisting}
    

\noindent In such cases, the Rule of Greedy Matching doesn't need to kick in
because there are no parameters following a pack. Template argument
deduction can be used for all of \lstinline!T1!, \lstinline!T2!, and
\lstinline!Ts! or for only for a subset. In the simplest case, no template
parameters are specified and template argument deduction is used for
all:

\begin{emcppslisting}[emcppsbatch=e17]
int x1a = f1(42, 2.2, 'a', true);
    // (ù{\codeincomments{T1=int}}ù), (ù{\codeincomments{T2=double}}ù), (ù{\codeincomments{Ts=<char, bool>}}ù) (all deduced)
\end{emcppslisting}
    

\noindent Explicitly specified template arguments, if any, will match template
parameters in the order in which they are declared. Therefore, if we
specify one type, it binds to \lstinline!T1!:

\begin{emcppslisting}[emcppsbatch=e17]
int x1b = f1<double>(42, 2.2, 'a', true);
    // (ù{\codeincomments{T1=double}}ù) (explicitly), (ù{\codeincomments{T2=double}}ù) (deduced), (ù{\codeincomments{Ts=<char, bool>}}ù) (deduced)
\end{emcppslisting}
    

\noindent If we specify two types, they will bind to \lstinline!T1! and \lstinline!T2!
in that order:

\begin{emcppslisting}[emcppsbatch=e17]
int x1c = f1<double, char>(42, 65, "abc", true);
    // (ù{\codeincomments{T1=double}}ù) (explicitly), (ù{\codeincomments{T2=char}}ù) (explicitly),
    // (ù{\codeincomments{Ts=<const char*, bool>}}ù) (deduced)
\end{emcppslisting}
    

\noindent Note how, in the two examples above, we also have implicit conversions
going on, i.e., \lstinline!42! is converted to \lstinline!double! and
\lstinline!65! is converted to \lstinline!char!. Furthermore, a call may
specify \lstinline!T1!, \lstinline!T2!, and the entirety of \lstinline!Ts!:

\begin{emcppslisting}[emcppsbatch=e17]
int x1d = f1<const char*, char, bool, double>("abc", 'a', true, 42U);
    // (ù{\codeincomments{T1=const char*}}ù) (explicitly), (ù{\codeincomments{T2=char}}ù) (explicitly),
    // (ù{\codeincomments{Ts=<bool, unsigned>}}ù) (explicitly)
\end{emcppslisting}
    

\noindent Last but not least, as mentioned, a call may specify \lstinline!T1!,
\lstinline!T2!, and only the first few types in \lstinline!Ts!:

\begin{emcppslisting}[emcppsbatch=e17]
int x1e = f1<const char*, char, bool, double>("abc", 'a', true, 42, 'a', 0);
    // (ù{\codeincomments{T1=const char*}}ù) (explicitly), (ù{\codeincomments{T2=char}}ù) (explicitly),
    // (ù{\codeincomments{Ts=<bool, int, char, int>}}ù) (first two explicit, others deduced)
\end{emcppslisting}
    

\noindent Let us now look at a function having a \emcppsgloss{template parameter pack}
not in the last position. However, in the argument list, the
\emcppsgloss{function parameter pack} is still in the last position:

\begin{emcppslisting}[emcppsbatch=e18]
template <typename T, typename... Ts, typename U>  // (ù{\codeincomments{...}}ù) not last
int f2(T, U, const Ts&...);
\end{emcppslisting}
    

\noindent In such cases, by the Rule of Greedy Matching, there is no way to
specify \lstinline!U! explicitly, so the only way to call \lstinline!f1! is to
let \lstinline!U! be deduced:

\begin{emcppslisting}[emcppsbatch=e18]
int x2a = f2(1, 2);
    // (ù{\codeincomments{T=int}}ù) (deduced), (ù{\codeincomments{U=int}}ù) (deduced), (ù{\codeincomments{Ts}}ù)=<> (by arity)

int x2b = f2<long>(1, 2, 3);
    // (ù{\codeincomments{T=long}}ù) (explicit), (ù{\codeincomments{U=int}}ù) (deduced), (ù{\codeincomments{Ts}}ù)=<int> (deduced)
\end{emcppslisting}
    

\noindent The first template argument passed to \lstinline!f2!, if any, is matched by
\lstinline!T!. Note that inferring the empty template parameter pack in the
initialization of \lstinline!x2a! does not involve deduction; the empty
length is inferred by the arity of the call. In contrast, in the
initialization of \lstinline!x2b!, a pack of length 1 is deduced.

Any subsequent template arguments will be matched \emph{en masse} by
\lstinline!Ts! in concordance with the Rule of Greedy Matching:

\begin{emcppslisting}[emcppsbatch=e18]
int x2c = f2<long, double, char>(1, 2, 3, 4);
    // (ù{\codeincomments{T1=long}}ù) (explicit), (ù{\codeincomments{T2=int}}ù) (deduced), (ù{\codeincomments{Ts=<double, char>}}ù) (explicit)

int x2d = f2<int, double>(1, 2, 3.0, "four");
    // (ù{\codeincomments{T1=int}}ù) (explicit), (ù{\codeincomments{T2=int}}ù) (deduced), (ù{\codeincomments{Ts=<double, const char*>}}ù) (partially specified)

int x2e = f2<int, char, double>(1, 3.0, 'a');
    // Error, no viable function for (ù{\codeincomments{T1=int}}ù) and (ù{\codeincomments{Ts=<char, double>}}ù)
\end{emcppslisting}
    

\noindent In all cases, \lstinline!T2! must be deduced for the call to \lstinline!f2! to
go through.

Another way to make a template parameter work even if it's positioned
after a parameter pack is by assigning it a default argument:

\begin{emcppslisting}[emcppsbatch=e19]
template <typename... Ts, typename T = int>
T f3(Ts... values);
\end{emcppslisting}
    

\noindent Due to the way \lstinline!f3! is defined, there is no way to either deduce
or specify \lstinline!T!, so it will always be \lstinline!int!:

\begin{emcppslisting}[emcppsbatch=e19]
int x3a = f3("one", 2);
    // (ù{\codeincomments{Ts=<const char*, int>}}ù) (deduced), (ù{\codeincomments{T=int}}ù) (default)

int x3b = f3<const char*>("one", 2);
    // (ù{\codeincomments{Ts=<const char*, int>}}ù) (partially deduced), (ù{\codeincomments{T=int}}ù) (default)

int x3c = f3<const char*, int>("one", 2);
    // (ù{\codeincomments{Ts=<const char*, int>}}ù) (explicit), (ù{\codeincomments{T=int}}ù) (default)
\end{emcppslisting}
    

\subsubsection[The Rule of Fair Matching]{The Rule of Fair Matching}\label{the-rule-of-fair-matching}

To further explore the varied ways in which parameter packs may interact
with the rest of C++, let's take a look at a function that has a type
following a \emcppsgloss{template parameter pack} and also a value following
a \emcppsgloss{function parameter pack}:

\begin{emcppslisting}[emcppsbatch=e20]
template <typename... Ts, typename T>
int f4(Ts... values, T value);
\end{emcppslisting}
    

\noindent Here, a new rule applies, the Rule of Fair Matching, which is to a good
extent the converse of the Rule of Greedy Matching. When a
\emcppsgloss{function parameter pack} (e.g., \lstinline!values! in the code
snippet above) is \emph{not} at the end of a function's parameter list,
its corresponding type parameter pack (e.g., \lstinline!Ts! above)
\emph{cannot be deduced} ever.

This rule makes the \emcppsgloss{function parameter pack} \lstinline!values!
fair because function parameters following a function parameter pack
have a chance to match function arguments.

Let's take a look at how the rule applies to \lstinline!f4!. In calls with
one argument, \lstinline!Ts! is not deduced, so it forcibly matches the
empty list, and \lstinline!T! matches the type of the argument:

\begin{emcppslisting}[emcppsbatch=e20]
int x4a = f4(123);     // (ù{\codeincomments{Ts=<>}}ù) (forced non-deduced), (ù{\codeincomments{T=int}}ù)
int x4b = f4('a');     // (ù{\codeincomments{Ts=<>}}ù) (forced non-deduced), (ù{\codeincomments{T=char}}ù)
int x4c = f4('a', 2);  // Error, cannot deduce (ù{\codeincomments{Ts}}ù)
\end{emcppslisting}
    

\noindent Calls with more than one argument can be made if and only if we provide
\lstinline!Ts! to the compiler explicitly:

\begin{emcppslisting}[emcppsbatch=e20]
int x4d = f4<int, char>(1, '2', "three");
    // (ù{\codeincomments{Ts=<int, char>}}ù) (explicit), (ù{\codeincomments{T=const char*}}ù)
\end{emcppslisting}
    

\noindent Incidentally, for \lstinline!f4! there is no way to specify \lstinline!T!
explicitly because of the Rule of Greedy Matching:

\begin{emcppslisting}[emcppsbatch=e20]
int x4e = f4<int, char, const char*>(1, '2', "three");
    // Error, (ù{\codeincomments{Ts=<int, char, const char*>}}ù) (explicit), no argument for (ù{\codeincomments{T value}}ù)
\end{emcppslisting}
    

\noindent Note that the two rules may work simultaneously on the same function
call; they do not compete because they apply in different places; the
Rule of Greedy Matching applies to \emcppsgloss[template parameter pack]{template parameter packs},
and the Rule of Fair Matching applies to \emcppsgloss[function parameter pack]{function parameter
packs}.

Let's now consider declaring a function with two consecutive parameter
packs and see how the rules work together in calls:

\begin{emcppslisting}[emcppsbatch=e21]
template <typename... Ts, typename... Us>  // two template parameter packs
int f5(Ts... ts, Us... us);                // two function parameter packs
\end{emcppslisting}
    

\noindent By the Rule of Greedy Matching, we cannot specify \lstinline!Us! explicitly
so \lstinline!us! will rely on deduction exclusively. By the Rule of Fair
Matching, \lstinline!Ts! cannot be deduced. First, let's analyze a call
with no template arguments:

\begin{emcppslisting}[emcppsbatch=e21]
int x5a = f5(1);
    // (ù{\codeincomments{Ts=<>}}ù) (forcibly), (ù{\codeincomments{Us=<int>}}ù)

int x5b = f5(1, '2');
    // (ù{\codeincomments{Ts=<>}}ù) (forcibly), (ù{\codeincomments{Us=<int, char>}}ù)

int x5c = f5(1, '2', "three");
    // (ù{\codeincomments{Ts=<>}}ù) (forcibly), (ù{\codeincomments{Us=<int, char, const char*>}}ù)
\end{emcppslisting}
    

\noindent Whenever a call specifies no \emcppsgloss[template argument]{template arguments}, \lstinline!Ts!
cannot be deduced so it can at best match the empty list. That leaves
all of the arguments to \lstinline!us!, and deduction will work as expected
for \lstinline!Us!. This right-to-left matching may surprise at first and
requires close reading of different parts of the C++ Standard but is
easy to explain by using the two rules.

Let's now issue a call that does specify template arguments:

\begin{emcppslisting}[emcppsbatch=e21]
int x5d = f5<int, char>(1, '2');
    // (ù{\codeincomments{Ts=<int, char>}}ù) (explicitly), (ù{\codeincomments{Us=<const char*>}}ù)

int x5e = f5<int, char>(1, '2', "three");
    // (ù{\codeincomments{Ts=<int, char>}}ù) (explicitly), (ù{\codeincomments{Us=<const char*>}}ù)

int x5f = f5<int, char>(1, '2', "three", 4.0);
    // (ù{\codeincomments{Ts=<int, char>}}ù) (explicitly), (ù{\codeincomments{Us=<const char*, double>}}ù)
\end{emcppslisting}
    

\noindent By the Rule of Greedy Matching, all explicit template arguments go to
\lstinline!Ts!, and, by the Rule of Fair Matching, there's no deduction for
\lstinline!Ts!, so, even before looking at the function arguments, we know
that \lstinline!Ts! is exactly \lstinline!<int,!~\lstinline!char>!. From here on,
it's easy: The first two arguments go to \lstinline!ts!, and all others, if
any, will go to \lstinline!us!.

\subsubsection[Corner cases of function template argument matching]{Corner cases of function template argument matching}\label{corner-cases-of-function-template-argument-matching}

There are cases in which a template function could be written that can
never be called, whether with explicit template parameters or by relying
on template argument deduction:

\begin{emcppslisting}
template <typename... Ts, typename T>
void odd1(Ts... values);
\end{emcppslisting}
    

\noindent By the Rule of Greedy Matching applied to \lstinline!Ts!, \lstinline!T! can
never be specified explicitly. Moreover, \lstinline!T! cannot be deduced
either because it's not part of the function's parameter list. Hence,
\lstinline!odd1! is impossible to call. According to standard C++, such
function declarations are \emcppsgloss{ill formed, no diagnostic required
(IFNDR)}. Current compilers do allow such functions to be defined
without a warning. However, any conforming compiler will disallow any
attempt to call such an ill-fated function.

Another scenario is one whereby a variadic function can be instantiated,
but one or more of its parameter packs must always have length zero:

\begin{emcppslisting}[emcppsbatch=e22]
template <typename... Ts, typename... Us, class T>
int odd2(Ts..., Us..., T);  // specious
\end{emcppslisting}
    

\noindent Any attempt to call \lstinline!odd2! by relying on only template argument
deduction will force both \lstinline!Ts! and \lstinline!Us! to the empty list
because, by the Rule of Fair Matching, neither \lstinline!Ts! nor
\lstinline!Us! can benefit from template argument deduction. So calls with
two, three, or more arguments fail:

\begin{emcppslisting}[emcppsbatch=e22]
int x2a = odd2(1, 2.5);           // Error, (ù{\codeincomments{Ts}}ù)=<>, (ù{\codeincomments{Us}}ù)=<>, too many arguments
int x2a = odd2(1, 2.5, "three");  // Error, (ù{\codeincomments{Ts}}ù)=<>, (ù{\codeincomments{Us}}ù)=<>, too many arguments
\end{emcppslisting}
    

\noindent However, there seem to be ways to invoke \lstinline!odd2!, at least on
contemporary compilers. First, calls using deduction with exactly one
argument will merrily go:

\begin{emcppslisting}[emcppsbatch=e22]
int x2c = odd2(42);  // (ù{\codeincomments{Ts}}ù)=<>, (ù{\codeincomments{Us}}ù)=<>, (ù{\codeincomments{T=42}}ù)
\end{emcppslisting}
    

\noindent Better yet, functions that pass an explicit argument list for
\lstinline!Ts! also seem to work:

\begin{emcppslisting}[emcppsbatch=e22]
int x2d = odd2<int, double>(1, 2.0, "three");
    // (ù{\codeincomments{Ts=<int, double>}}ù), (ù{\codeincomments{Us=<>}}ù), (ù{\codeincomments{T=const char*}}ù)
\end{emcppslisting}
    

\noindent The call above passes \lstinline!Ts! explicitly as
\lstinline!<int,!~\lstinline!double>!. Then, as always, \lstinline!Us! is forced
to the empty list, and \lstinline!T! is deduced as
\lstinline!const!~\lstinline!char*! for the last argument. That way, the call
goes through!

Or does it? Alas, the declaration of \lstinline!odd2! is \emcppsgloss{IFNDR}. By
the C++ Standard, if all valid instantiations of a variadic function
template require a specific template parameter pack argument to be
empty, the declaration is \emcppsgloss{IFNDR}. Although such a rule sounds
arbitrary, it does have a good motivation: If all possible calls to
\lstinline!odd2! require \lstinline!Us! to be the empty list, why is
\lstinline!Us! present in the first place? Such code is more indicative of
a bug than of a meaningful intent. Also, diagnosing such cases may be
quite difficult in the general case, so no diagnostic is required. As it
turns out, today's compilers do not issue such a diagnostic, so the onus
is on the template writer to make sure the code does what it's supposed
to do.

A simple fix for \lstinline!odd2! is to just eliminate the \lstinline!Us!
template parameter, in which case \lstinline!odd2! has the same signature
as \lstinline!f4! discussed in \intrarefsimple{the-rule-of-fair-matching}. Another possibility to ``legalize'' \lstinline!odd2! is to
drop the nonpack parameter, in which case it has the same signature as
\lstinline!f5! in the same section.

A function that has three parameter packs in a row would also be
\emcppsgloss{IFNDR}:

\begin{emcppslisting}
template <typename... Ts, typename... Us, typename... Vs>
void odd3(Ts..., Us..., Vs...);  // impossible to instantiate
\end{emcppslisting}
    

\noindent The reason \lstinline!odd3! cannot work is purely bureaucratic: Neither
\lstinline!Ts! nor \lstinline!Us! may benefit from deduction, and then there
is no way to specify \lstinline!Us! explicitly because \lstinline!Ts! is
greedy. Consequently, \lstinline!Us! is forced to be always of length zero.

It may seem there is no way to define a function template taking more
than two parameter packs. However, recall that deducing variadic
function template parameters from the (object) arguments passed to the
function uses the full power of C++'s \emcppsgloss{template argument
deduction}. Defining functions with any number of template parameter
packs is entirely possible provided the parameter packs are themselves
part of other template instantiations:

\begin{emcppslisting}[emcppsbatch=e23]
template <typename...> class Vct { };  // variadic class template definition

template <typename T, typename... Ts, typename... Us, typename... Vs>
int fvct(const T&, Vct<Ts...>, Vct<Us...>, Vct<Vs...>);
    // The first parameter matches any type by (ù{\codeincomments{const\&}}ù), followed by three
    // not necessarily related instantiations of (ù{\codeincomments{Vct}}ù).
\end{emcppslisting}
    

\noindent The function template \lstinline!fvct! takes a fixed number of parameters
(four), the last three of which are independent instantiations of a
variadic class template \lstinline!Vct!. For each of them, \lstinline!fvct!
takes a template parameter pack that it passes along to \lstinline!Vct!.
For each call to \lstinline!fvct!, template argument deduction figures out
whether the call is viable and also binds \lstinline!Ts!, \lstinline!Us!, and
\lstinline!Vs! to the packs that make the call work:

\begin{emcppslisting}[emcppsbatch=e23]
int x = fvct(5, Vct<>(), Vct<char, int, long>(), Vct<bool>());
    // OK, (ù{\codeincomments{T=int}}ù), (ù{\codeincomments{Ts=<>}}ù), (ù{\codeincomments{Us=<char, int, long>}}ù), (ù{\codeincomments{Vs=<bool>}}ù)
\end{emcppslisting}
    

\noindent For each argument in the call above, the compiler matches the type of
the argument with the pattern required by the template parameter; the
matching process deduces the types that would make the match work. The
general algorithm for matching a concrete type against a type pattern is
called \emcppsgloss[unification]{unification}.{\cprotect\footnote{\cite{bendersky18}}}

\subsubsection[Non-type template parameter packs]{Non-type template parameter packs}\label{non-type-template-parameter-packs}

Defining a variadic template that take arguments other than types is
also possible. Just as C++03 template parameters can be \emph{types},
\emph{values}, or \emph{templates}, so can \emcppsgloss[template parameter pack]{template parameter
packs}. We used \emcppsgloss[type template parameter pack]{type template parameter packs} up until now to
simplify exposition, but non-type template parameter packs apply to
class templates and function templates as well.

To clarify terminology, the C++ Standard refers to template parameters
that accept values as \emcppsgloss[non-type template parameter]{non-type template parameters} and to
template parameters that accept names of templates as \emcppsgloss[template template parameter]{template
template parameters} (to be discussed in subsection
\intrarefsimple{template-parameter-packs}).

\emcppsgloss[non-type template parameter pack]{Non-type template parameter packs} are defined analogously with
\emcppsgloss[non-type template parameter]{non-type template parameters}:

\begin{emcppslisting}
template <int...>
class Ci { };           // variadic (ù{\codeincomments{int}}ù)-parameter class template

Ci<>              ci0;  // OK, zero (ù{\codeincomments{int}}ù)s given
Ci<1>             ci1;  // OK, one (ù{\codeincomments{int}}ù) argument
Ci<2, 3>          ci2;  // OK, two (ù{\codeincomments{int}}ù) arguments
Ci<true, 'a', 3u> ci3;  // OK, converts to three (ù{\codeincomments{int}}ù) arguments
Ci<4.0>           ci4;  // Error, floating-point literal (ù{\codeincomments{4.0}}ù) is ineligible.
\end{emcppslisting}
    

\noindent The type specifier of the template \emcppsgloss{non-type parameter pack} need
not only be \lstinline!int!; the same rules as for \emcppsgloss[non-type parameter]{non-type parameters} apply, restricting the types of non-type parameters to
\begin{itemize}
\item{integral}
\item{enumerated}
\item{pointer to function or object}
\item{\romeovalue{lvalue} reference to function or object}
\item{pointer to member}
\item{\lstinline!std::nullptr_t!}
\end{itemize}
These types are the value types allowed for C++03 non-type template
parameters. In short, value parameter packs obey the same restrictions
as the C++03 non-type template parameters:

\begin{emcppslisting}
#include <cstddef>  // (ù{\codeincomments{std::nullptr\_t}}ù)
#include <string>  // (ù{\codeincomments{std::string}}ù)

enum Enum { /*...*/ };                  // arbitrary enumerated type
class AClass { /*...*/ };               // arbitrary class type

template <long... ls>          class Cl;   // OK, integral
template <bool... bs>          class Cb;   // OK, integral
template <char... cs>          class Cc;   // OK, integral
template <Enum... es>          class Ce;   // OK, enumerated
template <int&... is>          class Cri;  // OK, reference
template <std::string*... ss>  class Csp;  // OK, pointer
template <void (*... fs)(int)> class Cf;   // OK, pointer to function
template <int AClass::*... >   class Cpm;  // OK, pointer to member
template <std::nullptr_t>     class Cnl;  // OK, (ù{\codeincomments{std::nullptr\_t}}ù)

template <Ci<>... cis>         class Cu;   // Error, cannot be user-defined 
template <double... ds>        class Cd;   // Error, cannot be floating-point 
template <float... fs>         class Cf;   // Error, cannot be floating-point 
\end{emcppslisting}
    

\noindent In the example above, the declaration of class template \lstinline!Cu! is
not permitted because \lstinline!Ci<>! is a \emph{user-defined} type,
whereas the declarations of both \lstinline!Cd! and \lstinline!Cf! are
disallowed because \lstinline!double! and \lstinline!float! are floating-point
types.{\cprotect\footnote{C++20 does allow \emph{floating point}
non-type template parameters, which enable the definition and use of
\emcppsgloss[non-type parameter pack]{non-type parameter packs} using \lstinline!float!,
\lstinline!double!, or \lstinline!long!~\lstinline!double! (making, e.g., the
final entry --- \lstinline!Ci<4.0>!~\lstinline!ci4;! --- in the previous
  example above valid as well).}}

\subsubsection[Template parameter packs]{Template parameter packs}\label{template-parameter-packs}

\emcppsgloss[template parameter pack]{Template parameter packs} are the variadic generalization of
C++03's \emcppsgloss[template template parameter]{template template parameters}. Classes and functions may
be designed to take \emcppsgloss[template parameter pack]{template parameter packs} as parameters in
addition to \emcppsgloss[type parameter pack]{type parameter packs}.

A template \emph{template} parameter is a template parameter that names
an argument that is itself a \emph{template}. Consider, for example, two
arbitrary class templates, \lstinline!A1! and \lstinline!A2!:

\begin{emcppslisting}[emcppsbatch=e24]
template <typename> class A1 {/* ...*/ };  // some arbitrary class template
template <typename> class A2 {/* ...*/ };  // another arbitrary class template
\end{emcppslisting}
    

\noindent Now suppose that we have a \emph{class} template, (e.g., \lstinline!C1!)
that takes, as its template parameter, a \emph{class} \emph{template}:

\begin{emcppslisting}[emcppsbatch=e24]
template <template<typename> class X>  // (ù{\codeincomments{X}}ù) is a template template parameter.
struct C1 : X<int>, X<double>          // inherit (ù{\codeincomments{X<int>}}ù) and (ù{\codeincomments{X<double>}}ù)
{ };
\end{emcppslisting}
    

\noindent We can now create instances of class \lstinline!C1! where the bases are
obtained by instantiating whatever argument we pass to \lstinline!C1! with
\lstinline!int! and \lstinline!double!, respectively:

\begin{emcppslisting}[emcppsbatch=e24]
C1<A1> c1a;  // inherits (ù{\codeincomments{A1<int>}}ù) and (ù{\codeincomments{A1<double>}}ù)
C1<A2> c1b;  // inherits (ù{\codeincomments{A2<int>}}ù) and (ù{\codeincomments{A2<double>}}ù)
\end{emcppslisting}
    

\noindent In the code snippet above, \lstinline!X! is a template \emph{template}
parameter that takes one \emph{type} parameter. The template classes
\lstinline!A1! and \lstinline!A2! match \lstinline!X! because each of these
templates, in turn, takes one \emph{type} parameter as well.

If an instantiation is attempted with a class template that does not
take the same number of template parameters, the instantiation fails,
even when there is no doubt as to what the intent might be:

\begin{emcppslisting}[emcppsbatch=e24]
template <typename, typename = char>
class A3 { /*...*/ };  // OK, two-parameter template, with second one defaulted

C1<A3> c1c;  // Error, parameters of (ù{\codeincomments{A3}}ù) are different from parameters of (ù{\codeincomments{X}}ù).
\end{emcppslisting}
    

\noindent Although \lstinline!A3! could be instantiated with a single template
argument (due to its second template parameter having a default
argument) and \lstinline!A3<int>! is valid, \lstinline!C1<A3>! will not
compile. The compiler complains that \lstinline!A3! has two parameters,
whereas \lstinline!X! has a single parameter.

The same limitation is at work when the argument to \lstinline!C1! is a
variadic template:

\begin{emcppslisting}[emcppsbatch=e24]
template <typename...>
class A4 { /*...*/ };    // OK, arbitrary variadic template

C1<A4> c1d;  // Error, parameters of (ù{\codeincomments{A4}}ù) are different from parameters of (ù{\codeincomments{X}}ù).
\end{emcppslisting}
    

\noindent Let's define a class \lstinline!C2! that is a variadic generalization of
\lstinline!C1! in such a way that it allows instantiation with \lstinline!A3!
and \lstinline!A4!:

\begin{emcppslisting}[emcppsbatch=e24]
template <template<typename...> class X>  // template template parameter
struct C2 : X<int>, X<double>             // inherit (ù{\codeincomments{X<int>}}ù), (ù{\codeincomments{X<double>}}ù)
{ };
\end{emcppslisting}
    

\noindent Note that, although one may use \lstinline!typename! and \lstinline!class!
interchangeably inside the template parameters of \lstinline!X! above, one
must always must use \lstinline!class! for \lstinline!X!
itself.{\cprotect\footnote{Since C++17, code may use either
\lstinline!typename! or \lstinline!class! for template template parameters
  and for template parameter packs.}}

The difference between \lstinline!C2! and \lstinline!C1! is literally one
token: \lstinline!C2! adds one \lstinline!...! after \lstinline!typename!
\emph{inside} the parameter list of \lstinline!X!. That one token makes all
the difference: by using it, \lstinline!C2! signals to the compiler that it
accepts templates with any number of parameters, be they fixed in
number, defaulted, or variadic. In particular, it works just fine with
\lstinline!A1! and \lstinline!A2! as well as \lstinline!A3! and \lstinline!A4!:

\begin{emcppslisting}[emcppsbatch=e24]
C2<A1> c2a;
    // inherits (ù{\codeincomments{A1<int>}}ù) and (ù{\codeincomments{A1<double>}}ù) in that order
C2<A2> c2b;
    // inherits (ù{\codeincomments{A2<int>}}ù) and (ù{\codeincomments{A2<double>}}ù) in that order
C2<A3> c2c;
    // (ù{\codeincomments{C2<A3>}}ù) inherits (ù{\codeincomments{A3<int, char>}}ù) and (ù{\codeincomments{A3<double, char>}}ù) in that order.
    // (ù{\codeincomments{char}}ù) is the default argument for (ù{\codeincomments{A3}}ù)'s second type parameter.
C2<A4> c2d;
    // inherits (ù{\codeincomments{A4<int>}}ù) and (ù{\codeincomments{A4<double>}}ù) in that order
\end{emcppslisting}
    

\noindent When \lstinline!C3! instantiates \lstinline!A3<int>! or \lstinline!A3<double>!,
\lstinline!A3!'s default argument for its second parameter kicks in.
\lstinline!A4! will be instantiated with the type parameter pack
\lstinline!<int>! and separately with the type parameter pack
\lstinline!<double>!.

In contrast with template template parameters that require exact
matching with their arguments, variadic template template parameters
specifying \lstinline!typename...! work in a more ``do what I mean'' manner
by matching templates with default arguments and variadic templates.
Applications may need either style of matching depending on context.

There is an orthogonal other direction in which we can generalize
\lstinline!C2!: We can define a template, \lstinline!C3!, that accepts zero or
more template template arguments:

\begin{emcppslisting}[emcppsbatch=e24]
template <template<typename> class... Xs>  // (ù{\codeincomments{Xs}}ù) is a template parameter pack.
struct C3
    : Xs<int>...     // inherit (ù{\codeincomments{X0<int>}}ù), (ù{\codeincomments{X1<int>}}ù), ...
    , Xs<double>...  // inherit (ù{\codeincomments{X0<double>}}ù), (ù{\codeincomments{X1<double>}}ù), ...
{ };
\end{emcppslisting}
    

\noindent We get to instantiate \lstinline!C3! with zero or more template classes,
each of which takes exactly one type parameter:

\begin{emcppslisting}[emcppsbatch=e24]
C3<>           c3a;
    // no base classes at all; (ù{\codeincomments{Xs}}ù)=<>, all base specifiers vanish

C3<A1>         c3b;
    // inherits (ù{\codeincomments{A1<int>}}ù) and (ù{\codeincomments{A1<double>}}ù) in that order

C3<A1, A2>     c3c;
    // inherits (ù{\codeincomments{A1<int>}}ù), (ù{\codeincomments{A2<int>}}ù), (ù{\codeincomments{A1<double>}}ù), and (ù{\codeincomments{A2<double>}}ù) in that order

C3<A2, A1>     c3d;
    // inherits (ù{\codeincomments{A2<int>}}ù), (ù{\codeincomments{A1<int>}}ù), (ù{\codeincomments{A2<double>}}ù), and (ù{\codeincomments{A1<double>}}ù) in that order

C3<A1, A2, A1> c3e;
    // Error, cannot inherit (ù{\codeincomments{A1<int>}}ù) and (ù{\codeincomments{A1<double>}}ù) twice
\end{emcppslisting}
    

\noindent Note that \lstinline!C3!, just like \lstinline!C1!, cannot be instantiated
with \lstinline!A3!, again due to mismatched template parameters:

\begin{emcppslisting}[emcppsbatch=e24]
C3<A3> c3f;
    // Error, parameters of (ù{\codeincomments{A3}}ù) are different from parameters of (ù{\codeincomments{Xs}}ù).
C3<A4> c3g;
    // Error, parameters of (ù{\codeincomments{A4}}ù) are different from parameters of (ù{\codeincomments{Xs}}ù).
\end{emcppslisting}
    

\noindent If we want to make instantiations with \lstinline!A3! and \lstinline!A4!
possible, we can combine the two generalization directions by placing
the \lstinline!...! inside the \lstinline!Xs! parameter declaration \emph{and}
on \lstinline!Xs! as well:

\begin{emcppslisting}[emcppsbatch=e24]
template <template<typename...> class... Xs>  // two sets of (ù{\codeincomments{...}}ù)
struct C4                                     // most flexible
    : Xs<int>...                              // (ù{\codeincomments{X0<int>}}ù), (ù{\codeincomments{X0<int>}}ù), ...
    , Xs<double>...                           // (ù{\codeincomments{X1<double>}}ù), (ù{\codeincomments{X1<double>}}ù), ...
{ };
\end{emcppslisting}
    

\noindent \lstinline!C4! combines the characteristics of \lstinline!C2! and \lstinline!C3!.
It accepts zero or more arguments, which in turn are accepted in a ``do
what I mean'' manner:

\begin{emcppslisting}[emcppsbatch=e24]
C4<>           c4a;
    // no base classes at all; (ù{\codeincomments{Xs}}ù)=<>, all base specifiers vanish

C4<A1>         c4b;
    // inherits (ù{\codeincomments{A1<int>}}ù) and (ù{\codeincomments{A1<double>}}ù) in that order

C4<A1, A2>     c4c;
    // inherits (ù{\codeincomments{A1<int>}}ù), (ù{\codeincomments{A2<int>}}ù), (ù{\codeincomments{A1<double>}}ù), and (ù{\codeincomments{A2<double>}}ù) in that order

C4<A3, A1>     c4d;
    // inherits (ù{\codeincomments{A3<int>}}ù), (ù{\codeincomments{A1<int>}}ù), (ù{\codeincomments{A3<double>}}ù), and (ù{\codeincomments{A1<double>}}ù) in that order

C4<A1, A4, A2> c4e;
    // may pass any subset of (ù{\codeincomments{A1}}ù), (ù{\codeincomments{A2}}ù), (ù{\codeincomments{A3}}ù), (ù{\codeincomments{A4}}ù), in any order
\end{emcppslisting}
    

\noindent Quite a few other templates match \lstinline!C4!'s template argument, even
though they will fail to instantiate with a single parameter:

\begin{emcppslisting}[emcppsbatch=e24]
template <typename, typename> class A5 { /*...*/ };
template <typename, typename, typename...> class A6 { /*...*/ };

C4<A5> err1;  // Error, matches, but (ù{\codeincomments{A5<int>}}ù) and (ù{\codeincomments{A5<double>}}ù) are invalid.
C4<A6> err2;  // Error, matches, but (ù{\codeincomments{A6<int>}}ù) and (ù{\codeincomments{A6<double>}}ù) are invalid.
\end{emcppslisting}
    

\noindent Templates that do not take type template parameters, however, will
\emph{not} match \lstinline!C4! or, for that matter, any of \lstinline!C1!
through \lstinline!C4!:

\begin{emcppslisting}[emcppsbatch=e24]
template <typename, int>
class A7 { /*...*/ };          // one type parameter and one non-type parameter
template <typename, int = 42>
class A8 { /*...*/ };          // same, but non-type parameter defaulted
template <template<typename> class>
class A9 { /*...*/ };          // template template parameter

C4<A7> err3;  // Error, second template argument of (ù{\codeincomments{C4}}ù) has a different kind
C4<A8> err4;  // Error, second template argument of (ù{\codeincomments{C4}}ù) has a different kind
C4<A9> err5;  // Error, first template argument of (ù{\codeincomments{C4}}ù) has a different kind
\end{emcppslisting}
    

\noindent In short, class templates that do not take specifically \emph{types} as
their template parameters cannot be used in instantiations of
\lstinline!C4!.

In the general case, template parameter packs may appear together with
other template parameters and follow the rules and restrictions
discussed so far in the context of type parameter packs. Any number of
subtle but nevertheless perfectly meaningful matching cases may be
defined involving combinations of fixed and variadic template
parameters. Suppose, for example, we want to define a class \lstinline!C5!
that accepts a template that takes \emph{at} \emph{least} two parameters
and possibly more:

\begin{emcppslisting}[emcppsbatch=e24]
template <template<typename, typename, typename...> class X>
class C5
    // class template definition having one template template parameter
    // for which the template template accepts two or more type
    // arguments
{ /*...*/ };

// A few templates that match (ù{\codeincomments{C5}}ù).

template <typename, typename> class B1;
template <typename, typename, typename = int> class B2;
template <typename, typename = int, typename = int> class B3;
template <typename, typename, typename...> class B4;

C5<B1> c5a;  // OK
C5<B2> c5b;  // OK
C5<B3> c5c;  // OK
\end{emcppslisting}
    

\noindent However, templates that don't have two fixed type parameters in the
first two position will not match \lstinline!C5!:

\begin{emcppslisting}[emcppsbatch=e24]
template <typename> class B5;
template <int, typename, typename...> class B6;
template <typename, typename, int, typename...> class B7;
template <typename, typename...> class B8;

C5<B5> c5d;  // Error, argument mismatch
C5<B6> c5e;  // Error, argument mismatch
C5<B7> c5f;  // Error, argument mismatch
C5<B8> c5g;  // Error, argument mismatch
\end{emcppslisting}
    

\noindent To match \lstinline!C5!'s template parameter, a template must take types
for its first two parameters, followed by zero or more type parameters
(with default values or not). \lstinline!B5! does not match because it
takes only one parameter. \lstinline!B7! does not match because it takes an
\lstinline!int! in the first position, as opposed to a type, as required.
\lstinline!B7! fails to match because it takes an \lstinline!int! in the third
position instead of a type. Finally, \lstinline!B7! is not a match because
its second argument is not fixed.

To summarize our findings, \emcppsgloss[template parameter pack]{template parameter packs} generalize
\emcppsgloss[template template parameter]{template template parameters} in two distinct, orthogonal ways.
\begin{itemize}
\item{The \lstinline!...! at the template template parameter level allows zero or more template arguments to match.}
\item{The \lstinline!...! inside the parameter list of the template template parameter allows loose matching of templates with default arguments or variadic; however, type vs. value vs. template parameters are still checked, as in the example involving \lstinline!A7!, \lstinline!A68!, and \lstinline!A9!.}
\end{itemize}

\subsubsection[Pack expansion]{Pack expansion}\label{pack-expansion}

Now that we have a solid command of using parameter packs in type and
function declarations, it is time to explore how to use parameter packs
in function implementations.

As briefly mentioned in \intrarefsimple{variadic-class-templates},
parameter packs belong to a \emph{kind} distinct from any other C++
entity; they are not types, values, template names, and so on. As far as
learning parameter packs goes, they cannot be related to existing
entities, so they may as well come from another language with its own
syntax and semantics.

Literally the only way to use a parameter pack is to make it part of a
so-called \emcppsgloss{pack expansion}. A \emcppsgloss{pack expansion} consists of
a fragment of code (a ``pattern'') followed by \lstinline!...!. The code
fragment must contain at least a pack name; otherwise, it does not
qualify as an expansion. Exactly what patterns are allowed depends on
the place where the expansion occurs. Depending on context, the pattern
is syntactically a simple identifier, a parameter declaration, an
expression, or a type.

The dual use of \lstinline!...! --- to both introduce a pack and expand it
--- may seem confusing at first, but distinguishing between the two uses
of \lstinline!...! is easy: When the ellipsis occurs \emph{before} a
previously undefined identifier, it is meant to introduce it as the name
of a parameter pack; in all other cases, the ellipsis is an expansion
operator.

We've already seen \emcppsgloss{pack expansion} at work in \intrarefsimple{variadic-function-templates}. In a variadic function template
declaration, the function argument list (e.g.,
\lstinline!Ts...!~\lstinline!values!) is an expansion resulting in zero or
more by-value parameters.

To introduce a simple example of \emcppsgloss{pack expansion} in an actual
computation, recall the \lstinline!add! example in
\intrarefsimple{description-variadic}, in which a variadic function adds
together an arbitrary number of integers. The full implementation shown
below uses \lstinline!double! instead of \lstinline!int! for better usability.
The important part is the expansion that keeps the computation going:

\begin{emcppslisting}[emcppsbatch=e25]
double add()                                 // base case, no arguments
{
    return 0;                                // neutral element for addition
}

template <typename T, typename... Ts>        // recursive case
double add(const T& lhs, const Ts&... rest)  // accepts 1 or more arguments
{
    return lhs + add(rest...);               // recurse expanding (ù{\codeincomments{rest}}ù)
}
\end{emcppslisting}
    

\noindent The key to understanding how \lstinline!add! works is to model the
expansion \lstinline!rest...! as a comma-separated list of
\lstinline!double!s, always invoking \lstinline!add! with fewer arguments than
it currently received; when \lstinline!rest! becomes the empty pack, the
expansion expands to nothing and \lstinline!add()! is called, which
terminates the recursion by providing the neutral value 0.

Consider the call:

\begin{emcppslisting}[emcppsbatch=e25]
int x1 = add(1.5, 2.5, 3.5);
\end{emcppslisting}
    

\noindent Computation proceeds in a typical recursive manner.
\begin{enumerate}
\item{The top-level call goes to the variadic function template \lstinline!add!.}
\item{\lstinline!add! binds \lstinline!T! to \lstinline!double! and \lstinline!Ts! to \lstinline!<double,!~\lstinline!double>!.}
\item{The expression \lstinline!add(rest...)! expands into the recursive call \lstinline!add(2.5,!~\lstinline!3.5)!.}
\item{That call binds \lstinline!T! to \lstinline!double! and \lstinline!Ts! to \lstinline!<double>!.}
\item{The second expansion of \lstinline!add(rest...)! leads to the recursive call \lstinline!add(3.5)!.}
\item{Finally, the last expansion will recurse to \lstinline!add()!, which returns 0.}
\end{enumerate}
The result is constructed as the recursion
unwinds.{\cprotect\footnote{C++17 adds fold expressions ---
\lstinline!return!~\lstinline!lhs!~\lstinline!+!~\lstinline!...!~\lstinline!+!~\lstinline!rest;!
  --- that allow a more succinct implementation of \lstinline!add!.}}

From an efficiency perspective, it should be noted that \lstinline!add! is
not recursive in a traditional Computer Science sense. It does not call
itself. Each seemingly recursive call is a call to an entirely new
function with a different arity generated from the same template. After
inlining and other common optimizations, the code is as efficient as
writing the statements by hand.

A few rules apply to all parameter-pack expansions irrespective of their
kind or the context in which they are used.

First, any pattern must contain at least one parameter pack. Therefore,
expansions such as \lstinline!C<int...>! or \lstinline!f(5...)! are invalid.
This requirement can be problematic in function declarations because a
typo in a name may switch the meaning of \lstinline!...! from
\emcppsgloss{parameter pack expansion} to an old-style C variadic function
declaration; see \intraref{potential-pitfalls-variadic}{accidental-use-of-c-style-ellipsis}.

A single \emcppsgloss{pack expansion} may contain two or more parameter
packs. In that case, expansion of multiple parameter packs within the
same expansion is always carried \emph{in lockstep}, i.e., all packs are
expanded concomitantly. For example, consider a function modeled after a
slightly modified \lstinline!add!, and note how, instead of expanding just
\lstinline!rest!, we expand a slightly more complex pattern in which
\lstinline!rest! appears twice:

\begin{emcppslisting}[emcppsbatch=e25]
template <typename... Ts>
double add2(const Ts&... xs)   // accepts 0 or more arguments
{
    return add((xs * xs)...);  // expand (ù{\codeincomments{xs * xs}}ù) in call to (ù{\codeincomments{add}}ù)
}
\end{emcppslisting}
    

\noindent This time \lstinline!add2! calls \lstinline!add! with the expansion
\lstinline!(xs!~\lstinline!*!~\lstinline!xs)...!, not just \lstinline!xs...!, so
we're looking at two parameter packs (the two instances of \lstinline!xs!)
expanded in lockstep. The call\linebreak%%%%%%%
\mbox{\lstinline!add2(1.5,!~\lstinline!2.5,!~\lstinline!3.5)!} will forward to
\lstinline!add(1.5!~\lstinline!*!~\lstinline!1.5,!~\lstinline!2.5!~\lstinline!*!~\lstinline!2.5,!~\lstinline!3.5!~\lstinline!*!~\lstinline!3.5)!,
revealing that \lstinline!add2! computes the sum of squares of its
arguments.

The parentheses around the pattern in the expansion
\lstinline!(xs!~\lstinline!*!~\lstinline!xs)...! are not needed; the expansion
comprehends the full expression to the left of \lstinline!...!, so the call
could have been written as \lstinline!add(xs!~\lstinline!*!~\lstinline!xs...)!.

For expansion to work, all parameter packs in one expansion must be of
the same length; otherwise, an error will be diagnosed at compile time.
Suppose we define a function \lstinline!f1! that takes two parameter packs
and passes an expansion involving both to \lstinline!add2!:

\begin{emcppslisting}[emcppsbatch=e25]
template <typename... Ts, typename... Us>
double f1(const Ts&... ts, const Us&... us)
{
    return add2((ts - us)...);
}
\end{emcppslisting}
    

\noindent Here, the only valid invocations are those with equal number of
arguments for \lstinline!ts! and \lstinline!us!:

\begin{emcppslisting}[emcppsbatch=e25]
double x1a = f1<double, double>(1, 2, 3, 4);
    // OK, (ù{\codeincomments{Ts=<double, double>}}ù) (explicit), (ù{\codeincomments{Us=<int, int>}}ù) (deduced)

double x1b = f1<double, double>(1, 2, 3, 4, 5);
    // Error, parameter packs (ù{\codeincomments{ts}}ù) and (ù{\codeincomments{us}}ù) have different lengths.
    // (ù{\codeincomments{Ts=<double, double>}}ù) (explicit), (ù{\codeincomments{Us=<int, int, int>}}ù) (deduced)
\end{emcppslisting}
    

\noindent Every form of \emcppsgloss{pack expansion} produces a comma-separated list
consisting of copies of the pattern with the parameter packs suitably
expanded. Expansion is semantic, not textual --- that is, the compiler
is ``smarter'' than a typical text-oriented preprocessor. If the
\emcppsgloss{pack expansion} is within a larger comma-separated list and the
parameter packs being expanded have zero elements, the commas
surrounding the expansion are adjusted appropriately to avoid syntax
errors. For example, if \lstinline!ts! is empty, the expansion
\lstinline!add(1,!~\lstinline!ts...,!~\lstinline!2)! becomes
\lstinline!add(1,!~\lstinline!2)!, not \lstinline!add(1,!~\lstinline!,!~\lstinline!2)!.

Expansion constructs may be nested. Each nesting level must operate on
at least one parameter pack:

\begin{emcppslisting}[emcppsbatch=e25]
template <typename... Ts>
double f2(const Ts&... ts)
{
    return add2((add2(ts...) + ts)...);
}
\end{emcppslisting}
    

\noindent Expansion always proceeds ``inside out,'' with the innermost expansion
carried first. In the call \lstinline!f2(2,!~\lstinline!3)!, the expression
returned after the first, innermost \lstinline!ts! is expanded is
\lstinline!add2((add2(2,!~\lstinline!3)!~\lstinline!+!~\lstinline!ts)...)!. The
second expansion results in the considerably heftier expression
\lstinline!add2(add2(2,!~\lstinline!3)!~\lstinline!+!~\lstinline!2,!~\lstinline!add2(2,!~\lstinline!3)!~\lstinline!+!~\lstinline!3)!.
Nested expansions grow in a combinatorial manner, so care is to be
exercised.

What forms of \lstinline!pattern...! are allowed, and where in the source
code is the construct allowed? \emcppsgloss[parameter pack expansion]{Parameter pack expansions} are
defined for a variety of well-defined contexts, each of which is
separately described in the following subsections. Not all potentially
useful contexts are supported, however; see \intraref{Annoyances-variadic}{limitations-on-expansion-contexts}\textbf{[ AUs: There is no section called ``Expansion at the statement level is not permitted." Response: limitations on expansions contexts is the appropriate reference]}
Expansion is allowed in:
\begin{itemize}
\item{a function parameter pack}
\item{a function call argument list or a braced initializer list}
\item{a template argument list}
\item{a base specifier list}
\item{a member initializer list}
\item{a lambda capture list}
\item{an alignment specifier}
\item{an attribute list}
\item{a \lstinline!sizeof...! expression}
\item{a template parameter pack that is a \emcppsgloss{pack expansion}}
\end{itemize}

\subsubsection[Expansion in a function parameter pack]{Expansion in a function parameter pack}\label{expansion-in-a-function-parameter-pack}

An ellipsis in a function declaration's parameter list expands to a list
of parameter declarations. The pattern being expanded is a parameter
declaration.

We discussed this expansion at length in the preceding subsections, so
let's quickly recap by means of a few examples:

\begin{emcppshiddenlisting}[emcppsbatch=e26]
template <typename... T> class C {};
\end{emcppshiddenlisting}
\begin{emcppslisting}[emcppsbatch=e26]
template<typename... Ts>
void f1(Ts...);                // expands to (ù{\codeincomments{T0}}ù), (ù{\codeincomments{T1}}ù), (ù{\codeincomments{T2}}ù),...

template<typename... Ts>
void f2(const Ts&...);         // (ù{\codeincomments{const T0\&}}ù), (ù{\codeincomments{const T1\&}}ù),...

template<typename... Ts>
void f3(const C<Ts>&...);      // Complex use, e.g., in templates, is allowed.

template<typename... Ts, typename... Us>
void f4(const C<Ts, Us>&...);  // (ù{\codeincomments{const C<T0, U0>\&}}ù), (ù{\codeincomments{const C<T1, U1>\&}}ù),...
\end{emcppslisting}
    

\subsubsection[Expansion in a function call argument list or a braced initializer list]{Expansion in a function call argument list or a braced initializer list}\label{expansion-in-a-function-call-argument-list-or-a-braced-initializer-list}

Expansion may occur in the argument list of a function call or in an
initializer list --- either parenthesized or \emph{brace-enclosed} (see
\featureref{\locationc}{bracedinit}). In these cases, the pattern is the
\emph{largest expression or braced initialization list} to the left of
the ellipsis.

This expansion is the only one that expands into expressions (all others
are declarative), so in a way it is the most important because it
relates directly to runtime work getting done.

Let's look at a few examples of expansion. Suppose we have a library
that comprises three variadic function templates, \lstinline!f!,
\lstinline!g!, and \lstinline!h!, and an ordinary class, \lstinline!C!, having a
variadic \emph{value} constructor:

\begin{emcppslisting}[emcppsbatch=e27]
template <typename... Ts> int f(Ts...);  // variadic function template
template <typename... Ts> int g(Ts...);  //    "        "        "
template <typename... Ts> int h(Ts...);  //    "        "        "

struct C                                 // ordinary class
{
    template <typename... Ts> C(Ts...);  // variadic (ù{\emphincomments{value}}ù) constructor
};
\end{emcppslisting}
    

\noindent Let's now suppose that we another variadic function template,
\lstinline!client1!, that intends to make use of this library by expanding
its own parameter pack, \lstinline!xs!, in various contexts:

\begin{emcppslisting}[emcppsbatch=e27]
template <typename... Ts>
void client1(Ts... xs)
{
    f(xs...);                   // (1) (ù{\codeincomments{f(x0, x1, ...);}}ù)
    f(C(xs...));                // (2) (ù{\codeincomments{f(C(x0, x1, ...));}}ù)
    f(C(xs)...);                // (3) (ù{\codeincomments{f(C(x0), C(x1), ...);}}ù)
    f(3.14, xs + 1 ...);        // (4) (ù{\codeincomments{f(3.14, x0 + 1, x1 + 1, ...);}}ù)
    f(3.14, xs * 2. ...);       // (5) (ù{\codeincomments{f(3.14, x0 * 2., x1 * 2., ...);}}ù)
}
\end{emcppslisting}
    

\noindent In comments, we informally denote with \lstinline!x0!, \lstinline!x1!,
\lstinline!...!, the elements of the pack \lstinline!xs!. The first call,
\lstinline!f(xs...)!, illustrates the simplest expansion; the pattern being
expanded, \lstinline!xs!, is simply the name of a \emcppsgloss{function
parameter pack}. The expansion results in a comma-separated list of the
arguments received by \lstinline!client1!.

The other examples illustrate a few subtleties. Examples (2) and (3)
show how the positioning of \lstinline!...! determines how expansion
unfolds. In (2), the expansion is carried inside the call to
\lstinline!C!'s constructor, so \lstinline!f! is called with exactly one
object of type \lstinline!C!. In (3), the ellipsis occurs outside the
constructor call, so \lstinline!f! gets called with zero or more \lstinline!C!
objects, each constructed with exactly one argument.

Examples (4) and (5) show how whitespace may be important. If the space
before \lstinline!...! were missing, the C++ parser would encounter
\lstinline!1...! and \lstinline!2....!, both of which are incorrect
floating-point literals.

Let's now look at a few more complex examples in another function,
\lstinline!client2!:

\begin{emcppslisting}[emcppsbatch=e27]
template <typename... Ts>
void client2(Ts... xs)
{
    f("hi", xs + xs..., 3.14);  // (6) (ù{\codeincomments{f(x0 + x0, x1 + x1, ..., 3.14);}}ù)
    f(const_cast<Ts&>(xs)...);  // (7) (ù{\codeincomments{f(const\_cast<T1\&>(x0), ...);}}ù)
    f(g(xs)..., h(xs...));      // (8) (ù{\codeincomments{f(g(x0), g(x1), ..., h(x0, x1, ...))}}ù)
    C object1(*xs...);          // (9) (ù{\codeincomments{C::C(*x0, *x1, ...)}}ù)
    C object2{*xs...};          // (10) (ù{\codeincomments{C::C(*x0, *x1, ...)}}ù)
    int a[] = { xs..., 0 };     // (11) (ù{\codeincomments{int[] a = \{ x0, x1, ..., 0 \}}}ù)
}
\end{emcppslisting}
    

\noindent Examples (6) and (7) feature simultaneous expansion of two packs. In
(6), \lstinline!xs! is expanded twice. In (7), template parameter pack
\lstinline!Ts! and value parameter pack \lstinline!xs! are both expanded. In
all cases of simultaneous expansion, the two or more packs are expanded
in lockstep, i.e., the first element in \lstinline!Ts! together with the
first element in \lstinline!vs! form the first element in the expansion,
and so on. Attempting to expand packs of unequal lengths results in a
compile-time error. Example (6) also shows how an expansion may be
somewhere in the middle of a function's argument list.

Example (8) shows two sequential expansions that look similar but are
quite different. The two expansions are independent and can be analyzed
separately. In \lstinline!g(xs)...!, the pattern being expanded is
\lstinline!g(xs)! and results in the list \lstinline!g(x0)!, \lstinline!g(x1)!,
\lstinline!...!. In contrast, in the expansion \lstinline!h(xs...)!, the
expansion is carried inside the call to \lstinline!h! ---
\lstinline!h(x0,!~\lstinline!x1,!~\lstinline!...)!.

Example (9) shows that expansion is allowed inside special functions as
well. The expansion \lstinline!C(*xs...)! results in \lstinline!C!'s
constructor called with \lstinline!*x0!, \lstinline!*x1!, and so on.

Last but not least, examples (10) and (11) illustrates expansion inside
a braced-initialization list. Example (10) calls the same constructor as
(9), and example (11) initializes an array of \lstinline!int! with the
content of \lstinline!xs! followed by a \lstinline!0!.

For each of these examples to compile, the code resulting from
\emcppsgloss[pack expansion]{pack expansions} needs to pass the usual semantic checks; for
example, the \lstinline!int! array initialization in (11) would fail to
compile if \lstinline!xs! contained a value with a type not convertible to
\lstinline!int!. As is always the case with templates, some instantiations
work, whereas some don't.

In the examples above, the functions involved are all variadic. However,
a function doesn't need to be variadic --- or template for that matter
--- to be called with an expansion. The expansion is carried in the
function call expression, and then the usual lookup rules apply to
decide whether the call is valid:

\begin{emcppslisting}
int f1(int a, double b);  // simple function with two parameters

int f2();                 // no parameters
int f2(int a, double b);  // overload with two parameters

template <typename... Ts>
void client3(const Ts&... xs)
{
    f1(xs...);  // Works if and only if (ù{\codeincomments{xs}}ù) has exactly two elements
                // convertible to (ù{\codeincomments{int}}ù) and (ù{\codeincomments{double}}ù), respectively.

    f2(xs...);  // Works if and only if (ù{\codeincomments{xs}}ù) is empty or has exactly two elements
                // convertible to (ù{\codeincomments{int}}ù) and (ù{\codeincomments{double}}ù), respectively.
}
\end{emcppslisting}
    

\subsubsection[Expansion in a template argument list]{Expansion in a template argument list}\label{expansion-in-a-template-argument-list}

We have already encountered \emcppsgloss{pack expansion} in the argument list
of a template instantiation; if \lstinline!C! is a class template and
\lstinline!Ts! is a template parameter pack, \lstinline!C<Ts...>! instantiates
\lstinline!C! with the contents of \lstinline!Ts!. There is no need for the
template \lstinline!C! to accept a variadic list of parameters. The
resulting expansion must be appropriate for the template instantiated.

For example, suppose we define a variadic class \lstinline!Lexicon! that
uses its parameter pack in an instantiation of \lstinline!std::map!:

\begin{emcppslisting}
#include <map>     // (ù{\codeincomments{std::map}}ù)
#include <string>  // (ù{\codeincomments{std::string}}ù)

template <typename... Ts>               // template parameter pack
class Lexicon                           // variadic class template
{
    std::map<Ts...> d_data;             // Use (ù{\codeincomments{Ts}}ù) to instantiate (ù{\codeincomments{std::map}}ù).
    // ...
};

Lexicon<std::string, int> c1;           // (1) OK, (ù{\codeincomments{std::map<std::string, int>}}ù)
Lexicon<int> c2;                        // (2) Error, (ù{\codeincomments{std::map<int>}}ù) invalid
Lexicon<int, long, std::less<int>> c3;  // (3) OK
Lexicon<long, int, 42> c4;              // (4) Error, (ù{\codeincomments{42}}ù) instead of functor
\end{emcppslisting}
    

\noindent Given that \lstinline!Lexicon! forwards all of its template arguments to
\lstinline!std::map!, the only viable template arguments for
\lstinline!Lexicon! are those that would be viable for \lstinline!std::map! as
well. Therefore, (1) is valid because it instantiates
\lstinline!std::map<std::string,!~\lstinline!int>!. As usual,
\lstinline!std::map!'s default arguments for its third and fourth
parameters kick in; the \emcppsgloss{pack expansion} does not affect default
template arguments. To wit, (3) passes three template arguments to
\lstinline!std::map! and leaves the last one (the allocator) to be filled
with the default. Instantiations (2) and (4) of \lstinline!Lexicon! are not
valid because they would attempt to instantiate \lstinline!std::map! with
incompatible template arguments.

\subsubsection[Expansion in a base specifier list]{Expansion in a base specifier list}\label{expansion-in-a-base-specifier-list}

Suppose we set out to define a variadic template, \lstinline!MB1!, that
inherits all of its template arguments. This scheme is useful in
applying design patterns such as Visitor{\cprotect\footnote{\cite{alexandrescu01},
  Chapter~10, ``Visitor," pp.!235--262}} or
Observer{\cprotect\footnote{\cite{gamma95}, Chapter~5, section
  ``Observer," pp.~293--303}}. To enable such designs, expansion is
allowed in a base specifier list. The pattern under expansion is a base
specifier, which includes an optional protection specifier
(\lstinline!public!, \lstinline!protected!, or \lstinline!private!) and an
optional \lstinline!virtual! base specifier. Let us define \lstinline!MB1! to
inherit all of its template arguments using \lstinline!public! inheritance:

\begin{emcppslisting}[emcppsbatch=e28]
template <typename... Ts>  // template parameter pack
class MB1 : public Ts...   // multibase class, publicly inherit each of (ù{\codeincomments{Ts}}ù)
{
    // ...
};
\end{emcppslisting}
    

\noindent The pattern \lstinline!public!~\lstinline!Ts...! expands into
\lstinline!public!~\lstinline!T0!, \lstinline!public!~\lstinline!T1!, and so on for
each type in \lstinline!Ts!. All bases resulting from the expansion have
the same protection level. If \lstinline!Ts! is empty, \lstinline!MB1<>! has
no base class.

\begin{emcppslisting}[emcppsbatch=e28]
class S1 { /*...*/ };  // arbitrary class
class S2 { /*...*/ };  // arbitrary class

MB1<>           m1a;     // OK, no base class at all
MB1<S1>         m1b;     // OK, instantiate with (ù{\codeincomments{S1}}ù) as only base
MB1<S1, S2>     m1c;     // OK, instantiate with (ù{\codeincomments{S1}}ù) and (ù{\codeincomments{S2}}ù) as bases.
MB1<S1, S2, S1> m1d;     // Error, cannot inherit (ù{\codeincomments{S1}}ù) twice
MB1<S1, int>    m1e;     // Error, cannot inherit from scalar type (ù{\codeincomments{int}}ù)
\end{emcppslisting}
    

\noindent After expansion, the usual rules and restrictions apply; a class cannot
inherit another one twice and cannot inherit types such as \lstinline!int!.

Other bases may be specified before and/or after the pack. The other
bases may specify other protection levels (and if they don't, the
default protection level applies):

\begin{emcppslisting}[emcppsbatch=e28]
template <typename... Ts>      // parameter pack (ù{\codeincomments{Ts}}ù)
class MB2
    : virtual private S1       // (ù{\codeincomments{S1}}ù) virtual private base
    , public Ts...             // inherit each of (ù{\codeincomments{Ts}}ù) publicly
{ /*...*/ };

template <typename... Ts>      // parameter pack (ù{\codeincomments{Ts}}ù)
class MB3
    : public S1                // (ù{\codeincomments{S1}}ù) public base
    , virtual protected Ts...  // each type in (ù{\codeincomments{Ts}}ù) a virtual protected base
    , S2                       // (ù{\codeincomments{S2}}ù) private base (uses default protection)
{ /*...*/ };

MB2<>   m2a;                   // (1) virtual private base (ù{\codeincomments{S1}}ù)
MB2<S2> m2b;                   // (2) virtual private base (ù{\codeincomments{S1}}ù), public base (ù{\codeincomments{S2}}ù)
MB3<>   m3a;                   // public base (ù{\codeincomments{S1}}ù), private base (ù{\codeincomments{S2}}ù)
MB3<S2> m3b;                   // Error, cannot inherit (ù{\codeincomments{S2}}ù) twice
\end{emcppslisting}
    

\noindent Expansions are not limited to simple pack names. The general pattern
allowed in a base specifier list is that of a full-fledged base
specifier. For example, the parameter pack can be used to instantiate
another template:

\begin{emcppslisting}[emcppsbatch=e28]
template <typename T>
class Act                       // arbitrary class template
{ /*...*/ };

template <typename... Ts>       // template parameter pack (ù{\codeincomments{Ts}}ù)
class MB4
    : public Act<Ts>...         // bases (ù{\codeincomments{Act<T0>}}ù), (ù{\codeincomments{Act<T1>}}ù), ...
{ /*...*/ };

MB4<>                     m4a;  // no base class
MB4<int, double>          m4b;  // bases (ù{\codeincomments{Act<int>}}ù), (ù{\codeincomments{Act<double>}}ù)
MB4<MB4<int>, int>        m4c;  // bases (ù{\codeincomments{Act<MB4<int>>}}ù), (ù{\codeincomments{Act<int>}}ù)
\end{emcppslisting}
    

\noindent Arbitrarily complex instantiations can be specified in an base specifier
\emcppsgloss{pack expansion}, which opens to opportunity for a variety of
expansion patterns. Depending on where the ellipsis is placed, different
expansion patterns can be created.

\begin{emcppslisting}[emcppsbatch=e28]
template <typename... T>
class Avct                 // arbitrary variadic class template
{ /*...*/ };

template <typename... Ts>  // template parameter pack (ù{\codeincomments{Ts}}ù)
class MB5                  // multibase class example
: public Avct<Ts>...       // zero or more: (ù{\codeincomments{Avct<T0>}}ù), (ù{\codeincomments{Avct<T1>}}ù), ...
, private Avct<Ts...>      // exactly one: (ù{\codeincomments{Avct<T0, T1,}}ù) ...(ù{\codeincomments{>}}ù)
{ /*...*/ };
\end{emcppslisting}
    

\noindent Although the two expansions featured above are similar in syntax, they
are semantically very different. First,
\lstinline!public!~\lstinline!Avct<Ts>...! expands into multiple bases for
\lstinline!MB5!: \lstinline!public!~\lstinline!Avct<T0>!,
\lstinline!public!~\lstinline!Avct<T1>!, and so on. The second expansion is
completely different; in fact, it's not even an expansion in a base
specifier list. Its context is a template's argument list; see
\intrarefsimple{expansion-in-a-template-argument-list}. The result of
that expansion is a single class
\lstinline!Avct<T0,!~\lstinline!T1,!~\lstinline!...>! that is an additional
private base of \lstinline!MB5!:

\begin{emcppslisting}[emcppsbatch=e28]
MB5<int, double> mb5a;
    // inherits publicly (ù{\codeincomments{Avct<int>}}ù), (ù{\codeincomments{Avct<double>}}ù)
    // inherits privately (ù{\codeincomments{Avct<int, double>}}ù)

MB5<Avct<int, char>, double> mb5b;
    // inherits publicly (ù{\codeincomments{Avct<Avct<int, char>>}}ù), (ù{\codeincomments{Avct<double>}}ù),
    // inherits privately (ù{\codeincomments{Avct<Avct<int, char>, double>}}ù)

MB5<int> mb5c;
    // Error, cannot inherit (ù{\codeincomments{Avct<int>}}ù) twice
\end{emcppslisting}

\subsubsection[Expansion in a member initializer list]{Expansion in a member initializer list}\label{expansion-in-a-member-initializer-list}

This feature is a ``forced move'' of sorts. Allowing variadic bases on a
class naturally creates the necessity of being able to initialize those
bases accordingly. Consequently, \emcppsgloss{parameter pack expansion} is
allowed in a base initializer list. The pattern is a base initializer,
i.e., the name of a base followed by a parenthesized list of arguments
for its constructor:

\begin{emcppslisting}[emcppsbatch=e29]
template <typename... Ts>  // template parameter pack
struct S1 : Ts...           // publicly inherit every type in the pack
{
    S1() : Ts(0)...         // (1) call constructor with 0 for each base
    { /*...*/ }

    S1(int x) : Ts(x)...    // (2) call constructor with (ù{\codeincomments{x}}ù) for each base
    { /*...*/ }

    S1(const S1& rhs) : Ts(static_cast<const Ts&>(rhs))...
        // OK, call the copy constructor for each base
    { /*...*/ }
};
\end{emcppslisting}
    

\noindent The default constructor (1) calls all bases' constructors, passing
\lstinline!0! to each. The second constructor (2) passes its one
\lstinline!int! argument to each base. The last constructor (3) of
\lstinline!S! implements the copy constructor and is rather interesting
because it expands in turn to a call to the copy constructor for each
member, passing it the result of a \lstinline!static_cast! (which, in
fact, is implicit) to the appropriate base type. Similar syntax can be
used for defining the move constructor (see \featureref{\locationc}{Rvalue-References}) and
other constructors.

Let's embark on a more complex example. Suppose we want to define a
class \lstinline!S2! with a constructor that accepts any arguments and
forwards them to all of its base classes. To do so, that constructor
itself needs to be variadic with a distinct parameter pack:

\begin{emcppslisting}[emcppsbatch=e29]
template <typename... Ts>      // template parameter pack
struct S2 : Ts...              // publicly inherit every type in the pack
{
    template <typename... Us>  // variadic constructor
    S2(const Us&... xs)        // accepts any number of arguments by (ù{\codeincomments{const \&}}ù)
    : Ts(xs...)...             // (!) forwards them to each base constructor
    { }
};
\end{emcppslisting}
    

\noindent The code above has at least one ellipse on every significant line, and
all are needed. Let's take a closer look.

First off, class \lstinline!S2! inherits all of its template arguments. It
has no exact knowledge about the types it would be instantiated with
and, out of consideration for flexibility, defines a variadic
constructor that forwards any number of arguments from the caller into
each of its base classes. That constructor, therefore, is itself
variadic with a separate template parameter pack, \lstinline!Us!, and a
corresponding argument pack, \lstinline!xs!, that accepts arguments by
reference to \lstinline!const!. The key line, commented with \lstinline|(!)|
in the code, performs two expansions, which proceed inside out. First,
\lstinline!xs...! expands into the list of arguments passed to
\lstinline!S2!'s constructor, leading to the pattern
\lstinline!Ts(x0,!~\lstinline!x1,!~\lstinline!...)!. In turn, that pattern itself
gets expanded by the outer \lstinline!...! into a base initialization list:
\lstinline!T0(x0,!~\lstinline!x1,!~\lstinline!...),!~\lstinline!T1(x0,!~\lstinline!x1,!~\lstinline!...),!~\lstinline!...!.

What if pass by reference to \lstinline!const! is too constraining, and we
would want to define a more general constructor that can forward
modifiable values as well? In that case, we need to use forwarding
references (see \featureref{\locationc}{forwardingref}) and the Standard Library
function \lstinline!std::forward!:

\begin{emcppslisting}[emcppsbatch=e29]
#include <utility>  // (ù{\codeincomments{std::forward}}ù)

template <typename... Ts>      // template parameter pack
struct S3 : Ts...              // publicly inherit every type in the pack
{
    template <typename... Us>  // variadic constructor
    S3(Us&&... xs)             // arguments by forwarding reference
    : Ts(std::forward<Us>(xs)...)...
                               // forwards them to each base constructor
    { }
};
\end{emcppslisting}
    

\noindent \lstinline!S3!'s variadic constructor makes use of \emcppsgloss[forwarding reference]{forwarding references}, which automatically adapt to the type of the arguments
passed. The library function \lstinline!std::forward! ensures that each
argument is forwarded with the appropriate type, qualifier, and
\romeovalue{lvalue}ness to the constructors of each base class. The expansion
process is similar to that in \lstinline!S2!'s constructor previously
discussed, with the additional detail that
\lstinline!std::forward<Us>(xs)...! expands in lockstep \lstinline!Us! and
\lstinline!xs!.

\subsubsection[Expansion in a lambda capture list]{Expansion in a lambda capture list}\label{expansion-in-a-lambda-capture-list}

A C++ lambda expression, introduced with C++11 (see \featureref{\locationc}{lambda}, is an unnamed function object. A lambda can store
internally some of the local variables present at the point of creation
by a mechanism known as \emcppsgloss{lambda capture}. This important
capability distinguishes lambdas from simple functions. Let's put it to
use in defining a \lstinline!tracer! lambda that is able to print a given
variable to the console:

\begin{emcppslisting}[emcppsbatch=e30,emcppsstandards={c++14}]
#include <iostream>  // (ù{\codeincomments{std::cout}}ù), (ù{\codeincomments{std::endl}}ù)

template <typename T>  // single-parameter template
auto tracer(T& x)      // returns a lambda that, when invoked, prints (ù{\codeincomments{x}}ù)
{
    auto result = [&x]() { std::cout << x << std::endl; };
        // (ù{\codeincomments{[\&x]}}ù) means the function object captures (ù{\codeincomments{x}}ù) by reference.
        // (ù{\codeincomments{tracer}}ù) must use (ù{\codeincomments{auto}}ù) to initialize the function object.
    return result;
}
\end{emcppslisting}
    

\noindent Lambdas have a type chosen by the compiler, so we need \lstinline!auto! to
pass lambda objects around; see \featureref{\locationc}{auto}.

This may seem like a lot if you're new to lambdas, in which case reading
\featureref{locationc}{lambda} along with \featureref{\locationf}{Function-Return-Type-Deduction}
before continuing may be in order. The
underlying idea is simple: A call such as \lstinline!tracer(x)! saves a
reference to \lstinline!x! in a function object, which it then returns.
Subsequent calls to that function object output the current value of
\lstinline!x!. It's important to save \lstinline!x! by reference (hence the
\lstinline!&! in the capture), lest the lambda store \lstinline!x! by value
and uninterestingly print the same thing on each call.

Let's see \lstinline!tracer! at work, tracing some variable in a function:

\begin{emcppslisting}[emcppsbatch=e30]
int process(int x)           // uses the (ù{\codeincomments{trace}}ù) facility
{
    auto trace = tracer(x);  // Initialize (ù{\codeincomments{trace}}ù) to follow (ù{\codeincomments{x}}ù).
    trace();                 // prints current value of (ù{\codeincomments{x}}ù)
    ++x;                     // change the value of (ù{\codeincomments{x}}ù)
    trace();                 // prints current (changed) value of (ù{\codeincomments{x}}ù)
    return x;                // Return (ù{\codeincomments{x}}ù) back to the caller.
}

int x0 = process(42);         // prints 42, then 43, and initializes (ù{\codeincomments{x0}}ù) to 43
\end{emcppslisting}
    

\noindent What is the connection with variadics? Variadics are all about
generalization, which applies here as well. Suppose we now set out to
trace several variables at once. Instead of a one-argument function,
\lstinline!tracer! would then need to be variadic. Also, crucially, the
lambda returned needs to store references to all arguments received in
order to print them later. That means an expansion must be allowed
inside a lambda capture list.

First, let's assume a function, \lstinline!print!, exists that prints any
number of arguments to the console (\intraref{use-cases-variadic}{generic-variadic-functions} features an implementation of \lstinline!print!):

\begin{emcppslisting}[emcppsbatch=e30]
template <typename... Ts>     // variadic function
void print(const Ts&... xs);  // prints each argument to (ù{\codeincomments{std::cout}}ù) in turn
\end{emcppslisting}
    

\noindent The definition of \lstinline!multitracer! uses \lstinline!print! in a lambda
with variadic capture:

\begin{emcppslisting}[emcppsbatch=e30]
template <typename... Ts>    // variadic template
auto multitracer(Ts&... xs)  // returns a lambda that, when invoked, prints (ù{\codeincomments{xs}}ù)
{
    auto result = [&xs...]() { print(xs...); };
        // (ù{\codeincomments{[\&xs...]}}ù) means capture all of (ù{\codeincomments{xs}}ù) by reference.
        // (ù{\codeincomments{result}}ù) stores one reference for each argument.
    return result;
}
\end{emcppslisting}
    

\noindent The entire API is enabled by the ability to expand \lstinline!xs! inside
the capture list. Expanding with \lstinline![&xs...]! captures by
reference, whereas \lstinline![xs...]! captures the pack by value. Inside
the lambda, \lstinline!print! expands the pack as usual with \lstinline!x...!.

Expansions in captures can be combined with all other captures:

\begin{emcppslisting}[emcppsbatch=e30]
template <typename... Ts>    // variadic template
auto test(Ts&... xs)         // for illustration purposes
{
    int a = 0, b = 0;
    auto f1 = [&a, xs...]() { /*...*/ };
        // Capture (ù{\codeincomments{a}}ù) by reference and all of (ù{\codeincomments{xs}}ù) by value.

    auto f2 = [xs..., &a]() { /*...*/ };
        // same capture as (ù{\codeincomments{f1}}ù)

    auto f3 = [a, &xs..., &b]() { /*...*/ };
        // Capture (ù{\codeincomments{a}}ù) by value, all of (ù{\codeincomments{xs}}ù) by reference, and (ù{\codeincomments{b}}ù) by reference.

    auto f4 = [&, xs...]() { /*...*/ };
        // Capture all of (ù{\codeincomments{xs}}ù) by value and everything else by reference.

    auto f5 = [=, &xs..., &a]() { /*...*/ };
        // Capture (ù{\codeincomments{a}}ù) and all of (ù{\codeincomments{xs}}ù) by reference, and everything else by value.
}
\end{emcppslisting}
    

\noindent The pattern must be that of a simple capture; complex capture patterns
are not allowed as of C++14.{\cprotect\footnote{C++20 introduces
\emcppsgloss{pack expansion} in lambda initialization captures (see \cite{revzin18}) that allows capturing variadics with a syntax such as
\lstinline![...us!~\lstinline!=!~\lstinline!vs]! or
  \lstinline![...us!~\lstinline!=!~\lstinline!std::move(vs)]!.}}

\subsubsection[Expansion in an alignment specifier]{Expansion in an alignment specifier}\label{expansion-in-an-alignment-specifier}

The \lstinline!alignas! specifier is a feature new to C++11 that allows
specifying the alignment requirement of a type or object; see
\featureref{\locationc}{alignas}:

\begin{emcppslisting}
alignas(8)      float x2;  // Align (ù{\codeincomments{x1}}ù) at an address multiple of 8.
alignas(double) float x1;  // Align (ù{\codeincomments{x2}}ù) with the same alignment as a (ù{\codeincomments{double}}ù).
\end{emcppslisting}
    

\noindent \emcppsgloss[pack expansion]{Pack expansion} inside the \lstinline!alignas! specifier is
allowed. The meaning in the presence of the pack is to specify the
largest alignment of all types in the pack:

\begin{emcppslisting}[emcppsbatch=e31]
template <typename... Ts>    // variadic template
int test1(Ts... xs)        // for illustration purposes
{
    struct alignas(Ts...) S { };
        // Align (ù{\codeincomments{S}}ù) at the largest alignment of all types in (ù{\codeincomments{Ts}}ù).
        // If (ù{\codeincomments{Ts}}ù) is empty, the (ù{\codeincomments{alignas}}ù) directive ignored.

    alignas(Ts...) float x1;
        // Align (ù{\codeincomments{x1}}ù) at the largest alignment of all types in (ù{\codeincomments{Ts}}ù).
        // If (ù{\codeincomments{Ts}}ù) is empty, the (ù{\codeincomments{alignas}}ù) directive ignored.

    alignas(Ts...) alignas(float) float x2;
        // Align (ù{\codeincomments{x2}}ù) at the largest alignment of (ù{\codeincomments{double}}ù) and all types in (ù{\codeincomments{Ts}}ù).

    alignas(float) alignas(Ts...) float x3;
        // same alignment as (ù{\codeincomments{x2}}ù); order does not matter

    return 0;
}
\end{emcppslisting}
    

\noindent As always with \lstinline!alignas!, requesting an alignment smaller than
the minimum alignment required by the declaration is an error:

\begin{emcppslisting}[emcppsbatch=e31]
int a1 = test1();          // OK, (ù{\codeincomments{Ts}}ù) empty, all (ù{\codeincomments{alignas(Ts...)}}ù) ignored
int a2 = test1('a', 1.0);  // OK, align everything as a (ù{\codeincomments{double}}ù).
int a3 = test1('a');       // Error (most systems), can't align (ù{\codeincomments{x1}}ù) to 1 byte
\end{emcppslisting}
    

\noindent An idiom that avoids such errors is to use two \lstinline!alignas! for a
given declaration, one of which is the natural alignment of the
declaration. This is the idiom followed by the declarations of
\lstinline!x2! and \lstinline!x3! in the definition of function template
\lstinline!test1!.

Using handwritten, comma-separated lists inside an \lstinline!alignas!
specifier is, however, not allowed. Expansion \emph{outside} the
specifier is also disallowed:

\begin{emcppslisting}[emcppsbatch=e31]
template <typename... Ts>    // variadic template
void test2(Ts... xs)          // for illustration purposes
{
    alignas(Ts)... float x4;
        // Error, cannot expand outside the (ù{\codeincomments{alignas}}ù) specifier

    alignas(double, Ts...) float x5; // Error, syntax not allowed
    alignas(Ts..., double) float x6; // Error, syntax not allowed
    alignas(long, double) float x7;  // Error, syntax not allowed
}
\end{emcppslisting}
    

\noindent To conclude, \emcppsgloss{pack expansion} in an \lstinline!alignas! specifier
allows choosing without contortions the largest alignment of a parameter
pack. Combining two or more \lstinline!alignas! specifiers facilitates a
simple idiom for avoiding errors and corner cases.

\subsubsection[Expansion in an attribute list]{Expansion in an attribute list}\label{expansion-in-an-attribute-list}

Attributes, introduced with C++11, are a mechanism for adding built-in
or user-defined information about declarations; see
\featureref{\locationa}{attributes}.

Attributes are added to declaration using the syntax
\lstinline![[attribute]]!. For example,\linebreak%%%%%%
 \lstinline![[noreturn]]! is a standard
attribute indicating that a function will not return:

\begin{emcppslisting}
[[noreturn]] void abort();  // Once called, it won't return.
\end{emcppslisting}
    
\noindent Two or more attributes can be applied to a declaration either
independently or as a comma-separated list inside the square brackets:

\begin{emcppslisting}[emcppsstandards={c++14}]
[[noreturn]] [[deprecated]] void finish();  // won't return, also deprecated
[[deprecated, noreturn]]    void finish();  // same
\end{emcppslisting}
    

\noindent For completeness and future extensibility, \emcppsgloss{pack expansion} is
allowed inside an attribute specifier as in \lstinline![[attribute...]]!.
However, this feature is not currently usable with any current
attribute, standard or user-defined:

\begin{emcppslisting}[emcppsignore={gibberish}]
template <typename... Ts>
[[Ts()...]] void functionFromTheFuture();
    // NONWORKING CODE
    // Receive a number of types; instantiate them as attributes.
\end{emcppslisting}
    

\noindent The ability to expand packs inside attribute specifiers is reserved for
future use and good to keep in mind for future additions to the
language.

\subsubsection[Expansion in a \lstinline!sizeof...! expression]{Expansion in a {\SubsubsecCode sizeof...} expression}\label{expansion-in-a-sizeof...-expression}

The \lstinline!sizeof...! expression is an oddity in three ways. First, it
has nothing to do with classical \lstinline!sizeof! in the sense that
\lstinline!sizeof...! does not yield the extent occupied in memory by an
object. Second, it is the only \emcppsgloss{parameter pack expansion} that
does \emph{not} use the (by now familiar) \lstinline!pack...! syntax. And
third, although it is considered an expansion, it does not expand a pack
into its constituents.

For any parameter pack \lstinline!P!, \lstinline!sizeof...(P)! yields to a
compile-time constant of type \lstinline!size_t! equal to the number of
elements of \lstinline!P!:

\begin{emcppshiddenlisting}[emcppsbatch=e32]
#include <cstddef>  // (ù{\codeincomments{std::size\_t}}ù)
\end{emcppshiddenlisting}
\begin{emcppslisting}[emcppsbatch=e32]
template <typename... Ts>
std::size_t countArgs(Ts... xs)
{
    std::size_t x1 = sizeof...(Ts);        // (ù{\codeincomments{x1}}ù) is the number of parameters
    std::size_t x2 = sizeof...(xs);        // same value as (ù{\codeincomments{x1}}ù)
    static_assert(sizeof...(Ts) >= 0,"");  // (ù{\codeincomments{sizeof...(Ts)}}ù) is a constant.
    static_assert(sizeof...(xs) >= 0,"");  // (ù{\codeincomments{sizeof...(xs)}}ù) is a constant.
    return sizeof ... (Ts);                // whitespace around (ù{\codeincomments{...}}ù) allowed
}
\end{emcppslisting}
    

\noindent Let's see \lstinline!countArgs! in action:

\begin{emcppslisting}[emcppsbatch=e32]
std::size_t a0 = countArgs();           // initialized to 0
std::size_t a1 = countArgs(42);         // initialized to 1
std::size_t a2 = countArgs("ab", 'c');  // initialized to 2
\end{emcppslisting}
    

\noindent Whitespace is allowed around the \lstinline!...!, but parentheses are not
optional. Also, expansion is disallowed inside \lstinline!sizeof! and
\lstinline!sizeof...! alike:

\begin{emcppslisting}[emcppsbatch=e32]
template <typename... Ts>
std::size_t nogo(Ts... xs)
{
    std::size_t x1 = sizeof 42;         // OK, same as (ù{\codeincomments{sizeof(int)}}ù)
    std::size_t x2 = sizeof... Ts;      // Error, parens required around (ù{\codeincomments{Ts}}ù)
    std::size_t x3 = sizeof... xs;      // Error, parens required around (ù{\codeincomments{xs}}ù)
    std::size_t x4 = sizeof(Ts...);     // Error, cannot expand inside (ù{\codeincomments{sizeof}}ù)
    std::size_t x5 = sizeof...(Ts...);  // Error, cannot expand inside (ù{\codeincomments{sizeof...}}ù)
    std::size_t x6 = sizeof(xs...);     // Error, cannot expand inside (ù{\codeincomments{sizeof}}ù)
    std::size_t x7 = sizeof...(xs...);  // Error, cannot expand inside (ù{\codeincomments{sizeof...}}ù)
}
\end{emcppslisting}
    

\subsubsection[Expansion inside a template parameter list]{Expansion inside a template parameter list}\label{expansion-inside-a-template-parameter-list}

Not to be confused with the case discussed in \intrarefsimple{expansion-in-a-template-argument-list}, \emcppsgloss{pack expansion} may occur in a
template \emph{parameter} (not argument) list. This is different from
all other expansion cases because it involves two distinct parameter
packs: a type parameter pack and a non-type parameter pack. To set
things up, suppose we define a class template, \lstinline!C1!, that has a
type parameter pack, \lstinline!Ts!. Inside, we define a secondary class
template, \lstinline!C2!, that does \emph{not} take any type parameters.
Instead, it takes a non-type template parameter pack with types derived
from \lstinline!Ts!:

\begin{emcppslisting}[emcppsbatch=e33]
template <typename... Ts>  // type parameter pack
struct C1                  // class template
{
    template <Ts... vs>    // non-type parameters (attention: no (ù{\codeincomments{typename}}ù)!)
    struct C2 { };         // expansion in (ù{\codeincomments{C2}}ù)'s parameter list
};
\end{emcppslisting}
    

\noindent Once \lstinline!C1! is instantiated with some types, the inner class
\lstinline!C2! will accept \emph{values} of the types used in the
instantiation of \lstinline!C1!. For example, if \lstinline!C1! is
instantiated with \lstinline!int! and \lstinline!char!, its inner class
template \lstinline!C2! will accept an \lstinline!int! value and a
\lstinline!char! value:

\begin{emcppslisting}[emcppsbatch=e33]
C1<int, char>::C2<1, 'a'> x1;       // OK, (ù{\codeincomments{C2}}ù) takes an (ù{\codeincomments{int}}ù) and a (ù{\codeincomments{char}}ù).
C1<int, char>::C2<1> x2;            // Error, too few arguments for (ù{\codeincomments{C2}}ù)
C1<int, char>::C2<1, 'a', 'b'> x3;  // Error, too many arguments for (ù{\codeincomments{C2}}ù)
\end{emcppslisting}
    

\noindent Only instantiations of \lstinline!C1! that lead to valid declarations of
\lstinline!C2! are allowed. For example, user-defined types are not allowed
as non-type template parameters, and consequently \lstinline!C1! cannot be
instantiated with a user-defined type:

\begin{emcppslisting}[emcppsbatch=e33]
class AClass { };   // simple user-defined class

C1<int, AClass>::C2<1, AClass()> x1;
    // Error, a non-type template parameter cannot have type (ù{\codeincomments{AClass}}ù).
\end{emcppslisting}
    

\subsubsection[No other expansion contexts]{No other expansion contexts}\label{no-other-expansion-contexts}

Note that what's missing is as important as what's present.
\emcppsgloss[parameter pack expansion]{Parameter pack expansion} is explicitly disallowed in any other
context, even if it would make sense syntactically and semantically:

\begin{emcppslisting}
template <typename... Ts>
void bumpAll(Ts&... xs)
{
    ++xs...;  // Error, cannot expand (ù{\codeincomments{xs}}ù) in an expression-statement context
}
\end{emcppslisting}
    

\noindent \intraref{annoyances-variadic}{limitations-on-expansion-contexts}\textbf{[AUs: There is no subsection called ``Expansion at the statement level is not permitted"  Response: limitations on expansion contexts is the correct reference]} discusses this context further. Also recall
that it is illegal to use pack names anywhere without expanding them, so
they don't enjoy first-class status; see \intraref{annoyances-variadic}{parameter-packs-cannot-be-used-unexpanded}.

\subsubsection[Summary of expansion contexts and patterns]{Summary of expansion contexts and patterns}\label{summary-of-expansion-contexts-and-patterns}

To recap, expansion is allowed in only the following places:
%\begin{table}[h!]
\begin{center}
%\vspace{-3ex}
%\begin{threeparttable}
%\caption{}\label{}\vspace{1.5ex}
{\small \begin{tabular}{c|c}\thickhline
\rowcolor[gray]{.9}   {\sffamily\bfseries Context} & {\sffamily\bfseries Pattern} \\ \hline
 function parameter pack & parameter declaration \\ \hline
 function call argument list or a braced initializer list & function argument \\ \hline
 template argument list & template argument \\ \hline
 base specifier list & base specifier \\ \hline
 member initializer list & base initializer \\ \hline
 lambda capture list & capture \\ \hline
 alignment specifier & alignment specifier \\ \hline
 attribute list & attribute \\ \hline
 \lstinline!sizeof...! expression & identifier \\ \hline
 template parameter pack that is a \emcppsgloss{pack expansion} & parameter declaration \\  \thickhline
\end{tabular}
}
%\end{threeparttable}
\end{center}
%\end{table}


\subsection[Use Cases]{Use Cases}\label{use-cases-variadic}

\subsubsection[Generic variadic functions]{Generic variadic functions}\label{generic-variadic-functions}

A variety of functions of general utility are naturally variadic, either
mathematically (\lstinline!min!, \lstinline!max!, \lstinline!sum!) or as a
programmer's convenience. Suppose, for example, we want to define a
function, \lstinline!print!, that writes its arguments to
\lstinline!std::cout! in turn followed by a newline{\cprotect\footnote{C++20
introduces \lstinline!std::format!, a facility for general text
  formatting.}}:

\begin{emcppslisting}
#include <iostream>  // (ù{\codeincomments{std::cout}}ù), (ù{\codeincomments{std::endl}}ù)

std::ostream& print()                // parameterless overload
{
    return std::cout << std::endl;   // only advances to next line
}

template <typename T, typename... Ts>             // one or more types
std::ostream& print(const T& x, const Ts&... xs)  // one or more args
{
    std::cout << x;                               // output first argument
    return print(xs...);                          // recurse to print rest
}

void test()
{
    print("Pi is about ", 3.14159265);            // "Pi is about 3.14159"
}
\end{emcppslisting}
    

\noindent The implementation follows a head-and-tail recursion that is typically
used for C++ variadic function templates. The first overload of
\lstinline!print! has no parameters and simply outputs a newline to the
console. The second overload does the bulk of the work. It takes one or
more arguments, prints the first, and recursively calls \lstinline!print!
to print the rest. In the limit, \lstinline!print! is called with no
arguments, and the first definition kicks in, outputting the line
terminator and also ending the recursion.

A variadic function's smallest number of allowed arguments does not have
to be zero, and it is free to follow many other recursion patterns. For
example, suppose we want to define a variadic function \lstinline!isOneOf!
that returns \lstinline!true! if and only if its first argument is equal to
one of the subsequent arguments. Calls to such a function are sensible
for two or more arguments:

\begin{emcppslisting}[emcppsbatch=e34]
template <typename T1, typename T2>     // normal template function
bool isOneOf(const T1& a, const T2& b)  // two-parameter version
{
  return a == b;
}

template <typename T1, typename T2, typename... Ts>      // two or more
bool isOneOf(const T1& a, const T2& b, const Ts&... xs)  // all by (ù{\codeincomments{const\&}}ù)
{
  return a == b || isOneOf(a, xs...);                    // compare, recurse
}
\end{emcppslisting}
    

\noindent Again, the implementation uses two definitions in a pseudo-recursive
setup but in a slightly different stance. The first definition handles
two items and also stops recursion. The second version takes three or
more arguments, handles the first two, and issues the recursive call
only if the comparison yields \lstinline!false!.

Let's take a look at a few uses of \lstinline!isOneOf!:

\begin{emcppslisting}[emcppsbatch=e34]
#include <string>  // (ù{\codeincomments{std::string}}ù)

int a = 42;
bool b1 = isOneOf(a, 1, 42, 4);  // b1 is true.
bool b2 = isOneOf(a, 1, 2, 3);   // b2 is false.
bool b3 = isOneOf(a, 1, "two");  // Error, can't compare (ù{\codeincomments{int}}ù) with (ù{\codeincomments{const char*}}ù)
std::string s = "Hi";
bool b4 = isOneOf(s, "Hi", "a"); // b4 is true.
\end{emcppslisting}
    

\subsubsection[Object factories]{Object factories}\label{object-factories}

Suppose we want to define a generic \emcppsgloss{factory function} --- a
function able to create an instance of any given type by calling one of
its constructors. Object
factories{\cprotect\footnote{\cite{gamma95}, Chapter~1-5, section
``Factory Method," pp.~107--115}}{\cprotect\footnote{\cite{alexandrescu01},
  Chapter~8, ``Object Factories," pp.~197--218}} allow libraries and
applications to centrally control object creation for a variety of
reasons: using special memory allocation, tracing and logging,
benchmarking, object pooling, late binding, deserialization, interning,
and more.

The challenge in defining a generic object factory is that the type to
be created (and therefore its constructors) is not known at the time of
writing the factory. That's why C++03 object factories typically offer
only default object constructions, forcing clients to awkwardly use
two-phase initialization, first to create an empty object and then to
put it in a meaningful state.

Writing a generic function that can transparently forward calls to
another function (``perfect forwarding'') has been a long-standing
challenge in C++03. An important part of the puzzle is making the
forwarding function generic in the number of arguments, which is where
variadic templates help in conjunction with forwarding references (see
\featureref{\locationc}{forwardingref}):

\begin{emcppslisting}[emcppsbatch=e35]
#include <utility>  // (ù{\codeincomments{std::forward}}ù)

void log(const char* message);                // logging function

template <typename Product, typename... Ts>   // type to be created and params
Product factory(Ts&&... xs)                   // call by forwarding reference
{
    log("factory(): Creating a new object");  // Do some logging.
    return Product(std::forward<Ts>(xs)...);  // Forward arguments to ctor.
}
\end{emcppslisting}
    

\noindent \lstinline!Ts&&...!~\lstinline!xs! introduces \lstinline!xs!, a function
parameter pack that represents zero or more forwarding references. As we
know, the construct \lstinline!std::forward<Ts>(xs)...! is a \emcppsgloss{pack
expansion} that expands to a comma-separated list
\lstinline!std::forward<T0>(x0),!~\lstinline!std::forward<T1>(x1),! and so on.
The Standard Library function template \lstinline!std::forward! passes
accurate type information from the forwarding references \lstinline!x0!,
\lstinline!x1!, \lstinline!...! to \lstinline!Product!'s constructor.

To use the function, we must always provide the \lstinline!Product! type
explicitly; it is not a function parameter, so it cannot be deduced. The
others are at best left to template argument deduction. In the simplest
case, \lstinline!factory! is usable with primitive types:

\begin{emcppslisting}[emcppsbatch=e35]
int i1 = factory<int>();               // Initialize (ù{\codeincomments{i1}}ù) to 0.
int i2 = factory<int>(42);             // Initialize (ù{\codeincomments{i2}}ù) to 42.
\end{emcppslisting}
    

\noindent It also works correctly with overloaded constructors:

\begin{emcppslisting}[emcppsbatch=e35]
struct Widget
{
    Widget(double);        // constructor taking a (ù{\codeincomments{double}}ù)
    Widget(int&, double);  // constructor taking an (ù{\codeincomments{int\&}}ù) and a (ù{\codeincomments{double}}ù)
};

int g = 0;
Widget w1 = factory<Widget>(g, 2.4);   // calls ctor with (ù{\codeincomments{int\&}}ù) and (ù{\codeincomments{double}}ù)
Widget w2 = factory<Widget>(20);       // calls ctor with (ù{\codeincomments{double}}ù)
Widget w3 = factory<Widget>(20, 2.0);  // Error, cannot bind (ù{\codeincomments{rvalue}}ù) to (ù{\codeincomments{int\&}}ù)
\end{emcppslisting}
    

\noindent The last line introducing \lstinline!w3! fails to compile because the
\romeovalue{rvalue} \lstinline!20! cannot convert to the
non-\lstinline!const!~\lstinline!int&! required by \lstinline!Widget!'s
constructor --- an illustration of perfect forwarding doing its job.

Many variations of object factories (e.g., using dynamic allocation,
custom memory allocators, and special exceptions treatment) can be built
on the skeleton of \lstinline!factory! shown. In fact, Standard Library
factory functions, such as \lstinline!std::make_shared! and
\lstinline!std::make_unique!, use variadics and perfect forwarding in this
same manner.

\subsubsection[Hooking function calls]{Hooking function calls}\label{hooking-function-calls}

Forwarding is not limited to object construction. We can use it to
intercept function calls in a generic manner and add processing such as
tracing, logging, and so on. Suppose, for example, writing a function
that calls another function and logs any exception it may throw:

\begin{emcppslisting}[emcppsbatch=e36]
#include <exception>  // (ù{\codeincomments{std::exception}}ù)
#include <utility>    // (ù{\codeincomments{std::forward}}ù)

void log(const char* msg);                     // Log a message.

template <typename Callable, typename... Ts>
auto logExceptions(Callable&& fun, Ts&&... xs)
    -> decltype(fun(std::forward<Ts>(xs)...))
{
    try
    {
        return fun(std::forward<Ts>(xs)...);   // perfect forwarding to (ù{\codeincomments{fun}}ù)
    }
    catch (const std::exception& e)
    {
        log(e.what());                         // log exception information
        throw;                                 // Rethrow the same exception.
    }
    catch (...)
    {
        log("Nonstandard exception thrown.");  // log exception information
        throw;                                 // Rethrow the same exception.
    }
}
\end{emcppslisting}
    

\noindent Here, we enlist not only the help of \lstinline!std::forward! but also that
of the \lstinline!auto!~\lstinline!->!~\lstinline!decltype! idiom; see
\featureref{\locationa}{trailing-function-return-types} and
\featureref{\locationa}{decltype}. By using \lstinline!auto! instead of the
return type of \lstinline!logExceptions! and following with \lstinline!->! and
the trailing type \lstinline!decltype(fun(std::forward<Ts>(xs)...))!, we
state that the return type of \lstinline!logExceptions! is the same as the
type of the call \lstinline!fun(std::forward<Ts>(xs)...)!, which matches
perfectly the expression that the function will actually return.

In case the call to \lstinline!fun! throws an exception,
\lstinline!logExceptions! catches, logs, and rethrows that exception. So
\lstinline!logExceptions! is entirely transparent other than for logging
the passing exceptions. Let's see it in action. First, we define a
function, \lstinline!assumeIntegral!, that is likely to throw an exception:

\begin{emcppslisting}[emcppsbatch=e36]
#include <stdexcept>  // (ù{\codeincomments{std::runtime\_error}}ù)

long assumeIntegral(double d)            // throws if (ù{\codeincomments{d}}ù) has a fractional part
{
    long result = static_cast<long>(d);  // Compute the returned value.
    if (result != d)                     // Verify.
        throw std::runtime_error("Integral expected");
    return result;
}
\end{emcppslisting}
    

\noindent To call \lstinline!assumeIntegral! via \lstinline!logExceptions!, we just pass
it along with its argument:

\begin{emcppslisting}[emcppsbatch=e36]
void test()
{
    long a = logExceptions(assumeIntegral, 4.0);  // Initialize a to 4.
    long b = logExceptions(assumeIntegral, 4.4);  // throws and logs
}
\end{emcppslisting}
    

\subsubsection[Tuples]{Tuples}\label{tuples}

A \emph{tuple} or a record is a type that groups together a fixed number
of values of unrelated types. The C++03 Standard Library template
\lstinline!std::pair! is a tuple with two elements. The standard library
template \lstinline!std::tuple!, introduced in C++11, implements a tuple
with the help of variadic templates. For example,
\lstinline!std::tuple<int,!~\lstinline!int,!~\lstinline!float>! holds two
\lstinline!int!s and a \lstinline!float!.

There are many possible ways to implement a tuple in C++. C++03
implementations typically define a hardcoded limit on the number of
values the tuple can hold and use considerable amounts of scaffolding,
as described in \intrarefsimple{description-variadic}:

\begin{emcppslisting}
struct None { };  // empty "tag" used as a special "not used" marker

template <typename T1 = None, typename T2 = None, typename T3 = None,
          typename T4 = None, typename T5 = None, typename T6 = None,
          typename T7 = None, typename T8 = None, typename T9 = None>
class Cpp03Tuple;
    // tuple containing up to 9 data members of arbitrary types
\end{emcppslisting}
    

\noindent Variadics are a key ingredient in a scalable, manageable tuple
implementation. We discuss a few possibilities in approaching the core
definition of a tuple, with an emphasis on data layout.

The definition of \lstinline!Tuple1! (in the code snippet below) uses
specialization and recursion to accommodate any number of types:

\begin{emcppshiddenlisting}[emcppsbatch=e37,emcppsstandards={c++14}]
#include <cstddef>  // (ù{\codeincomments{std::size\_t}}ù)
#include <string>   // (ù{\codeincomments{std::string}}ù)
#include <cassert>  // standard C (ù{\codeincomments{assert}}ù) macro
#include <stdexcept>  // (ù{\codeincomments{std::runtime\_error}}ù)
\end{emcppshiddenlisting}
\begin{emcppslisting}[emcppsbatch=e37]
template <typename... Ts>
class Tuple1;                // (0) incomplete declaration

template <>
class Tuple1<>               // (1) specialization for zero elements
{ /*...*/ };

template <typename T, typename... Ts>
class Tuple1<T, Ts...>       // (2) specialization for one or more elements
{
    T first;                 // first element
    Tuple1<Ts...> rest;      // all other elements
    // ...
};
\end{emcppslisting}
    

\noindent \lstinline!Tuple1! uses composition and recursion to create its data
layout. As discussed in \intrarefsimple{expansion-in-a-base-specifier-list}, the expansion \lstinline!Tuple1<Ts...>! results in\linebreak%%%%%%
\lstinline!Tuple1<T0,!~\lstinline!T1,!~\lstinline!...,!~\lstinline!Tn>!. The
specialization \lstinline!Tuple1<>! ends the recursion.

The only awkward detail is that \lstinline!Tuple1<int>! has member
\lstinline!rest! of type \lstinline!Tuple1<>!, which is empty but is required
to have nonzero size, so it ends up occupying space in the
tuple.\footnote{On Clang 11.0 and GCC 7.5,
\lstinline!sizeof(T1)! is \lstinline!8!, twice the size of an \lstinline!int!.} This is an important issue if the
tuple is to be used at scale.

A solution to avoid this issue is to partially specialize
\lstinline!Tuple1! for one element in addition to the two existing
specializations:

\begin{emcppslisting}[emcppsbatch=e37]
template <typename T>
class Tuple1<T>               // (3) specialization for one element
{
    T first;
    // ...
};
\end{emcppslisting}
    

\noindent With this addition, \lstinline!Tuple1<>! uses the total specialization (1),
\lstinline!Tuple1<int>! uses the partial specialization (3), and all
instantiations with two or more types use the partial specialization
(2). For example, \lstinline!Tuple1<int,!~\lstinline!long,!~\lstinline!double>!
instantiates specialization (2), which uses
\lstinline!Tuple1<long,!~\lstinline!double>! as a member, which in turn uses
the partial specialization (3) for member \lstinline!rest! of type
\lstinline!Tuple1<double>!.

The disadvantage of the design above is that it requires similar code in
the \lstinline!Tuple1<T>! partial specialization and the general
definition, leading to a subtle form of code duplication. This may not
seem very problematic, but a good tuple API has a considerable amount of
scaffolding; for example, \lstinline!std::tuple! has 25 member functions.

Let's address \lstinline!Tuple1!'s problem by using inheritance instead of
composition, thus benefitting from an old and well-implemented C++
layout optimization known as the \emcppsgloss{empty base optimization}. When
a base of a class has no state, that base is allowed, under certain
circumstances, to occupy no room at all in the derived class. Let's
design a \lstinline!Tuple2! variadic class template that takes advantage of
the \emcppsgloss{empty base optimization}:

\begin{emcppslisting}[emcppsbatch=e37]
template <typename... Ts>
class Tuple2;                // incomplete declaration

template <>
class Tuple2<>               // specialization for zero elements
{ /*...*/ };

template <typename T, typename... Ts>
class Tuple2<T, Ts...>       // specialization for one or more elements
    : public Tuple2<Ts...>   // recurses in inheritance
{
    T first;
    //...
};
\end{emcppslisting}
    

\noindent If we assess the size of \lstinline!Tuple2<int>! with virtually any
contemporary compiler, it is the same as \lstinline!sizeof(int)!, so the
base does not, in fact, add to the size of the complete object. One
awkwardness with \lstinline!Tuple2! is that with most compilers the types
specified appear in the memory layout in reverse order; for example, in
an object of type\linebreak%%%%%%
\lstinline!Tuple1<int,!~\lstinline!int,!~\lstinline!float,!~\lstinline!std::string>!,
the string would be the first member in the layout, followed by the
\lstinline!float! and then by the two \lstinline!int!s. (Compilers do have
some freedom in defining layout, but most of today's compilers simply
place bases first in their order, followed by members in the order of
their declarations.)

To ensure a more intuitive layout, let's define \lstinline!Tuple3! that
uses an additional \lstinline!struct! to hold individual elements, which
\lstinline!Tuple3! inherits (by means of the seldom-used \lstinline!protected!
inheritance) before recursing:

\begin{emcppslisting}[emcppsbatch=e37]
template <typename T>
struct Element3      // element holder
{
    T value;         // no other data or member functions
};

template <typename... Ts>
class Tuple3;        // declaration to introduce the class template

template <>
class Tuple3<>       // specialization for zero elements
{ /*...*/ };

template <typename T, typename... Ts>  // one or more types
class Tuple3<T, Ts...>                 // one or more elements
    : public Element3<T>               // first in layout
    , public Tuple3<Ts...>             // recurse to complete layout
{ /*...*/ };
\end{emcppslisting}
    

\noindent This is close to what we need, but there is one additional problem to
address: The instantiation \lstinline!Tuple3<int,!~\lstinline!int>! will
attempt to inherit \lstinline!Element<int>! twice, which is not allowed.
One way to address this issue is by passing a so-called cookie to
\lstinline!Element!, an additional template parameter that uniquely tags
each \lstinline!Element! differently. We choose \lstinline!size_t! for the
cookie type:

\begin{emcppslisting}[emcppsbatch=e37]
template <typename T, std::size_t cookie>
struct Element4      // Element holder also takes a cookie so the same element
                     // is not inherited twice; cookie is actually not used.
{
    T value;
};
\end{emcppslisting}
    

\noindent The \lstinline!Tuple4! class instantiates \lstinline!Element! with a
decreasing value of \lstinline!cookie! for each successive element:

\begin{emcppslisting}[emcppsbatch=e37]
template <typename... Ts>
class Tuple4;                            // (0) incomplete declaration

template <>
class Tuple4<>                           // (1) specialization for no elements
{ /*...*/ };

template <typename T, typename... Ts>
class Tuple4<T, Ts...>                   // (2) one or more elements
    : public Element4<T, sizeof...(Ts)>  // first in layout, count is cookie
    , public Tuple4<Ts...>               // recurse to complete layout
{ /*...*/ };
\end{emcppslisting}
    

\noindent To see how it all works, consider the instantiation
\lstinline!Tuple4<int,!~\lstinline!int,!~\lstinline!char>!, which matches
specialization (2) with \lstinline!T=int! and
\lstinline!Ts=<int,!~\lstinline!char>!. Consequently \lstinline!sizeof...(Ts)!
--- the number of elements in \lstinline!Ts! --- is 2. The specialization
first inherits \lstinline!Element<2,!~\lstinline!int>! and then
\lstinline!Tuple4<int,!~\lstinline!char>!. The latter, in turn, also uses
specialization (2) with \lstinline!T=int! and \lstinline!Ts=<char>!, which
inherits \lstinline!Element<int,!~\lstinline!1>! and \lstinline!Tuple4<char>!.
Finally, \lstinline!Tuple4<char>! inherits
\lstinline!Element<char,!~\lstinline!0>! and \lstinline!Tuple4<>!, which kicks
the first specialization into gear to terminate the recursion.

It follows that \lstinline!Tuple4<int,!~\lstinline!int,!~\lstinline!char>!
ultimately inherits (in this order) \lstinline!Element<int,!~\lstinline!2>!,
\lstinline!Element<int,!~\lstinline!1>!, and
\lstinline!Element<char,!~\lstinline!0>!. Most implementations of
\lstinline!std::tuple! are variations of the patterns illustrated by
\lstinline!Tuple1! through \lstinline!Tuple4!.\footnote{\lstinline!libstdc++!, the GNU C++ Standard
Library, uses an inheritance-based scheme with increasing indexes (as
opposed to \lstinline!Tuple4! in which \lstinline!cookie! values are
decreasing). \lstinline!libc++!, the LLVM Standard Library that ships with
Clang, does not use inheritance for \lstinline!std::tuple!, but its state
implementation uses inheritance in conjunction with an increasing
integral sequence. Microsoft's open-source STL
(\cite{microsoftb}) uses, at time of this writing, the
approach taken by \lstinline!Tuple2!.}

If \lstinline!Element! didn't take a distinct number for each member of the
product type,\linebreak%%%%%
 \lstinline!Tuple4<int,!~\lstinline!int>! would not work because
it would inherit \lstinline!Element<int>! twice, which is illegal. With
\lstinline!cookie!, the instantiation works because it inherits the
distinct types\linebreak%%%%%%
 \lstinline!Element<int,!~\lstinline!1>! and
\lstinline!Element<int,!~\lstinline!2>!.

The expanded templates for the above code example might look like this
invalid but illustrative code:

\begin{emcppslisting}[emcppsbatch=e37,emcppsignore={invalid but illustrative}]
class Tuple4<>
{ /*...*/ };
class Tuple4<char> : public Element<char, 0>, public Tuple4<>
{ /*...*/ };
class Tuple4<int, char> : public Element<int, 1>, public Tuple4<char>
{ /*...*/ };
class Tuple4<int, int, char> : public Element<int, 2>, public Tuple4<int, char>
{ /*...*/ };
\end{emcppslisting}
    

\noindent The complete implementation of a tuple type would contain the usual
constructors and assignment operators as well as a \emph{projection
function} that takes an index \lstinline!i! as a compile-time parameter and
returns a reference to the \lstinline!i!th element of the tuple. Let's see
how to implement this rather subtle function. To get it done, we first
need a helper template that returns the \lstinline!n!th type in a template
parameter pack.

\begin{emcppslisting}[emcppsbatch=e37]
template <std::size_t n, typename T, typename... Ts>
struct NthType               // yields (ù{\codeincomments{n}}ù)th type in the sequence (ù{\codeincomments{<T, Ts...>}}ù)
{
    typedef typename NthType<n - 1, Ts...>::type
        type;                // recurse to smaller (ù{\codeincomments{n}}ù)
};

template <typename T, typename... Ts>
struct NthType<0, T, Ts...>  // base case, 0th type in (ù{\codeincomments{<T, Ts...>}}ù) is (ù{\codeincomments{T}}ù)
{
    typedef T type;
};
\end{emcppslisting}
    

\noindent \lstinline!NthType! follows the now familiar pattern of recursive parameter
pack handling. The first declaration introduces the recursive case. The
specialization that follows handles the limit case
\lstinline!n!~\lstinline!==!~\lstinline!0! to stop the recursion. It is easy to
follow that, for example,\linebreak%%%%%%
\lstinline!NthType<1,!~\lstinline!short,!~\lstinline!int,!~\lstinline!long>::type!
is \lstinline!int!.

We are now ready to define the function \lstinline!get! such that
\lstinline!get<0>(x)! returns a reference to the first element of a
\lstinline!Tuple4! object called \lstinline!x!.

\begin{emcppslisting}[emcppsbatch=e37]
template <std::size_t n, typename... Ts>  // (ù{\codeincomments{n}}ù) is the index. (ù{\codeincomments{Ts}}ù) is the tuple pack.
auto& get(Tuple4<Ts...>& x)          // top-level function
{
    typedef typename NthType<n, Ts...>::type
        ResultType;                  // Reference to this type is returned.
    typedef Element4<ResultType, sizeof...(Ts) - n - 1>
        ElementType;                 // element holding the value returned
    ElementType& r = x;              // implicit conversion to get element
    return r.value;                  // Access the value from the (ù{\codeincomments{Element}}ù).
}
\end{emcppslisting}
    

\noindent Calculating the cookie
\lstinline!sizeof...(Ts)!~\lstinline!-!~\lstinline!n!~\lstinline!-!~\lstinline!1!
requires some finesse. Recall that the elements in a tuple come with
cookies in the reverse order of their natural order, so the first
element in a \lstinline!Tuple4<Ts...>! has cookie
\lstinline!sizeof(Ts...)!~\lstinline!-!~\lstinline!1! and the last element has
cookie \lstinline!0!. Therefore, when we compute the cookie of the
\lstinline!n!th element in the cookie, we use elementary algebra to get to
the expression shown.

After all typing has been sorted out, the implementation itself is
trivial; it fetches the appropriate \lstinline!Element! base by means of an
implicit cast and then returns its \lstinline!value!. Let's put the code to
test:

\begin{emcppslisting}[emcppsbatch=e37]
void test()
{
    Tuple4<int, double, std::string> value;
    get<0>(value) = 3;
    get<1>(value) = 2.718;
    get<2>(value) = "hello";
    assert(get<2>(value) == "hello");
}
\end{emcppslisting}
    

\noindent The example also illustrates why \lstinline!get! is best defined as a
nonmember function: A member function would have been forced to use the
awkward syntax
\lstinline!value.template!~\lstinline!get<0>()!~\lstinline!=!~\lstinline!3! to
disambiguate the use of \lstinline!<! as a template instantiation as
opposed to the less-than operator.

\subsubsection[Variant types]{Variant types}\label{variant-types}

A \emph{variant} type, sometimes called a \emph{discriminated union}, is
similar to a C++ \lstinline!union! that keeps track of which of its
elements is currently active and protects client code against unsafe
uses. Variadic templates support a natural interface to express this
design as a generic library feature.{\cprotect\footnote{C++17's Standard
Library type \lstinline!std::variant! provides a robust and comprehensive
  implementation of a variant type.}} For example, a variant type such
as \lstinline!Variant<int,!~\lstinline!float,!~\lstinline!std::string>! would be
able to hold exactly one \lstinline!int! or one \lstinline!float! or one
\lstinline!std::string! value. Client code can change the current type by
assigning to the variant object an \lstinline!int!, a \lstinline!float!, or an
\lstinline!std::string! respectively.

To define a variant type, we need it to have enough storage to keep any
of its possible values, plus a \emph{discriminator} --- typically a
small integral that keeps the index of the currently stored type. For
\lstinline!Variant<int,!~\lstinline!float,!~\lstinline!std::string>!, the
discriminator could be by convention 0 for \lstinline!int!, 1 for
\lstinline!float!, and 2 for \lstinline!std::string!.

We saw in the previous sections how to define data structures
recursively for parameter packs, so let's try our hand at a variant
layout in the \lstinline!Variant1! design:

\begin{emcppslisting}
template <typename... Ts>                   // parameter pack
class Variant1                              // can hold any in parameter pack
{
    template <typename...>                  // union of all types in (ù{\codeincomments{Ts}}ù)
    union Store {};

    template <typename U, typename... Us>   // Specialize for >=1 types.
    union Store<U, Us...>
    {
        U head;                             // Lay out a (ù{\codeincomments{U}}ù) object.
        Store<Us...> tail;                  // all others at same address
    };

    Store<Ts...> d_data;                    // Store for current datum.
    unsigned int d_active;                  // index of active type in (ù{\codeincomments{Ts}}ù)

public:
    // ... (API goes here)
};
\end{emcppslisting}
    

\noindent C-style \lstinline!union!s can be templates, too, and variadic ones at
that. We take advantage of this feature in \lstinline!Variant1! to
recursively define \lstinline!Store<Ts...>! that stores each of the types
in the parameter pack \lstinline!Ts! at the same address. One important
C++11 feature that conveys flexibility to the design above is the
relaxation on the restrictions on types that can be stored in
\lstinline!union!s. In C++03, \lstinline!union! members were not allowed to
have non-trivial constructors or destructors. Starting with C++11, any
type can be a member in a \lstinline!union!; see \featureref{\locatione}{unrestricted-unions}. Therefore, types such as\linebreak%%%%%%%
\lstinline!Variant1<std::string,!~\lstinline!std::map<int,!~\lstinline!int>>!
work fine.

It is possible to define \lstinline!d_data! in a more succinct manner as a
fixed-size array of \lstinline!char!. There are two challenges to address.
First, the size of the array needs to be computed during compilation as
the maximum of the sizes of all types in \lstinline!Ts!. Second, the array
needs to have sufficient alignment to store any of the types in
\lstinline!Ts!. Fortunately, both problems have simple solutions in
idiomatic modern C++:

\begin{emcppslisting}[emcppsbatch=e37]
#include <algorithm>  // (ù{\codeincomments{std::max}}ù)

template <typename... Ts> class Variant2;  // introducing declaration

template <> class Variant2<>     // specialization for empty (ù{\codeincomments{Ts}}ù)
{ /*...*/ };

template <typename T, typename... Ts>
class Variant2<T,Ts...>          // specialization for one or more types
{
    enum : std::size_t { size = std::max({sizeof(T), sizeof(Ts)...}) };
        // (ù{\codeincomments{std::max}}ù) takes (ù{\codeincomments{std::initializer\_list}}ù) and is (ù{\codeincomments{constexpr}}ù) in C++14

    alignas(T) alignas(Ts...)
    char d_data[size];           // payload
    unsigned int d_active;       // index of active type in (ù{\codeincomments{Ts}}ù)

public:
    // ... (API goes here)
};
\end{emcppslisting}
    

\noindent The code above uses a new use of \lstinline!std::max! --- overload
introduced in C++14 that takes an initializer list as parameter; see
\featureref{\locationc}{initlist}.
Another novelty is the use of \lstinline!std::max! during compilation; see
\featureref{\locationc}{constexprfunc}. We apply
\lstinline!std::max! to \lstinline!sizeof(T)! and the \lstinline!sizeof(Ts)...!
expansion, which results in a comma-separated list \lstinline!sizeof(T)!,
\lstinline!sizeof(T0)!, \lstinline!sizeof(T1)!, \lstinline!...!. (Note it is not
the same expansion as \lstinline!sizeof...(Ts)!, which would just return
the number of elements in \lstinline!Ts!).

In brief, \lstinline!d_data! is an array of \lstinline!char! as large as the
maximum of the sizes of all of the types passed to \lstinline!Variant2!. In
addition, the \lstinline!alignas! directives instructs the compiler to
align \lstinline!d_data! at the largest alignment of all types among
\lstinline!T! and all of \lstinline!Ts!; see \intraref{description-variadic}{expansion-in-an-alignment-specifier} and \featureref{\locationc}{alignas}.

It is worth noting that both \lstinline!Variant1! and \lstinline!Variant2! are
equally good from a layout perspective; in fact, even the implementation
of their respective APIs are identical. The only use of \lstinline!d_data!
is to take its address and use it as a pointer to \lstinline!void!, which
the API casts appropriately.

The public interface ensures that when an element is stored in
\lstinline!d_data!, \lstinline!d_active! will have the value of the index
into the parameter pack \lstinline!Ts...! that corresponds to that type.
Hence, when a user attempts to retrieve a value from the variant, if the
wrong type is requested, a runtime error will be reported.

Let's take a look at defining some relevant API functions --- the
default constructor, a value constructor, and the destructor:

\begin{emcppshiddenlisting}[emcppsbatch={e38,e39},emcppsstandards={c++14}]
#include <cstddef>  // (ù{\codeincomments{std::size\_t}}ù)
#include <string>   // (ù{\codeincomments{std::string}}ù)
#include <cassert>  // standard C (ù{\codeincomments{assert}}ù) macro
#include <stdexcept>  // (ù{\codeincomments{std::runtime\_error}}ù)
\end{emcppshiddenlisting}
\begin{emcppslisting}[emcppsbatch={e38,e39}]
#include <algorithm>  // (ù{\codeincomments{std::max}}ù)

template <typename... Ts>              // introducing declaration
class Variant;

template <> class Variant<>            // specialization for empty (ù{\codeincomments{Ts}}ù)
{ /*...*/ };

template <typename T, typename... Ts>  // specialization for 1 or more
class Variant<T,Ts...>
{
    enum : std::size_t { size = std::max({sizeof(T), sizeof(Ts)...}) };
        // compute payload size

    alignas(T) alignas(Ts...)
    char d_data[size];                 // approach in (ù{\codeincomments{Variant1}}ù) fine too
    unsigned int d_active;             // index of active type in (ù{\codeincomments{Ts}}ù)

    template <typename U, typename... Us>
    friend U& get(Variant<Us...>& v);  // (ù{\codeincomments{friend}}ù) accessor

public:
    Variant();                         // default constructor

    template <typename U>              // value constructor
    Variant(U&&);                      // (ù{\codeincomments{U}}ù) must be among (ù{\codeincomments{T}}ù), (ù{\codeincomments{Ts}}ù).

    ~Variant();                        // destroy the current object

    // ...
};
\end{emcppslisting}
    

\noindent The default constructor should put the object in a simple, meaningful
state. A reasonable decision is to create (by default construction) the
\emph{first} object in \lstinline!Ts!:

\begin{emcppslisting}[emcppsbatch={e38,e39}]
template <typename T, typename... Ts>
Variant<T, Ts...>::Variant()
{
    ::new(&d_data) T();  // default-constructed (ù{\codeincomments{T}}ù) at address of (ù{\codeincomments{d\_data}}ù)
    d_active = 0;        // Set the active type to (ù{\codeincomments{T}}ù), first in the list.
}
\end{emcppslisting}
    

\noindent The default constructor uses \emcppsgloss{placement new} to create a
default-constructed object at the address of \lstinline!d_data!. The first
element in the parameter pack is selected by means of partial
specialization.

The value constructor is a bit more challenging because it needs to
compute the appropriate index for \lstinline!d_active! during compilation,
for example as an \lstinline!enum! value. To implement it, first we need a
support metafunction that reports the index of a type in a template
parameter pack. The first type is the sought type, followed by the types
to be searched. If the first type is not among the others, an error is
produced:

\begin{emcppslisting}[emcppsbatch={e38,e39}]
template <typename X, typename T, typename... Ts>  // Find (ù{\codeincomments{X}}ù) in (ù{\codeincomments{T}}ù), (ù{\codeincomments{Ts...}}ù).
struct IndexOf                                     // primary definition
{
    enum : std::size_t { value = IndexOf<X, Ts...>::value + 1 };
};

template <typename X, typename... Ts>              // partial specialization 1
struct IndexOf<X, X, Ts...>                        // found (ù{\codeincomments{X}}ù) at front
{
    enum : std::size_t { value = 0 };              // found in position 0
};

template <typename X, typename... Ts>              // partial specialization 2
struct IndexOf<const X, X, Ts...>                  // found const (ù{\codeincomments{X}}ù) at front
{
    enum : std::size_t { value = 0 };              // also found in position 0
};
\end{emcppslisting}
    

\noindent The \lstinline!:!~\lstinline!size_t! syntax, new to C++11, specifies that the
introduced anonymous \lstinline!enum! has type \lstinline!size_t! as a base;
see \featureref{\locationc}{explicit-enumeration-underlying-type}. The class
template \lstinline!IndexOf! follows a simple recursive pattern. In the
general case, the type \lstinline!X! is different from the first type
\lstinline!T!, and \lstinline!value! is computed recursively as a search
through the tail of the list.

If the sought type is identical to the first in the list, partial
specialization 1 kicks in; if the sought type is a \lstinline!const!
variant of the second, partial specialization 2 matches. (A complete
implementation would also add a similar specialization for the
\lstinline!volatile! qualifier.) In either case, the recursion ends and the
value \lstinline!0! is popped up the compile-time recursion stack:

\begin{emcppslisting}[emcppsbatch={e38,e39}]
std::size_t i1 = IndexOf<int, int, long>::value;         // (ù{\codeincomments{i1}}ù) is 0
std::size_t i2 = IndexOf<int, short, int, long>::value;  // (ù{\codeincomments{i2}}ù) is 1
std::size_t i3 = IndexOf<const int, short, int>::value;  // (ù{\codeincomments{i3}}ù) is 1
std::size_t i4 = IndexOf<int, float, double>::value;     // Error
\end{emcppslisting}
    

\noindent If the type is not found in the pack at all, then the recursion will
come to an end when \lstinline!Ts! is empty and the recursion cannot find a
specialization for only one type \lstinline!T!, resulting in a compile-time
error.

It is worth noting that \lstinline!IndexOf! has an alternative
implementation that uses\linebreak%%%%%
 \lstinline!std::integral_constant!, a Standard
Library facility introduced in C++11 that automates part of the
\lstinline!value! definition:

\begin{emcppslisting}[emcppsbatch={e38,e39}]
#include <type_traits>  // (ù{\codeincomments{std::integral\_constant}}ù)
template <typename X, typename T, typename... Ts>  // general definition
struct IndexOf2
    : std::integral_constant<std::size_t, IndexOf<X, Ts...>::value + 1> {};

template <typename X, typename... Ts>
struct IndexOf2<X, X, Ts...>
    : std::integral_constant<std::size_t, 0u> {};  // partial specialization 1

template <typename X, typename... Ts>
struct IndexOf2<const X, X, Ts...>
    : std::integral_constant<std::size_t, 0u> {};  // partial specialization 2
\end{emcppslisting}
    

\noindent The type \lstinline!std::integral_constant<size_t,!~\lstinline!n>! defines a
constant member named \lstinline!value! of type \lstinline!size_t! with value
\lstinline!n!, which simplifies to some extent the definition of
\lstinline!IndexOf! and clarifies its intent.

With this template in our toolbox, we are ready to implement
\lstinline!Variant!'s value constructor, using \emcppsgloss{perfect forwarding}
to create a \lstinline!Variant! holding an object of the given type, with a
compile-time error if the specified type is not found in the parameter
pack \lstinline!Ts!.

There is one more detail to handle. By design, we require \lstinline!Ts! to
contain only unqualified (no \lstinline!const! or \lstinline!volatile!),
nonreference types, but the value constructor may deduce its type
parameter as a reference type (such as \lstinline!int&!). In such cases,
we need to extract \lstinline!int! from \lstinline!int&!. The Standard
Library template \lstinline!std::remove_reference_t! was designed exactly
for this task --- both \lstinline!std::remove_reference_t<int>! and
\lstinline!std::remove_reference_t<int&>! are aliases for \lstinline!int!:

\begin{emcppslisting}[emcppsbatch={e38,e39}]
template <typename T, typename... Ts>  // definition for partial specialization
template <typename UARG>               // value constructor
Variant<T, Ts...>::Variant(UARG&& xs)  // uses perfect forwarding
{
    typedef std::remove_reference_t<UARG> U;
        // Remove reference from (ù{\codeincomments{UARG}}ù) if any, e.g. transform (ù{\codeincomments{int\&}}ù) into (ù{\codeincomments{int}}ù).
    ::new(&d_data) U(std::forward<UARG>(xs));  // Construct object at address.
    d_active = IndexOf<U, T, Ts...>::value;    // This code fails if (ù{\codeincomments{U}}ù) not in (ù{\codeincomments{Ts}}ù).
}
\end{emcppslisting}
    

\noindent Now we get to construct a \lstinline!Variant! given any value of one of its
possible types:

\begin{emcppslisting}[emcppsbatch={e38,e39}]
Variant<float, double> v1(1.0F);  // (ù{\codeincomments{v1}}ù) has type (ù{\codeincomments{float}}ù) and value 1.
Variant<float, double> v2(2.0);   // (ù{\codeincomments{v2}}ù) has type (ù{\codeincomments{double}}ù) and value 2.
Variant<float, double> v3(1);     // Error, (ù{\codeincomments{int}}ù) is not among allowed types.
\end{emcppslisting}
    

\noindent A more advanced \lstinline!Variant! implementation could support implicit
conversions during construction as long as there is no ambiguity. Such
functionality is supported by \lstinline!std::variant!.

Now that \lstinline!Variant! knows the index of the active type in
\lstinline!Ts!, we can implement an accessor function that retrieves a
reference to the active element, by a client that knows the type. For
example, given a \lstinline!Variant<short,!~\lstinline!int,!~\lstinline!long>!
object named \lstinline!v!, \lstinline!int&!~\lstinline!get<int>(v)! should
return a reference to the stored \lstinline!int! if and only if the current
value in \lstinline!v! has indeed type \lstinline!int!; otherwise, it throws
an exception:

\begin{emcppslisting}[emcppsbatch={e38,e39}]
template <typename T, typename... Ts>            // (ù{\codeincomments{T}}ù) is the assumed type.
T& get(Variant<Ts...>& v)                        // (ù{\codeincomments{Variant<Ts...>}}ù) by ref
{
    if (v.d_active != IndexOf<T, Ts...>::value)  // Is the index correct?
        throw std::runtime_error("wrong type");  // If not, throw.
    void* p = &v.d_data;                         // If so, take store address
    return *static_cast<T*>(p);                  // and convert.
}
\end{emcppslisting}
    

\noindent A overload of \lstinline!get! that takes and returns \lstinline!const! is
defined analogously.

In spite of its simplicity, the \lstinline!get! function (which needs to be
a \lstinline!friend! of \lstinline!Variant! because it needs access to its
\lstinline!private! members) is safe and robust. If given a type not
present in the \lstinline!Variant!'s parameter pack, \lstinline!IndexOf! fails
to compile, and, consequently, \lstinline!get! does not compile either. If
the type is present in the pack but is not the current type stored in
the \lstinline!Variant!, an exception is thrown. If everything works well,
the address of data is converted to a reference to the target type, in
full confidence that the cast is safe to perform:

\begin{emcppslisting}[emcppsbatch={e38,e39}]
typedef Variant<long, double, std::string> Var;

Var x1(1L);                            // type (ù{\codeincomments{long}}ù), value 1
Var x2(2.5);                           // type (ù{\codeincomments{double}}ù), value 2.5
Var x3(std::string("hi"));             // type (ù{\codeincomments{std::string}}ù), value "hi"

long y1(get<long>(x1));                // OK, (ù{\codeincomments{y1}}ù) is 1.
double y2(get<double>(x2));            // OK, (ù{\codeincomments{y2}}ù) is 2.5.
std::string y3(get<std::string>(x3));  // OK, (ù{\codeincomments{y3}}ù) contains "hi".
double y4(get<double>(x3));            // throws exception, wrong type
\end{emcppslisting}
    

\noindent Writing \lstinline!Variant!'s destructor is more difficult because, in that
case, we need to produce the compile-time type of the active element
from the \emph{runtime} index, \lstinline!d_active!. The language offers
no built-in support for such an operation, so we must produce a library
solution instead.

One idea is to use a linear search approach: Starting with the active
index \lstinline!d_active! and the entire parameter pack \lstinline!Ts!, we
reduce both successively until \lstinline!d_active! becomes zero. At that
point, we know that the dynamic type of the variant is the head of
what's left of \lstinline!Ts!, and we call the appropriate destructor. To
implement such an algorithm, we define two overloaded functions,
\lstinline!destroyLinear!, that are friends of \lstinline!Variant!:

\begin{emcppslisting}[emcppsbatch={e38,e39}]
template <unsigned int>
void destroyLinear(unsigned int, void*)      // terminates recursion
{ }

template <unsigned int i, typename T, typename... Ts>
void destroyLinear(unsigned int n, void* p)  // index and pointer to data
{
    if (n == i)
        static_cast<T*>(p)->~T();            // found, call destructor manually
    else
        destroyLinear<i + 1, Ts...>(n, p);   // "recurse" with list tail
}
\end{emcppslisting}
    

\noindent The second overload employs the idiom (used in several places in this
feature section) of stripping the first element from the parameter pack
on each call using a named type parameter. If the runtime index is 0,
then the destructor of \lstinline!T!, the first type in the pack, is called
against the pointer received. Otherwise, \lstinline!destroyLinear!
``recursively'' calls a version of itself with the parameter pack
reduced by 1 and the compile-time counter \lstinline!i! correspondingly
bumped. Note that ``recursion'' is not quite the correct term because
the template instantiates a different function for each call.

The first overload simply terminates the recursion. It is never called
in a correct program, but the compiler doesn't know that, so we need to
provide a body for it.

\lstinline!Variant!'s destructor ensures that the variant object is not
corrupt and then calls\linebreak%%%%%% 
\lstinline!destroyLinear!, passing the entire pack
\lstinline!Ts...! as template argument and the current index and pointer to
state as runtime arguments:

\begin{emcppslisting}[emcppsbatch=e38]
template <typename T, typename... Ts>  // definition for partial specialization
Variant<T, Ts...>::~Variant()          // linear lookup destructor
{
    assert((d_active < Variant<T,Ts...>::size));    // check invariant
    destroyLinear<0, T, Ts...>(d_active, &d_data);  // initiate destruction
}
\end{emcppslisting}
    

\noindent When presented with a linear complexity algorithm, the natural reaction
is to look for a similar solution with lower complexity, especially
considering that the linear search will be performed at run time, not
during compilation. In this case, we might try a \emph{binary search}
through the type parameter pack. In common usage, a variant does not
have that many types, so this may be considered overkill, but there are
two reasons why this problem deserves our attention. First, there are
variant types in common use that have a large number of alternatives,
such as the \lstinline!VARIANT! type in the Windows operating system with
around 50 options in its union, and some data exchange formats that can
have hundreds of types. Second, destructors are of particular importance
because they tend to be called intensively, so destructors' size and
speed can often affect performance of programs using them.

Defining a binary search that is a mix of compile-time and runtime
computations is challenging, particularly because parameter packs do not
have indexed access. However, we can implement \lstinline!destroyLog! with
relative ease if we design the algorithm in a hybrid manner --- linear
search during compilation and binary search at runtime. We do so by
defining \lstinline!destroyLog! to take two integral template parameters,
\lstinline!skip! and \lstinline!total!, that instruct the template which types
in the pack it must look at. If \lstinline!skip! is greater than 0, the
algorithm does a linear search during compilation in the parameter pack.
When \lstinline!skip! is zero, we know we need to search \lstinline!total!
elements in the parameter pack, and we do so in a textbook binary search
manner:

\begin{emcppslisting}[emcppsbatch={e38,e39}]
template <unsigned int, unsigned int>
void destroyLog(unsigned int n, void*) // no-op terminal function
{ }

template <unsigned int skip, unsigned int total, typename T, typename... Us>
void destroyLog(unsigned int n, void* p)
{
    enum : std::size_t { mid = total / 2 };
    if (skip > 0)
        destroyLog<skip - 1, total - 1, Us...>(n, p);
    else if (n == 0)
        static_cast<T*>(p)->~T();
    else if (n < mid)
        destroyLog<0, mid, T, Us...>(n, p);
    else
        destroyLog<mid, total, T, Us...>(n - mid, p);
}
\end{emcppslisting}
    

\noindent There are quite a few moving parts in \lstinline!destroyLog!, so let's take
a look at each in turn. The first overload is simple: Its role, just
like before, is to stop the recursion. It takes two
\lstinline!unsigned!~\lstinline!int! parameters, both of which it ignores. The
first overload will never be called or even linked.

The bulk of the work is carried by the second overload. First, it
computes half of the total in constant \lstinline!mid!.

Now, to understand how the four branches of the
\lstinline!if!/\lstinline!else! cascade work, it's important to distinguish
the first condition from all others; the
\lstinline!skip!~\lstinline!>!~\lstinline!0! test is essentially a compile-time
test and does no computation at run time. All instantiations with a
nonzero \lstinline!skip! will simply recurse to a different instantiation
and do nothing else. The compiler will in all likelihood inline the call
and eliminate all other code in the function.

Why do we subtract \lstinline!(skip!~\lstinline!>!~\lstinline!0)! from
\lstinline!skip! and \lstinline!total! instead of simply subtracting
\lstinline!1!? If we used \lstinline!skip!~\lstinline!-!~\lstinline!1!, when
\lstinline!skip! reaches \lstinline!0!, the compiler would attempt to
instantiate \lstinline!destroyLog! with \lstinline!-1! (even if it never calls
that instantiation), which translates into a very large
\lstinline!unsigned!, causing a runaway of further instantiations. The way
the condition is written avoids this situation.

All other tests are performed during run time. The second test
\lstinline!n!~\lstinline!==!~\lstinline!0! checks for a match, and, if the test
passes, the appropriate destructor is called manually. This is in
keeping with how \lstinline!destroyLinear! works.

The rest of the function is the engine that accelerates
\lstinline!destroyLog! in comparison to\linebreak%%%%%%%
 \lstinline!destroyLinear!. If
\lstinline!n! is less than \lstinline!mid!, then there's no need to consider
the upper elements of the pack at all; therefore, \lstinline!destroyLog! is
instantiated with \lstinline!mid! as the total elements to search. All
other arguments --- both of the template and runtime kind --- are the
same. Otherwise, on the contrary, there's no need to look at the first
\lstinline!mid! elements of the pack, so \lstinline!destroyLog! is
instantiated accordingly.

All in all, the \lstinline!destroyLog! template compactly encodes a linear
search during compilation and simultaneously a binary search during run
time. As expected, contemporary compilers eliminate dead code entirely
and generate code virtually identical to code competently handwritten in
a hardcoded approach.{\cprotect\footnote{The corresponding code has been
tested with Clang 11.0.1 and GCC 10.2 at optimization level
  \lstinline!-O3!.}}

Of course, once we have a logarithmic implementation, we immediately
wonder if we can do better, perhaps even a constant time lookup. That
brings us to an application of variadic templates in a braced
initialization, as described in \intraref{description-variadic}{expansion-in-a-function-call-argument-list-or-a-braced-initializer-list}. We use braced
initialization to generate a table of function pointers, each pointing
to a different instantiation of the same function template. For the
table to work, each function must have exactly the same signature. For
the case of invoking a destructor, we will want to supply the object to
be destroyed by using \lstinline!void*! just like we did with
\lstinline!destroyLinear! and \lstinline!destroyLog!. We can then write a
function template taking a non-deduced type parameter to carry the
necessary type information for the function implementation to cast the
\lstinline!void*! pointer to the necessary type:

\begin{emcppslisting}[emcppsbatch={e38,e39}]
template <typename T>
static void destroyElement(void *p)
{
    static_cast<T*>(p)->~T();
}
\end{emcppslisting}
    

\noindent With this simple function template, we can populate a static array of
function pointers by initializing an array of unknown bound (that will
implicitly deduce the correct size) with a braced list produced by a
\emcppsgloss{pack expansion}, taking the address of the
\lstinline!destroyElement! function template instantiated with the types in
the pack. Once we have the array of destructor functions, matching the
expected order of the runtime index \lstinline!d_active!, we can simply
invoke the function pointer at the current index to invoke the correct
destructor for the currently active element.

\begin{emcppslisting}[emcppsbatch={e38,e39}]
template <typename... Ts>
void destroyCtTime(unsigned int n, void *p)  // same signature
{
    typedef void(*destructor)(void *);       // simplify definition
    static const destructor dt[] =           // array of function pointers
        { &destroyElement<Ts>... };          // initialize with pack expansion
    dt[n](p);                                // call appropriate destructor
}
\end{emcppslisting}
    

\noindent Note that this constant-time lookup is also the simplest of the three
forms presented since it leans more heavily on integrating variadic
\emcppsgloss{pack expansion} with other language features, in this case
braced array initialization.

It may appear that \lstinline!destroyCtTime! is the best of the lot: It
runs in constant time, it's small, it's simple, and it's easy to
understand. However, upon a closer look, \lstinline!destroyCtTime! has
serious performance disadvantages. First, each destructor call entails
an indirect call, which is notoriously difficult to inline and optimize
except for the most trivial cases.{\cprotect\footnote{GCC 10.2 generates
tables and indirect calls even for the most trivial uses. Clang 11.0.1
is able to optimize away indirect calls for locally defined
\lstinline!Variant! objects only if the function has no control flow
affecting \lstinline!Variant! values. Both compilers were tested at
  optimization level \lstinline!-O3!.}}

Second, it is often the case that many types involved in a
\lstinline!Variant! have trivial destructors that do not perform any work
at all. The functions \lstinline!destroyLinear! and \lstinline!destroyLog!
have a white-box approach that naturally leads to the inlining and
subsequent elimination of such destructors, leading to a massive
simplification of the ultimately generated code. In contrast,
\lstinline!destroyCtTime! cannot take advantage of such opportunities; even
if some destructors do no work, they will still be hidden beyond an
indirect call, which is paid in all cases.

There is, however, a way to combine the advantages of
\lstinline!destroyCtTime!, \lstinline!destroyLinear!, and \lstinline!destroyLog!
by using a meta-algorithmic strategy called \emcppsgloss{algorithm
selection}{\cprotect\footnote{\cite{leyton-brown03}}}: Choose the appropriate algorithm depending on the
\lstinline!Variant! instantiation. The characteristics of instantiation can
be inferred by using \emcppsgloss[compile time introspection]{compile-time introspection}. The criteria
for selecting the best of three algorithms can be fairly complex. For
instantiations with only a few types, most of which have trivial
destructors, \lstinline!destroyLinear! is likely to work best; for
moderately large parameter pack sizes, \lstinline!destroyLog! will be the
algorithm of choice; finally, for very large parameter pack sizes,
\lstinline!destroyCtTime! is best.

For a simple example, we can use the parameter pack size as a simple
heuristic:

\begin{emcppslisting}[emcppsbatch=e39]
template <typename T, typename... Ts>  // definition for partial specialization
Variant<T, Ts...>::~Variant()          // improved destructor implementation
{
    assert((d_active < Variant<T,Ts...>::size));   // check invariant of variant
    void* p = &d_data;                             // (ù{\codeincomments{d\_data}}ù) as (ù{\codeincomments{void*}}ù)
    if (Variant<T,Ts...>::size <= 4)
        destroyLinear<0u, T, Ts...>(d_active, p);  // choose linear algorithm
    else if (Variant<T,Ts...>::size <= 64)
        destroyLog<0u, Variant<T,Ts...>::size,
                   Ts...>(d_active, p);            // choose log algorithm
    else
        destroyCtTime<T,Ts...>(d_active, p);       // choose O(1) algorithm
}
\end{emcppslisting}
    

\noindent The constants 4 and 64 deciding the thresholds for choosing between
algorithms are called \emcppsgloss[metaparameter]{metaparameters} and are to be chosen
experimentally. As mentioned, a more sophisticated implementation would
eliminate from \lstinline!Ts...! all types that have trivial destructors
and focus only on the types that require destructor calls.
Distinguishing between trivial and non-trivial destructors is possible
with the help of the Standard Library introspection primitive
\lstinline!std::is_trivially_destructible! introduced in C++11.

\subsubsection[Advanced traits]{Advanced traits}\label{advanced-traits}

The use of \lstinline!template!~\lstinline!template! parameters with variadic
arguments allows us to create partial template specializations that
match template instances with an arbitrary number of type parameters.
This allows the definition of traits that were not possible with
prevariadics technology.

For example, consider the family of \emcppsgloss{smart pointer} templates. A
smart pointer type virtually always is instantiated from a template
having the pointed-to type as its first parameter:

\begin{emcppslisting}[emcppsbatch=e40]
template <typename T>
struct SmartPtr1
{
    typedef T value_type;
    T& operator*() const;
    T* operator->() const;
    // ...
};
\end{emcppslisting}
    

\noindent A more sophisticated smart pointer might take one or more additional
template parameters, such as a deletion policy:

\begin{emcppslisting}[emcppsbatch=e40]
template <typename T, typename Deleter>
struct SmartPtr2
{
    T& operator*() const;
    T* operator->() const;
    // ...
};
\end{emcppslisting}
    

\noindent \lstinline!SmartPtr2! still takes a value type as its first template
parameter but also takes a \lstinline!Deleter! functor for destroying the
pointed-to object. (The Standard Library smart pointer\linebreak%%%%%%%
\lstinline!std::unique_ptr! added with C++11 also takes a deleter
parameter). Note that the author of \lstinline!SmartPtr2! did not add a
nested \lstinline!value_type!, yet the human reader can easily deduce that
\lstinline!SmartPtr2!'s value type is \lstinline!T!.

Now, we aim to define a traits class template that, given an arbitrary
pointer-like type such as \lstinline!SmartPtr1<int>! or
\lstinline!SmartPtr2<double,!~\lstinline!MyDeleter>!, can deduce the value
type pointed-to by the pointer (in our examples, as \lstinline!int! and
\lstinline!double!, respectively). Additionally, our traits class should
allow us to ``rebind'' the pointer-like type, yielding a new
pointer-like type with a different value type. Such an operation is
useful, for example, when we want to use the same smart pointer facility
as another library, but with our own types.

Suppose, for example, a library defines a type \lstinline!Widget!:

\begin{emcppslisting}[emcppsbatch=e40]
class Widget           // third-party class definition
{ /*...*/ };
\end{emcppslisting}
    

\noindent Furthermore, the same library defines type \lstinline!WidgetPtr! that
behaves like a pointer to a \lstinline!Widget! type but could be (depending
on the library version, debug versus release builds, and so on) either
\lstinline!SmartPtr1! or \lstinline!SmartPtr2!:

\begin{emcppslisting}[emcppsbatch=e40]
class FastDeleter     // policy for performing minimal checking on (ù{\codeincomments{SmartPtr2}}ù)
{ /*...*/ };

class CheckedDeleter        // policy for performing maximal checking on (ù{\codeincomments{SmartPtr2}}ù)
{ /*...*/ };

#if !defined(DBG_LEVEL)
typedef SmartPtr1<Widget>
    WidgetPtr;                             // release mode, fastest
#elif DBG_LEVEL >= 2
typedef SmartPtr2<Widget, CheckedDeleter>
    WidgetPtr;                             // safe smart pointer for debugging
#else
typedef SmartPtr2<Widget, FastDeleter>
    WidgetPtr;                             // safety/speed compromise
#endif
\end{emcppslisting}
    

\noindent In debug mode (\lstinline!DBG_LEVEL! defined), the library uses a
\lstinline!SmartPtr2! smart pointer that does additional checking around,
for example, dereference and deallocation. There are two possible
debugging levels, one with stringent checks and one that cuts a
trade-off between safety and speed. In release mode, the library wants
to run at full speed so it uses \lstinline!SmartPtr1!. User code simply
uses \lstinline!WidgetPtr! transparently because the interfaces of the
types are very similar.

On the client side, we'd like to define a \lstinline!GadgetPtr! type that
behaves like a pointer to our own type \lstinline!Gadget! but automatically
adjusts to use the same smart pointer underpinnings, if any, that
\lstinline!WidgetPtr! is using. However, we don't have control over
\lstinline!DBG_LEVEL! or over the code introducing \lstinline!WidgetPtr!. The
strategies used by the definition of \lstinline!WidgetPtr! may change
across releases. How can we robustly figure out what kind of pointer ---
smart or not --- \lstinline!WidgetPtr! is representing?

Let's begin by declaring a primary class template with no body, and then
specializing it for native pointer types:

\begin{emcppslisting}[emcppsbatch=e40]
template <typename Ptr>
struct PointerTraits;       // incomplete declaration

template <typename T>
struct PointerTraits<T*>   // partial specialization for all raw pointers
{
    typedef T value_type;  // normalized alias for (ù{\codeincomments{T}}ù)
    template <typename U>
    using rebind = U*;     // (ù{\codeincomments{rebind<U>}}ù) is an alias for (ù{\codeincomments{U*}}ù)
};
\end{emcppslisting}
    

\noindent The new \lstinline!using! syntax has been introduced in C++11 as a
generalized \lstinline!typedef!; see \featureref{\locationa}{alias-declarations-and-alias-templates}. \lstinline!PointerTraits! provides a basic
traits API. For any built-in pointer type, \lstinline!P!,
\lstinline!PointerTraits<P>::value_type! resolves to whatever type
\lstinline!P! points to. Moreover, for some other type, \lstinline!X!,
\lstinline!PointerTraits<P>::rebind<X>! is an alias for \lstinline!X*!, i.e.,
it propagates the information that \lstinline!P! is a built-in pointer to
\lstinline!X!:

\begin{emcppslisting}[emcppsbatch=e40]
#include <type_traits>  // (ù{\codeincomments{std::is\_same}}ù)

static_assert(std::is_same<int, PointerTraits<int*>::value_type>::value, "");
static_assert(std::is_same<double*,
                           PointerTraits<int*>::rebind<double>>::value, "");
\end{emcppslisting}
    
\lstinline!PointerTraits! has a nested type, \lstinline!value_type!, and a
nested alias template, \lstinline!rebind!. The first
\lstinline!static_assert! shows that, when \lstinline!Ptr! is \lstinline!int*!,
\lstinline!value_type! is \lstinline!int!. The second \lstinline!static_assert!
shows that, when \lstinline!Ptr! is \lstinline!int*!, \lstinline!rebind<double>!
is \lstinline!double*!. In other words, \lstinline!PointerTraits! can
determine the pointed-to type for a raw pointer and provides a facility
for generating a raw pointer type pointing to a \emph{different} value
type.

For now, however, \lstinline!PointerTraits! is not defined for any type
that is not a built-in pointer. For \lstinline!PointerTraits! to work with
an arbitrary smart pointer class (such as \lstinline!SmartPtr1! and
\lstinline!SmartPtr2! above but also \lstinline!std::shared_ptr!,
\lstinline!std::unique_ptr!, and \lstinline!std::weak_ptr!), we must
partially specialize it for a template instantiation,
\lstinline!PtrLike<T,!~\lstinline!X...>!, where \lstinline!T! is assumed to be
the value type and \lstinline!X...! is a parameter pack of zero or more
additional type parameters to \lstinline!PtrLike!:

\begin{emcppslisting}[emcppsbatch=e40]
template <
    template <typename, typename...> class PtrLike,
    typename T, typename... X>
struct PointerTraits<PtrLike<T, X...>>  // partial specialization for template
{
    using value_type = T;               // extract pointee type
    template <typename U>
    using rebind = PtrLike<U, X...>;    // rebind to some other type (ù{\codeincomments{U}}ù)
};
\end{emcppslisting}
    

\noindent This partial specialization will produce the correct result for any
pointer-like class template that takes one or more type template
parameters, where the first parameter is the value type of the pointer.
First, it correctly deduces the \lstinline!value_type! from the first
argument to the template:

\begin{emcppslisting}[emcppsbatch=e40]
typedef SmartPtr2<Widget, CheckedDeleter>  WP1;  // fully checked
typedef SmartPtr2<Widget, FastDeleter>     WP2;  // minimally checked

static_assert(std::is_same<
    PointerTraits<WP1>::value_type,  // Fetch the pointee type of (ù{\codeincomments{WP1}}ù).
    Widget>::value, "");             // should be (ù{\codeincomments{Widget}}ù)

static_assert(std::is_same<
    PointerTraits<WP1>::value_type,  // Fetch the pointee type of (ù{\codeincomments{WP2}}ù).
    Widget>::value, "");             // should also be (ù{\codeincomments{Widget}}ù)
\end{emcppslisting}
    

\noindent Second, \lstinline!rebind! is able to reinstantiate the original template,
\lstinline!SmartPtr2!, with another first argument but the same second
argument:

\begin{emcppslisting}[emcppsbatch=e40]
class Gadget { /*...*/ };

static_assert(std::is_same<
    PointerTraits<WP1>::rebind<Gadget>,  // Rebind (ù{\codeincomments{WP1}}ù) to (ù{\codeincomments{Gadget}}ù).
    SmartPtr2<Gadget, CheckedDeleter>>   // fully checked, just like (ù{\codeincomments{WP1}}ù)
::value, "");

static_assert(std::is_same<
    PointerTraits<WP2>::rebind<Gadget>,  // Rebind (ù{\codeincomments{WP2}}ù) to (ù{\codeincomments{Gadget}}ù).
    SmartPtr2<Gadget, FastDeleter>>      // minimally checked, like (ù{\codeincomments{WP2}}ù)
::value, "");
\end{emcppslisting}
    

\noindent The Standard Library facility \lstinline!std::pointer_traits!, introduced
with C++11, is a superset of our \lstinline!PointerTraits! example.

\subsection[Potential Pitfalls]{Potential Pitfalls}\label{potential-pitfalls-variadic}

\subsubsection[Accidental use of C-style ellipsis]{Accidental use of C-style ellipsis}\label{accidental-use-of-c-style-ellipsis}

Inside the function parameters declaration, \lstinline!...! can be used
only in conjunction with a template parameter pack. However, there is an
ancient use of \lstinline!...! in conjunction with C-style variadic
functions such as \lstinline!printf!. That use can cause confusion. Say we
set out to declare a simple variadic function, \lstinline!process!, that
takes any number of arguments by pointer:

\begin{emcppslisting}[emcppsbatch=e40]
class Widget;                   // declaration of some user-defined type

template <typename... Widgets>  // parameter pack named (ù{\codeincomments{Widgets}}ù)
int process(Widget*...);        // meant as a pack expansion, but is it?
\end{emcppslisting}
    

\noindent The author meant to declare \lstinline!process! as a variadic function
taking any number of pointers to objects. However, instead of
\lstinline!Widgets*...!, the author mistakenly typed \lstinline!Widget*...!.
This typo took the declaration into a completely different place: It is
now a C-style variadic function in the same category as \lstinline!printf!.
Recall the \lstinline!printf! declaration in the C Standard Library:

\begin{emcppslisting}[emcppsbatch=e40]
int printf(const char* format, ...);
\end{emcppslisting}
    

\noindent The comma and the parameter name are optional in C and C++, so omitting
both leads to an equivalent declaration:

\begin{emcppslisting}[emcppsbatch=e40]
int printf(const char*...);
\end{emcppslisting}
    

\noindent Comparing \lstinline!process! (with the typo in tow) with \lstinline!printf!
makes it clear that \lstinline!process! is a C-style variadic function.
Runtime errors of any consequence are quite rare because the expansion
mechanisms are very different across the two kinds of variadics.
However, the compile- and link-time diagnostics can be puzzling. In
addition, if the variadic function ignores the arguments passed to it,
calling it may even compile, but the call will use a different calling
convention than that intended and assumed.

As an anecdote, a similar situation occurred during the review stage of
this feature section. A simple misunderstanding caused a function to be
declared inadvertently as a C-style variadic instead of C++ variadic
template, leading to numerous indecipherable compile-time and link-time
errors in testing that took many emails to figure out.

\subsubsection[Undiagnosed errors]{Undiagnosed errors}\label{undiagnosed-errors}

\intraref{description-variadic}{corner-cases-of-function-template-argument-matching}
shows definitions of variadic template functions that are in error
according to the C++ Standard yet pass compilation on contemporary
compilers --- that is, \emcppsgloss{IFNDR}. In certain cases, they can even
be called. Such situations are most assuredly latent bugs:

\begin{emcppslisting}[emcppsbatch=e40]
template <typename... Ts, typename... Us, typename T>
int process(Ts..., Us..., T);
    // ill-formed declaration - (ù{\codeincomments{Us}}ù) must be empty in every possible call
int x = process<int, double>(1, 2.5, 3);
    // (ù{\codeincomments{Ts=<int, double>}}ù), (ù{\codeincomments{Us=<>}}ù), (ù{\codeincomments{T=int}}ù)
\end{emcppslisting}
    

\noindent In virtually all cases, such code reflects a misplaced expectation; an
always-empty parameter pack has no reason to exist in the first place.

\subsubsection[Compiler limits on the number of arguments]{Compiler limits on the number of arguments}\label{compiler-limits-on-the-number-of-arguments}

The C++ Standard recommends that compilers support at least 1024
arguments in a variadic template instantiation. Although this limit
seems very generous, real-world code may push against it, especially in
conjunction with generated code or combinatorial uses.

This limit may lead to a lack of portability in production --- for
example, code that works with one compiler but fails with another.
Suppose, for example, we define \lstinline!Variant! that carries all
possible types that can be serialized in a large application:


\begin{emcppshiddenlisting}[emcppsbatch=e41]
template <typename...>
class Variant { };
\end{emcppshiddenlisting}
\begin{emcppslisting}[emcppsbatch=e41]
typedef Variant<
    char,
    signed char,
    unsigned char,
    short,
    unsigned short
    // ... (more built-in and user-defined types)
>
WireData;
\end{emcppslisting}
    

\noindent We release this code to production and then, at some later date, clients
find it fails to build on some platforms, leading to a need to
reengineer the entire solution to provide full cross-platform support.

\subsection[Annoyances]{Annoyances}\label{annoyances-variadic}

\subsubsection[Unusable functions]{Unusable functions}\label{unusable-functions}

Before variadics, any properly defined template function could be called
by using explicit template argument specification, type deduction, or a
combination thereof. Now it is possible to define variadic function
templates that pass compilation but are impossible to call (either by
using explicit instantiation, argument deduction, or both). This may
cause confusion and frustration. Consider, for example, a few function
templates, none of which take any function parameters:

\begin{emcppslisting}[emcppsbatch=e42]
template <typename T>                  // template with one parameter
int f1();

template <typename T, typename U>      // template with two parameters
int f2();

template <typename... Ts>              // pack followed by type parameter
int f3();

template <typename T, typename... Ts>  // parameter pack at the end
int f4();

template <typename... Ts, typename T>  // pack followed by type parameter
int f5();
\end{emcppslisting}
    

\noindent The first four functions can be called by explicitly specifying their
template arguments:

\begin{emcppslisting}[emcppsbatch=e42]
int a1 = f1<int>();              // (ù{\codeincomments{T=int}}ù)
int a2 = f2<int, long>();        // (ù{\codeincomments{T=int}}ù), (ù{\codeincomments{U=long}}ù)
int a3 = f3<char, int, long>();  // (ù{\codeincomments{Ts=<char, int, long>}}ù)
int a4 = f4<char, int, long>();  // (ù{\codeincomments{T=char}}ù), (ù{\codeincomments{Ts=<int, long>}}ù)
\end{emcppslisting}
    

\noindent However, there is no way to call \lstinline!f5! because there is no way to
specify \lstinline!T!:

\begin{emcppslisting}
int a5a = f5();             // Error, cannot infer type argument for (ù{\codeincomments{T}}ù)
int a5b = f5<int>();        // Error, cannot infer type argument for (ù{\codeincomments{T}}ù)
int a5c = f5<int, long>();  // Error, cannot infer type argument for (ù{\codeincomments{T}}ù)
\end{emcppslisting}
    

\noindent Recall that by the Rule of Greedy Matching (see \intraref{description-variadic}{the-rule-of-greedy-matching}), \lstinline!Ts! will match all of the template
arguments passed to \lstinline!f5!, so \lstinline!T! is starved. Such
uncallable functions are \emcppsgloss{IFNDR}. There are several other
variations that render variadic function templates uncallable and
therefore \emcppsgloss{IFNDR}. However, most contemporary compilers do allow
compilation of \lstinline!f5!.{\cprotect\footnote{The corresponding code
  has been tested with Clang 11.0 and GCC 7.5.}} If other overloads of
such an uncallable function are present, the matter may be interpreted
as the wrong overload being called.

\subsubsection[Limitations on expansion contexts]{Limitations on expansion contexts}\label{limitations-on-expansion-contexts}

As discussed in \intraref{description-variadic}{pack-expansion} and in the sections
that follow it, expansion contexts are prescriptive. The standard
enumerates all expansion contexts exhaustively: There is no other place
in a C++ program where a parameter pack is allowed to occur, even if it
seems syntactically and semantically correct.

For example, consider a variadic function template, \lstinline!bump1!, that
attempts to expand and increment each of the arguments in its parameter
pack:

\begin{emcppslisting}
template <typename... Ts>
void bump1(Ts&... vs)  // some variadic function template
{
    ++vs...;           // Error, can't expand parameter pack at statement level
}
\end{emcppslisting}
    

\noindent Attempting to expand a parameter pack at the statement level is simply
not among the allowed expansion contexts; hence, the example function
body above fails to compile.

Such limitations can be worked around by artificially creating an
expansion context. For example, we can achieve our goal by replacing the
erroneous line in \lstinline!bump1! (above) with one in \lstinline!bump2!
(below) that, say, creates a local class with a constructor that takes
\lstinline!Ts&...! as parameters:

\begin{emcppslisting}
template <typename... Ts>
void bump2(Ts&... vs)
{
    struct Local          // local struct
    {
        Local(Ts&...) {}  // constructor takes each of (ù{\codeincomments{Ts}}ù) by reference
    }                     // no semicolon here, will create an object
    local(++vs...);       // OK, expansion allowed in constructor call
}
\end{emcppslisting}
    

\noindent The code above creates a local \lstinline!struct! called \lstinline!Local!
with a constructor and immediately constructs an object of that type
called \lstinline!local!. Expansion is allowed inside the argument list for
the constructor call, which makes the code work.

A possibility to achieve the same effect with terser code is to create a
lambda expression, \lstinline![](Ts&...){}! and then immediately call it
with the expansion \lstinline!++vs...! as its arguments:

\begin{emcppslisting}
template <typename... Ts>
void bump3(Ts&... vs)          // some variadic function template
{
     ([](Ts&...){})(++vs...);  // OK, pack expansion allowed in lambda call
}
\end{emcppslisting}
    

\noindent The function above works, albeit awkwardly, by making use of another
feature of C++11 that essentially allows us to define an anonymous
function \emph{in} \emph{situ} and then invoke it; see
\featureref{\locationc}{lambda}
{\cprotect\footnote{C++17 adds \emph{fold expressions} that allow easy \emcppsgloss{pack expansion}
  at expression and statement level. The semantics desired for the
  example shown would be achieved with the syntax \lstinline!(...++vs);!.}}

\subsubsection[Parameter packs cannot be used unexpanded]{Parameter packs cannot be used unexpanded}\label{parameter-packs-cannot-be-used-unexpanded}

As discussed in \intraref{description-variadic}{pack-expansion}, the name of a
parameter pack cannot appear on its own in a correct C++ program; the
only way to use a parameter pack is as part of an expansion by using
\lstinline!...! or \lstinline!sizeof!. Such behavior is unlike types, template
names, or values.

It is impossible to pass parameter packs around or to give them
alternative names (as is possible with types by means of
\lstinline!typedef! and \lstinline!using! and with values by means of
references). Consequently, it is also impossible to define them as
``return'' values for metafunctions following conventions such as
\lstinline!::type! and \lstinline!::value! that are commonly used in the
\lstinline!<type_traits>! standard header.

Consider, for example, sorting a type parameter pack by size. This
simple task is not possible without a few helper types because there is
no way to return the sorted pack. One necessary helper would be a
typelist:

\begin{emcppslisting}[emcppsbatch=e43]
template <typename...> struct Typelist { };
\end{emcppslisting}
    

\noindent With this helper type in hand, it is possible to encapsulate parameter
packs, give them alternate names, and so on --- in short, give parameter
packs the same maneuverability that C++ types have:

\begin{emcppslisting}[emcppsbatch=e43]
typedef Typelist<short, int, long, float, double, long double> Numbers;
    // can be used to give a pack an alternate name

template <typename L>
struct SortBySize
{
    using type = Typelist< /*...*/ >;  // computed sorted by size version of
                                       // the (ù{\codeincomments{Typelist}}ù) (ù{\codeincomments{L}}ù) 
};

typedef SortBySize<Numbers>::type SortedNumbers;
    // can be used to "return" a pack from a metafunction
\end{emcppslisting}
    

\noindent Currently no \lstinline!Typelist! facility has been standardized. An active
proposal{\cprotect\footnote{\cite{spertus13}}}
introduces \lstinline!parameter_pack! along the same lines as
\lstinline!Typelist! above. Meanwhile compiler vendors have attempted to
work around the problem in nonstandard ways.{\cprotect\footnote{GNU
defines the nonstandard primitives
\lstinline!std::tr2::__direct_bases! and \lstinline!std::tr2::__bases!.
The first yields a list of all direct bases of a given class, and the
second yields the transitive closure of all bases of a class,
including the indirect ones. To make these artifacts possible, GNU
defines and uses a helper \lstinline!__reflection_typelist! class
  template similar to \lstinline!Typelist! above.}} A related
proposal{\cprotect\footnote{\textbf{[AUs: url please, so I can cite this.  Response: http://wg21.link/N2965}}} defines
\lstinline!std::bases! and \lstinline!std::direct_bases! but has, at the time
of writing, been rejected.

\subsubsection[Expansion is rigid and requires verbose support code]{Expansion is rigid and requires verbose support code}\label{expansion-is-rigid-and-requires-verbose-support-code}

There are only two syntactic constructs that apply to parameter packs:
\lstinline!sizeof...! and expansion via \lstinline!...!. The latter underlies
virtually all treatment of variadics and, as discussed, requires
handwritten support classes or functions as scaffolding toward building
a somewhat involved recursion-based pattern.

There is no expansion in an expression context, so it is not possible to
write functions such as \lstinline!print! in a concise, single-definition
manner; see \intraref{use-cases-variadic}{generic-variadic-functions}. In particular, expressions are not expansion contexts so
the following code would not work:

\begin{emcppslisting}
#include <iostream>  // (ù{\codeincomments{std::cout}}ù), (ù{\codeincomments{std::ostream}}ù)

template <typename T, typename... Ts>
std::ostream& print(const T& v, const Ts&... vs)
{
    std::cout << vs...;             // Error, invalid expansion
    return std::cout << std::endl;
}
\end{emcppslisting}
    

\subsubsection[Linear search for everything]{Linear search for everything}\label{linear-search-for-everything}

One common issue with parameter packs is the difficulty of accessing
elements in an indexed manner. Getting to the \lstinline!n!th element of a
pack is a linear search operation by necessity, which makes certain uses
awkward and potentially time-consuming during compilation. Refer to the
implementation of \lstinline!destroyLog! in \intraref{use-cases-variadic}{variant-types} as an example.

\subsection[See Also]{See Also}\label{see-also}

\begin{itemize}
\item{\seealsoref{bracedinit}{\seealsolocationc} illustrates one of the expansion contexts for function parameter packs.}
\item{\seealsoref{forwardingref}{\seealsolocationc} describes a feature used in conjunction with variadics to achieve \emcppsgloss{perfect forwarding}.}
\item{\seealsoref{lambda}{\seealsolocationc} describes a feature that allows expansion both in capture list and in the arguments list.}
\end{itemize}

\subsection[Further Reading]{Further Reading}\label{further-reading}

\begin{itemize}
\item{``F.21: To return multiple''out" values, prefer returning a struct or tuple," \cite{stroustrup20}}
\item{\cite{vandevoorde18}}
\end{itemize}



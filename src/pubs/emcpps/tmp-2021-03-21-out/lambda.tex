% 20 March 2021, received and cleaned up; updated commands; sent to CE, Steven B for revisions, and Josh for code review. 
% 21 March 2021 JMB - cleaned up code compilation

\emcppsFeature{
    short={Lambdas},
    long={Unnamed Local Function Objects (Closures)},
}{lambda}\label{lambda-expressions}
\setcounter{table}{0}
\setcounter{footnote}{0}
\setcounter{lstlisting}{0}
%\section[Lambdas]{Unnamed Local Function Objects (Closures)}\label{lambda}
%\subsection[Lambda Expressions]{Lambda Expressions}\label{lambda-expressions}

Lambda expressions provide a means of defining function objects at the
point where they are needed, enabling a powerful and convenient way to
specify callbacks or local functions.

\subsection[Description]{Description}\label{description}

Generic, object-oriented, and functional programming paradigms all place
great importance on the ability of a programmer to specify a
\emph{callback} that is passed as an argument to a function. For
example, the Standard-Library algorithm, \lstinline!std::sort!, accepts a
callback argument specifying the sort order:

\begin{emcppslisting}
#include <algorithm>   // (ù{\codeincomments{std::sort}}ù)
#include <functional>  // (ù{\codeincomments{std::greater}}ù)
#include <vector>      // (ù{\codeincomments{std::vector}}ù)

template <typename T>
void sortAscending(std::vector<T>& v)
{
    std::sort(v.begin(), v.end(), std::greater<T>());
}
\end{emcppslisting}
    

The function object, \lstinline!std::greater<T>()!, is callable with two
arguments of type \lstinline!T! and returns \lstinline!true! if the first is
greater than the second and \lstinline!false! otherwise. The Standard
Library provides a small number of similar functor types, but, for more
complicated cases, the programmer must write a functor themselves. If a
container holds a sequence of \lstinline!Employee! records, for example, we
might want to sort the container by name or by salary:

\begin{emcppslisting}[emcppsbatch=e1]
#include <string>  // (ù{\codeincomments{std::string}}ù)
#include <vector>  // (ù{\codeincomments{std::vector}}ù)

struct Employee
{
    std::string name;
    long        salary;  // in whole dollars
};

void sortByName(std::vector<Employee>& employees);
void sortBySalary(std::vector<Employee>& employees);
\end{emcppslisting}
    

The implementation of \lstinline!sortByName! can delegate the sorting task
to the standard algorithm, \lstinline!std::sort!. However, because
\lstinline!Employee! does not supply \lstinline!operator<! and to achieve the
correct sorting criteria, we will need to supply \lstinline!std::sort! with
a callback that compares the names of two \lstinline!Employee! objects. We
implement this callback as a pointer to a simple function that we pass
to \lstinline!std::sort!:

\begin{emcppslisting}[emcppsbatch=e1]
#include <algorithm>  // (ù{\codeincomments{std::sort}}ù)

bool nameLt(const Employee& e1, const Employee& e2)
    // returns true if (ù{\codeincomments{e1.name}}ù) is less than (ù{\codeincomments{e2.name}}ù)
{
    return e1.name < e2.name;
}

void sortByName(std::vector<Employee>& employees)
{
    std::sort(employees.begin(), employees.end(), &nameLt);
}
\end{emcppslisting}
    

The \lstinline!sortBySalary! function can similarly delegate to
\lstinline!std::sort!. For illustrative purposes, we will use a
\emcppsgloss{function object} (a.k.a., \emcppsgloss{functor}) rather than a
function pointer as the callback to compare the salaries of two
\lstinline!Employee! objects. Every \emcppsgloss{functor class} must provide a
\emcppsgloss{call operator} (i.e., \lstinline!operator()!), which, in this case,
compares the salary fields of its arguments:

\begin{emcppslisting}[emcppsbatch=e1]
struct SalaryLt
{
    // Functor whose call operator compares two (ù{\codeincomments{Employee}}ù) objects and returns
    // (ù{\codeincomments{true}}ù) if the first has a lower salary than the second, (ù{\codeincomments{false}}ù) otherwise.

    bool operator()(const Employee& e1, const Employee& e2) const
    {
        return e1.salary < e2.salary;
    }
};

void sortBySalary(std::vector<Employee>& employees)
{
    std::sort(employees.begin(), employees.end(), SalaryLt());
}
\end{emcppslisting}
    

Although it is a bit more verbose, a call through the \emcppsgloss{function
object} is easier for the compiler to analyze and automatically inline
within \lstinline!std::sort! than is a call through the function pointer.
\emcppsgloss[function object]{Function objects} are also more flexible because they can carry
state, as we'll see shortly. The sorting example illustrates how small
bits of a function's logic must be factored out into special-purpose
auxiliary functions and/or functor classes that are often not re-usable.
It is possible, for example, that the \lstinline!nameLt! function and
\lstinline!SalaryLt! class are not used anywhere else in the program.

When callbacks are tuned to the specific context in which they are used,
they become both more complicated and less re-usable. Let's say, for
example, that we wish to count the number of employees whose salary is
above the average for the collection. Using Standard Library algorithms,
this task seems trivial: (1) sum all of the salaries using
\lstinline!std::accumulate!, (2) calculate the average salary by dividing
this sum by the total number of employees, and (3) count the number of
employees with above-average salaries using \lstinline!std::count_if!.
Unfortunately, both \lstinline!std::accumulate! and \lstinline!std::count_if!
require callbacks to return the salary for an \lstinline!Employee! and to
supply the criterion for counting, respectively. The callback for
\lstinline!std::accumulate! must take two parameters --- the current
running sum and an element from the sequence being summed --- and must
return the new running sum:

\begin{emcppslisting}[emcppsbatch=e1]
struct SalaryAccumulator
{
    long operator()(long currSum, const Employee& e) const
        // returns the sum of (ù{\codeincomments{currSum}}ù) and the (ù{\codeincomments{salary}}ù) field of (ù{\codeincomments{e}}ù)
    {
        return currSum + e.salary;
    }
};
\end{emcppslisting}
    

The callback for \lstinline!std::count_if! is a \emcppsgloss{predicate} (i.e.,
an expression that yields a Boolean result in response to a yes-or-no
question) that takes a single argument and returns \lstinline!true! if an
element of that value should be counted and \lstinline!false! otherwise. In
this case, we are concerned with \lstinline!Employee! object's having
salaries above the average. Our \emcppsgloss{predicate functor} must,
therefore, carry around that average so that it can compare it to the
salary of the employee that is presented as an argument:

\begin{emcppslisting}[emcppsbatch=e1]
class SalaryIsGreater  // function object constructed with a reference salary
{
    const long d_referenceSalary;

public:
    explicit SalaryIsGreater(long rs) : d_referenceSalary(rs) { }
        // construct with a reference salary, (ù{\codeincomments{rs}}ù)

    bool operator()(const Employee& e) const
        // return (ù{\codeincomments{true}}ù) if the salary for (ù{\codeincomments{Employee}}ù) (ù{\codeincomments{e}}ù) is greater than the
        // reference salary specified on construction, (ù{\codeincomments{false}}ù) otherwise
    {
        return e.salary > d_referenceSalary;
    }
};
\end{emcppslisting}
    

Note that, unlike our previous \emcppsgloss[functor class]{functor classes},
\lstinline!SalaryIsGreater! has a member variable, i.e., it has
\emph{state}. This member variable must be initialized, necessitating a
constructor. Its \emcppsgloss{call operator} compares its input argument
against this member variable to compute the \emcppsgloss{predicate} value.

With these two \emcppsgloss[functor class]{functor classes} defined, we can finally
implement the simple three-step algorithm for determining the number of
employees with salaries greater than the average:

\begin{emcppslisting}[emcppsbatch=e1]
#include <algorithm>  // (ù{\codeincomments{std::count\_if}}ù)
#include <numeric>    // (ù{\codeincomments{std::accumulate}}ù)

std::size_t numAboveAverageSalaries(const std::vector<Employee>& employees)
{
    const long sum = std::accumulate(employees.begin(), employees.end(), 0L,
                                     SalaryAccumulator());

    const long average = sum / employees.size();
    return std::count_if(employees.begin(), employees.end(),
                         SalaryIsGreater(average));
}
\end{emcppslisting}
    

The first statement creates an object of the \lstinline!SalaryAccumulator!
class and passes that object to the \lstinline!std::accumulate! algorithm
to produce the sum of all of the salaries. The second statement divides
the sum by the size of the \lstinline!employees! collection to compute the
average salary. The third statement creates an object of the
\lstinline!SalaryIsGreater! class and passes it to the
\lstinline!std::count_if! algorithm to compute the result. Note that the
local variable, \lstinline!average!, is used to initialize the reference
value in the \lstinline!SalaryIsGreater! object.

We now turn our attention to a syntax that allows us to rewrite these
examples much more simply and compactly. Returning to the sorting
example, the rewrite has the name-comparison and salary-comparison
operations expressed in-place, within the call to \lstinline!std::sort!:

\begin{emcppslisting}[emcppsbatch=e1]
void sortByName2(std::vector<Employee>& employees)
{
    std::sort(employees.begin(), employees.end(),
              [](const Employee &e1, const Employee &e2)
              {
                  return e1.name < e2.name;
              });
}

void sortBySalary2(std::vector<Employee>& employees)
{
    std::sort(employees.begin(), employees.end(),
              [](const Employee &e1, const Employee &e2)
              {
                  return e1.salary < e2.salary;
              });
}
\end{emcppslisting}
    

In each case, the third argument to \lstinline!std::sort! --- beginning
with \lstinline![]! and ending with the nearest closing \lstinline!}! --- is called a
\emcppsgloss[lambda expressions]{lambda expression}. Intuitively, for this case, one can think of
a \emcppsgloss[lambda expressions]{lambda expression} as an \emph{operation} that can be invoked
as a callback by the algorithm. The example shows a function-style
parameter list --- matching that expected by the \lstinline!std::sort!
algorithm --- and a function-like body that computes the needed
predicate. Using \emcppsgloss{lambda expressions}, a developer can express a
desired operation directly at the point of use rather than defining it
elsewhere in the program.

The compactness and simplicity afforded by the use of \emcppsgloss{lambda
expressions} is even more evident when we rewrite the average-salaries
example:

\begin{emcppslisting}[emcppsbatch=e1]
std::size_t numAboveAverageSalaries2(const std::vector<Employee>& employees)
{
    const long sum = std::accumulate(employees.begin(), employees.end(), 0L,
                                     [](long currSum, const Employee& e)
                                     {
                                         return currSum + e.salary;
                                     });

    const long average = sum / employees.size();
    return std::count_if(employees.begin(), employees.end(),
                         [average](const Employee& e)
                         {
                             return e.salary > average;
                         });
}
\end{emcppslisting}
    

The first \emcppsgloss[lambda expressions]{lambda expression}, above, specifies the operation for
adding another salary to a running sum. The second \emcppsgloss[lambda expressions]{lambda
expression} returns true if the \lstinline!Employee! argument, \lstinline!e!,
has a salary that is larger than \lstinline!average!, which is a local
variable \emph{captured} by the \emcppsgloss[lambda expressions]{lambda expression}. A
\emcppsgloss{lambda capture} is a set of local variables that are usable
within the body of the \emcppsgloss[lambda expressions]{lambda expression}, effectively making
the \emcppsgloss[lambda expressions]{lambda expression} an extension of the immediate
environment. We will look at the syntax and semantics of \emcppsgloss[lambda capture]{lambda
captures} in more detail in {Parts of a Lambda Expression}.

Note that the lambda expressions replaced a significant portion of code
that was previously expressed as separate functions or \emcppsgloss{functor}
classes. The fact that some of that code reduction is in the form of
documentation (comments) increases the appeal of \emcppsgloss{lambda
expressions} to a surprising degree. Creating a named entity such as a
function or class imposes on the developer the responsibility to give
that entity a meaningful name and sufficient documentation for a future
human reader to understand its \emph{abstract} purpose, outside the
context of its use, even for one-off, non-reusable entities. Conversely,
when an entity is defined right at the point of use, it might not need a
name at all, and it is often self-documenting, as in both the sorting
and average-salaries examples above. Both the original creation and
maintenance of the code is simplified.

\subsubsection[Parts of a lambda expression]{Parts of a lambda expression}\label{parts-of-a-lambda-expression}

A \emcppsgloss[lambda expressions]{lambda expression} has a number of parts and subparts, many of
which are optional. For exposition purposes, let's look at a sample
\emcppsgloss[lambda expressions]{lambda expression} that contains all of the parts:

\begin{emcppslisting}[emcppsignore={not code}]
       introducer
     ______^______
    /             \
    [&, cap2, cap3](T1 arg1, T2 arg2) mutable noexcept -> R { /* ... */ }
     \_____ _____/ \__________________ ___________________/ \____ ____/
           V                          V                          V
        capture                   declarator                    body
\end{emcppslisting}
    

Evaluating a lambda expression creates a temporary \emcppsgloss{closure}
object of an unnamed type called the \emcppsgloss{closure type}. Each part of
a \emcppsgloss[lambda expressions]{lambda expression} is described in detail in the subsections
below.

\subsubsection[Closures]{Closures}\label{closures}

A \emcppsgloss[lambda expressions]{lambda expression} looks a lot like an unnamed function
definition, and it is often convenient to think of it that way, but a
lambda expression is actually more complex than that. First and
foremost, a \emcppsgloss[lambda expressions]{lambda expression}, as the name implies, is an
\emph{expression} rather than a \emph{definition}. The result of
evaluating a \emcppsgloss[lambda expressions]{lambda expression} is a special \emcppsgloss{function
object} called a \emcppsgloss{closure}{\cprotect\footnote{The terms
\emph{lambda} and \emph{closure} are borrowed from \emph{Lambda
Calculus}, a computational system developed by Alonzo Church in the
1930s. Many computer languages have features inspired by Lambda
Calculus, although most (including C++) take some liberties with the
terminology. See \cite{rojas15} and
 \cite{barendregt84}.}}; it is not until the
\emcppsgloss{closure} is \emph{invoked} --- which can happen immediately but
usually occurs later (e.g., as a callback) --- that the actual body of
the \emcppsgloss[lambda expressions]{lambda expression} gets evaluated.

Evaluating a \emcppsgloss[lambda expressions]{lambda expression} creates a temporary
\emcppsgloss{closure object} of an unnamed type called the \emcppsgloss{closure
type}. The \emcppsgloss{closure type} encapsulates captured variables (see\linebreak[4] 
\featureref{\locationd}{lambda-capture-expressions}) and has a \emcppsgloss{call operator} that
executes the body of the \emcppsgloss[lambda expressions]{lambda expression}. Each \emcppsgloss[lambda expressions]{lambda
expression} has a unique \emcppsgloss{closure type}, even if it is identical
to another \emcppsgloss[lambda expressions]{lambda expression} in the program. If the
\emcppsgloss[lambda expressions]{lambda expression} appears within a template, the
\emcppsgloss{closure type} for each instantiation of that template is unique.
Note, however, that, although the \emcppsgloss{closure object} is an unnamed
temporary object, it can be saved in a named variable whose type can be
queried. \emcppsgloss[closure type]{Closure types} are copy constructible and move
constructible, but they have no other constructors and have deleted
assignment operators.{\cprotect\footnote{C++17 provides default
constructors for empty-capture lambdas. Empty-capture lambdas are
  assignable in C++20.}} Interestingly, it is possible to \emph{inherit}
from a \emcppsgloss{closure type}, provided the derived class constructs its
\emcppsgloss{closure type} base class using only the default or move
constructors. This ability to derive from a \emcppsgloss{closure type} is
convenient when implementing certain library features such as
\lstinline!std::bind!, which take advantage of the empty-base optimization:

\begin{emcppslisting}
#include <utility>  // (ù{\codeincomments{std::move}}ù)

template <typename Func>
int callFunc(const Func& f) { return f(); }

void f1()
{
    int   i   = 5;
    auto  c1  = [i]{ return 2 * i; };   // OK, deduced type for (ù{\codeincomments{c1}}ù)
    using C1t = decltype(c1);           // OK, named alias for unnamed type
    C1t   c1b = c1;                     // OK, copy of (ù{\codeincomments{c1}}ù)
    auto  c2  = [i]{ return 2 * i; };   // OK, identical lambda expression
    using C2t = decltype(c2);
    C1t   c2b = c2;                     // Error, different types, (ù{\codeincomments{C1t}}ù) & (ù{\codeincomments{C2t}}ù)
    using C3t = decltype([]{/* ... */});  // Error, lambda expr within (ù{\codeincomments{decltype}}ù)

    class C1Derived : public C1t        // OK, inherit from closure type
    {
        int d_auxValue;

    public:
        C1Derived(C1t c1, int aux) : C1t(std::move(c1)), d_auxValue(aux) { }
        int aux() const { return d_auxValue; }
    };

    int ret = callFunc([i]{ return 2 * i; });  // OK, deduced arg type, (ù{\codeincomments{Func}}ù)

    c1b = c1;  // Error, assignment of closures is not allowed.
}
\end{emcppslisting}
    

The types of \lstinline!c1! and \lstinline!c2!, above, are different, even
though they are token-for-token identical. As there is no way to
explicitly name a \emcppsgloss{closure type}, we use \lstinline!auto! (in the
case of \lstinline!c1! and \lstinline!c2! in \lstinline!f1!) or template-argument
deduction (in the case of \lstinline!f! in \lstinline!callFunc!) to create
variables directly from the \emcppsgloss[lambda expressions]{lambda expression}, and we use
\lstinline!decltype! to create aliases to the types of existing closure
variables (\lstinline!C1t! and \lstinline!C2t!). Note that using
\lstinline!decltype! directly on a \emcppsgloss[lambda expressions]{lambda expression} is ill
formed, as shown with \lstinline!C3t!, because there would be no way to
construct an object of the resulting unique type. The derived class,
\lstinline!C1Derived!, uses the type alias \lstinline!C1t! to refer to its
base class. Note that its constructor forwards its first argument to the
base-class move constructor.

There is no way to specify a \emcppsgloss{closure type} prior to creating an
actual \emcppsgloss{closure object} of that type. Consequently, there is no
way to declare \lstinline!callFunc! with a parameter of the actual
\emcppsgloss{closure type} that will be passed; hence, it is declared as a
template parameter. As a special case, however, if the \emcppsgloss{lambda
capture} is \emph{empty} (i.e., the \emcppsgloss[lambda expressions]{lambda expression} begins
with \lstinline![]!; see \featureref{\locationd}{lambda-capture-expressions}), then the
\emcppsgloss{closure} is implicitly convertible to an ordinary function
pointer having the same signature as its \emcppsgloss{call operator}:

\begin{emcppslisting}
char callFunc2(char (*f)(const char*)) { return f("x"); }  // not a template

char c = callFunc2([](const char* s) { return s ? s[0] : '\0'; });
    // OK, closure argument is converted to function-pointer parameter

char d = callFunc2([c](const char* s) { /* ... */ });
    // Error, lambda capture is not empty; no conversion to function pointer
\end{emcppslisting}
    

The \lstinline!callFunc2! function takes a callback in the form of a
pointer to function. Even though it is not a template, it can be called
with a lambda argument having the same parameter types, the same return
type, and an empty \emcppsgloss{lambda capture}; the \emcppsgloss{closure object}
is converted to an ordinary pointer to function. This conversion is
\emph{not} available in the second call to \lstinline!callFunc2! because
the \emcppsgloss{lambda capture} is not empty.

Conversion to function pointer is considered a user-defined conversion
operator and thus cannot be implicitly combined with other conversions
on the same expression. It can, however, be invoked \emph{explicitly},
as needed:

\begin{emcppslisting}
using Fp2 = int(*)(int);  // function-pointer type

struct FuncWrapper
{
    FuncWrapper(Fp2) { /* ... */ }  // implicit conversion from function-pointer
    // ...
};

int f2(FuncWrapper)  { /* ... */ return 0; }
int i2 = f2([](int x) { return x; });  // Error, two user-defined conversions
int i3 = f2(static_cast<Fp2>([](int x) { return x; }));  // OK, explicit cast
int i4 = f2(+[](int x) { return x; });  // OK, forced conversion
\end{emcppslisting}
    

The first call to \lstinline!f2! fails because it would require two
implicit user-defined conversions: one from the \emcppsgloss{closure type} to
the \lstinline!Fp2! function-pointer type and one from \lstinline!Fp2! to
\lstinline!FuncWrapper!. The second call succeeds because the first
conversion is made explicit with the \lstinline!static_cast!. The third
call is an interesting shortcut that takes advantage of the fact that
unary \lstinline!operator+! is defined as the identity transformation for
pointer types. Thus, the \emcppsgloss{closure}-to-pointer conversion is
invoked for the operand of \lstinline!operator+!, which returns the
unchanged pointer, which, in turn, is converted to \lstinline!FuncWrapper!;
the first and third steps of this sequence use only one user-defined
conversion each. The Standard Library \lstinline!std::function! class
template provides another way to pass a function object of unnamed type,
one that does not require the \emcppsgloss{lambda capture} to be empty; see
\intrarefsimple{use-cases-lambda}.

The compile-time and runtime phases of defining a \emcppsgloss{closure type}
and constructing a \emcppsgloss{closure object} from a single \emcppsgloss[lambda expressions]{lambda
expression} resembles the phases of calling a function template; what
looks like an ordinary function call is actually broken down into a
compile-time instantiation and a runtime call. The \emcppsgloss{closure type}
is deduced when a \emcppsgloss[lambda expressions]{lambda expression} is encountered during
compilation. When the control flow passes through the \emcppsgloss[lambda expressions]{lambda
expression} at run time, the \emcppsgloss{closure object} is
\emph{constructed} from the list of captured local variables. In the
\lstinline!numAboveAverageSalaries! example in the {Description} section,
the \lstinline!SalaryIsGreater! class can be thought of as a
\emcppsgloss{closure type} --- created by hand instead of by the compiler ---
whereas the call to \lstinline!SalaryIsGreater(average)! is analogous to
constructing the \emcppsgloss{closure object} at run time.

Finally, the purpose of a \emcppsgloss{closure} is to be invoked. It can be
invoked immediately by supplying arguments for each of its parameters:

\begin{emcppslisting}
#include <iostream>  // (ù{\codeincomments{std::cot}}ù)
void f3()
{
    [](const char* s) { std::cout << s; }("hello world\n");
        // equivalent to (ù{\codeincomments{std::cout << "hello world$\backslash$n";}}ù)
}
\end{emcppslisting}
    

The \emcppsgloss{closure object}, in this example, is invoked immediately and
then destroyed, making the above just a complicated way to say
\lstinline!std::cout!~\lstinline!<<!~\lstinline!"hello!~\lstinline!world\n";!.
More commonly, the \emcppsgloss[lambda expressions]{lambda expression} is used as a local
function for convenience and to avoid clutter:

\begin{emcppslisting}
#include <cmath>  // (ù{\codeincomments{std::sqrt}}ù)

double hypotenuse(double a, double b)
{
    auto sqr = [](double x) { return x * x; };
    return std::sqrt(sqr(a) + sqr(b));
}
\end{emcppslisting}
    

Note that there is no way to overload calls to \emcppsgloss[closure]{closures}:

\begin{emcppslisting}
auto sqr = [](int x) { return x * x; };     // OK, store **closure** in (ù{\codeincomments{sqr}}ù)
auto sqr = [](double x) { return x * x; };  // Error, redefinition of (ù{\codeincomments{sqr}}ù)
\end{emcppslisting}
    

The most common use of a \emcppsgloss[lambda expressions]{lambda expression}, however, is as a
callback to a function template, e.g., as a functor argument to an
algorithm from the Standard Library:

\begin{emcppslisting}
#include <algorithm>  // (ù{\codeincomments{std::partition}}ù)

template <typename FwdIt>
FwdIt oddEvenPartition(FwdIt first, FwdIt last)
{
    using value_type = decltype(*first);
    return std::partition(first, last, [](value_type v) { return v % 2 != 0; });
}
\end{emcppslisting}
    

The \lstinline!oddEvenPartition! function template moves odd values to the
start of the sequence and even values to the back. The \emcppsgloss{closure
object} is invoked repeatedly within the \lstinline!std::partition!
algorithm.

\subsubsection[Lambda capture and lambda introducer]{Lambda capture and lambda introducer}\label{lambda-capture-and-lambda-introducer}

The purpose of the \emcppsgloss{lambda capture} is to make certain local
variables from the environment available to be used (or, more precisely,
\emcppsgloss{ODR-used}, which means that they are used in a
potentially-evaluated context) within the \emcppsgloss{lambda body}. Each
local variable can be \emcppsgloss{captured by copy} or \emcppsgloss{captured by
reference}. Orthogonally, each variable can be \emcppsgloss{explicitly
captured} or \emcppsgloss{implicitly captured}. When a \emcppsgloss[lambda expressions]{lambda
expression} appears within a non-static member function, the
\lstinline!this! pointer can be captured as a special case. We'll examine
each of these aspects of \emcppsgloss{lambda capture} in turn. An extension
to \emcppsgloss{lambda capture} in C++14 is discussed in \intrarefsimple{c++14-init-capture}.

Syntactically, the \emcppsgloss{lambda capture} consists of an optional
\emcppsgloss{capture default} followed by a comma-separated list of zero or
more identifiers (or the keyword \lstinline!this!), which are
\emcppsgloss{explicitly captured}. The capture default can be one of
\lstinline!=! or \lstinline!&! for \emcppsgloss[captured by copy]{capture by copy} or
\emcppsgloss[captured by reference]{capture by reference}, respectively. If there is a
\emcppsgloss{capture default}, then \lstinline!this! and any local variables in
scope that are \emcppsgloss{ODR-used} within the \emcppsgloss{lambda body} and not
\emcppsgloss{explicitly captured} will be \emcppsgloss{implicitly captured}.

\begin{emcppslisting}
void f1()
{
    int a = 0, b = 1, c = 2;
    auto c1 = [a, b]{ return a + b; };
        // (ù{\codeincomments{a}}ù) and (ù{\codeincomments{b}}ù) are explicitly captured.
    auto c2 = [&]{ return a + b; };
        // (ù{\codeincomments{a}}ù) and (ù{\codeincomments{b}}ù) are implicitly captured.
    auto c3 = [&, b]{ return a + b; };
        // (ù{\codeincomments{a}}ù) is implicitly captured and (ù{\codeincomments{b}}ù) is explicitly captured.
    auto c4 = [a]{ return a + b; }
        // Error, (ù{\codeincomments{b}}ù) is ODR-used but not captured.
}
\end{emcppslisting}
    

The Standard defines the \emcppsgloss{lambda introducer} as the
\emcppsgloss{lambda capture} together with its surrounding \lstinline![! and
\lstinline!]!. If the \emcppsgloss{lambda introducer} is an empty pair of
brackets, no variables will be captured.

\begin{emcppslisting}
auto c1 = []{ /* ... */ };  // Empty **lambda capture**
\end{emcppslisting}
    

The \emcppsgloss{lambda capture} enables access to portions of the local
stack frame. As such, only variables with \emph{automatic storage
duration} --- i.e., non-static local variables --- can be captured, as
we'll see in detail later in this section and in \emcppsgloss{lambda body}.
An \emcppsgloss{explicitly captured} variable whose name is immediately
preceded by an \lstinline!&! symbol in the \emcppsgloss{lambda capture} is
\emcppsgloss{captured by reference}; without the \lstinline!&!, it is
\emcppsgloss{captured by copy}. If the \emcppsgloss{capture default} is
\lstinline!&!, then all \emcppsgloss{implicitly captured} variables are
\emcppsgloss{captured by reference}. Otherwise, if the \emcppsgloss{capture
default} is \lstinline!=!, all \emcppsgloss{implicitly captured} variables are
\emcppsgloss{captured by copy}:

\begin{emcppslisting}
void f2a()
{
    int a = 0, b = 1;
    auto c1 = [&a]{ /* ... */ return a; };  // (ù{\codeincomments{a}}ù) captured by reference
    auto c2 = [a] { /* ... */ return a; };  // (ù{\codeincomments{a}}ù) captured by copy
    auto c3 = [a, &b] { return a + b; };
        // (ù{\codeincomments{a}}ù) is explicitly captured by copy and (ù{\codeincomments{b}}ù) is explicitly
        // captured by reference.
    auto c4 = [=]{ return a + b; };
        // (ù{\codeincomments{a}}ù) and (ù{\codeincomments{b}}ù) are implicitly captured by copy.
    auto c5 = [&]{ return &a; };
        // (ù{\codeincomments{a}}ù) is implicitly captured by reference.
    auto c6 = [&, b]{ return a * b; };
        // (ù{\codeincomments{a}}ù) is implicitly captured by reference and (ù{\codeincomments{b}}ù) is explicitly
        // captured by copy.
    auto c7 = [=, &b]{ return a * b; };
        // (ù{\codeincomments{a}}ù) is implicitly captured by copy and (ù{\codeincomments{b}}ù) is explicitly
        // captured by reference.
    auto c8 = [a]{ return a * b; };
        // Error, (ù{\codeincomments{a}}ù) is explicitly captured by copy, but (ù{\codeincomments{b}}ù) is not captured.
    auto c9 = [this]{ /* ... */ };  // Error, no (ù{\codeincomments{this}}ù) in nonmember function
}

class Class1a
{
public:
    void mf1()
    {
        auto c12 = [this]{ return this; };  // Explicitly capture (ù{\codeincomments{this}}ù).
        auto c13 = [=]   { return this; };  // Implicitly capture (ù{\codeincomments{this}}ù).
    }
};
\end{emcppslisting}
    

Redundant captures are not allowed; the same name (or \lstinline!this!)
cannot appear twice in the \emcppsgloss{lambda capture}. Moreover, if the
\emcppsgloss{capture default} is \lstinline!&!, then none of the
\emcppsgloss{explicitly captured} variables may be \emcppsgloss{captured by
reference}, and if the \emcppsgloss{capture default} is \lstinline!=!, then any
\emcppsgloss{explicitly captured} entities can be neither \emcppsgloss{explicitly
copied} variables nor \lstinline!this!{\cprotect\footnote{C++20 removed
the prohibition on explicit capture of \lstinline!this! with an
  \lstinline!=! capture default.}}:

\begin{emcppslisting}
class Class1b
{
public:
    void mf1()
    {
        int a = 0;
        auto c1 = [a, &a]{ /* ... */ }; // Error, (ù{\codeincomments{a}}ù) is captured twice.
        auto c2 = [=, a]{ /* ... */ };
            // Error, explicit capture of (ù{\codeincomments{a}}ù) by copy is redundant.
        auto c3 = [&,&a]{ /* ... */ };
            // Error, explicit capture of (ù{\codeincomments{a}}ù) by reference is redundant.
        auto c4 = [=, this]{ return this; };
            // Error, explicit capture of (ù{\codeincomments{this}}ù) with (ù{\codeincomments{=}}ù) capture default
    }
};
\end{emcppslisting}
    

We'll use the term \emph{primary variable} to refer to the block-scope
local variable outside of the \emcppsgloss[lambda expressions]{lambda expression} and
\emph{captured variable} to refer to the variable of the same name as
viewed from within the \emcppsgloss{lambda body}. For every object that is
\emcppsgloss{captured by copy}, the \emcppsgloss{lambda closure} will contain a
member variable having the same name and type, after stripping any
reference qualifier (except reference-to-function); this member variable
is initialized from the primary variable by direct initialization and is
destroyed when the \emcppsgloss{closure object} is destroyed. Any
\emcppsgloss[ODR-used]{ODR-use} of that name within the \emcppsgloss{lambda body} will refer
to the \emcppsgloss{closure}'s member variable. Thus, for an entity that is
\emcppsgloss{captured by copy}, the primary and captured variables refer to
distinct objects with distinct lifetimes. By default, the \emcppsgloss{call
operator} is \lstinline!const!, providing read-only access to members of
the \emcppsgloss{closure object} (i.e., captured variables that are
\emcppsgloss{captured by copy}); mutable (non\lstinline!const!) \emcppsgloss[call operator]{call
operators} are discussed in \intrarefsimple{lambda-declarator}:

\begin{emcppshiddenlisting}[emcppsbatch=e2]
#include <cassert>  // standard C (ù{\codeincomments{assert}}ù) macro
\end{emcppshiddenlisting}
\begin{emcppslisting}[emcppsbatch=e2]

void f3()
{
    int a = 5;
    auto c1 = [a]        // (ù{\codeincomments{a}}ù) is captured by copy.
    {
        return a;        // return value of copy of (ù{\codeincomments{a}}ù)
    };
    a = 10;              // Modify (ù{\codeincomments{a}}ù) after it was captured by (ù{\codeincomments{c1}}ù).
    assert(5 == c1());   // OK, (ù{\codeincomments{a}}ù) within (ù{\codeincomments{c1}}ù) had value from before the change.

    int& b = a;
    auto c2 = [b]        // (ù{\codeincomments{b}}ù) is (ù{\codeincomments{int}}ù) (not (ù{\codeincomments{int\&}}ù)) **captured by copy**.
    {
        return b;        // return value of copy of (ù{\codeincomments{b}}ù)
    };
    b = 15;              // Modify (ù{\codeincomments{a}}ù) through reference (ù{\codeincomments{b}}ù).
    assert(10 == c2());  // OK, (ù{\codeincomments{b}}ù) within (ù{\codeincomments{c2}}ù) is a copy, not a reference.

    auto c3 = [a]
    {
        ++a;             // Error, (ù{\codeincomments{a}}ù) is (ù{\codeincomments{const}}ù) within the lambda body.
    };
}
\end{emcppslisting}
    

In the example above, the \emcppsgloss[lambda expressions]{lambda expression} is evaluated to
produce a \emcppsgloss{closure object}, \lstinline!c1!, that captures a
\emph{copy} of \lstinline!a!. Even when the primary \lstinline!a! is
subsequently modified, the captured \lstinline!a! in \lstinline!c1! remains
unchanged. When \lstinline!c1! is invoked, the \emcppsgloss{lambda body} returns
the \emph{copy}, which still has the value 5. The same applies to
\lstinline!c2!, but note that the copy of \lstinline!b! is \emph{not a
reference} even though \lstinline!b! is a reference. Thus, the copy of
\lstinline!b! in \lstinline!c2! is the value of \lstinline!a! that \lstinline!b!
referred to at the time that \lstinline!c2! was created.

When a variable is \emcppsgloss{captured by reference}, the captured variable
is simply an alias to the primary variable; no copies are made. It is,
therefore, possible to modify the primary variable and/or take its
address within the \emcppsgloss{lambda body}:

\begin{emcppshiddenlisting}[emcppsbatch=e3]
#include <cassert>  // standard C (ù{\codeincomments{assert}}ù) macro
\end{emcppshiddenlisting}
\begin{emcppslisting}[emcppsbatch=e3]
void f4()
{
    int a = 5;
    auto c1 = [&a]      // (ù{\codeincomments{a}}ù) is **captured by reference**.
    {
        a = 10;         // Modify (ù{\codeincomments{a}}ù) through the captured variable.
        return &a;      // return address of captured (ù{\codeincomments{a}}ù)
    };
    assert(c1() == &a); // OK, primary and captured (ù{\codeincomments{a}}ù) have the same address.
    assert(10 == a);    // OK, primary (ù{\codeincomments{a}}ù) is now 10.

    int& b = a;
    auto c2 = [&b]      // (ù{\codeincomments{b}}ù) is **captured by reference**
    {
        return &b;      // return address of captured (ù{\codeincomments{b}}ù)
    };
    assert(c2() == &b); // OK, primary and captured (ù{\codeincomments{b}}ù) have the same address.
    assert(c2() == &a); // OK, captured (ù{\codeincomments{b}}ù) is an alias for (ù{\codeincomments{a}}ù).
}
\end{emcppslisting}
    

In contrast to the \lstinline!f3! example, the \lstinline!c1! \emcppsgloss{closure
object} above does \emph{not} hold a copy of the captured variable,
\lstinline!a!, though the compiler may choose to define a member of type
\lstinline!int&! that refers to \lstinline!a!. Within the \emcppsgloss{lambda
body}, modifying \lstinline!a! modifies the primary variable, and taking
its address returns the address of the primary variable, i.e., the
captured variable is an alias for the primary variable. With respect to
variables that are \emcppsgloss{captured by reference}, the \emcppsgloss{lambda
body} behaves very much as though it were part of the surrounding block.
The lifetime of a variable that is \emcppsgloss{captured by reference} is the
same as that of the primary variable (since they are the same). In
particular, if a copy of the \emcppsgloss{closure object} outlives the
primary variable, then the captured variable becomes a \emph{dangling
reference}; see \intrarefsimple{potential-pitfalls-lambda}.

If \lstinline!this! appears in the \emcppsgloss{lambda capture}, then (1) the
current \lstinline!this! pointer is \emcppsgloss{captured by copy} and (2)
within the \emcppsgloss{lambda body}, member variables accessible through
\lstinline!this! can be used without prefixing them with \lstinline!this->!,
as though the \emcppsgloss{lambda body} were an extension of the surrounding
member function. The \emcppsgloss{lambda body} cannot refer to the
\emcppsgloss{closure} directly; the captured \lstinline!this! does not point to
the \emcppsgloss{closure} but to the \lstinline!*this! object of the function
within which it is defined:

\begin{emcppshiddenlisting}[emcppsbatch=e4]
#include <cassert>  // standard C (ù{\codeincomments{assert}}ù) macro
\end{emcppshiddenlisting}
\begin{emcppslisting}[emcppsbatch=e4]
struct Class1
{
    int d_value;

public:
    // ...
    void mf() const
    {
        auto c1 = []{ return *this; };        // Error, (ù{\codeincomments{this}}ù) is not captured.
        auto c2 = []{ return d_value; };      // Error, (ù{\codeincomments{this}}ù) is not captured.
        auto c3 = [d_value]{ /* ... */; };    // Error, cannot capture member
        auto c4 = [this]{ return this; };     // OK, returns (ù{\codeincomments{this}}ù)
        auto c5 = [this]{ return d_value; };  // OK, returns (ù{\codeincomments{this->d\_value}}ù)
        assert(this == c4());                 // OK, captured (ù{\codeincomments{this}}ù) is (ù{\codeincomments{Class1}}ù).
    }
};
\end{emcppslisting}
    

Note that \lstinline!c4! returns \lstinline!this!, which is the address of the
\lstinline!Class1! for which \lstinline!mf! was called. This is one way in
which the \emcppsgloss{closure type} is different from a named
\emcppsgloss{functor type} --- there is no way for an object of
\emcppsgloss{closure type} to refer to itself directly. Because the
\emcppsgloss{closure type} is unnamed and because it does not supply its own
\lstinline!this! pointer, it is difficult (but not impossible) to create a
\emph{recursive} \emcppsgloss[lambda expressions]{lambda expression}; see \textbf{Usage examples [there is no section with this name] }.

If \lstinline!this! is captured (implicitly or explicitly), the
\emcppsgloss{lambda body} will behave much like an extension of the member
function in which the \emcppsgloss[lambda expressions]{lambda expression} appears, with direct
access to the class's members:

\begin{emcppshiddenlisting}[emcppsbatch=e5]
#include <algorithm>  // (ù{\codeincomments{std::count\_if}}ù)
#include <vector>     // (ù{\codeincomments{std::vector}}ù)
\end{emcppshiddenlisting}
\begin{emcppslisting}[emcppsbatch=e5]

class Class2
{
    int d_value;

public:
    std::size_t mem(const std::vector<int>& v) const
    {
        auto f = []{ return d_value; };
            // Error, (ù{\codeincomments{this}}ù) not captured; can't see (ù{\codeincomments{d\_value}}ù).
        return std::count_if(v.begin(), v.end(),
                             [this](int element){ return element < d_value; });
            // OK, uses (ù{\codeincomments{this->d\_value}}ù).
    }
};
\end{emcppslisting}
    

Note that capturing \lstinline!this! does not copy the class object that it
points to; the original \lstinline!this! and the captured \lstinline!this!
will point to the same object:

\begin{emcppshiddenlisting}[emcppsbatch=e6]
#include <cassert>  // standard C (ù{\codeincomments{assert}}ù) macro
\end{emcppshiddenlisting}
\begin{emcppslisting}[emcppsbatch=e6]
class Class3
{
    int d_value;

public:
    void mf()
    {
        auto c1 = [this]{ ++d_value; };  // increment (ù{\codeincomments{this->d\_value}}ù)
        d_value = 1;
        c1();
        assert(2 == d_value);            // change to (ù{\codeincomments{d\_value}}ù) is visible
    }
};
\end{emcppslisting}
    

Here, we captured \lstinline!this! in \lstinline!c1! but then proceeded to
modify the object pointed to by \lstinline!this! within the \emcppsgloss{lambda
body}.{\cprotect\footnote{In C++17, it is possible to capture
\lstinline!*this!, which results in the entire class object being copied,
  not just the \lstinline!this! pointer.}}

A \emcppsgloss[lambda expressions]{lambda expression} can occur wherever other expressions can
occur, including within other \emcppsgloss{lambda expressions}. The set of
entities that can be captured in a valid \emcppsgloss[lambda expressions]{lambda expression}
depends on the surrounding scope. A \emcppsgloss[lambda expressions]{lambda expression} that does
not occur immediately within \emcppsgloss{block scope} cannot have a
\emcppsgloss{lambda capture}:

\begin{emcppslisting}
namespace ns1
{
    int v = 10;
    int w = [v]{ /* ... */ return 0; }();
        // Error, capture in global/namespace scope

    void f4(int a = [v]{ return v; }());  // Error, capture in default argument
}
\end{emcppslisting}
    

When a \emcppsgloss[lambda expressions]{lambda expression} occurs in block scope, it can capture
any local variables with \emph{automatic} (i.e., non-static) storage
duration in its \emcppsgloss{reaching scope}. The Standard defines the
\emcppsgloss{reaching scope} of the \emcppsgloss[lambda expressions]{lambda expression} as the set of
enclosing scopes up to and including the innermost enclosing function
and its parameters. Static variables can be used without capturing them;
see \intrarefsimple{lambda-body}:

\begin{emcppslisting}
void f5(const int& a)
{
    int b = 2 * a;
    if (a)
    {
        int c;
        // ...
    }
    else
    {
               int d = 4 * a;
        static int e = 10;

        auto c1 = [a]{ /* ... */ };    // OK, capture argument (ù{\codeincomments{a}}ù) from (ù{\codeincomments{f5}}ù).
        auto c2 = [=]{ return b; };  // OK, implicitly capture local (ù{\codeincomments{b}}ù).
        auto c3 = [&c]{ /* ... */ };   // Error, (ù{\codeincomments{c}}ù) is not in **reaching scope**.
        auto c4 = [&]{ d += 2; };    // OK, implicitly capture local (ù{\codeincomments{d}}ù).
        auto c5 = [e]{ /* ... */ };    // Error, (ù{\codeincomments{e}}ù) has static duration.
    }

    struct LocalClass
    {
        void mf()
        {
            auto c6 = [b]{ /* ... */ };  // Error, (ù{\codeincomments{b}}ù) not in **reaching scope**
        }
    };
}
\end{emcppslisting}
    

The \emcppsgloss{reaching scope} of the \emcppsgloss{lambda expressions} for
\lstinline!c1! through \lstinline!c5!, above, includes the local variable
\lstinline!d! in the \lstinline!else! block, \lstinline!b! in the surrounding
function block, and \lstinline!a! from \lstinline!f5!'s arguments. The local
variable, \lstinline!c!, is not in their \emcppsgloss{reaching scope} and cannot
be captured. Although \lstinline!e! \emph{is} in their \emcppsgloss{reaching
scope}, it cannot be captured because it does not have automatic storage
duration. Finally, the \emcppsgloss[lambda expressions]{lambda expression} for \lstinline!c6! is
within a member function of a local class. Its \emcppsgloss{reaching scope}
ends with the innermost function, \lstinline!LocalClass::mf!, and does not
include the surrounding block that includes \lstinline!a! and \lstinline!b!.

Only when the innermost enclosing function is a non-static class member
function can \lstinline!this! be captured:

\begin{emcppslisting}
void f5()
{
    auto c1 = [this]{ /* ... */ };  // Error, (ù{\codeincomments{f5}}ù) is not a member function.
}

class Class3
{
    static void mf1()
    {
        auto c2 = [this]{ /* ... */ };  // Error, (ù{\codeincomments{mf1}}ù) is static.
    }

    void mf2()
    {
        auto c3 = [this]{ /* ... */ };  // OK, (ù{\codeincomments{mf2}}ù) is non-static member function

        struct LocalClass
        {
            static void mf3()
            {
                auto c4 = [this]{ /* ... */ };
                    // Error, innermost function, (ù{\codeincomments{mf3}}ù), is static
            }
        };
    }
};
\end{emcppslisting}
    

When a \emcppsgloss[lambda expressions]{lambda expression} is enclosed within another
\emcppsgloss[lambda expressions]{lambda expression}, then the \emcppsgloss{reaching scope} includes
all of the intervening \emcppsgloss[lambda body]{lambda bodies}. Any variable captured
(implicitly or explicitly) by the inner \emcppsgloss[lambda expressions]{lambda expression} must
be either defined or captured by the enclosing lambda expression:

\begin{emcppslisting}
void f6()
{
    int a, b, c;
    const char* d;
    auto c1 = [&a]                   // capture (ù{\codeincomments{a}}ù) from function block
    {
        int d;                        // local definition of (ù{\codeincomments{d}}ù) hides outer def
        auto c2 = [&a]{ /* ... */ };  // OK, (ù{\codeincomments{a}}ù) is captured in enclosing lambda
        auto c3 = [d]{ /* ... */ };   // OK, capture (ù{\codeincomments{int d}}ù) from enclosing
        auto c4 = [&]{ return d; };   // OK,    "       "     "      "
        auto c5 = [b]{ /* ... */ };   // Error, (ù{\codeincomments{b}}ù) is not captured in enclosing
    };
    auto c6 = [=]
    {
        auto c7 = [&]{ return b; };
            // OK, ODR-use of (ù{\codeincomments{b}}ù) causes implicit capture in (ù{\codeincomments{c7}}ù) and (ù{\codeincomments{c6}}ù).
        auto c8 = [&d]{ return &d; };
            // (ù{\codeincomments{d}}ù) is captured by copy in (ù{\codeincomments{c6}}ù); (ù{\codeincomments{c8}}ù) returns address of copy
    };
}
\end{emcppslisting}
    

Note that there are two variables named \lstinline!d!: one at function
scope and one within the body of the first \emcppsgloss[lambda expressions]{lambda expression}.
Following normal rules for unqualified name lookup, the inner
\emcppsgloss{lambda expressions} used to initialize \lstinline!c3! and
\lstinline!c4! capture the \emph{inner} \lstinline!d! (of type \lstinline!int!),
not the \emph{outer} \lstinline!d! (of type \lstinline!const!~\lstinline!char*!).
Because it is not captured, primary variable \lstinline!b! is
\emph{visible} but not \emph{usable} --- an important distinction that
we'll discuss in \intrarefsimple{lambda-body} --- within the body of \lstinline!c1! and
cannot, therefore, be captured by \lstinline!c5!.

The \emcppsgloss{lambda body} for \lstinline!c7! \emcppsgloss[ODR-used]{ODR-uses} \lstinline!b!,
thus causing it to be \emcppsgloss{implicitly captured}. This capture by
\lstinline!c7! constitutes an \emcppsgloss[ODR-used]{ODR-use} of \lstinline!b! within the
enclosing \emcppsgloss[lambda expressions]{lambda expression}, \lstinline!c6!, in turn causing
\lstinline!b! to be \emcppsgloss{implicitly captured} by \lstinline!c6!. In this
way, a single \emcppsgloss[ODR-used]{ODR-use} can trigger a \emph{chain} of
\emcppsgloss[implicitly captured]{implicit captures} from an enclosed \emcppsgloss[lambda expressions]{lambda expression}
through its enclosing \emcppsgloss{lambda expressions}. Critically, when a
variable is \emcppsgloss{captured by copy} in one \emcppsgloss[lambda expressions]{lambda expression},
any enclosed \emcppsgloss{lambda expressions} that capture the same name will
capture the \emph{copy}, not the primary variable, as we see in the
\emcppsgloss[lambda expressions]{lambda expression} for \lstinline!c8!.

Note that, when a variable is named in a \emcppsgloss{lambda capture}, it
isn't automatically \emph{captured}. A variable is not captured unless
it is \emcppsgloss{ODR-used} within the \emcppsgloss[lambda expressions]{lambda expression}:

\begin{emcppslisting}
void f7()
{
    int       a = 0;
    int const b = 2;
    auto c1 = [a]{ return 2 * a; };      // OK, (ù{\codeincomments{a}}ù) is explicitly captured.
    auto c2 = [a]{ return 0; };          // Warning, no uses of (ù{\codeincomments{a}}ù)
    auto c3 = [a]{ return sizeof(a); };  // Warning, (ù{\codeincomments{sizeof(a)}}ù) isn't an ODR-use
    auto c4 = [b]{ return b; };          // Warning, value of (ù{\codeincomments{b}}ù) isn't an ODR-use
    auto c5 = [&b]{ return &b; };        // OK, address of (ù{\codeincomments{b}}ù) is an ODR-use
}
\end{emcppslisting}
    

In the above example, the \emcppsgloss{lambda body} for \lstinline!c1! contains
an \emcppsgloss[ODR-used]{ODR-use} of \lstinline!a! and thus captures \lstinline!a!.
Conversely, \lstinline!c2! does \emph{not} capture \lstinline!a! because the
\emcppsgloss{lambda body} for \lstinline!c2! does not contain an
\emcppsgloss[ODR-used]{ODR-use} of \lstinline!a!; most compilers will issue a warning
diagnostic about the superfluous presence of \lstinline!a! in the
\emcppsgloss{lambda capture} for \lstinline!c2!. The case of \lstinline!c3! is a
bit more subtle. Although \lstinline!a! is \emph{used} within \lstinline!c3!,
it is not \emcppsgloss{ODR-used} --- i.e., it is not used in a
potentially-evaluated context because \lstinline!sizeof! does not evaluate
its argument --- so the warning is the same as for \lstinline!c2!; see
\intrarefsimple{potential-pitfalls-lambda}. The last two cases are a bit more subtle: The use of the
\emph{value} of a \lstinline!const! variable (in \lstinline!c4!) is \emph{not}
an \emcppsgloss[ODR-used]{ODR-use} of that variable, whereas the use its \emph{address}
(in \lstinline!c5!) \emph{is} an \emcppsgloss[ODR-used]{ODR-use}.

Finally, a \emcppsgloss{lambda capture} within a \emcppsgloss{variadic function
template} (see \featureref{\locationc}{variadictemplate}) may contain a
\emcppsgloss[parameter pack]{parameter pack expansion}:

\begin{emcppslisting}
#include <utility>  // (ù{\codeincomments{std::forward}}ù)

template <typename... ArgTypes>
int f8(const char* s, ArgTypes&&... args);

template <typename... ArgTypes>
int f9(ArgTypes&&... args)
{
    const char* s = "Introduction";
    auto c1 = [=]{ return f8(s, args...); };  // OK, (ù{\codeincomments{args...}}ù) captured by copy
    auto c2 = [s,&args...]{ return f8(s, std::forward<ArgTypes>(args)...); };
        // OK, explicit capture of (ù{\codeincomments{args...}}ù) by reference
}
\end{emcppslisting}
    

In the example above, the variadic arguments to \lstinline!f9! are
\emcppsgloss{implicitly captured} using \emcppsgloss[captured by copy]{capture by copy} in the first
\emcppsgloss[lambda expressions]{lambda expression}. This means that, regardless of the
\emcppsgloss{value category} (\romeovalue{rvalue}, \romeovalue{lvalue}, and so on) of the
original arguments, the captured variables are all \romeovalue{lvalue} members
of the resulting \emph{closure}. Conversely, the second \emcppsgloss[lambda expressions]{lambda
expression} captures the set of arguments using \emcppsgloss[captured by reference]{capture by
reference}, again resulting in captured variables that are
\romeovalue{lvalues}. The \lstinline!ArgTypes! \emcppsgloss[parameter pack]{parameter pack expansion}
designates a list of \emph{types}, not \emph{variables}, and does not,
therefore, need to be captured to be used within the \emcppsgloss[lambda expressions]{lambda
expression}, nor would it be valid to attempt to capture it. Because
\lstinline!ArgTypes! is specified using a forwarding reference
(\lstinline!&&!, see \featureref{\locationc}{forwardingref}), the Standard
Library function, \lstinline!std::forward!, can be used to cast the
captured variables to the \emcppsgloss{value category} of their corresponding
arguments.

\subsubsection[C++14 init capture]{C++14 init capture}\label{c++14-init-capture}

\textbf{TODO VR: this subsection shouldn't be here, we have a specific C++14
feature `lambdacapture' for this stuff.}

Each item in a C++11 \emcppsgloss{lambda capture} is either a \emcppsgloss{capture
default} or a \emcppsgloss{simple capture} consisting of the name of a local
variable, either by itself (for \emcppsgloss[captured by copy]{capture by copy}) or preceded by
an \lstinline!&! (for \emcppsgloss[captured by reference]{capture by reference}). C++14 introduces
another possibility, an \emcppsgloss{init capture}, consisting of a variable
name and an initializer, which creates a new captured variable
initialized to an arbitrary expression. The initializer can be either
preceded by an \lstinline!=! token or can be a braced initialization (see
\featureref{\locationc}{bracedinit}). The newly defined variable does
not necessarily share the name or type of a primary local variable:

\begin{emcppslisting}
void f1(int a, bool bits[])
{
    double g(int);

    int b;
    auto c1 = [i{5}]{ /* ... */ };        // Define (ù{\codeincomments{int i = 5}}ù).
    auto c2 = [b=bits[a]]{ /* ... */ };   // Define (ù{\codeincomments{bool b}}ù) = copy of (ù{\codeincomments{bits[a]}}ù).
    auto c3 = [&r=a, b]{ /* ... */ };     // (ù{\codeincomments{int\& r}}ù) = reference to (ù{\codeincomments{a}}ù). Copy (ù{\codeincomments{b}}ù).
    auto c4 = [&, p=bits+1]{ *p = !a; };  // (ù{\codeincomments{bool* p}}ù) = pointer to (ù{\codeincomments{bits[1]}}ù).
    auto c5 = [x=g(a)]{ return x; };      // (ù{\codeincomments{double x = g(a)}}ù).
}
\end{emcppslisting}
    

In the \emcppsgloss[lambda expressions]{lambda expression} for \lstinline!c1!, above, the
\emcppsgloss{init capture} defines a new variable, \lstinline!i!, initialized
with the value 5. Within the \emcppsgloss{lambda body}, this \lstinline!i! is
indistinguishable from any other variable captured by the
\emcppsgloss{closure}, but, outside of the \emcppsgloss{lambda body}, it differs
from a \emcppsgloss{simple capture} in that it does not capture a local
variable. The \emcppsgloss{lambda capture} for \lstinline!c2! similarly defines
a new variable, \lstinline!b!, initialized from an expression involving
\lstinline!bits! and \lstinline!a!, but does not capture either of them. Once
captured, \lstinline!bits[a]! can change without affecting the value of
\lstinline!b!. An \emcppsgloss{init capture} can also define a variable of
\emph{reference} type, as shown in the \emcppsgloss{init capture} for
\lstinline!c3!. The \emcppsgloss{lambda capture} for \lstinline!c3! also shows an
\emcppsgloss{init capture} mixed in with \emcppsgloss[simple capture]{simple captures}. Note,
however, that the \emcppsgloss{capture default}, if any, has no effect on the
\emcppsgloss{init capture}, as shown in the \emcppsgloss[lambda expressions]{lambda expression} for
\lstinline!c4!. The \emcppsgloss{init capture} for \lstinline!c5! shows an
arbitrary expression being captured in this the return value of a
function call.

The variable defined in an \emcppsgloss{init capture} is defined as if by the
declaration:

\begin{emcppslisting}[emcppsignore={pseudocode}]
(ù{\codeincomments{auto}}ù) *init-capture* (ù{\codeincomments{;}}ù)
\end{emcppslisting}
    

The hypothetical variable created by such a definition is unique and
separate from any similarly named variable in the environment. This
uniqueness allows the same name to appear on both the left and right of
the \lstinline!=! symbol:

\begin{emcppslisting}
#include <string>   // (ù{\codeincomments{std::string}}ù)
#include <utility>  // (ù{\codeincomments{std::move}}ù)

void f2(std::string s)
{
   float a = 1.2;
   auto c1 = [&s=s]{ /* ... */ };            // effectively capture by reference
   auto c2 = [a=static_cast<double>(a)]{ /* ... */ };
   auto c3 = [s=std::move(s)]{ /* ... */ };  // effectively capture by move
   std::string s2 = s;                     // BAD IDEA, (ù{\codeincomments{s}}ù) is moved from
}
\end{emcppslisting}
    

In all of the \emcppsgloss{lambda expressions} above, an \emcppsgloss{init
capture} defines a variable whose name shadows one in the environment.
In fact, the first use, in \lstinline!c1!, defines a captured variable,
\lstinline!s!, that is a reference to the argument variable by the same
name, yielding a behavior within the \emcppsgloss{lambda body} that is
essentially indistinguishable from normal \emcppsgloss[captured by reference]{capture by reference}.
The second \emcppsgloss[lambda expressions]{lambda expression} copies the local variable,
\lstinline!a!, into a captured variable such that, within the
\emcppsgloss{lambda body}, the variable \lstinline!a! is a \lstinline!double!.
Finally, the \emcppsgloss{lambda capture} for \lstinline!c3! creates a captured
variable, \lstinline!s!, initialized from the argument \lstinline!s! using the
\lstinline!std::string! \emph{move constructor} (see \featureref{\locationc}{Rvalue-References}), simulating something that many
considered to be missing in C++11: capture by move. Note, however, that
after constructing the \lstinline!c3! \emcppsgloss{closure}, the local variable,
\lstinline!s!, is in a \emph{moved-from} state and thus has an unspecified
value, even if \lstinline!c3! is never invoked.

In C++14, an \emcppsgloss{init capture} cannot be a \emcppsgloss[parameter pack]{parameter pack
expansion}.{\cprotect\footnote{A syntax for \emcppsgloss[parameter pack]{parameter pack
expansion} of \emcppsgloss[init capture]{init captures} was introduced in C++20:

\begin{emcppslisting}[style=footcode]
template <typename T> class X { /* ... */ };
template <typename T> X<T> f3(T&&);

template <typename... ArgTypes>
void f4(ArgTypes&&... args)
{
    auto c1 = [...x=f3(std::forward<ArgTypes>(args))]{ /* ... */ };
        // Error in C++14.  OK in C++20
}
\end{emcppslisting}
      }}

\subsubsection[Lambda declarator]{Lambda declarator}\label{lambda-declarator}

The \emcppsgloss{lambda declarator} looks a lot like a function declaration
and is effectively the declaration of the \emcppsgloss{closure type}'s
\emcppsgloss{call operator}. The \emcppsgloss{lambda declarator} comprises the
\emcppsgloss{call operator}'s parameter list, mutability, exception
specification, and return type:

\begin{emcppslisting}[emcppsignore={not code}]
[/* ... */](T1 arg1, T2 arg2) mutable   noexcept(/* ... */) -> RetType { /* ... */ }
           \________ _______/ \__ __/   \_______ _______/   \_____ ___/
                    V            V              V                 V
            parameter list   mutability   exception spec     return type
           \___________________________ _____________________________/
                                       V
                               lambda declarator
\end{emcppslisting}
    

Although the \emcppsgloss{lambda declarator} looks very similar to a function
declaration, we cannot forward declare any part of a \emcppsgloss[lambda expressions]{lambda
expression}; we can only define it.

The entire \emcppsgloss{lambda declarator} is optional. However, if
\emph{any} part is present, the parameter list must be present (even if
it declares no parameters):

\begin{emcppslisting}
auto c1 = [](int x) noexcept { /* ... */ };  // OK, param list and exception spec
auto c2 = []() -> int { return 5; };         // OK, with ret type empty param list
auto c3 = [] -> double { /* ... */ };        // Error, ret type with no param list
\end{emcppslisting}
    

The parameter list for a \emcppsgloss[lambda expressions]{lambda expression} is the same as a
parameter list for a function declaration, with minor modifications.

\begin{enumerate}
\item{A parameter is not permitted to have the same name as an explicitly-captured variable:

\begin{emcppslisting}
void f1()
{
    int a;
    auto c1 = [a](short* a){ /* ... */ };  // Error, parameter shadows captured (ù{\codeincomments{a}}ù).
    auto c2 = [](short* a){ /* ... */ };   // OK, parameter hides local (ù{\codeincomments{a}}ù).
    auto c3 = [=](short* a){ /* ... */ };  // OK, local (ù{\codeincomments{a}}ù) is not captured.
}
\end{emcppslisting} 

In the definition of \lstinline!c1!, the \emcppsgloss[lambda expressions]{lambda expression}
\emcppsgloss[explicitly captured]{explicitly captures} \lstinline!a!, then improperly tries to
declare a parameter by the same name. When \lstinline!a! is not captured,
as in the \emcppsgloss[lambda expressions]{lambda expression} for \lstinline!c2!, having a parameter
named \lstinline!a! does not pose a problem; within the \emcppsgloss{lambda
body}, the declaration of \lstinline!a! in the parameter list will prevent
name lookup from finding the declaration in the enclosing scope. The
situation with \lstinline!c3! is essentially the same as for \lstinline!c2!;
because name lookup finds \lstinline!a! in the parameter list rather than
the enclosing scope, it does not attempt to capture it.}

\item{In C++11, none of the parameters may have default arguments. This restriction does not apply to C++14 and after:

\begin{emcppslisting}
auto c4 = [](int x, int y = 0){ /* ... */ };  // Error in C++11.  OK in C++14.
\end{emcppslisting}
}

\item{If the type of any of the parameters contains the keyword \lstinline!auto!, then the \emcppsgloss[lambda expressions]{lambda expression} becomes a \emcppsgloss{generic lambda}; see \featureref{\locationd}{genericlambda}. Everything in this chapter applies to \emcppsgloss{generic lambda} as well as regular \emcppsgloss{lambda expressions}, so it is recommended that you read the rest of this chapter before moving on to the \emcppsgloss[generic lambda]{generic lambdas} feature.}
\end{enumerate}

Note that, unlike the \emcppsgloss{lambda capture}, the parameter list is
usually dictated by the \emph{client} of a \emcppsgloss[lambda expressions]{lambda expression}
rather than by its author. Moreover, the \emcppsgloss{lambda capture} is
evaluated only once when the \emcppsgloss{closure} is created, whereas the
parameter list is bound to actual arguments each time the \emcppsgloss{call
operator} is invoked:

\begin{emcppslisting}[emcppserrorlines={22,24}]
#include <iostream>  // (ù{\codeincomments{std::cout}}ù)
#include <vector>    // (ù{\codeincomments{std::vector}}ù)

template <typename InputIter, typename Func>
void applyToEveryOtherElement(InputIter start, InputIter last, Func f) 
    // For elements in the range (ù{\codeincomments{[start, last)}}ù), invoke (ù{\codeincomments{f}}ù) on the first
    // element, skip the second element, etc., alternating between calling (ù{\codeincomments{f}}ù)
    // and skipping elements.
{
    while (start != last)
    {
        f(*start++);                     // Process one element.
        if (start != last) { start++; }  // Skip one element.
    }
}

void f2(const std::vector<float>& vec)
{
    std::size_t size = vec.size();
    applyToEveryOtherElement(vec.begin(), vec.end(),
                [](float x){ /* ... */ });         // OK, one (ù{\codeincomments{float}}ù) parameter
    applyToEveryOtherElement(vec.begin(), vec.end(),
                [](float x, int y){ /* ... */ });  // Error, too many parameters
    applyToEveryOtherElement(vec.begin(), vec.end(),
                [size](){ /* ... */ });            // Error, too few parameters
    applyToEveryOtherElement(vec.begin(), vec.end(),
                [size](double x){ /* ... */ });    // OK, convertible from (ù{\codeincomments{float}}ù)
}
\end{emcppslisting}
    

In the above definition of \lstinline!applyToEveryOtherElement!, the
callable argument, \lstinline!f!, is applied to half of the elements of the
input range and has the \emcppsgloss{closure type} resulting from a
\emcppsgloss[lambda expressions]{lambda expression}. In this example, therefore, each
instantiation of \lstinline!applyToEveryOtherElement! calls its \lstinline!f!
parameter multiple times with a single argument of type \lstinline!float!.
In the first call to \lstinline!applyToEveryOtherElement!, the
\emcppsgloss{lambda closure} has a parameter list consisting of a single
parameter of type \lstinline!float! and is thus compatible with the
expected signature of \lstinline!f!. The second and third calls to
\lstinline!applyToEveryOtherElement! supply a \emcppsgloss{lambda closure} with
too many and too few parameters, respectively, resulting in a
compilation error at the point where \lstinline!f! is called. The last call
to \lstinline!applyToEveryOtherElement! supplies a \emcppsgloss{lambda closure}
that takes a single argument of type \lstinline!double!. Since an argument
of type \lstinline!float! is convertible to \lstinline!double!, this
\emcppsgloss[lambda expressions]{lambda expression} is also a valid argument to
\lstinline!applyToEveryOtherElement!. Note that the presence or absence of
a \emcppsgloss{lambda closure} makes no difference to the validity of the
\emcppsgloss[lambda expressions]{lambda expression} from the point of view of the client
function.

The \lstinline!mutable! keyword, if present, indicates that the
\emcppsgloss{call operator} for the \emcppsgloss{closure type} should \emph{not}
be \lstinline!const!. Recall that a normal class member function can modify
the class's members if not declared \lstinline!const!. The \emcppsgloss{call
operator} is just an ordinary member function in this regard:

\begin{emcppslisting}
class Class1
{
    int d_value;

public:
    // ...
    void operator()(int v)       { d_value = v; }  // OK, object is mutable
    void operator()(int v) const { d_value = v; }  // Error, object is (ù{\codeincomments{const}}ù)
};
\end{emcppslisting}
    

The \lstinline!const! version of \lstinline!operator()! cannot modify the
member variables of the \lstinline!Class1! object, whereas the undecorated
one can. The \emcppsgloss{call operator} for a \emcppsgloss{closure type} has the
inverse default \lstinline!const!ness: the \emcppsgloss{call operator} is
implicitly \lstinline!const! \emph{unless} the \emcppsgloss{lambda declarator}
is decorated with \lstinline!mutable!. In practice, this rule means that
member variables of the \emcppsgloss{closure object}, i.e., variables that
were \emcppsgloss{captured by copy}, are \lstinline!const! by default and cannot
be modified within the \emcppsgloss{lambda body} unless the \lstinline!mutable!
keyword is present:

% Note: this was const int, which made the capture variable const even though c2 was mutable
% We should bring this up as a pitfall/annoyance?
\begin{emcppshiddenlisting}[emcppsbatch=e7]
#include <cassert>  // standard C (ù{\codeincomments{assert}}ù) macro
\end{emcppshiddenlisting}
\begin{emcppslisting}[emcppsbatch=e7]
void f2()
{
    int a = 5;
    auto c1 = [a]()         { return ++a; };  // Error, copy of (ù{\codeincomments{a}}ù) is (ù{\codeincomments{const}}ù)
    auto c2 = [a]() mutable { return ++a; };  // OK, increment *copy* of (ù{\codeincomments{a}}ù)
    assert(6 == c2());                        // OK, captured (ù{\codeincomments{a}}ù) incremented
    assert(5 == a);                           // OK, primary (ù{\codeincomments{a}}ù) not changed
    assert(7 == c2());                        // OK, captured (ù{\codeincomments{a}}ù) incremented
}
\end{emcppslisting}
    

The two \emcppsgloss{lambda expressions} are identical except for the
\lstinline!mutable! keyword. Both use \emcppsgloss[captured by copy]{capture by copy} to capture
local variable \lstinline!a!, and both try to increment \lstinline!a!, but
only the one decorated with \lstinline!mutable! can perform that
modification. When the \emcppsgloss{call operator} on \emcppsgloss{closure object}
\lstinline!c2! is invoked, it increments the \emph{captured copy} of
\lstinline!a!, leaving the primary \lstinline!a! untouched. If \lstinline!c2()!
is invoked again, it increments its copy of \lstinline!a! a second time.
Using \emcppsgloss[captured by reference]{capture by reference} allows the primary variable to be
changed within the \emcppsgloss{lambda body} regardless of the presence or
absence of the \lstinline!mutable! keyword. Similarly, member variables
accessed through \lstinline!this! are unaffected by the \lstinline!mutable!
keyword, but they \emph{are} affected by the \lstinline!const!ness of the
surrounding member function:

\begin{emcppshiddenlisting}[emcppsbatch=e8]
#include <cassert>  // standard C (ù{\codeincomments{assert}}ù) macro
\end{emcppshiddenlisting}
\begin{emcppslisting}[emcppsbatch=e8]
class Class2
{
    int d_value;
public:
    // ...
    void mf()
    {
        d_value = 1;
        int a = 0;
        auto c1 = [&a,this]{
            a = d_value;   // OK, (ù{\codeincomments{a}}ù) is a reference to a non-(ù{\codeincomments{const}}ù) object.
            d_value *= 2;  // OK, (ù{\codeincomments{this}}ù) points to a non-(ù{\codeincomments{const}}ù) object.
        };
        c1();
        assert(1 == a && 2 == d_value);  // values updated by (ù{\codeincomments{c1}}ù)
        c1();
        assert(2 == a && 4 == d_value);  // values updated by (ù{\codeincomments{c1}}ù) again
    }

    void cmf() const
    {
        int a = 0;
        auto c2 = [=]() mutable {
            ++a;        // OK, increment mutable **captured variable**
            ++d_value;  // Error, (ù{\codeincomments{*this}}ù) is const within (ù{\codeincomments{cmf}}ù).
        };
    }
};
\end{emcppslisting}
    

The \emcppsgloss[lambda expressions]{lambda expression} for \lstinline!c1! is not decorated with
\lstinline!mutable! yet both \lstinline!a! and \lstinline!d_value! can be
modified; the first because it was \emcppsgloss{captured by reference}, and
the second because it was accessed through \lstinline!this! within a
non\lstinline!const! member function, \lstinline!mf!. Conversely, the
\emcppsgloss[lambda expressions]{lambda expression} for \lstinline!c1! cannot modify
\lstinline!d_value! even though it is declared \lstinline!mutable! because
the captured \lstinline!this! pointer points to a \lstinline!const! object
within the surrounding member function, \lstinline!cmf!.

The \emcppsgloss{lambda declarator} may include an \emcppsgloss{exception
specification}, consisting of a \lstinline!throw! or \lstinline!noexcept!
clause, after the \lstinline!mutable! decoration, if any. The syntax and
meaning of the \emcppsgloss{exception specification} is identical to that of
a normal function; see \featureref{\locatione}{noexcept-specifier}.

The return type of the \emcppsgloss{call operator} can be determined either
by a \emcppsgloss{trailing return type} or by a \emcppsgloss{deduced return type}.
Every example we have seen up to this point has used a \emcppsgloss{deduced
return type} whereby the return type of the \emcppsgloss{closure}'s
\emcppsgloss{call operator} is deduced by the type of object returned by the
return statement(s). If there are no return statements in the
\emcppsgloss{lambda body} or if the return statements have no operands, then
the return type is \lstinline!void!. If there are multiple return
statements, they must agree with respect to the return type. The rules
for a \emcppsgloss{deduced return type} are the same for a \emcppsgloss[lambda expressions]{lambda
expression} as they are in C++14 for an ordinary function; see \featureref{\locationf}{Function-Return-Type-Deduction}:

\begin{emcppslisting}
void f3()
{
    auto c1 = [](int& i){ i = 0; };   // deduced return type is (ù{\codeincomments{void}}ù)
    auto c2 = []{ return "hello"; };  // deduced return type is (ù{\codeincomments{const char*}}ù)
    auto c3 = [](bool c)              // deduced return type is (ù{\codeincomments{int}}ù)
    {
        if (c) { return 5; }
        else   { return 6; }
    };
    auto c4 = [](bool c)
    {
        if (c) { return 5; }          // deduced return type is (ù{\codeincomments{int}}ù)
        else   { return 6.0; }        // Error, (ù{\codeincomments{double}}ù) does not match (ù{\codeincomments{int}}ù).
    };
}
\end{emcppslisting}
    

All four of the above \emcppsgloss{lambda expressions} have a \emcppsgloss{deduced
return type}. The first one deduces a return type of \lstinline!void!
because the \emcppsgloss{lambda body} has no \lstinline!return! statements. The
next one deduces a return type of \lstinline!const!~\lstinline!char*! because
the string literal, \lstinline!"hello"!, decays to a
\lstinline!const!~\lstinline!char*! in that context. The third one deduces a
return type of \lstinline!int! because all of the \lstinline!return!
statements return values of type \lstinline!int!. The last one fails to
compile because the two branches return values of different
types.{\cprotect\footnote{The original C++11 Standard did not allow a
\emcppsgloss{deduced return type} for a \emcppsgloss{lambda body} containing
anything other than a single \lstinline!return! statement. This
restriction was lifted by a defect report and is no longer part of
C++11. Compiler versions that predate ratification of this defect
report might reject \emcppsgloss{lambda expressions} having multiple
  statements and a \emcppsgloss{deduced return type}.}}

If a \emcppsgloss{deduced return type} is impossible or undesirable (see
\featureref{\locationf}{Function-Return-Type-Deduction} for a description of why this feature
needs to be used with care), a \emcppsgloss{trailing return type} can be
specified (see \featureref{\locationa}{trailing-function-return-types}:

\begin{emcppshiddenlisting}[emcppsbatch=e9]
#include <utility>  // (ù{\codeincomments{std::pair}}ù)
\end{emcppshiddenlisting}
\begin{emcppslisting}[emcppsbatch=e9]
void f4()
{
    auto c1 = [](bool c) -> double {
        if (c) { return 5; }          // OK, (ù{\codeincomments{int}}ù) value converted to (ù{\codeincomments{double}}ù)
        else   { return 6.0; }        // OK, (ù{\codeincomments{double}}ù) return value
    };
    auto c2 = []() -> std::pair<int, int> {
        return { 5, 6 };              // OK, brace-initialize returned (ù{\codeincomments{pair}}ù)
    };
}
\end{emcppslisting}
    

In the first \emcppsgloss[lambda expressions]{lambda expression} above, we specify a
\emcppsgloss{trailing return type} of \lstinline!double!. The two branches of
the \lstinline!if! statement would return different types (\lstinline!int! and
\lstinline!double!), but, because the return type has been definitively
declared, the compiler converts the return values to the known return
type (\lstinline!double!). The second \emcppsgloss[lambda expressions]{lambda expression} returns a
value by brace initialization, which is insufficient for deducing a
return value. Again, the ambiguity is resolved by declaring the return
value explicitly. Note that, unlike ordinary functions, a \emcppsgloss[lambda expressions]{lambda
expression} cannot have a return type specified before the
\emcppsgloss{lambda introducer} or \emcppsgloss{lambda declarator}:

\begin{emcppslisting}
auto c5 = int [](int x){ return 0; };     // Error, return type misplaced
auto c6 = [] int (int x){ return 0; };    // Error, return type misplaced
auto c7 = [](int x) -> int{ return 0; };  // OK, trailing return type
\end{emcppslisting}
    

Attributes (see \featureref{\locationa}{attributes}) that appertain to the
\emph{type} of \emcppsgloss{call operator} can be inserted in the
\emcppsgloss{lambda declarator} just before the \emcppsgloss{trailing return
type}. If there is no \emcppsgloss{trailing return type}, the attributes can
be inserted before the open brace of the \emcppsgloss{lambda body}.
Unfortunately, these attributes do not apply to the \emcppsgloss{call
operator} itself, but to its type, ruling out some common attributes:

\begin{emcppslisting}[emcppsignore={invalid construct}]
#include <cstdlib>  // (ù{\codeincomments{std::abort}}ù)
auto c1 = []() noexcept [[noreturn]] {  // Error, (ù{\codeincomments{[[noreturn]]}}ù) on a type
    std::abort();
};
\end{emcppslisting}
    

\subsubsection[Lambda body]{Lambda body}\label{lambda-body}

Combined, the \emcppsgloss{lambda declarator} and the \emcppsgloss{lambda body}
make up the declaration and definition of an \lstinline!inline! class
member function that is the \emcppsgloss{call operator} for the
\emcppsgloss{closure type}. For the purposes of name lookup and the
interpretation of \lstinline!this!, the \emcppsgloss{lambda body} is considered
to be in the context where the \emcppsgloss[lambda expressions]{lambda expression} is evaluated
(independent of the context where the \emcppsgloss{closure}'s \emcppsgloss{call
operator} is invoked).

Critically, the set of entity names that can be used from within the
\emcppsgloss{lambda body} is not limited to captured local variables. Types,
functions, templates, constants, and so on --- just like any other
member function --- do not need to be captured and, in fact,
\emph{cannot} be captured in most cases. To illustrate, let's create a
number of entities in multiple scopes:

\begin{emcppslisting}[emcppsbatch=e10]
#include <iostream>  // (ù{\codeincomments{std::cout}}ù)

namespace ns1
{
    void f1() { std::cout << "ns1::f1" << '\n'; }
    struct Class1 { Class1() { std::cout << "ns1::Class1()" << '\n'; } };
    int g0 = 0;
}

namespace ns2
{
    void f1() { std::cout << "ns2::f1" << '\n'; }

    template <typename T>
    struct Class1 { Class1() { std::cout << "ns2::Class1()" << '\n'; } };

    int const g1 = 1;
    int       g2 = 2;

    class Class2
    {
        int        d_value;  // non-static member variable
        static int s_mem;    // static member variable

        void mf1() { std::cout << "Class2::mf1" << '\n'; }

        struct Nested { Nested() { std::cout << "Nested()" << '\n'; } };

        template <typename T>
        static void print(const T& v) { std::cout << v << '\n'; }

    public:
        explicit Class2(int v) : d_value(v) { }

        void mf2();
        void mf3();
        void mf4();
        void mf5();
    };

    int Class2::s_mem = 0;
}
\end{emcppslisting}
    

Namespace \lstinline!ns1! contains three global entities: function
\lstinline!f1!, class \lstinline!Class1!, and variable \lstinline!g0!. Namespace
\lstinline!ns2! contains global variables \lstinline!g1! and \lstinline!g2!,
function \lstinline!f1!, and classes \lstinline!Class1! and \lstinline!Class2!.
Within \lstinline!Class2!, we have non-static member variable
\lstinline!d_value!, non-static member function \lstinline!mf1!, static
member function template \lstinline!print!, and public member functions
\lstinline!mf2! through \lstinline!mf5!.

With these declarations, we first demonstrate the use of entities that
are not variables and are accessible within the scope of a
\emcppsgloss{lambda body}:

\begin{emcppslisting}[emcppsbatch=e10]
void ns2::Class2::mf2()
{
    using LocalType = const char*;

    auto c1 = []{
        // Access non-variables in scope
        f1();           // find global (ù{\codeincomments{ns2::f1}}ù) by unqualified name lookup.
        Class1<int> x1; // construct (ù{\codeincomments{ns2::Class1<int>}}ù) object.
        Nested      x2; // construct (ù{\codeincomments{ns2::Class2::Nested}}ù) object.
        print("print"); // call static member function (ù{\codeincomments{ns2::Class2::print}}ù).
        LocalType   x3; // declare object of local type.
        ns1::f1();      // find global (ù{\codeincomments{ns1::f1}}ù) func by qualified name lookup
        ns1::Class1 x4; // find global (ù{\codeincomments{ns1::Class1}}ù) type by qualified lookup
    };
}
\end{emcppslisting}
    

We can see that, within the \emcppsgloss{lambda body}, non-variables can be
accessed normally, using either unqualified name lookup or, if needed,
qualified name lookup. Unqualified name lookup will find global entities
within the namespace; types and static functions within the class; and
types declared within the enclosing function scope. Qualified name
lookup will find entities in other namespaces.

Variables with static storage duration can also be accessed directly,
without being captured:

\begin{emcppslisting}[emcppsbatch=e10]
void ns2::Class2::mf3()
{
    static int s1 = 3;
    auto c1 = []{
        // Access variables with static storage duration.
        print(g1);      // print global constant (ù{\codeincomments{ns2::g1}}ù)
        print(g2);      // print global variable (ù{\codeincomments{ns2::g2}}ù)
        print(ns1::g0); // print global variable (ù{\codeincomments{ns1::g0}}ù)
        print(s_mem);   // print static member variable (ù{\codeincomments{s\_mem}}ù)
        print(s1);      // print static local variable (ù{\codeincomments{s1}}ù)
    };
}
\end{emcppslisting}
    

Here we see global constants, global variables, static member variables,
and local static variables being used from the local scope.

Next, we look at uses of variables with \emph{automatic} storage
duration from the \emcppsgloss[lambda expressions]{lambda expression}'s surrounding block scope:

\begin{emcppslisting}[emcppsbatch=e10]
void ns2::Class2::mf4()
{
    int       a = 4;
    int       b = 5;
    int const k = 6;

    auto c1 = [](double b) {
        // Access local variables within the reaching scope.
        print(a);    // Error, (ù{\codeincomments{a}}ù) is ODR-used but not captured.
        print(b);    // OK, (ù{\codeincomments{b}}ù) argument hides (ù{\codeincomments{b}}ù) defined in (ù{\codeincomments{mf1}}ù).
        int kb = k;  // OK, (ù{\codeincomments{const}}ù) variable is not ODR-used.
        print(k);    // Error, (ù{\codeincomments{k}}ù) is ODR-used but not captured.
    };
}
\end{emcppslisting}
    

The attempt to print \lstinline!a! will fail because \lstinline!a! is a
non-static local variable within the surrounding scope but is not
captured. Printing \lstinline!b! is not a problem because the \lstinline!b!
parameter in the \emcppsgloss{lambda declarator} is local to the
\emcppsgloss{lambda body}; it hides the \lstinline!b! variable in the
surrounding block scope. A \lstinline!const! variable of fundamental type
is not \emcppsgloss{ODR-used} unless its \emph{identity} (i.e., address) is
needed. Hence, \lstinline!k! can be used even though it is not captured.
Conversely, the call to \lstinline!print(k)! \emph{is} an \emcppsgloss[ODR-used]{ODR-use}
of \lstinline!k! because \lstinline!print! takes its argument by
\emph{reference}, which requires taking the \emph{address} of
\lstinline!k!, which, in turn, makes it an \emcppsgloss[ODR-used]{ODR-use}. Since
\lstinline!k! is a local variable with automatic storage duration that was
not captured, \lstinline!print(k)! is ill formed.

Finally, we look at access to (non-static) members of the surrounding
class:

\begin{emcppslisting}[emcppsbatch=e10]
void ns2::Class2::mf5()
{
    auto c1 = []{
        // Access non-static members
        print(d_value); // Error, (ù{\codeincomments{this}}ù) is ODR-used but not captured.
        mf1();          // Error,    "   "        "       "   "     "
    };
    auto c2 = [=] {
        print(d_value); // OK, (ù{\codeincomments{this}}ù) is captured; print (ù{\codeincomments{this->d\_value}}ù).
        mf1();          // OK,   "    "     "    ; call (ù{\codeincomments{this->mf1()}}ù).
    };
}
\end{emcppslisting}
    

The above shows that member variables and functions can be accessed only
if \lstinline!this! is (implicitly or explicitly) captured by the
\emcppsgloss[lambda expressions]{lambda expression}, as is the case for \lstinline!c2! but not for
\lstinline!c1!.

\subsection[Use Cases]{Use Cases}\label{use-cases-lambda}

\subsubsection[Interface adaptation, partial application, and currying]{Interface adaptation, partial application, and currying}\label{interface-adaptation,-partial-application,-and-currying}

\emcppsgloss[lambda expressions]{Lambda expressions} can be used to adapt the set of arguments
provided by an algorithm to the parameters expected by another facility:

\begin{emcppslisting}
#include <algorithm>  // (ù{\codeincomments{std::count\_if}}ù)
#include <string>     // (ù{\codeincomments{std::string}}ù)
#include <vector>     // (ù{\codeincomments{std::vector}}ù)

extern "C" int f1(const char* s, std::size_t n);

void f2(const std::vector<std::string>& vec)
{
    std::size_t n = std::count_if(vec.begin(), vec.end(),
        [](const std::string& s){ return 0 != f1(s.data(), s.size()); });
    // ...
}
\end{emcppslisting}
    

Here we have a function, \lstinline!f1!, that takes a C string and length
and computes some predicate, returning 0 for false and nonzero for true.
We want to use this predicate with \lstinline!std::count_if! to count how
many strings in a specified vector match this predicate. The
\emcppsgloss[lambda expressions]{lambda expression} in \lstinline!f2! adapts \lstinline!f1! to the
needs of \lstinline!std::count_if! by converting a \lstinline!std::string!
argument into \lstinline!const!~\lstinline!char*! and \lstinline!std::size_t!
arguments and converting the \lstinline!int! return value to \lstinline!bool!.

A particularly common kind of interface adaptation is \emcppsgloss{partial
application}, whereby we reduce the \emph{parameter count} of a function
by holding one or more of its arguments constant for the duration of the
algorithm:

\begin{emcppslisting}
#include <algorithm>  // (ù{\codeincomments{std::all\_of}}ù)

template <typename InputIter, typename T>
bool all_greater_than(InputIter first, InputIter last, const T& v)
    // returns (ù{\codeincomments{true}}ù) if all the values in the specified range [(ù{\codeincomments{first}}ù), (ù{\codeincomments{last}}ù))
    // are greater than the specified (ù{\codeincomments{v}}ù), and false otherwise
{
    return std::all_of(first, last, [&](const T& i) { return i > v; });
}
\end{emcppslisting}
    

In the example above, the greater-than operator (\lstinline!>!) takes two
operands, but the \lstinline!std::all_of! algorithm expects a functor
taking a single argument. The \emcppsgloss[lambda expressions]{lambda expression} passes its
single argument as the first operand to \lstinline!operator>! and
\emph{binds} the other operand to the captured \lstinline!v! value, thus
solving the interface mismatch.

Finally, let's touch on \emcppsgloss{currying}, a transformation borrowed
from lambda calculus and functional programming languages. Currying is a
flexible way to get results similar to \emcppsgloss{partial application} by
transforming, e.g., a function taking two parameters into one taking
just the first parameter and returning a function taking just the second
parameter. To apply this technique, we define a \emcppsgloss[lambda expressions]{lambda
expression} whose call operator returns another \emcppsgloss[lambda expressions]{lambda
expression}, i.e., a \emcppsgloss{closure} that returns another
\emcppsgloss{closure}:

\begin{emcppshiddenlisting}[emcppsbatch=e11]
#include <algorithm>  // (ù{\codeincomments{all\_of}}ù)
\end{emcppshiddenlisting}
\begin{emcppslisting}[emcppsbatch=e11]
template <typename InputIter, typename T>
bool all_greater_than2(InputIter first, InputIter last, const T& v)
    // returns (ù{\codeincomments{true}}ù) if all the values in the specified range [(ù{\codeincomments{first}}ù), (ù{\codeincomments{last}}ù))
    // are greater than the specified (ù{\codeincomments{v}}ù), and false otherwise
{
    auto isGreaterThan = [](const T& v){
        return [&v](const T& i){ return i > v; };
    };
    return std::all_of(first, last, isGreaterThan(v));
}
\end{emcppslisting}
    

The example above is another way to express the previous example. The
call operator for \lstinline!isGreaterThan! takes a single argument,
\lstinline!v!, and returns another single-argument \emcppsgloss{closure object}
that can be used to compare \lstinline!i! to \lstinline!v!. Thus,
\lstinline!isGreaterThan(v)(i)! is equivalent to
\lstinline!i!~\lstinline!>!~\lstinline!v!.

\subsubsection[Emulating local functions]{Emulating local functions}\label{emulating-local-functions}

Local functions in languages other than C++ allow functions to be
defined within other functions. They are useful when the outer function
needs to repeat a set of steps two or more times but where the repeated
steps are meaningless outside of the immediate context and/or require
access to the outer function's local variables. Using a \emcppsgloss[lambda expressions]{lambda
expression} to produce a re-usable \emcppsgloss{closure} provides this
functionality in C++:

\begin{emcppslisting}
class Token { /* ... */ };

bool parseToken(const char*& cursor, Token& result)
    // Parse the token at (ù{\codeincomments{cursor}}ù) up to the next space or end-of-string,
    // setting (ù{\codeincomments{result}}ù) to the resulting token value.  Advance (ù{\codeincomments{cursor}}ù) to the
    // space or to the null terminator and return (ù{\codeincomments{true}}ù) on success.  Reset
    // (ù{\codeincomments{cursor}}ù) to its original value, set (ù{\codeincomments{result}}ù) to an empty token, and
    // return (ù{\codeincomments{false}}ù) on failure.
{
    const char* const initCursor = cursor;
    auto error = [&]
    {
        cursor = initCursor;
        result = Token{};
        return false;
    };
    // ...
    if (*cursor++ != '.')
    {
        return error();
    }
    // ...
}
\end{emcppslisting}
    

The \lstinline!error! \emcppsgloss{closure object} acts as a local function that
performs all of the necessary error processing and returns
\lstinline!false!. Using this object, every error branch can be reduced to
a single statement, \lstinline!return!~\lstinline!error()!. Without
\emcppsgloss{lambda expressions}, the programmer would likely resort to
defining a custom class to store the parameters, using a \lstinline!goto!,
or, worse, cutting-and-pasting the three statements shown within the
\emcppsgloss{lambda body}.

\subsubsection[Emulate user-defined control constructs]{Emulate user-defined control constructs}\label{emulate-user-defined-control-constructs}

Using a \emcppsgloss[lambda expressions]{lambda expression}, an algorithm can look almost like a
new control construct in the language:

\begin{emcppslisting}
#include <mutex>  // (ù{\codeincomments{std::mutex}}ù)
#include <vector>  // (ù{\codeincomments{std::vector}}ù)

template <typename RandomIter, typename F>
void parallel_foreach(RandomIter first, RandomIter last, const F& op)
    // For each element, (ù{\codeincomments{e}}ù), in [(ù{\codeincomments{first}}ù), (ù{\codeincomments{last}}ù)), create a copy (ù{\codeincomments{opx}}ù) of (ù{\codeincomments{op}}ù),
    // and invoke (ù{\codeincomments{opx(e)}}ù).  Any number of invocations of (ù{\codeincomments{opx(e)}}ù) may occur
    // concurrently, each using a separate copy of (ù{\codeincomments{op}}ù).
{ /*...*/ }

void processData(std::vector<double>& data)
{
    double       beta    = 0.0;
    double const init = 7.45e-4;
    std::mutex m;

    parallel_foreach(data.begin(), data.end(), [&, init](double e) mutable
    {
        if (e < 1.0)
        {
           // ...
        }
        else
        {
           // ...
        }
    });
}
\end{emcppslisting}
    

The \lstinline!parallel_foreach! algorithm is intended to act like a
\lstinline!for! loop except that all of the elements in the input range may
potentially be processed in parallel. By inserting the ``body'' of this
``parallel for loop'' directly into the call to
\lstinline!parallel_foreach!, the resulting loop looks and feels a lot
like a built-in control construct. Note that the \emcppsgloss{capture
default} is \emcppsgloss[captured by reference]{capture by reference} and will result in all of the
iterations sharing the outer function's call frame, including the mutex
variable, \lstinline!m!, used to prevent race conditions. This
\emcppsgloss{capture default} should be used with care in parallel
computations, which often use \emcppsgloss[captured by copy]{capture by copy} to deliberately
\emph{avoid} sharing. If an asynchronous computation might outlive its
caller, then using \emcppsgloss[captured by copy]{capture by copy} is a must for avoiding
dangling references; see \intrarefsimple{potential-pitfalls-lambda}.

\subsubsection[Variables and control constructs in expressions]{Variables and control constructs in expressions}\label{variables-and-control-constructs-in-expressions}

In situations where a single expression is required --- e.g.,
member-initializers, initializers for \lstinline!const! variables, and so
on --- an \emph{immediately evaluated} \emcppsgloss[lambda expressions]{lambda expression} allows
that expression to include local variables and control constructs such
as loops:

\begin{emcppslisting}
#include <climits>  // (ù{\codeincomments{SHRT\_MAX}}ù)

bool isPrime(long i);
    // Return (ù{\codeincomments{true}}ù) if (ù{\codeincomments{i}}ù) is a prime number.

const short largestShortPrime = []{
    for (short v = SHRT_MAX; ; v -= 2) {
        if (isPrime(v)) return v;
    }
}();
\end{emcppslisting}
    

The value of \lstinline!largestShortPrime! must be set at initialization
time because it is a \lstinline!const! variable with static duration. The
loop inside of the \emcppsgloss[lambda expressions]{lambda expression} computes the desired
value, using local variable, \lstinline!v!, and a \lstinline!for! loop. Note
that the call operator for the resulting \emcppsgloss{closure object} is
immediately invoked via the \lstinline!()! argument list at the end of the
\emcppsgloss[lambda expressions]{lambda expression}; the \emcppsgloss{closure object} is never stored
in a named variable and goes out of scope as soon as the full expression
is completely evaluated. This computation would formerly have been
possible only by creating a single-use \emph{named} function.

\subsubsection[Use with \lstinline!std::function!]{Use with {\SubsubsecCode std::function}}\label{use-with-std::function}

As convenient as a \emcppsgloss[lambda expressions]{lambda expression} is for passing a functor
to an algorithm \emph{template}, the fact that each \emcppsgloss{closure
type} is unnamed and distinct makes it difficult to use them outside of
a generic context. The C++11 Standard Library class template,
\lstinline!std::function!, bridges this gap by providing a polymorphic
invocable type that can be constructed from any type with a compatible
invocation prototype, including but not limited to \emcppsgloss[closure type]{closure
types}.

A simple interpreter for a postfix input language stores a sequence of
instructions in a \lstinline!std::vector!. Each instruction can be of a
different type, but they all accept the current stack pointer as an
argument and return the new stack pointer as a result. Each instruction
is typically a small operation, ideally suited for being expressed as
\emcppsgloss{lambda expressions}:

\begin{emcppslisting}
#include <cstdlib>     // (ù{\codeincomments{std::strtol}}ù)
#include <functional>  // (ù{\codeincomments{std::function}}ù)
#include <string>      // (ù{\codeincomments{std::string}}ù)
#include <vector>      // (ù{\codeincomments{std::vector}}ù)

using Instruction = std::function<long*(long*& sp)>;

std::vector<Instruction> instructionStream;

std::string nextToken();                 // read the next token
char tokenOp(const std::string& token);  // operator for token

void readInstructions()
{
    std::string token;
    Instruction nextInstr;
    while (!(token = nextToken()).empty())
    {
        switch (tokenOp(token))
        {
            case 'i':
            {
                // Integer literal
                long v = std::strtol(token.c_str(), nullptr, 10);
                nextInstr = [v](long* sp){ *sp++ = v; return sp; };
                break;
            }
            case '+':
            {
                // + operation
                nextInstr = [](long*& sp){
                    long v1 = *--sp;
                    long v2 = *--sp;
                    *sp++ = v1 + v2;
                    return sp;
                };
                break;
            }
            // ... more cases
        }

        instructionStream.push_back(nextInstr);
    }
}
\end{emcppslisting}
    

The \lstinline!Instruction! type alias is a \lstinline!std::function! that can
hold, through a process called \emcppsgloss{type erasure}, any invocable
object that takes a \lstinline!long*! argument and returns a \lstinline!long*!
result. The \lstinline!readInstructions! function reads successive string
tokens and switches on the operation represented by the token. If the
operation is \lstinline!i!, then the token is an integer literal. The
string token is converted into a \lstinline!long! value, \lstinline!v!, which
is captured in a \emcppsgloss[lambda expressions]{lambda expression}. The resulting
\emcppsgloss{closure} object is stored in the \lstinline!nextInstr! variable;
when called, it will push \lstinline!v! onto the stack. Note that the
\lstinline!nextInstr! variable outlives the primary \lstinline!v! variable,
but, because \lstinline!v! was \emcppsgloss{captured by copy}, the
\emcppsgloss{captured variable}'s lifetime is the same as the \emcppsgloss{closure
object}'s. If the next operation is \lstinline!+!, \lstinline!nextInstr! is
set to the \emcppsgloss{closure object} of an entirely different
\emcppsgloss[lambda expressions]{lambda expression}, one that captures nothing and whose call
operator pops two values from the stack and pushes their sum back onto
the stack.

After the \lstinline!switch! statement, the current value of
\lstinline!nextInstr! is appended to the instruction stream. Note that,
although each \emcppsgloss{closure type} is different, they all can be stored
in an \lstinline!Instruction! object because the prototype for their call
operator matches the prototype specified in the instantiation of
\lstinline!std::function!. The \lstinline!nextInstr! variable can be created
empty, assigned from the value of a \emcppsgloss[lambda expressions]{lambda expression}, and then
later reassigned from the value of a different \emcppsgloss[lambda expressions]{lambda
expression}. This flexibility makes \lstinline!std::function! and
\emcppsgloss{lambda expressions} a potent combination.

One specific use of \lstinline!std::function! worth noting is to return a
\emcppsgloss[lambda expressions]{lambda expression} from a non-template function:

\begin{emcppshiddenlisting}[emcppsbatch=e12]
#include <functional>  // (ù{\codeincomments{std::function}}ù)
\end{emcppshiddenlisting}
\begin{emcppslisting}[emcppsbatch=e12]
std::function <int(int)> add_n(int n)
{
    return [n](int i) { return n + i; };
}

int result = add_n(3)(5);  // (ù{\codeincomments{result}}ù) is 8.
\end{emcppslisting}
    

The return value of \lstinline!add_n! is a \emcppsgloss{closure object} wrapped
in a \lstinline!std::function! object. Note that \lstinline!add_n! is not a
template and that it is not called in a template or \lstinline!auto!
context. This example illustrates a runtime-polymorphic way to achieve
\emcppsgloss{currying}; see the earlier example in \intrarefsimple{interface-adaptation,-partial-application,-and-currying}.

\subsubsection[Event-driven callbacks]{Event-driven callbacks}\label{event-driven-callbacks}

Event-driven systems tend to have interfaces that are littered with
callbacks:

\begin{emcppslisting}[emcppsbatch=e13]
#include <memory>  // std::unique_ptr

class DialogBox { /* ... */ };

template <typename Button1Func, typename Button2Func>
std::unique_ptr<DialogBox> twoButtonDialog(const char* prompt,
                                           const char* button1text,
                                           Button1Func button1callback,
                                           const char* button2text,
                                           Button2Func button2callback)
{
    // ...
}
\end{emcppslisting}
    

The \lstinline!twoButtonDialog! factory function takes three strings and
two callbacks and returns a pointer to a dialog box having two buttons.
The dialog-box logic invokes one of the two callbacks, depending on
which of the two buttons is pressed. These callbacks are often quite
small pieces of code that can best be expressed directly in the program
logic using \emcppsgloss{lambda expressions}:

\begin{emcppslisting}[emcppsbatch=e13]
void runModalDialogBox(DialogBox& db);

void launchShuttle(/* ... */)
{
    bool doLaunch = false;

    std::unique_ptr<DialogBox> confirm =
        twoButtonDialog("Are you sure you want to launch the shuttle?",
                        "Yes", [&]{ doLaunch = true; },
                        "No",  []{});

    runModalDialogBox(*confirm);

    if (doLaunch)
    {
        // ... launch the shuttle!
    }
}
\end{emcppslisting}
    

Here, the user is being prompted as to whether or not to launch a
missile. Since the dialog box is processed entirely within the
\lstinline!launchShuttle! function, it is convenient to express two
callbacks in-place, within the function, using \emcppsgloss{lambda
expressions}. The first \emcppsgloss[lambda expressions]{lambda expression} --- passed as the
callback for when the user clicks ``Yes'' --- captures the
\lstinline!doLaunch! flag by reference and simply sets it to \lstinline!true!.
The second \emcppsgloss[lambda expressions]{lambda expression} --- passed as the callback for
when the user clicks ``No'' --- does nothing, leaving the
\lstinline!doLaunch! flag having its original \lstinline!false! value. The
simplicity of these callbacks come from fact that they are effectively
extensions of the surrounding block and, hence, have access (via the
\emcppsgloss{lambda capture}) to block-scoped variables such as
\lstinline!doLaunch!.

\subsubsection[Recursion]{Recursion}\label{recursion}

A \emcppsgloss[lambda expressions]{lambda expression} cannot refer to itself, so creating one
that is recursive involves using one of a number of different possible
workarounds. If the \emcppsgloss{lambda capture} is empty, recursion can be
accomplished fairly simply by converting the \emcppsgloss[lambda expressions]{lambda expression}
into a plain function pointer stored in a \lstinline!static! variable:

\begin{emcppslisting}
void f1()
{
    static int (*const fact)(int) = [](int i)
    {
        return i < 2 ? 1 : i * fact(i-1);
    };

    int result = fact(4);  // computes 24
}
\end{emcppslisting}
    

In the above example, \lstinline!fact(n)! returns the factorial of
\lstinline!n!, computed using a recursive algorithm. The variable,
\lstinline!fact!, becomes visible before its initializer is compiled,
allowing it to be called from within the \emcppsgloss[lambda expressions]{lambda expression}. To
enable the conversion to function pointer, the \emcppsgloss{lambda capture}
must be empty; hence, \lstinline!fact! must be static so that it can be
accessed without capturing it.

If a recursive \emcppsgloss[lambda expressions]{lambda expression} is desired with a nonempty
\emcppsgloss{lambda capture}, then the entire recursion can be enclosed in an
outer \emcppsgloss[lambda expressions]{lambda expression}:

\begin{emcppslisting}
void f2(int n)
{
    auto permsN = [n](int m) -> int
    {
        static int (*const imp)(int, int) = [](int x, int m) {
            return m <= x ? m : m * imp(x, m - 1);
        };
        return imp(m - n + 1, m);
    };

    int a = permsN(5);  // permutations of 5 items, (ù{\codeincomments{n}}ù) at a time
    int b = permsN(4);  // permutations of 4 items, (ù{\codeincomments{n}}ù) at a time
}
\end{emcppslisting}
    

In this example, \lstinline!permsN(m)!, returns the number of permutations
of \lstinline!m! items taken \lstinline!n! at a time, where \lstinline!n! is
captured by the \emcppsgloss{closure object}. The implementation of
\lstinline!permsN! defines a nested \lstinline!imp! function pointer that uses
the same technique as \lstinline!fact!, above, to achieve recursion. Since
\lstinline!imp! must have an empty \emcppsgloss{lambda capture}, everything it
needs is passed in as arguments by the \lstinline!permsN! enclosing
\emcppsgloss[lambda expressions]{lambda expression}. Note that the \lstinline!imp! pointer and the
\emcppsgloss[lambda expressions]{lambda expression} from which it is initialized do not needed to
be scoped inside of the \lstinline!permN! \emcppsgloss[lambda expressions]{lambda expression};
whether such nesting is desirable is a matter of taste.

In C++14, additional approaches to recursion (e.g., the ``Y Combinator''
borrowed from lambda calculus{\cprotect\footnote{\cite{derevenets16}}}) are possible due to
using \emcppsgloss[generic lambda]{generic lambdas}; see \featureref{\locationd}{genericlambda}.

\subsection[Potential Pitfalls]{Potential Pitfalls}\label{potential-pitfalls-lambda}

\subsubsection[Dangling references]{Dangling references}\label{dangling-references}

\emcppsgloss[closure object]{Closure objects} can capture references to local variables and
copies of the \lstinline!this! pointer. If a copy of the \emcppsgloss{closure
object} outlives the stack frame in which it was created, these
references can refer to objects that have been destroyed. The two ways
in which a \emcppsgloss{closure object} can outlive its creation context are
if (1) it is returned from the function or (2) it is stored in a data
structure for later invocation:

\begin{emcppslisting}
#include <functional>  // std::function
#include <vector>      // std::vector

class Class1
{
    int d_mem;

    static std::vector<std::function<double(void*)> > s_workqueue;

    std::function<void(int)> mf1()
    {
        int local;
        return [&](int i) -> void { d_mem = local = i; };  // Bug, dangling refs
    }

    void mf2()
    {
        double local = 1.0;
        s_workqueue.push_back([&,this](void* p) -> double {
                return p ? local : double(d_mem);
            });  // Bug, dangling refs
    }
};
\end{emcppslisting}
    

The example above uses \lstinline!std::function! to hold \emcppsgloss[closure object]{closure
objects}, as described in \intrarefsimple{use-with-std::function}. In member
function \lstinline!mf1!, the \emcppsgloss{lambda body} modifies both the local
variable and the member variable currently in scope. However, as soon as
the function returns, the local variable goes out of scope and the
\emcppsgloss{closure} contains a dangling reference. Moreover, the object on
which it is invoked can also go out of scope while the \emcppsgloss{closure
object} continues to exist. Modifying either \lstinline!this->d_mem! or
\lstinline!local! through the capture is likely to corrupt the stack,
leading to a crash, potentially much later in the program.

The member function \lstinline!mf2!, rather than \emph{return} a
\emcppsgloss{closure} with dangling references, stores it in a data
structure, i.e., the \lstinline!s_workqueue! static \lstinline!vector!. Once
again, \lstinline!local! and \lstinline!d_mem! become dangling references and
can result in data corruption when the call operator for the stored
\emcppsgloss{closure object} is invoked. It is safest to capture
\lstinline!this! and use \emcppsgloss[captured by reference]{capture by reference} only when the
lifetime of the \emcppsgloss{closure object} is clearly limited to the
current function. \emcppsgloss[implicitly captured]{Implicitly captured} \lstinline!this! is
particularly insidious because, even if the \emcppsgloss{capture default} is
\emcppsgloss[captured by copy]{capture by copy}, member variables are not copied and are often
referenced without the \lstinline!this->! prefix, making them hard to spot
in the source code.

\subsubsection[Overuse]{Overuse}\label{overuse}

The ability to write functions, especially functions with state, at the
point where they are needed and without much of the syntactic overhead
that accompanies normal functions and class methods, can potentially
lead to a style of code that uses ``lambdas everywhere'', losing the
abstraction and well-documented interfaces of separate functions.
\emcppsgloss[lambda expressions]{Lambda expressions} are not intended for large-scale reuse.
Sprinkling \emcppsgloss{lambda expressions} throughout the code can result in
poor software-engineering practices such as cut-and-paste programming
and the absence of cohesive abstractions.

\subsubsection[Mixing captured and non-captured variables]{Mixing captured and non-captured variables}\label{mixing-captured-and-non-captured-variables}

A \emcppsgloss{lambda body} can access both automatic-duration local
variables that were captured from the enclosing block and
static-duration variables that need not and cannot be captured.
Variables \emcppsgloss{captured by copy} are ``frozen'' at the point of
capture and cannot be changed except by the \emcppsgloss{lambda body} (if
mutable), whereas static variables can be changed independent of the
\emcppsgloss[lambda expressions]{lambda expression}. This difference is often useful but can
cause confusion when reasoning about a \emcppsgloss[lambda expressions]{lambda expression}:

\begin{emcppshiddenlisting}[emcppsbatch=e14]
#include <cassert>  // standard C (ù{\codeincomments{assert}}ù) macro
\end{emcppshiddenlisting}
\begin{emcppslisting}[emcppsbatch=e14]

void f1()
{
    static int a;
    int        b;

    a = 5;
    b = 6;

    auto c1 = [b]{ return a + b; };  // OK, (ù{\codeincomments{b}}ù) is **captured by copy**.
    assert(11 == c1());              // OK, (ù{\codeincomments{a == 5}}ù) and (ù{\codeincomments{b == 6}}ù).
    ++b;                             // Increment *primary* (ù{\codeincomments{b}}ù).
    assert(11 == c1());              // OK, captured (ù{\codeincomments{b}}ù) did not change.
    ++a;                             // Increment static-duration (ù{\codeincomments{a}}ù).
    assert(12 == c1());              // Bug, (ù{\codeincomments{a == 6}}ù) and captured (ù{\codeincomments{b == 6}}ù)
}
\end{emcppslisting}
    

When the \emcppsgloss{closure object} for \lstinline!c1! is created, the
captured \lstinline!b! value is frozen within the \emcppsgloss{lambda body}.
Changing the primary \lstinline!b! has no effect. However, \lstinline!a! is
not captured (nor is it allowed to be). As a result, there is only
\emph{one} \lstinline!a! variable, and modifying that variable outside of
the \emcppsgloss{lambda body} changes the result of invoking the call
operator.

C++14 \emcppsgloss{capture init} can be used to effectively capture a
non-local variable:

\begin{emcppshiddenlisting}[emcppsbatch=e15]
#include <cassert>  // standard C (ù{\codeincomments{assert}}ù) macro
\end{emcppshiddenlisting}
\begin{emcppslisting}[emcppsbatch=e15]
void f2()
{
    static int a;
    int        b;

    a = 5;
    b = 6;

    auto c1 = [a=a,b]{ return a + b; };  // OK, capture both (ù{\codeincomments{a}}ù) and (ù{\codeincomments{b}}ù).
    ++a;                                 // Increment static-duration (ù{\codeincomments{a}}ù).
    assert(11 == c1());                  // OK, captured (ù{\codeincomments{a}}ù) did not change.
}
\end{emcppslisting}
    

The \emcppsgloss{lambda capture}, \lstinline![a=a,b]!, creates a new capture
variable \lstinline!a! that is initialized from the static variable
\lstinline!a! at the point that the \emcppsgloss[lambda expressions]{lambda expression} is evaluated
to produce a \emcppsgloss{closure object}. The \lstinline!a! variable within the
\emcppsgloss{lambda body} refers to this captured variable, not to the static
one.

\subsubsection[Local variables in unevaluated contexts can yield surprises]{Local variables in unevaluated contexts can yield surprises}\label{local-variables-in-unevaluated-contexts-can-yield-surprises}

To use a local variable, \lstinline!x!, from the surrounding block as part
of an unevaluated operand (e.g., \lstinline!sizeof(x)! or
\lstinline!alignof(x)!), it is generally not necessary to capture
\lstinline!x! because it is not \emcppsgloss{ODR-used} within the \emcppsgloss{lambda
body}. Whether or not \lstinline!x! is captured, most expressions in
unevaluated contexts behave as though \lstinline!x! were \emph{not}
captured and the expression were evaluated directly in the enclosing
block scope. This is itself surprising because, for example, a captured
variable in a non-\lstinline!mutable! \emcppsgloss[lambda expressions]{lambda expression} is
\lstinline!const!, whereas the primary variable might not be:

\begin{emcppslisting}
#include <iostream>  // (ù{\codeincomments{std::cout}}ù)

short s1(int&)       { return 0; }
int   s1(const int&) { return 0; }

void f1()
{
    int x = 0;  // (ù{\codeincomments{x}}ù) is a non-const (ù{\emphincomments{lvalue}}ù).
    [x]{
        // captured (ù{\codeincomments{x}}ù) in non-(ù{\codeincomments{mutable}}ù) lambda is (ù{\emphincomments{lvalue}}ù) of type (ù{\codeincomments{const int}}ù)
        std::cout << sizeof(s1(x)) << '\n';  // prints sizeof(short)
        auto s1x = s1(x);                    // yields an (ù{\codeincomments{int}}ù)
        std::cout << sizeof(s1x) << '\n';    // prints sizeof(int)
    }();
}
\end{emcppslisting}
    

The first print statement calls \lstinline!s1(x)! in an unevaluated
context, which ignores the captured \lstinline!x! and returns the size of
the result of \lstinline!s1(int&)!. The next statement actually
\emph{evaluates} \lstinline!s1(x)!, passing the \emph{captured} \lstinline!x!
and calling \lstinline!s1(const!~\lstinline!int&)! because the call operator
is not decorated with \lstinline!mutable!.

When using \lstinline!decltype(x)!, the result is the declared type of the
\emph{primary} variable, regardless of whether or not \lstinline!x! was
captured. However, if \lstinline!x! had been \emcppsgloss{captured by copy},
\lstinline!decltype((x))! (with two sets of parentheses) would have yielded
the \romeovalue{lvalue} type of the \emph{captured} variable. There is some dispute
as to what the correct results should be if \lstinline!x! is \emph{not}
captured, with some compilers yielding the type of the primary variable
and others complaining that it was not captured.

\begin{emcppslisting}
void f1()
{
    int x = 0;  // (ù{\codeincomments{x}}ù) is a non-(ù{\codeincomments{const}}ù) }}(ù{\emphincomments{lvalue}}ù).
    auto c1 = [x]{ decltype((x)) y = x; };  // (ù{\codeincomments{y}}ù) has type (ù{\codeincomments{const int\&}}ù).
}
\end{emcppslisting}
    

Finally, there is an unsettled question as to whether \lstinline!typeid(x)!
is an \emcppsgloss[ODR-used]{ODR-use} of \lstinline!x! and, therefore, requires that
\lstinline!x! be captured. Some compilers will complain about the following
code:

\begin{emcppslisting}
#include <typeinfo>  // (ù{\codeincomments{typeid}}ù)
void f3()
{
    int x = 0;
    auto c1 = []{ return typeid(x); };
        // Error, on some platforms ``(ù{\codeincomments{x}}ù) was not captured''
}
\end{emcppslisting}
    

One can avoid this pitfall simply by calling \lstinline!typeid! outside of
the lambda, capturing the result if necessary:

\begin{emcppslisting}
#include <typeinfo>  // (ù{\codeincomments{typeid}}ù)
void f3()
{
    int x = 0;
    const std::type_info& xid = typeid(x);
        // OK, (ù{\codeincomments{typeid}}ù) called outside of lambda
    auto c1 = [&]() -> const std::type_info& { return xid; }
        // OK, return captured (ù{\codeincomments{typeinfo}}ù)
}
\end{emcppslisting}
    

\subsection[Annoyances]{Annoyances}\label{annoyances}

\subsubsection[Debugging]{Debugging}\label{debugging}

By definition, lambdas do not have names. Tools such as debuggers and
stack-trace examiners typically display the compiler-generated names of
the closure types instead of names selected by the programmer to clearly
describe the purpose of a function, making it difficult to discern where
a problem occurred.

\subsubsection[Can’t capture \lstinline!*this! by copy]{Can’t capture {\SubsubsecCode *this} by copy}\label{can’t-capture-*this-by-copy}

A \emcppsgloss[lambda expressions]{lambda expression} can freeze the value of a surrounding local
variable by using \emcppsgloss[captured by copy]{capture by copy}, but no such ability is
available directly to copy the object pointed to by \lstinline!this!. In
C++14, this deficiency can be mitigated using \emcppsgloss{capture init}:

\begin{emcppslisting}
class Class1
{
    int d_value;

    void mf1()
    {
        auto c1 = [self=*this]{ return self.d_value; };
    }
};
\end{emcppslisting}
    

The \emcppsgloss{lambda capture}, \lstinline![self=*this]! creates a new
captured variable, \lstinline!self!, that contains a copy of
\lstinline!*this!. Unfortunately, accessing member variable
\lstinline!d_value! requires explicit use of \lstinline!self.d_value!.

C++11 doesn't have \emcppsgloss{capture init}, so it is necessary to create a
\lstinline!self! variable external to the \emcppsgloss[lambda expressions]{lambda expression} and
capture \emph{that} variable{\cprotect\footnote{As of C++17,
\lstinline!*this! can be captured directly with \lstinline!this! within the
\emcppsgloss{lambda body} pointing to the \emph{copy} rather than the
original:

\begin{emcppslisting}[style=footcode]
class Class2
{
    int d_value;

    void mf1()
    {
        auto c1 = [*this]{ return d_value; };
            // C++17: return (ù{\fncodeincomments{d\_value}}ù) from copy of (ù{\fncodeincomments{*this}}ù)
    }
};
\end{emcppslisting}
      }}:

\begin{emcppslisting}
class Class1
{
    int d_value;

    void mf1()
    {
        Class1& self = *this;
        auto c1 = [self]{ return self.d_value; };
    }
};
\end{emcppslisting}
    

\subsubsection[Confusing mix of immediate and deferred-execution code]{Confusing mix of immediate and deferred-execution code}\label{confusing-mix-of-immediate-and-deferred-execution-code}

The main selling point of \emcppsgloss{lambda expressions} --- i.e., the
ability to define a function object at the point of use --- can
sometimes be a liability. The code within a \emcppsgloss{lambda body} is
typically not executed immediately but is deferred until some other
piece of code, e.g., an algorithm, invokes it as a callback. The code
that is immediately executed and the code whose invocation is deferred
are visually intermixed in a way that could confuse a future maintainer.
For example, let's look at a simplified excerpt from an earlier use
case, \intraref{use-cases-lambda}{use-with-std::function}.

\begin{emcppslisting}
#include <string>      // (ù{\codeincomments{std::string}}ù)
#include <functional>  // (ù{\codeincomments{std::function}}ù)

void readInstructions()
{
    std::string                     token;
    std::function<long*(long*& sp)> nextInstr;

    while ( /* ... */ (!token.empty()))
    {
        switch (token[0])
        {
            // ... more cases
            case '+':
            {
                // + operation
                nextInstr = [](long*& sp){
                    long v1 = *--sp;
                    long v2 = *--sp;
                    *sp++ = v1 + v2;
                    return sp;
                };
                break;
            }
            // ... more cases
        }
       // ...
    }
}
\end{emcppslisting}
    

A casual reading might lead to the assumption that operations such as
\lstinline!*--sp! are taking place within \lstinline!case!~\lstinline!'+'!, when
the truth is that these operations are encapsulated in a \emcppsgloss[lambda expressions]{lambda
expression} and are not executed until the \emcppsgloss{closure object} is
called (via \lstinline!nextInstr!) in a relatively distant part of the
code.

\subsubsection[Trailing punctuation]{Trailing punctuation}\label{trailing-punctuation}

The body of a \emcppsgloss[lambda expressions]{lambda expression} is a \emph{compound statement}.
When compound statements appear elsewhere in the C++ grammar, e.g., as
the body of a function or loop, they are not followed by punctuation. A
\emcppsgloss[lambda expressions]{lambda expression}, conversely, is invariably followed by some
sort of punctuation, usually a semicolon or parenthesis but sometimes a
comma or binary operator. This difference between a \emcppsgloss{lambda body}
and other compound statements makes this punctuation easy to forget:

\begin{emcppslisting}
auto c1 = []{ /* ... */ };  // <-- Don't forget the semicolon at the end.
\end{emcppslisting}
    

The extra punctuation can also be unattractive when emulating a control
construct using \emcppsgloss{lambda expressions} as in the
\lstinline!parallel_foreach! example in \intraref{use-cases-lambda}{emulate-user-defined-control-constructs}:

\begin{emcppshiddenlisting}[emcppsbatch=e16]
template <typename RandomIter, typename F>
void parallel_foreach(RandomIter first, RandomIter last, const F& op) {}
#include <vector>  // (ù{\codeincomments{std::vector}}ù)
\end{emcppshiddenlisting}
\begin{emcppslisting}[emcppsbatch=e16]
void f(const std::vector<int>& data)
{
    // ...
    for (int e : data)
    {
        // ...             (ù{\codeincomments{for}}ù) loop body
    }  // <-- no punctuation after the closing brace

    parallel_foreach(data.begin(), data.end(), [&](int e)
    {
        // ...             parallel loop body
    });  // <-- Don't forget the closing parenthesis and semicolon.
    // ...
}
\end{emcppslisting}
    

In the above code snippet, the programmer would like the
\lstinline!parallel_foreach! algorithm to look as much like the built-in
\lstinline!for! loop as possible. However, the built-in \lstinline!for! loop
doesn't end with a closing parenthesis and a semicolon, whereas the
\lstinline!parallel_foreach! does, so the illusion of a language extension
is incomplete.

\subsection[See Also]{See Also}\label{see-also}

\begin{itemize}
\item{\seealsoref{decltype}{\seealsolocationa}illustrates a form of type inference often used in conjunction with (or in place of) trailing return types.}
\item{\seealsoref{Function-Return-Type-Deduction}{\seealsolocationf}shows a form of type inference that shares syntactical similarities with trailing return types, leading to potential pitfalls when migrating from C++11 to C++14.}
\end{itemize}

\subsection[Further Reading]{Further Reading}\label{further-reading}

TODO


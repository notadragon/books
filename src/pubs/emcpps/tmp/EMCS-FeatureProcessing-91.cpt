Since the early days of C++, a common
  idiom to test for validity of an object has been to use it in a
  context where it can (implicitly) convert itself to a type whose value
  can be interpreted (contextually) as a boolean, with \texttt{true}
  implying validity (and \texttt{false} otherwise). Implicit conversion
  to \texttt{bool} (an integral type) was considered too dangerous,
  so the cumbersome \textbf{safe-\texttt{bool} idiom} was used instead,
  converting to a type that --- while contextually convertible to
  \texttt{bool} --- could not (by design) participate in any other
  operations. While making the conversion to \texttt{bool} (or
  \texttt{const}~\texttt{bool}) \texttt{explicit} solves the safety
  issue, the benefit of the idiom would be entirely lost if an explicit
  cast would have to be performed to test for validity. To address this,
  C++11 extends contextual conversion to \texttt{bool} for a given
  expression \texttt{E} to include an application of
  \texttt{static\_cast<const}~\texttt{volatile}~\texttt{bool>} to
  \texttt{E}, thus enabling explicit conversion to \texttt{bool} to be
  used in lieu of the (now deprecated) \textbf{safe-\texttt{bool} idiom}; see
  \textbf{{sharpe13}}.^^E^^L 

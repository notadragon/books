Compilers are permitted to increase alignment
(e.g., in the presence of virtual functions) but have certain restrictions
on padding. For example, they must ensure that each comprised type is
itself sufficiently aligned and that the alignment of the parent type
divides its size. This ensures that the fundamental identity for
arrays holds for all types, \texttt{T}, and positive integers,
\texttt{N}:

\begin{lstlisting}[language=C++, basicstyle={\ttfamily\footnotesize}]
T a[N]; static_assert(n == sizeof(a) / sizeof(*a));  // guaranteed
\end{lstlisting}

\noindent The alignment of user-defined types can be made artificially stricter
  (but not weaker) using the {\tt alignas} (see ``\titleref{alignas}" on page~\pageref{alignas}) specifier.
  Also note that, for \textbf{standard-layout types}, the address of the
  first member object is guaranteed to be the same as that of the parent
  object:

  \begin{lstlisting}[language=C++, basicstyle={\ttfamily\footnotesize}]
  struct S { int i; }
  class T { public: S s; }
  T t;
  static_assert(&t.s == &t,     "");  // guaranteed
  static_assert(&t.s == &t.s.i, "");  // guaranteed
  \end{lstlisting}

\noindent This property also holds for (e.g., anonymous) unions:

  \begin{lstlisting}[language=C++, basicstyle={\ttfamily\footnotesize}]
  struct { union { char c; float f; double d; } } u;
  static_assert(&u == &u.c, "");  // guaranteed
  static_assert(&u == &u.f, "");  // guaranteed
  static_assert(&u == &u.d, "");  // guaranteed
  \end{lstlisting}
      ^^E^^L 

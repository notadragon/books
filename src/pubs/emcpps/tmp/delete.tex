

Use of \texttt{=}~\texttt{delete} in a function's (first) declaration
forces a compilation error upon any attempt to use or access it.

\subsection[Description]{Description}\label{description}

Declaring a particular function (or function overload) to result in a
fatal diagnostic upon invocation can be useful --- e.g., to suppress the
generation of a \emph{special function} or to limit the types of
arguments a particular function is able to accept. In such cases,
\texttt{=}~\texttt{delete;} can be used in place of the body of any
function (on first declaration only) to force a compile-time error if
any attempt is made to invoke it or take its address.

\begin{lstlisting}[language=C++]
void g(double) { }
void g(int) = delete;

void f()
{
    g(3.14);  // OK, (ù{\codeincomments{f(double)}}ù) is invoked.
    g(0);     // Error: (ù{\codeincomments{f(int)}}ù) is deleted.
}
\end{lstlisting}
    
\noindent Notice that deleted functions participate in \emph{overload resolution}
and produce a compile-time error when selected as the best candidate.

\subsection[Use Cases]{Use Cases}\label{use-cases}

\subsubsection[Suppressing special member function generation]{Suppressing special member function generation}\label{suppressing-special-member-function-generation}

When instantiating an object of user-defined type, \textbf{special
member functions}\glossary{special
member functions} that have not been declared explicitly are
often{\cprotect\footnote{The generation of individual special member
functions can be affected by the existence of other user-defined special
member functions or by limitations imposed by the specific types of
any data members or base types. For more information, see Section~\ref{Defaulted-Special-Member-Functions}, ``\titleref{Defaulted-Special-Member-Functions}."}} generated automatically by the compiler.
For certain kinds of types, the notion of \textbf{copy semantics}\glossary{copy semantics}
(including \textbf{move semantics}\glossary{move semantics}{\cprotect\footnote{The two
\textbf{special member functions}\glossary{special member functions} controlling \emph{move} operations
(introduced in C++11) are sometimes implemented as effective
optimizations of copy operations and (rarely) with copy operations
  explicitly deleted; see Section~\ref{Rvalue-References}, ``\titleref{Rvalue-References}."}}) is not meaningful and
hence permitting the generation of copy operations is contraindicated.

Consider a class, \texttt{FileHandle}, that uses the \textbf{RAII}\glossary{RAII} idiom
to safely acquire and release an I/O stream. As \emph{copy semantics}
are typically not meaningful for such resources, we will want to
suppress generation of both the \emph{copy constructor} and \emph{copy
assignment operator}. Prior to C++11, there was no direct way to express
suppression of \emph{special functions} in C++. The commonly
recommended workaround was to declare the two methods \texttt{private}
and leave them unimplemented, typically resulting in a compile-time (or
link-time) error when accessed{\cprotect\footnote{Leaving unimplemented a special
member function that is declared to be private ensures
that there will be at least a link-time error in case that function is
inadvertently accessed from within the implementation of the class
  itself.}}:

\begin{lstlisting}[language=C++]
class FileHandle
{
private:
    // ...

    FileHandle(const FileHandle&);             // not implemented
    FileHandle& operator=(const FileHandle&);  // not implemented

public:
    explicit FileHandle(FILE* filePtr);
    ~FileHandle();

    // ...
};
\end{lstlisting}
    
\noindent With the \texttt{=}~\texttt{delete} syntax, we are able to (1)
explicitly express our intention to make these special member
functions unavailable, (2) do so directly in the \texttt{public} region
of the class, and (3) enable more precise compiler diagnostics:

\begin{lstlisting}[language=C++]
class FileHandle
{
private:
    // ...

public:
    explicit FileHandle(FILE* filePtr);
    ~FileHandle();

    FileHandle(const FileHandle&) = delete;             // make unavailable
    FileHandle& operator=(const FileHandle&) = delete;  // make unavailable

    // ...
};
\end{lstlisting}
    

\subsubsection[Preventing a particular implicit conversion]{Preventing a particular implicit conversion}\label{preventing-a-particular-implicit-conversion}

Certain functions --- especially those that take a \texttt{char} as an
argument --- are prone to inadvertent misuse. As a truly classic
example, consider the C library function \texttt{memset}, which may be used
to write the character \texttt{*} five times in a row, starting at a
specified memory address, \texttt{buf}:

\begin{lstlisting}[language=C++]
#include <cstring>
#include <cstdio>

void f()
{
    char buf[] = "Hello World!";
    memset(buf, 5, '*');  // undefined behavior
    puts(buf);            // expected output: "***** World!"
}
\end{lstlisting}
    
\noindent Sadly, inadvertently reversing the final two arguments is a commonly
recurring error, and the C language provides no help. In C++, we
can target such observed misuse using an extra deleted overload:

\begin{lstlisting}[language=C++]
#include <cstring>  // memset()
void* memset(void* str, int ch, size_t n);      // standard library function
void* memset(void* str, int n, char) = delete;  // defensive against misuse
\end{lstlisting}
    
\noindent Pernicious user errors can now be reported during compilation:

\begin{lstlisting}[language=C++]
// ...
memset(buf, 5, '*');  // Error: (ù{\codeincomments{memset(void\*, int, char)}}ù) is deleted.
// ...
\end{lstlisting}
    

\subsubsection[Preventing all implicit conversions]{Preventing all implicit conversions}\label{preventing-all-implicit-conversions}

The \texttt{ByteStream::send} member function below is designed to work
with 8-bit unsigned integers only. Providing a deleted overload
accepting an \texttt{int} forces a caller to ensure that the argument is
always of the appropriate type:

\begin{lstlisting}[language=C++]
class ByteStream
{
public:
    void send(unsigned char byte) { /* ... */ }
    void send(int) = delete;

    // ...
};

void f()
{
    ByteStream stream;
    stream.send(0);   // Error: (ù{\codeincomments{send(int)}}ù) is deleted.     (1)
    stream.send('a'); // Error: (ù{\codeincomments{send(int)}}ù) is deleted.     (2)
    stream.send(0L);  // Error: ambiguous                 (3)
    stream.send(0U);  // Error: ambiguous                 (4)
    stream.send(0.0); // Error: ambiguous                 (5)
    stream.send(
        static_cast<unsigned char>(100));  // OK          (6)
}
\end{lstlisting}
    
\noindent Invoking \texttt{send} with an \texttt{int} (noted with (1) in the code above) or any integral type
(other than \texttt{unsigned}~\texttt{char}{\cprotect\footnote{Note that
implicitly converting from \texttt{unsigned}~\texttt{char} to either a
\texttt{long} or \texttt{unsigned} integer involves a \textbf{standard
conversion}\glossary{standard
conversion} (not just an \textbf{integral promotion}\glossary{integral promotion}), the same as
  converting to a \texttt{double}.}}) that promotes to \texttt{int} (2)
will map exclusively to the deleted \texttt{send(int)} overload; all
other integral (3 \& 4) and floating-point types (5) are convertible to
both (via a \textbf{standard conversion}\glossary{standard conversion}) and hence will be ambiguous.
An explicit cast to \texttt{unsigned}~\texttt{char} (6) can always be
pressed into service if needed.

\subsubsection[Hiding a structural (nonpolymorphic) base class's member function]{Hiding a structural (nonpolymorphic) base class’s member function}\label{hiding-a-structural-(nonpolymorphic)-base-class's-member-function}

Best practices notwithstanding,{\cprotect\footnote{By publicly deriving
from a concrete class, we do not hide the underlying capabilities,
which can easily be accessed (perhaps accidentally) via assignment to
a pointer or reference to a base class (no casting required). What's
more, inadvertently passing such a class to a function taking the base
class by value will result in \emph{slicing}, which can be especially
problematic when the derived class holds data. Finally, if the derived
class purports to maintain \emph{class invariants} that the base class
does not preserve, this design technique is beyond dubious; a more
robust approach would be to use layering or at least private
inheritance. For more on improving compositional designs at scale, see
  \textbf{{lakos20}}, sections 3.5.10.5 and 3.7.3, pp.~687--703 and
  726--727, respectively.}} it can be cost-effective (in the short
term) to provide an elided ``view'' on a concrete class for (trusted)
clients. Imagine a class \texttt{AudioStream} designed to play sounds
and music that --- in addition to providing basic ``play'' and
``rewind'' operations --- sports a large, robust interface:

\begin{lstlisting}[language=C++]
struct AudioStream
{
    void play();
    void rewind();
    // ...
    // ... (large, robust interface)
    // ...
};
\end{lstlisting}
    

Now suppose that, on short notice, we need to whip up a very similar
class,\linebreak[4] \texttt{ForwardAudioStream}, to use with audio samples that
cannot be rewound (e.g., coming directly from a live feed). Realizing
that we can readily reuse most of \texttt{AudioStream}'s interface, we
pragmatically decide to prototype the new class simply by exploiting
public \textbf{structural inheritance}\glossary{structural inheritance} and then deleting just the lone
unwanted \texttt{rewind} member function:

\begin{lstlisting}[language=C++]
struct ForwardAudioStream : AudioStream
{
    void rewind() = delete; // make just this one function unavailable
};

void f()
{
    ForwardAudioStream stream = FMRadio::getStream();
    stream.play();   // fine
    stream.rewind(); // Error: (ù{\codeincomments{rewind()}}ù) is deleted.
}
\end{lstlisting}
    
\noindent If the need for a \texttt{ForwardAudioStream} type persists, we can always
consider reimplementing it more carefully later.{\cprotect\footnote{\textbf{{lakos20}}, sections 3.5.10.5 and 3.7.3, pp.~687--703 and 726--727}}

\subsection[Potential Pitfalls]{Potential Pitfalls}\label{potential-pitfalls}

None so far

\subsection[Annoyances]{Annoyances}\label{annoyances}

None so far

\subsection[See Also]{See Also}\label{see-also}

\begin{itemize}
\item{Section~\ref{Defaulted-Special-Member-Functions}, ``\titleref{Defaulted-Special-Member-Functions}" — Companion safe C++11 feature that enables \emph{defaulting} (as opposed to \emph{deleting}) special member functions}
\item{Section~\ref{Rvalue-References}, ``\titleref{Rvalue-References}" — Conditionally safe C++11 feature that introduces the two \emph{move} variants to \emph{copy} special member functions}
\end{itemize}

\subsection[Further Reading]{Further Reading}\label{further-reading}

None so far



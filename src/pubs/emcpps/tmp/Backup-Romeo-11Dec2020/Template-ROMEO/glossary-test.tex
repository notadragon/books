****: TODO (include any expression that is used to refer to a class member, such as `object.member`, `object->member`, `object.*member`.)

****: TODO

****: An expression that can be evaluated at compile-time.  Mention `constexpr` and state that `const` variables that are initialized from a compile-time constants are themselves required to be compile-time constants.  New info to me in June 2020, worthwhile to have.

****: 

**Copy semantics**: TODO

**Declaration**: TODO

**Declared type**: TODO The type of the *entity* named by the given expression.

**Entity**: TODO

**Expression SFINAE**: TODO

**Fundamental type**: TODO

**Hiding**: Function-name *hiding* occurs when a member function in a derived class has the same name as one in the base class, but it is not overriding it due to a difference in the function signature or because the member function in the base class is not `virtual`. The hidden member function will *not* participate in dynamic dispatch; the member function of the base class will be invoked instead when invoked via a pointer or reference to the base class . The same code would have invoked the derived class's implementation had the member function of the base class had been *overridden* rather than *hidden*.

**Id-expression**: TODO are most commonly *Identifiers*; other forms include overloaded operator names (in function notation), names of user-defined-conversion or literal operators, and destructor names, and ??template names followed by their argument lists??.

**Ill-formed**: TODO (`[temp.res]p8`)

**Integer literal**: TODO

**Move semantics**: TODO

**Non-trivial special member function**: TODO

**Overriding:** TODO

**Placement `new`**: TODO

**POD type**: TODO

**RAII**: TODO

**Range**: TODO

**Redundant check**: TODO

**Reference type**: TODO

**SFINAE**: TODO

**Signature**: TODO

**Special member function**: TODO

**String literal**: TODO

**Structural inheritance**: TODO

**Sum type**: Abstract data type allowing the representation of one of multiple possible alternative types. Each alternative has its own type (and state), and only one alternative can be "active" at any given point in time. Sum types automatically keep track of which choice is "active", and properly implement value-sematic special member functions (even for non-trivial types). They can be implemented efficiently as a C++ `class` using a C++ `union` and a separate (integral) discriminator. This sort of implementation is commonly referred to as a discriminating (or "tagged") union.

**Template instantiation time**: TODO

**Template instantiation**: TODO

**Trivial type**: TODO

**Type trait**: TODO

**Undefined behavior**: TODO

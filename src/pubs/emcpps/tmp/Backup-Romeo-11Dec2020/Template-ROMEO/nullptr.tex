

The keyword \texttt{nullptr} (unambiguously) denotes the
null-pointer-value literal.

\subsection[Description]{Description}\label{description}

The \texttt{nullptr} keyword is a \textbf{prvalue} (pure rvalue) of type
\texttt{std::nullptr\_t} representing the (implementation-defined)
bit pattern corresponding to a \textbf{null address} on the host platform;
\texttt{nullptr} and other values of type \texttt{std::nullptr\_t}
(along with the integer literal \texttt{0} and the macro \texttt{NULL})
can be converted implicitly to any pointer (or pointer-to-member) type:

\begin{lstlisting}[language=C++]
int data;  // non-member data

int *pi0 = &data;    // Initialize with non-null address.
int *pi1 = nullptr;  // Initialize with null address.
int *pi2 = NULL;     //  "          "    "    "
int *pi3 = 0;        //  "          "    "    "

double f(int x);  // non-member function

double (*pf0)(int) = &f;       // Initialize with non-null address.
double (*pf1)(int) = nullptr;  // Initialize with null address.

struct S
{
    short d_data;    // member data
    float g(int y);  // member function
};

short S::*pmd0 = &S::d_data;  // Initialize with non-null address.
short S::*pmd1 = nullptr;     // Initialize with null address.

float (S::*pmf0)(int) = &S::g;    // Initialize with non-null address.
float (S::*pmf1)(int) = nullptr;  // Initialize with null address.
\end{lstlisting}
    

\noindent Because \texttt{std::nullptr\_t} is its own distinct type, overloading on
it is possible:

\begin{lstlisting}[language=C++]
#include <cstddef>  // (ù{\codeincomments{std::nullptr\_t}}ù)

void g(void*);           // (1)
void g(int);             // (2)
void g(std::nullptr_t);  // (3)

void f()
{
    g("hello");  // OK --- (1) (ù{\codeincomments{void g(void}}ù)*(ù{\codeincomments{)}}ù)
    g(0);        // OK --- (2) (ù{\codeincomments{void g(int)}}ù)
    g(nullptr);  // OK --- (3) (ù{\codeincomments{void g(std::nullptr\_t)}}ù)
    g(NULL);     // Error: ambiguous --- (1), (2), or (3)
}
\end{lstlisting}
    

\subsection[Use Cases]{Use Cases}\label{use-cases}

\subsubsection[Improve type safety]{Improve type safety}\label{improve-type-safety}

In pre-C++11 code bases, use of the \texttt{NULL}
macro{\cprotect\footnote{In the C Standard, the macro \texttt{NULL} is
defined as an \textbf{implementation-defined} integral or \texttt{void*}
constant. Unlike C, C++ forbids conversions from \texttt{void*} to
arbitrary pointer types and instead, prior to C++11, defined
\texttt{NULL} as an \emph{``integral constant expression rvalue of
integer type that evaluates to zero''}; any integer literal (e.g.,
\texttt{0}, \texttt{0L}, \texttt{0U}, \texttt{0LLU}) satisfies this
  criterion.}} was a common way of indicating (mostly to the human
reader) that the literal value it conveys is intended specifically to
represent a \emph{null address} rather than the literal \texttt{int}
value \texttt{0}. From a type-safety perspective, its
implementation-defined (typically integral{\cprotect\footnote{As of
C++11, the definition of \texttt{NULL} has been expanded to --- in
theory --- permit \texttt{nullptr} as a conforming definition; as of
this writing, however, no major compiler vendors do so. Both GCC and
Clang default to \texttt{0L} (\texttt{long}~\texttt{int}) while MSVC
defaults to \texttt{0} (\texttt{int}). Such definitions are unlikely
to change since existing code could cease to compile or (possibly
  silently) present altered run-time behavior.}}) definition, however,
makes the use of \texttt{NULL} only marginally better suited than a raw
literal \texttt{0} to represent a null pointer.

As just one specific illustration of the added type safety provided by
\texttt{nullptr}, imagine that you work for a large software company
that has historically required, as one of its coding standards, that
values returned via output parameters (as opposed to a \texttt{return}
statement) are always returned via pointer to a modifiable
object.{\cprotect\footnote{Functions that return via argument typically
do so to reserve the function's return value to communicate status.
  See \textbf{{lakos96}}, section~9.1.11, pp.~621--628, specifically the
  \emph{Guideline} at the bottom of p.~621: ``Be consistent about
  returning values through arguments (e.g., avoid declaring
  non-\texttt{const} reference parameters)."}} In the illustrative function below, the output parameter's local pointer
variable is ``zeroed'' (shown here in three different ways) to indicate
(and ensure) that nothing more is to be written:

\begin{lstlisting}[language=C++]
int illustrativeFunction(int* x)   // pointer to modifiable integer
{
    // ...
    if (/*...*/)
    {
        x = 0;       // (1) Set pointer (ù{\codeincomments{x}}ù) to null address.
        x = NULL;    // (2) Set pointer (ù{\codeincomments{x}}ù) to null address.
        x = nullptr; // (3) Set pointer (ù{\codeincomments{x}}ù) to null address.
    }
    // ...
    return 0;    // success
}
\end{lstlisting}
    

Now suppose that the function signature is changed (e.g., due to a
change in coding standards in the organization) to accept a reference
instead of a pointer:

\begin{lstlisting}[language=C++]
int illustrativeFunction(int& x)  // reference to modifiable integer
{
    // ...
    if (/*...*/)
    {
        x = 0;       // (1) always compiles; makes what (ù{\codeincomments{x}}ù) refers to 0
        x = NULL;    // (2) implementation-defined (might warn)
        x = nullptr; // (3) always a compile-time error
    }
    // ...
    return 0;    // SUCCESS
}
\end{lstlisting}
    

As the example above demonstrates, how we represent the notion of a
\textbf{null address} matters:
\begin{enumerate}
\item{\texttt{0} — Portable across all implementations but minimal type safety.}
\item{\texttt{NULL} — Implemented as a macro; added type safety (if any) is platform specific.}
\item{\texttt{nullptr} — Portable across all implementations and fully type-safe.}
\end{enumerate}
Use of \texttt{nullptr} instead of \texttt{0} or \texttt{NULL} to denote
a null address maximizes type safety and readability, while avoiding
both macros and implementation-defined behavior.

\subsubsection[Disambiguation of \tt{(int) 0} versus \tt{(T*) 0} during overload resolution]{Disambiguation of {\ParaCode (int) 0} versus {\ParaCode (T*) 0} during overload resolution}\label{disambiguation-of-(int)-0-versus-(t*)-0-during-overload-resolution}

The platform-dependent nature of \texttt{NULL} presents additional
challenges when used to call a function whose overloads differ only in
accepting a pointer or an integral type as the same positional argument
(which might be the case, e.g., in a poorly designed third-party
library):

\begin{lstlisting}[language=C++]
void uglyLibraryFunction(int* p);  // (1)
void uglyLibraryFunction(int  i);  // (2)
\end{lstlisting}
    

\noindent Calling this function with the literal \texttt{0} will always invoke
overload (2), but that might not always be what casual clients expect:

\begin{lstlisting}[language=C++]
void f()
{
    uglyLibraryFunction(0);         // unambiguously invokes (2)
    uglyLibraryFunction((int*) 0);  // unambiguously invokes (1)
    uglyLibraryFunction(nullptr);   // unambiguously invokes (1)
    uglyLibraryFunction(NULL);      // anything! (platform-defined)
    uglyLibraryFunction(0L);        // always ambiguous
    uglyLibraryFunction(0U);        // always ambiguous
}
\end{lstlisting}
    

\noindent\texttt{nullptr} is especially useful when such problematic overloads
are unavoidable because it obviates explicit
casts.{\cprotect\footnote{N.B., Explicitly casting \texttt{0} to an
appropriately typed pointer (other than \texttt{void*}) was at one
  time considered by some to be a best practice, especially in C.}}

\subsubsection[Overloading for a literal null pointer]{Overloading for a literal null pointer}\label{overloading-for-a-literal-null-pointer}

Being a distinct type, \texttt{std::nullptr\_t} can itself participate
in an overload set:

\begin{lstlisting}[language=C++]
void f(int* v);          // (1)
void f(std::nullptr_t);  // (2)

void g()
{
    int* ptr = nullptr;
    f(ptr);      // unambiguously invokes (1)
    f(nullptr);  // unambiguously invokes (2)
}
\end{lstlisting}
    

\noindent Given the relative ease with which a \texttt{nullptr} (above) can be
converted to a typed pointer having the same null-address value, such
overloads are, however, dubious when used to control essential behavior.
Nonetheless, one can envision such use to, say, aid in compile-time
diagnostics when passing a \textbf{null address} would otherwise result in
a runtime error\footnote{see also Section~\ref{deleted-functions}, ``\titleref{deleted-functions}"}:

\begin{lstlisting}[language=C++]
std::size_t strlen(const char* s);
    // The behavior is undefined unless (ù{\codeincomments{s}}ù) is null-terminated.

std::size_t strlen(std::nullptr_t);
    // declared but not defined 
\end{lstlisting}
    

\noindent Another arguably safe use of such an overload for a \texttt{nullptr} is
to avoid a null-pointer check. However, for cases where the client knows the address is null at compile time, better ways typically exist for avoiding the (often
insignificant) overhead to test for a null pointer at runtime.

\subsection[Potential Pitfalls]{Potential Pitfalls}\label{potential-pitfalls}

None so far

\subsection[Annoyances]{Annoyances}\label{annoyances}

None so far

\subsection[See Also]{See Also}\label{see-also}

None so far

\subsection[Further Reading]{Further Reading}\label{further-reading}

None so far




Any nonreference type is permitted to be a member of a \texttt{union}.

\subsection[Description]{Description}\label{unrestrictedunion-description}

Prior to C++11, only \textbf{trivial types}\glossary{trivial types} --- e.g.,
\textbf{fundamental types}, such as \texttt{int} and \texttt{double},
enumerated or pointer types, or a C-style array or \texttt{struct}
(a.k.a. a \textbf{POD}\glossary{POD}) --- were allowed to be members of a
\texttt{union}. This limitation prevented any (user-defined) type having
a \textbf{non-trivial special member function}\glossary{non-trivial special member function} from being a member of a
\texttt{union}:

\begin{lstlisting}[language=C++]
union U0
{
    int         d_i;  // OK
    std::string d_s;  // compile-time error in C++03 (OK as of C++11)
};
\end{lstlisting}
    
\noindent C++11 relaxes such restrictions on \texttt{union} members, such as
\texttt{d\_s} above, allowing any type other than a \textbf{reference
type}\glossary{reference
type} to be a member of a \texttt{union}.

A \texttt{union} type is permitted to have user-defined special member
functions but --- by design --- does not initialize any of its members
automatically. Any member of a \texttt{union} having a
\textbf{non-trivial constructor}\glossary{non-trivial constructor}, such as \texttt{struct}~\texttt{Nt}
(below), must be constructed manually (e.g., via \textbf{placement
\texttt{new}}\glossary{placement
\texttt{new}} implemented within the body of a constructor of the union
itself) before it can be used:

\begin{lstlisting}[language=C++]
struct Nt  // used as part of a (ù{\codeincomments{union}}ù) (below)
{
    Nt();   // non-trivial default constructor
    ~Nt();  // non-trivial destructor

    // Copy construction and assignment are implicitly defaulted.
    // Move construction and assignment are implicitly deleted.
};
\end{lstlisting}
    
\noindent As an added safety measure, any non-trivial \textbf{special member
function}\glossary{special member
function} defined --- either implicitly or explicitly --- for any
\emph{member} of a \texttt{union} results in the compiler implicitly
deleting (see Section~\ref{deleted-functions}, ``\titleref{deleted-functions}") the corresponding \textbf{special
member function}\glossary{special
member function} of the \texttt{union} itself:

\begin{lstlisting}[language=C++]
union U1
{
    int d_i;   // fundamental type having all trivial special member functions
    Nt  d_nt;  // user-defined type having non-trivial special member functions

    // Implicitly deleted special member functions of (ù{\codeincomments{U1}}ù):
    /*
        U1()                     = delete; // due to explicit (ù{\codeincomments{Nt::Nt()}}ù)
        U1(const U1&)            = delete; // due to implicit (ù{\codeincomments{Nt::Nt(const Nt\&)}}ù)
        ~U1()                    = delete; // due to explicit (ù{\codeincomments{Nt::}}ù)~(ù{\codeincomments{Nt()}}ù)
        U1& operator=(const U1&) = delete; // due to implicit 
                                           // (ù{\codeincomments{Nt::operator=(const Nt\&)}}ù)
    */
};
\end{lstlisting}
    
\noindent This same sort of precautionary deletion also occurs for any class
containing such a union as a data member (see {\it\titleref{unrestrictedunion-use-cases}: \titleref{implementing-a-sum-type-as-a-discriminating-(or-tagged)-union}} on page~\pageref{implementing-a-sum-type-as-a-discriminating-(or-tagged)-union}).

A special member function of a \texttt{union} that is implicitly deleted
can be restored via explicit declaration, thereby forcing a programmer
to think about how non-trivial members should be managed. For example,
we can start providing a \emph{value constructor} and corresponding
\emph{destructor}:

\begin{lstlisting}[language=C++]
struct U2
{
    union
    {
        int  d_i;   // fundamental type (trivial)
        Nt   d_nt;  // non-trivial user-defined type
    };

    bool d_useInt;  // discriminator

    U2(bool useInt) : d_useInt(useInt)       // value constructor
    {
        if (d_useInt) { new (&d_i) int(); }  // value initialized (to (ù{\codeincomments{0}}ù))
        else          { new (&d_nt) Nt(); }  // default constructed in place
    }

    ~U2()  // destructor
    {
        if (!d_useInt) { d_nt.~Nt(); }
    }
};
\end{lstlisting}
    
\noindent Notice that we have employed \textbf{placement \texttt{new}}\glossary{placement \texttt{new}} syntax to
control the lifetime of both member objects. Although assignment would
be permitted for the (trivial) \texttt{int} type, it would be
\textbf{undefined behavior}\glossary{undefined behavior} for the (non-trivial) \texttt{Nt} type:

\begin{lstlisting}[language=C++]
U2(bool useInt) : d_useInt(useInt)  // value constructor
{
    if (d_useInt) { d_i = int(); }  // value initialized (to (ù{\codeincomments{0}}ù))
    else          { d_nt = Nt(); }  // undefined behavior
}
\end{lstlisting}
    
\noindent Now if we were to try to copy-construct or assign an object of type
\texttt{U2} to another, the operation would fail because we have not
(yet) specifically addressed those \textbf{special member functions}\glossary{special member functions}:

\begin{lstlisting}[language=C++]
void f()
{
    U2 a(false), b(true);  // OK (construct both instances of (ù{\codeincomments{U2}}ù))
    U2 c(a);               // compile-time error: no (ù{\codeincomments{U2(const U2\&)}}ù)
    a = b;                 // compile-time error: no (ù{\codeincomments{U2\& operator=(const U2\&)}}ù)
}
\end{lstlisting}
    
\noindent We can restore these implicitly deleted special member functions too,
simply by adding appropriate copy-constructor and assignment-operator
definitions for \texttt{U2} explicitly{\cprotect\footnote{Attempting to
restore a \texttt{union}'s implicitly deleted special member
functions by using the \texttt{=}~\texttt{default} syntax (see
Section~\ref{Defaulted-Special-Member-Functions}, ``\titleref{Defaulted-Special-Member-Functions}") will still result in their being deleted because
the compiler cannot know which member of the union is active without a
  discriminator.}}:

\begin{lstlisting}[language=C++]
union U2
{
    // ... (everything in (ù{\codeincomments{U2}}ù) above)

    U2(const U2& original) : d_useInt(original.d_useInt)
    {
        if (d_useInt) { new (&d_i) int(original.d_i);  }
        else          { new (&d_nt) Nt(original.d_nt); }
    }

    U2& operator=(const U2& rhs)
    {
        if (this == &rhs) // Prevent self-assignment.
        {
            return *this;
        }

        // Resolve all possible combinations of active types between the 
        // left-hand side and right-hand side of the assignment:

        if (d_useInt)
        {
            if (rhs.d_useInt) { d_i = rhs.d_i; }
            else              { new (&d_nt) Nt(rhs.d_nt); }
        }
        else
        {
            if (rhs.d_useInt) { d_nt.~Nt(); new (&d_i) int(rhs.d_i); }
            else              { d_nt = rhs.d_nt; }
        }

        return *this;
    }
};
\end{lstlisting}
    

\subsection[Use Cases]{Use Cases}\label{unrestrictedunion-use-cases}

\subsubsection[Implementing a \textbf{sum type}\glossary{sum type} as a discriminating (or tagged) \tt{union}]{Implementing a \textbf{sum type}\glossary{sum type} as a discriminating (or tagged) {\ParaCode union}}\label{implementing-a-sum-type-as-a-discriminating-(or-tagged)-union}

A \textbf{sum type}\glossary{sum type} is an abstract data type that provides a choice
among a fixed set of specific types. Although other implementations are
possible, using the storage of a single object to accommodate one out of
a set of types along with a (typically integral) discriminator enables
programmers to implement a \textbf{sum type}\glossary{sum type} (a.k.a.
\emph{discriminating} or \emph{tagged} union) efficiently (e.g., without
necessarily involving memory allocation or virtual dispatch) and
nonintrusively (i.e., the individual types comprised need not be related
in any way). A C++ \texttt{union} can serve as a convenient and
efficient way to define storage for a \textbf{sum type}\glossary{sum type} as alignment and
size calculations are performed (by the compiler) automatically.

As an example, consider writing a parsing function \texttt{parseInteger}
that, given a\linebreak[4] \texttt{std::string} \texttt{input}, will return, as a
\textbf{sum type}\glossary{sum type} \texttt{ParseResult} (see below), either an
\texttt{int} result (on success) or an informative error message
(on failure):

\begin{lstlisting}[language=C++]
ParseResult parseInteger(const std::string& input)  // Return a sum type.
{
    int result;     // accumulate (ù{\codeincomments{result}}ù) as we go
    std::size_t i;  // current character index

    // ...

    if (/* Failure case (1). */)
    {
        std::ostringstream oss;
        oss << "Found non-numerical character '" << input[i]
            << "' at index '" << i << "'.";

        return ParseResult(oss.str());
    }

    if (/* Failure case (2). */)
    {
        std::ostringstream oss;
        oss << "Accumulating '" << input[i]
            << "' at index '" << i
            << "' into the current running total '" << result
            << "' would result in integer overflow.";

        return ParseResult(oss.str());
    }

    // ...

    return ParseResult(result);  // Success!
}
\end{lstlisting}
    
\noindent The implementation above relies on \texttt{ParseResult} being able to
hold a value of type either \texttt{int} or \texttt{std::string}. By
encapsulating a C++ \texttt{union} and a Boolean{\cprotect\footnote{For
\textbf{sum types}\glossary{sum types} comprising more than two types, a larger integral
  or enumerated type may be used instead.}} \emph{discriminator} as part
of the \texttt{ParseResult} \textbf{sum type}\glossary{sum type}, we can achieve the
desired semantics:

\begin{lstlisting}[language=C++]
class ParseResult
{
    union  // storage for either the result or the error
    {
        int         d_value;  // trivial result type
        std::string d_error;  // non-trivial error type
    };

    bool d_isError;  // discriminator

public:
    explicit ParseResult(int value);                 // value constructor (1)
    explicit ParseResult(const std::string& error);  // value constructor (2)

    ParseResult(const ParseResult& rhs);             // copy constructor
    ParseResult& operator=(const ParseResult& rhs);  // copy assignment

    ~ParseResult();                                  // destructor
};
\end{lstlisting}
    
\noindent As discussed in {\it\titleref{unrestrictedunion-description}} on page~\pageref{unrestrictedunion-description}, having a non-trivial
type within a \texttt{union} forces the programmer to provide each
desired special member function and define it manually; note, although,
that the use of placement \texttt{new} is not required for either of the
two \emph{value constructors} (above) because the initializer syntax
(below) is sufficient to begin the lifetime of even a non-trivial
object:

\begin{lstlisting}[language=C++]
ParseResult::ParseResult(double value) : d_value(value), d_isError(false)
{
}

ParseResult::ParseResult(const std::string& error) 
    : d_error(error), d_isError(true)
    // Note that placement (ù{\codeincomments{new}}ù) was not necessary here because a new 
    // (ù{\codeincomments{std::string}}ù) object will be created as part of the initialization of 
    // (ù{\codeincomments{d\_error}}ù).
{
}
\end{lstlisting}
    
\noindent Placement \texttt{new} and explicit destructor calls are, however,
required for destruction and both copy operations{\cprotect\footnote{For
more information on initiating the lifetime of an object, see \textbf{iso14}, section 3.8, ``Object Lifetime," pp. 66--69.}}:

\begin{lstlisting}[language=C++]
ParseResult::~ParseResult()
{
    if(d_isError)
    {
        d_error.std::string::~string();
            // An explicit destructor call is required for (ù{\codeincomments{d\_error}}ù) because its
            // destructor is non-trivial.
    }
}

ParseResult::ParseResult(const ParseResult& rhs) : d_isError(rhs.d_isError)
{
    if (d_isError)
    {
        new (&d_error) std::string(rhs.d_error);
            // Placement (ù{\codeincomments{new}}ù) is necessary here to begin the lifetime of a
            // (ù{\codeincomments{std::string}}ù) object at the address of (ù{\codeincomments{d\_error}}ù).
    }
    else
    {
        d_value = rhs.d_value;
            // Placement (ù{\codeincomments{new}}ù) is not necessary here as (ù{\codeincomments{int}}ù) is a trivial type.
    }
}

ParseResult& ParseResult::operator=(const ParseResult& rhs)
{
    // Destroy (ù{\codeincomments{lhs}}ù)'s error string if existent:
    if (d_isError) { d_error.std::string::~string(); }

    // Copy (ù{\codeincomments{rhs}}ù)'s object:
    if (rhs.d_isError) { new (&d_error) std::string(rhs.d_error); }
    else               { d_value = rhs.d_value; }

    d_isError = rhs.d_isError;
    return *this;
}
\end{lstlisting}
    
\noindent In practice, \texttt{ParseResult} would typically be defined as a
template and renamed to allow any arbitrary result type \texttt{T} to be
returned or else implemented in terms of a more general \textbf{sum
type}\glossary{sum type} abstraction.{\cprotect\footnote{\texttt{std::variant}, introduced
in C++17, is the standard construct used to represent a \textbf{sum
type}\glossary{sum type} as a \emph{discriminating union}. Prior to C++17,
\texttt{boost::variant} was the most widely used \emph{tagged} union
  implementation of a \textbf{sum type}\glossary{sum type}.}}

\subsection[Potential Pitfalls]{Potential Pitfalls}\label{potential-pitfalls}

\subsubsection[Inadvertent misuse can lead to latent \textbf{undefined behavior}\glossary{undefined behavior} at runtime]{Inadvertent misuse can lead to latent \textbf{undefined behavior}\glossary{undefined behavior} at runtime}\label{inadvertent-misuse-can-lead-to-latent-undefined-behavior-at-runtime}

When implementing a type that makes use of an unrestricted union,
forgetting to initialize a non-trivial object (using either a
\emph{member initialization list} or \textbf{placement \texttt{new}}\glossary{placement \texttt{new}}) or
accessing a different object than the one that was actually initialized
can result in tacit \textbf{undefined behavior}\glossary{undefined behavior}. Although forgetting to
destroy an object does not necessarily result in \textbf{undefined
behavior}\glossary{undefined behavior}, failing to do so for any object that manages a resource (such
as dynamic memory) will result in a \emph{resource leak} and/or lead to
unintended behavior. Note that destroying an
object having a trivial destructor is never necessary; there are, however, rare cases where
we may choose not to destroy an object having a non-trivial
one.{\cprotect\footnote{A specific example of where one might
deliberately choose \emph{not} to destroy an object occurs when a
collection of related objects are allocated from the same local memory
resource and then deallocated unilaterally by releasing the memory
back to the resource. No issue arises if the only resource that is ``leaked''
by not invoking each individual destructor is the memory allocated
from that memory resource, and that memory can be
reused without resulting in \textbf{undefined behavior}\glossary{undefined behavior} if it
is not subsequently referenced in the context of the deallocated
  objects.}}

\subsection[Annoyances]{Annoyances}\label{annoyances}

None so far

\subsection[See Also]{See Also}\label{see-also}

\begin{itemize}
\item{Section~\ref{deleted-functions}, ``\titleref{deleted-functions}" — Safe C++11 feature that forbids the invocation of a particular function. Similar effects to deleting a function happen when we specify a special function within a subobject of a union or when a class has such a union as a data member.}
\end{itemize}

\subsection[Further Reading]{Further Reading}\label{further-reading}

None so far



An attribute can
generally appear syntactically at the beginning of any
\emph{statement}, -- e.g., \texttt{[[attr]]} \texttt{x} \texttt{=}
\texttt{5;} -- or in almost any position relative to a \emph{type} or
\emph{expression} (e.g., \texttt{const} \texttt{int} \texttt{\&} ) but
typically cannot be associated within a named objects outside of a
declaration statement:

\begin{lstlisting}[language=C++, basicstyle={\ttfamily\footnotesize}]
[[]] static [[]] int [[]] a [[]], /*[[]]*/ b [[]];  // declaration statement
\end{lstlisting}


Notice how we have used the empty attribute syntax \texttt{[[]]} above
to probe for statically viable positions for arbitrary attributes on
the host platform (in this case GCC) -- the only invalid one being
immediately following the comma, shown above as \texttt{/*[[]*/}.
Outside of a declaration statement, however, viable attribute
locations are typically far more limited:

\begin{lstlisting}[language=C++, basicstyle={\ttfamily\footnotesize}]
[[]] void [[]] f [[]] ( [[]] int [[]] n [[]] )
[[]] {
[[]] n /**/ *= /**/ sizeof /**/ ( [[]] const [[]] int [[]] & [[]] ) /**/;
[[]] for ([[]] int [[]] i [[]] = /**/ 0 /**/ ;
/**/ i  /**/ < /**/ n /**/ ;
/**/ ++ /**/ i /**/ )
[[]] {
[[]] ;                      // (*{\codeincomments{[[]]}}*) denotes viable attribute location
      /**/ }
  /**/ }                              // (*{\codeincomments{/**/}}*) denotes no attribute is allowed
  \end{lstlisting}


  Type expressions -- e.g., the argument to \texttt{sizeof} (above) --
  are a notable exception.^^E^^L 

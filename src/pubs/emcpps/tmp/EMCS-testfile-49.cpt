The notion of the largest supported alignment is characterized by both \textbf{maximal alignment} and the maximum \textbf{extended alignment}. \textbf{Maximal alignment} is defined as that most restrictive alignment that is valid in \emph{all} contexts on the current platform. All fundamental and pointer types necessarily have a minimal alignment that is less than or equal to \texttt{alignof(std::max\_align\_t)} â€” typically 8 or 16. Any alignment value greater than \textbf{maximal alignment} is an \textbf{extended alignment} value. Whether any extended alignment is supported (and in which contexts) is implementation defined. On typical platforms, extended alignment will often be as large as $2^{18}$ or $2^{19}$, however implementations may warn when the alignment of a global object exceeds some maximal hardware threshold (such as the size of a physical memory page, e.g., 4096 or 8192). For \textbf{automatic variables} (defined on the program stack), making alignment more restrictive than what would naturally be employed  is seldom desired because at most one thread is able to access proximately located variables there unless explicitly passed in via address to separate threads; see \textit{\titleref{alignas-use-cases}: \titleref{avoiding-false-sharing-among-distinct-objects-in-a-multi-threaded-program}} on page~\pageref{avoiding-false-sharing-among-distinct-objects-in-a-multi-threaded-program}. Note that, in the case of \texttt{i} in the first code snippet on page~\pageref{restricting-the-alignment-of-a-particular-object}, a conforming platform that did not support an extended alignment of 64 would be required to report an error at compile time.^^E^^L 

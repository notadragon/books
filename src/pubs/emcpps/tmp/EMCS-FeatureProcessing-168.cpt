Notice that this \texttt{Count}
\textbf{metafunction} also makes use (in its implementation) of
variadic class templates to parse a \textbf{type list} of unbounded
depth. Had this been a C++03 implementation, we would have been forced
to create an approximation (to the simple class-template
specialization containing the \textbf{parameter pack}
\texttt{Tail...}) consisting of a bounded number (e.g., 20) of simple
(class) template specializations, each one taking an increasing number
of template arguments:

\begin{lstlisting}[language=C++, basicstyle={\ttfamily\footnotesize}]
template <typename X, typename Y>
struct Count<X, TypeList<Y>>
    : std::integral_constant<int, std::is_same<X, Y>::value> { };
    // (class) template specialization for one argument

template <typename X, typename Y, typename Z>
struct Count<X, TypeList<Y, Z>>
    : std::integral_constant<int,
        std::is_same<X, Y>::value + std::is_same<X, Z>::value> { };
    // (class) template specialization for two arguments

template <typename X, typename Y, typename Z, typename A>
struct Count<X, TypeList<Y, Z, A>>
    : std::integral_constant<int,
        std::is_same<X, Y>::value + Count<X, TypeList<Z, A>>::value> { };
    // recursive (class) template specialization for three arguments

// ...
\end{lstlisting}
      ^^E^^L 

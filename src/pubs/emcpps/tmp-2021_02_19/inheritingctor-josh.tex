% 12 Feb 2021, revisions in; ready for Josh's code fixes
% 16 Feb 2021 JMB; code compiles

\emcppsFeature{
    short={Inheriting Ctors},
    long={Inheriting Base Class Constructors},
}{ctorinheriting}
\label{inheriting-constructors}
\setcounter{table}{0}
\setcounter{footnote}{0}
\setcounter{lstlisting}{0}
%\section[Inheriting Ctors]{Inheriting Base Class Constructors}\label{ctorinheriting}\label{inheriting-constructors}



The term \emph{inheriting constructors} refers to the use of a
\romeogloss{\lstinline!using! declaration} to expose nearly all of the
constructors of a base class in the scope of a derived class.

\subsection[Description]{Description}\label{description-inheritingctor}

In a class definition, a \romeogloss{\lstinline!using! declaration} naming a
base class's constructor results in the derived class ``inheriting'' all
of the nominated base class's constructors, except for \emph{copy} and
\emph{move} constructors. Just like \lstinline!using! declarations of member functions, the nominated base class's
constructors will be considered when no matching constructor is found in
the derived class. When a base class constructor is selected in this way,
that constructor will be used to construct the base class and the
remaining bases and data members of the subclass will be initialized as
if by the default constructor (e.g., applying default initializers;
see \featureref{\locationc}{Default-Member-Initializers}).
%``\titleref{Default-Member-Initializers}" on page~\pageref{Default-Member-Initializers}). 

\begin{emcppslisting}[emcppsbatch=e1]
struct B0
{
    B0() = default;      // public, default constructor
    B0(int)         { }  // public, one argument (implicit) value constructor
    B0(int, int)    { }  // public, two argument value constructor

private:
    B0(const char*) { }  // private, one argument (implicit) value constructor
};

struct D0 : B0
{
    using B0::B0;  // (ù{\codeincomments{using}}ù) declaration
    D0(double d);  // suppress implicit default constructor
};

D0 t(1);     // OK, inherited from (ù{\codeincomments{B0::B0(int)}}ù)
D0 u(2, 3);  // OK, inherited from (ù{\codeincomments{B0::B0(int, int)}}ù)
D0 v("hi");  // Error, Base constructor is declared (ù{\codeincomments{private}}ù).
\end{emcppslisting}
    
\noindent The only constructors that are explicitly \emph{not} inheritable by the
derived class are the (potentially compiler-generated) \emph{copy} and
\emph{move} constructors:

\begin{emcppslisting}[emcppsbatch=e1]
#include <utility>  // (ù{\codeincomments{std::move}}ù)

B0 b1(1);              // OK, base-class object can be created.
B0 b2(2, 3);           // OK, base-class object can be created.
B0 b3(b1);             // OK, base-class object can be copied (from *lvalue*).
B0 b4(std::move(b1));  // OK, base-class object can be moved (from *rvalue*).

D0 w(b1);    // Error, Base-class copy constructor is not inherited.
D0 v;        // OK, base-class default constructor is inherited.
D0 x(B0{});  // Error, Base-class move constructor is not inherited.(ù{\footnotemark}ù)

D0 y(B0(4));  // Error, Base-class move constructor is not inherited.
D0 z(t);      // OK, uses compiler-generated (ù{\codeincomments{D0::D0(const D0\&)}}ù)
D0 j(D0(5));  // OK, uses compiler-generated (ù{\codeincomments{D0::D0(D\&\&)}}ù)
\end{emcppslisting}
{\cprotect\footnotetext{Note that we use
 braced initialization (see \featureref{\locationc}{bracedinit}) 
% ``\titleref{bracedinit}" on page~\pageref{bracedinit})
  in \lstinline!D0!~\lstinline!x(B0{});!
  to ensure that a variable \lstinline!x! of type \lstinline!D0! is declared.
  \lstinline!D0!~\lstinline!x(B0());! would instead be interpreted as a
  declaration of a function \lstinline!x! returning \lstinline!D0! and
  accepting a pointer to a nullary function returning \lstinline!B0!, which
  is referred to as the \romeogloss{most vexing parse}.}}
    
\noindent The constructors inherited by the derived class have the same effect on
whether the compiler implicitly generates special member functions as
explicitly implemented ones would. For example, \lstinline!D0!'s default
constructor would be implicitly \emph{deleted} (see \featureref{\locationa}{deleted-functions}) 
%``\titleref{deleted-functions}" on page~\pageref{deleted-functions}) 
if
\lstinline!B0! doesn't have a default constructor. Note that since the copy
and move constructors are \emph{not} inherited, their presence in the
base class wouldn't suppress implicit generation of copy and move
assignment in the derived class. For instance, \lstinline!D0!'s implicitly
generated assignment operators \romeogloss{hide} their
counterparts in \lstinline!B0!:

\begin{emcppslisting}[emcppsbatch=e1]
void f()
{
    B0 b(0), bb(0);  // Create destination and source (ù{\codeincomments{B0}}ù) objects.
    D0 d(0), dd(0);  //   "         "       "    "    (ù{\codeincomments{D0}}ù)    ".

    b = bb;          // OK, assign base from lvalue base.
    b = B0(0);       // OK,   "       "   "  rvalue   "

    d = bb;          // Error, (ù{\codeincomments{B0::operator=}}ù) is hidden by (ù{\codeincomments{D0::operator=}}ù).
    d = B0(0);       // Error,       "         "    "     "        "

    d.B0::operator=(bb);     // OK, explicit slicing is still possible.
    d.B0::operator=(B0(0));  // OK,    "         "      "   "      "

    d = dd;          // OK, assign derived from lvalue derived.
    d = D0(0);       // OK,   "        "     "  rvalue    "
}
\end{emcppslisting}
    
\noindent Note that, when inheriting constructors, private constructors in the
base class are accessed as private constructors of that base class and
are subject to the same access controls; see \intraref{annoyances-inheritingctor}{access-levels-of-inherited-constructors-are-same-as-in-base-class}. 
% \textit{\titleref{annoyances-inheritingctor}: \titleref{access-levels-of-inherited-constructors-are-same-as-in-base-class}} on page~\pageref{access-levels-of-inherited-constructors-are-same-as-in-base-class}.

Inheriting constructors having the same \romeogloss{signature} from multiple
base classes lead to ambiguity errors:

\begin{emcppslisting}
struct B1A { B1A(int); }; // Here we have two bases classes, each of which
struct B1B { B1B(int); }; // provides a conversion constructor from an int.

struct D1 : B1A, B1B
{
    using B1A::B1A;
    using B1B::B1B;
};

D1 d1(0);  // Error, Call of overloaded (ù{\codeincomments{D1(int)}}ù) is ambiguous.
\end{emcppslisting}
    
\noindent Each inherited constructor shares the same characteristics as the
corresponding one in the nominated base class's constructor and then
delegates to it. This means the \romeogloss{access specifiers}, the
\lstinline!explicit! specifier, the \lstinline!constexpr! specifier, the
default arguments, and the exception specification are also preserved by
constructor inheritance; see \featureref{\locatione}{noexcept-specifier} and \featureref{\locationc}{constexprfunc}.  
%``\titleref{noexcept}" on page~\pageref{noexcept} and ``\titleref{constexprfunc}" on page~\pageref{constexprfunc}. 
For template
constructors, the template parameter list and the default template
arguments are preserved as well:

\begin{emcppslisting}
struct B2
{
    template <typename T = int>
    explicit B2(T) { }
};

struct D2 : B2 { using B2::B2; };
\end{emcppslisting}
    
\noindent The declaration \lstinline!using!~\lstinline!B2::B2! above behaves as if a
constructor template that delegates to its nominated base class's
template was provided in \lstinline!D2!:

\begin{emcppshiddenlisting}[emcppsbatch=e2]
struct B2
{
    template <typename T = int>
    explicit B2(T) { }
};
\end{emcppshiddenlisting}
\begin{emcppslisting}[emcppsbatch=e2]
// pseudocode
struct D2 : B2
{
    template <typename T = int>
    explicit D2(T i) : B2(i) { }
};
\end{emcppslisting}
    
\noindent When deriving from a base class in which inheriting most
(but not all) of its constructors is desirable, suppressing
inheritance of one or more of them is possible by providing constructors in the
derived class having the same signature as the ones that would be
inherited:

\begin{emcppshiddenlisting}[emcppsbatch=e3]
#include <iostream>  // (ù{\codeincomments{std::cout}}ù)
\end{emcppshiddenlisting}
\begin{emcppslisting}[emcppsbatch=e3]
struct B3
{
    B3()         { std::cout << "B3()\n"; }
    B3(int)      { std::cout << "B3(int)\n"; }
    B3(int, int) { std::cout << "B3(int, int)\n"; }
};

struct D3 : B3
{
    using B3::B3;
    D3(int) { std::cout << "D3(int)\n"; }
};

D3 d;        // prints (ù{\codeincomments{"B3()"}}ù)
D3 e(0);     // prints (ù{\codeincomments{"D3(int)"}}ù) --- The derived constructor is invoked.
D3 f(0, 0);  // prints (ù{\codeincomments{"B3(int, int)"}}ù)
\end{emcppslisting}
    
\noindent In other words, we can suppress what would otherwise be an inherited
constructor from a nominated base class by simply declaring a
replacement with the same signature in the derived class. We can then
choose to either implement it ourselves, \lstinline!default! it (see \featureref{\locationa}{defaulted-special-member-functions}), 
%``\titleref{defaulted-special-member-functions}" on page~\pageref{defaulted-special-member-functions}), 
or \lstinline!delete! it (see \featureref{\locationa}{deleted-functions}). 
% ``\titleref{deleted-functions}" on page~\pageref{deleted-functions}).

If we have chosen to inherit the constructors from multiple
base classes, we can disambiguate conflicts by declaring the offending
constructor(s) explicitly in the derived class and then delegating to
the base classes if and as appropriate:

\begin{emcppslisting}
struct B1A { B1A(int); };  // Here we have two base classes, each of which
struct B1B { B1B(int); };  // provides a conversion constructor from an (ù{\codeincomments{int}}ù).

struct D3 : B1A, B1B
{
    using B1A::B1A;  // Inherit the (ù{\codeincomments{int}}ù) constructor from base class (ù{\codeincomments{B1A}}ù).
    using B1B::B1B;  // Inherit the (ù{\codeincomments{int}}ù) constructor from base class (ù{\codeincomments{B1B}}ù).

    D3(int i) : B1A(i), B1B(i) { }  // User-declare (ù{\codeincomments{int}}ù) conversion constructor
};                                  // that delegates to bases.

D3 d3(0);  // OK, calls (ù{\codeincomments{D3(int)}}ù)
\end{emcppslisting}
    
\noindent Lastly, inheriting constructors from a \romeogloss{dependent
type} affords a capability over C++03 that is more than just convenience
and avoidance of boilerplate code.{\cprotect\footnote{A decidedly more
complex alternative affording a different set of tradeoffs would
  involve variadic template constructors (see \featureref{\locationc}{variadictemplate}) 
%  ``\titleref{variadictemplate}" on page~\pageref{variadictemplate}) 
  having
 forwarding references (see \featureref{\locationc}{forwardingref}) 
% ``\titleref{forwardingref}" on page~\pageref{forwardingref}) 
 as parameters. In this
  alternative approach, all of the constructors from the
  \mbox{\lstinline!public!}, \mbox{\lstinline!protected!}, and \mbox{\lstinline!private!} regions of the
  bases class would now appear under the same access specifier --- i.e.,
  the one in which the perfectly forwarding constructor is declared.
  What's more, this approach would not retain other constructor
  characteristics, such as \lstinline!explicit!, \lstinline!noexcept!,
  \lstinline!constexpr!, and so on. The forwarding can, however, be restricted to
  inheriting just the \lstinline!public! constructors (without
  characteristics) by constraining on \lstinline!std::is_constructible!
  using \romeogloss{SFINAE}; see \intraref{annoyances-inheritingctor}{access-levels-of-inherited-constructors-are-same-as-in-base-class}.}} 
%  \textit{\titleref{annoyances-inheritingctor}: \titleref{access-levels-of-inherited-constructors-are-same-as-in-base-class}} on page~\pageref{access-levels-of-inherited-constructors-are-same-as-in-base-class}.}} 
  In all of the example code in \intrarefsimple{description-inheritingctor} 
%  \textit{\titleref{description-inheritingctor}} 
  thus far, we know how to ``spell" the
base-class constructor; we are simply automating some drudge work. In
the case of a \emph{dependent} base class, however, we do \emph{not}
know how to spell the constructors, so we \emph{must} rely on
\romeogloss{inheriting constructors} if that is the forwarding semantic we
seek:

\begin{emcppslisting}
template <typename T>
struct S : T  // The base type, (ù{\codeincomments{T}}ù), is a *dependent type*.
{
    using T::T;  // inheriting constructors (generically) from a dependent type
};

#include <string>   // (ù{\codeincomments{std::string}}ù)
#include <vector>   // (ù{\codeincomments{std::vector}}ù)

S<std::string>        ss("hello");    // OK, uses constructor from base
S<std::vector<char>> svc("goodbye");  // Error, no suitable constructor in base
\end{emcppslisting}
    
\noindent In this example, we created a class template, \lstinline!S!, that
derives publicly from its template argument, \lstinline!T!. Then, when
creating an object of type \lstinline!S! parameterized by
\lstinline!std::string!, we were able to pass it a string literal via
the inherited \lstinline!std::string! constructor overloaded on a
\lstinline!const!~\lstinline!char*!. Notice, however, that no such constructor
is available in \lstinline!std::vector!; hence, attempting to create the
derived class from a literal string results in a compile-time error. See \intraref{use-cases-ctorinheriting}{incorporating-reusable-functionality-via-a-mix-in-class}. 
%\textit{\titleref{use-cases-ctorinheriting}: \titleref{incorporating-reusable-functionality-via-a-mix-in-class}} on page~\pageref{incorporating-reusable-functionality-via-a-mix-in-class}.

\subsection[Use Cases]{Use Cases}\label{use-cases-ctorinheriting}
%\subsubsection[Abstract use case]{Abstract use case}
\label{abstract-use-case}

Use of this form of \lstinline!using! declaration to inherit a nominated
base class's constructors --- essentially verbatim --- suggests that one
or more of those constructors is sufficient to initialize the
\emph{entire} derived-class object to a valid useful state. Typically,
such will pertain only when the derived class adds no member data of its
own. While additional derived-class member data could possibly
be initialized if by a \emph{defaulted} default constructor, this state must be \emph{orthogonal} to
any modifiable state initialized in the base class, as such state is
subject to independent change via \romeogloss{slicing}, which might in turn
invalidate \romeogloss{object invariants}. Derived-class data will be either default-initialized or have its value set using member
initializers (see \featureref{\locationc}{Default-Member-Initializers}).  
%``\titleref{Default-Member-Initializers}" on page~\pageref{Default-Member-Initializers}). 
Hence, most typical use cases will involve wrapping an
existing class by deriving from it (either publicly or privately),
adding only defaulted data members having orthogonal values, and then
adjusting the derived class's behavior via \romeogloss{overriding} its virtual
or \romeogloss{hiding} its non-virtual member functions.

\subsubsection[Avoiding boilerplate code when employing structural inheritance]{Avoiding boilerplate code when employing structural inheritance}\label{avoiding-boilerplate-code-code-when-employing-structural-inheritance}

A key indication for the use of inheriting constructors is that the
derived class addresses only auxiliary or optional, rather than required
or necessary, functionality to its self-sufficient base class. As an
interesting, albeit mostly pedagogical,{\cprotect\footnote{Although this example might be compelling, it suffers from inherent deficiencies making it insufficient for general use in practice: Passing the derived class to a function --- whether by value or reference --- will
strip it of its auxiliary functionality. When we have access to the source, and alternative solution would be to use conditional compilation to add explicit checks in certain build configurations (e.g., using C-style \lstinline!assert! macros). A more robust solution along these same lines is anticipated for a future release of the C++ language standard and will be addressed in \cite{lakos23}.}} example, suppose we
want to provide a proxy for a \lstinline!std::vector! that performs
explicit checking of indices supplied to its index operator:

\begin{emcppslisting}
#include <cassert>                                                              
#include <vector>

template <typename T>
struct CheckedVector : std::vector<T>
{
    using std::vector<T>::vector;      // Inherit (ù{\codeincomments{std::vector}}ù)'s constructors.

    T& operator[](std::size_t index)   // Hide (ù{\codeincomments{std::vector}}ù)'s index operator.
    {
         assert(index < std::vector<T>::size());
         return std::vector<T>::operator[](index);
    }

    const T& operator[](std::size_t index) const  // Hide (ù{\codeincomments{const}}ù) index operator.
    {
         assert(index < std::vector<T>::size());
         return std::vector<T>::operator[](index);
    }
};
\end{emcppslisting}
    
\noindent In the example above, inheriting constructors allowed us to use public
structural inheritance to readily create a distinct new type having
all of the functionality of its base type except for a couple of
functions where we chose to augment the original behavior.

\subsubsection[Avoiding boilerplate code when employing implementation inheritance]{Avoiding boilerplate code when employing implementation inheritance}\label{avoiding-boilerplate-code-when-employing-implementation-inheritance}

Sometimes it can be cost effective to adapt a \romeogloss{concrete class}
having virtual functions{\cprotect\footnote{Useful design patterns
exist where a \romeogloss{partial implementation} class, derived from a
pure abstract interface (a.k.a. a \romeogloss{protocol}), contains data,
constructors, and pure virtual functions; see
  \cite{lakos2a}, section~4.7.}} to a specialized purpose
using inheritance.{\cprotect\footnote{Such inheritance, known as
\romeogloss{implementation inheritance}, is decidedly distinct from pure
\romeogloss{interface inheritance}, which is often the preferred design
  pattern in practice; see \cite{lakos2b}, section~4.6.}}
As an example, consider a base class,
\lstinline!NetworkDataStream!, that allows overriding its virtual functions
for processing a stream of data from an expanding variety of arbitrary
sources over the network:

\begin{emcppshiddenlisting}[emcppsbatch=e4]
#include <iostream>   // (ù{\codeincomments{std::ostream}}ù)
class DataPacket;                                                               
class RawDataStreamHandle;                                                      
class TCPConnection;                                                            
class UDPConnection;
std::ostream& operator<<(std::ostream& stream, const DataPacket& data);

struct LogTrace {};
constexpr LogTrace LOG_TRACE; // Quick and dirty syntactic simulation of logger
template <typename T>
const LogTrace& operator<<(const LogTrace& lhs, const T&) { return lhs; }
\end{emcppshiddenlisting}
\begin{emcppslisting}[emcppsbatch=e4]
class NetworkDataStream
{
private:
    // ...                   (member data)

public:
    explicit NetworkDataStream(TCPConnection* tcpConnection);
    explicit NetworkDataStream(UDPConnection* udpConnection);
    explicit NetworkDataStream(RawDataStreamHandle* rawDataStreamHandle);

    virtual ~NetworkDataStream();

    virtual void onPacketReceived(DataPacket& dataPacket) = 0;
        // Derived classes must override this method.
};        
\end{emcppslisting}
    
\noindent The \lstinline!NetworkDataStream! class above provides three constructors (with more
under development) that can be used assuming no per-packet processing is
required. Now, imagine the need for logging information about received
packets (e.g., for auditing purposes). Inheriting constructors make
deriving from \lstinline!NetworkDataStream! and overriding (see \featureref{\locationa}{override}) 
%``\titleref{override}" on page~\pageref{override}) 
\lstinline!onPacketReceived(DataPacket&)! more convenient because we don't need to reimplement each of the constructors, which are
anticipated to increase in number over time:

\begin{emcppslisting}[emcppsbatch=e4]
class LoggedNetworkDataStream : public NetworkDataStream
{
public:
    using NetworkDataStream::NetworkDataStream;

    void onPacketReceived(DataPacket& dataPacket) override
    {
        LOG_TRACE << "Received packet " << dataPacket;    // local log facility
        NetworkDataStream::onPacketReceived(dataPacket);  // Delegate to base.
    }
};
\end{emcppslisting}
    

\subsubsection[Implementing a strong \lstinline!typedef!]{Implementing a strong {\SubsubsecCode typedef}}\label{implementing-a-strong-typedef}

Classic \lstinline!typedef! declarations --- just like C++11
\lstinline!using! declarations (see \featureref{\locationa}{alias-declarations-and-alias-templates}) 
% ``\titleref{alias-declarations-and-alias-templates}" on page~\pageref{alias-declarations-and-alias-templates}) 
--- are just synonyms; they
offer absolutely no type safety. A commonly desired capability is to
provide an alias to an existing type \lstinline!T! that is uniquely
interoperable with itself, explicitly convertible from \lstinline!T!, but
not implicitly convertible from \lstinline!T!. This somewhat \emph{more}
type-safe form of alias is sometimes referred to as a \romeogloss{strong
\lstinline!typedef!}.{\cprotect\footnote{A typical implementation of a \romeogloss{strong \lstinline!typedef!} suppresses implicit conversions both from the new type to the type it wraps and vice versa via \lstinline!explicit! converting constructors and \lstinline!explicit! conversion operators.  In this respect, the relationship of \romeogloss{strong \lstinline!typedef!} with the type it wraps is analogous to that of a scoped enumeration (\lstinline!enum!~\lstinline!class!)  to its \romeogloss{underlying type}; see \featureref{\locationc}{explicit-enumeration-underlying-type}.}}
%A so-called \romeogloss{strong
%  \lstinline!typedef!} is similar to a classic, C-style enumeration in
%  that it is (1) its own type and (2) implicitly convertible to its
%  base type (which for enumerators corresponds to its
%  \romeogloss{underlying type}; see \featureref{\locationc}{explicit-enumeration-underlying-type}). 
%%  ``\titleref{explicit-enumeration-underlying-type}" on page~\pageref{explicit-enumeration-underlying-type}). 
%  Unlike a classic
%  \lstinline!enum!, however, a typical implementation of a \romeogloss{strong
%  \lstinline!typedef!} allows only for explicit conversion from its base
%  type. An analogy to the more strongly typed
%\lstinline!enum!~\lstinline!class! (see \featureref{\locationc}{enumclass}) 
%% ``\titleref{enumclass}" on page~\pageref{enumclass}) 
%would suppress conversion
%  in either direction, e.g., via private inheritance and then
%  \lstinline!explicit! conversion constructors and
% \lstinline!explicit! conversion operators (see \featureref{\locationa}{explicit-conversion-operators}).
% [Underlying Type'11]{.xref}, [`enum class`]{.xref}, and [`explicit` Operators]{.xref}.}}
% ``\titleref{explicit-conversion-operators}" on page~\pageref{explicit-conversion-operators}).}}

As a practical example, suppose we are exposing, to a fairly wide and varied audience, a class,
\lstinline!PatientInfo!, that associates two \lstinline!Date! objects to a
given hospital patient:

\begin{emcppslisting}[emcppsbatch=e5]
class Date
{
    // ...

public:
    Date(int year, int month, int day);

    // ...
};

class PatientInfo
{
private:
    Date d_birthday;
    Date d_appointment;

public:
    PatientInfo(Date birthday, Date appointment);
        // Please pass the birthday as the first date and the appointment as
        // the second one!
};
\end{emcppslisting}
    
\noindent For the sake of argument, imagine that our users are not as diligent as
they should be in reading documentation to know which constructor
argument is which:

\begin{emcppslisting}[emcppsbatch=e5]
PatientInfo client1(Date birthday, Date appointment)
{
    return PatientInfo(birthday, appointment);  // OK
}

int client2(PatientInfo* result, Date birthday, Date appointment)
{
    *result = PatientInfo(appointment, birthday);  // Oops! wrong order
    return 0;
}
\end{emcppslisting}
    
\noindent Now suppose that we continue to get complaints, from folks like
\lstinline!client2! in the example above, that our code doesn't work. What can we
do?{\cprotect\footnote{Although this example is presented lightheartedly, misuse by clients is a perennial problem in large-scale
software organizations. Choosing the same type for both arguments
might well be the right choice in some environments but not in others.
We are not advocating use of this technique; we are merely
  acknowledging that it exists.}}

One way is to force clients to make a conscious and explicit decision in
their own source code as to which \lstinline!Date! is the birthday and
which is the appointment. Employing a \romeogloss{strong \lstinline!typedef!}
can help us to achieve this goal. Inheriting constructors provide a
concise way to define a \romeogloss{strong \lstinline!typedef!}; for
the example above, they can be used to define two new types to
 uniquely represent a birthday and an appointment date:

\begin{emcppslisting}[emcppsbatch=e5]
struct Birthday : Date  // somewhat type-safe alias for a (ù{\codeincomments{Date}}ù)
{
    using Date::Date;  // inherit (ù{\codeincomments{Date}}ù)'s three integer ctor
    explicit Birthday(Date d) : Date(d) { }  // (ù{\codeincomments{explicit}}ù) conversion from (ù{\codeincomments{Date}}ù)
};

struct Appointment : Date  // somewhat type-safe alias for a (ù{\codeincomments{Date}}ù)
{
    using Date::Date;  // inherit (ù{\codeincomments{Date}}ù)'s three integer ctor
    explicit Appointment(Date d) : Date(d) { }  // (ù{\codeincomments{explicit}}ù) conv. from (ù{\codeincomments{Date}}ù)
};
\end{emcppslisting}
    
\noindent The \lstinline!Birthday! and \lstinline!Appointment! types expose the same
interface of \lstinline!Date!, yet, given our inheritance-based design,
\lstinline!Date! is not implicitly convertible to either. Most importantly,
however, these two new types are not implicitly convertible to each
other:

\begin{emcppslisting}[emcppsbatch=e5]
Birthday b0(1994, 10, 4);  // OK, thanks to inheriting constructors
Date d0 = b0;              // OK, thanks to public inheritance
Birthday b1 = d0;          // Error, no implicit conversion from (ù{\codeincomments{Date}}ù)
Appointment a0;            // Error, (ù{\codeincomments{Appointment}}ù) has no default ctor.
Appointment a1 = b0;       // Error, no implicit conversion from (ù{\codeincomments{Birthday}}ù)
Birthday n2(d0);           // OK, thanks to an (ù{\codeincomments{explicit}}ù) constructor in (ù{\codeincomments{Birthday}}ù)
Appointment a2(1999, 9, 17); // OK, thanks to inheriting constructors           
Birthday    b3(a2);          // OK, an (ù{\codeincomments{Appointment}}ù) (unfortunately) is a (ù{\codeincomments{Date.}}ù)
\end{emcppslisting}
    
\noindent We can now reimagine a \lstinline!PatientInfo! class that exploits this
newfound (albeit artificially manufactured{\cprotect\footnote{Replicating
types that have identical behavior in the name of type safety can run
afoul of interoperability. Distinct types that are otherwise
physically similar are often most appropriate when their respective
behaviors are inherently distinct and unlikely to interact in practice
(e.g., a \mbox{\lstinline!CartesianPoint!} and a \mbox{\lstinline!RationalNumber!},
each implemented as having two integral data members); see
  \cite{lakos2a}, section~4.4.}}) type-safety:

\begin{emcppshiddenlisting}[emcppsbatch={e6,e7}]
class Date
{
public:
    Date(int year, int month, int day);
};
struct Birthday : Date  // somewhat type-safe alias for a (ù{\codeincomments{Date}}ù)
{
    using Date::Date;  // inherit (ù{\codeincomments{Date}}ù)'s three integer ctor
    explicit Birthday(Date d) : Date(d) { }  // (ù{\codeincomments{explicit}}ù) conversion from (ù{\codeincomments{Date}}ù)
};

struct Appointment : Date  // somewhat type-safe alias for a (ù{\codeincomments{Date}}ù)
{
    using Date::Date;  // inherit (ù{\codeincomments{Date}}ù)'s three integer ctor
    explicit Appointment(Date d) : Date(d) { }  // (ù{\codeincomments{explicit}}ù) conv. from (ù{\codeincomments{Date}}ù)
};
\end{emcppshiddenlisting}
\begin{emcppslisting}[emcppsbatch={e6,e7}]
class PatientInfo
{
private:
    Birthday d_birthday;
    Appointment d_appointment;

public:
    PatientInfo(Birthday birthday, Appointment appointment);
        // Please pass the birthday as the first argument and the appointment as
        // the second one! 
};
\end{emcppslisting}
    
\noindent Now our clients have no choice but to make their intentions clear at the
call site. The previous implementation of the client functions no longer compile:

\begin{emcppslisting}[emcppsbatch=e6,emcppserrorlines={1,2,4}]
PatientInfo client1(Date birthday, Date appointment)
{
    return PatientInfo(birthday, appointment);     // Error, doesn't compile.
}

int client2(PatientInfo* result, Date birthday, Date appointment)
{
    *result = PatientInfo(appointment, birthday);  // Error, doesn't compile.
    return 0;
}
\end{emcppslisting}
Because the clients now need to explicitly convert their \lstinline!Date! objects to the appropriate \romeogloss{strong \lstinline!typedef!s}, it is easy to spot and fix the defect in \lstinline!client2!:
\begin{emcppslisting}[emcppsbatch=e7]
PatientInfo client1(Date birthday, Date appointment)
{
    return PatientInfo(Birthday(birthday), Appointment(appointment));  // OK
}

int client2(PatientInfo* result, Date birthday, Date appointment)
{
    Birthday b(birthday);
    Appointment a(appointment);
    *result = PatientInfo(b, a);  // OK
}
\end{emcppslisting}
    
\noindent 
%This example works because the \romeogloss{value constructor} takes three
%arguments and cannot be invoked as part of an implicit conversion
%sequence; see \intraref{potential-pitfalls-ctorinheriting}{beware-of-inheriting-implicit-constructors}. 
%%\textit{\titleref{potential-pitfalls-ctorinheriting}: \titleref{beware-of-inheriting-implicit-constructors}} on page~\pageref{beware-of-inheriting-implicit-constructors}. 
%Note that, in an ideal
%world where thorough unit testing is ubiquitous, such machinations would
%most likely be supererogatory.
In this example, the client functions failed to compile after the introduction of the \romeogloss{strong \lstinline!typedef!s} which is the intended effect. However, if \lstinline!Date! objects were \emph{implicitly} constructed when client functions created \lstinline!PatientInfo!, the defective code would continue to compile because both \romeogloss{strong \lstinline!typedef!s} can be implicitly constructed from the same arguments; see \intraref{potential-pitfalls-ctorinheriting}{beware-of-inheriting-implicit-constructors}.

\subsubsection[Incorporating reusable functionality via a mix-in]{Incorporating reusable functionality via a mix-in}\label{incorporating-reusable-functionality-via-a-mix-in-class}

Some classes are designed to generically enhance the behavior of a class
just by inheriting from it; such classes are sometimes referred to as
\emph{mix-ins}. If we wish to adapt a class to support the additional
behavior of the mix-in, with no other change to its behavior, we can use
simple \romeogloss{structural inheritance} (e.g., to preserve reference
compatibility through function calls). To preserve the public interface,
however, we will need it to inherit the constructors as well.

Consider, for example, a simple class to track the total number of
objects created:

\begin{emcppslisting}[emcppsbatch=e8]
template <typename T>
struct CounterImpl  // mix-in used to augment implementation of arbitrary type
{
    static int s_constructed;  // count of the number of (ù{\codeincomments{T}}ù) objects constructed

    CounterImpl()                   { ++s_constructed; }
    CounterImpl(const CounterImpl&) { ++s_constructed; }
};

template <typename T>
int CounterImpl<T>::s_constructed;  // required member definition
\end{emcppslisting}
    
\noindent The class template \lstinline!CounterImpl!, in the example above, counts the number of
times an object of type \lstinline!T! was constructed during a run of the
program. We can then write a generic adapter, \lstinline!Counted!, to
facilitate use of \lstinline!CounterImpl! as a \emph{mix-in}:

\begin{emcppslisting}[emcppsbatch=e8]
template <typename T>
struct Counted : T, CounterImpl<T>
{
    using T::T;
};
\end{emcppslisting}
    
\noindent Note that the \lstinline!Counted! adaptor class inherits all of the
constructors of the \emph{dependent} class, \lstinline!T!, that it wraps,
without its having to know what those constructors are:

\begin{emcppshiddenlisting}[emcppsbatch=e8]
// myfoo.h:
struct MyFoo {};
\end{emcppshiddenlisting}
\begin{emcppslisting}[emcppsbatch=e8]
#include <string>   // (ù{\codeincomments{std::string}}ù)
#include <vector>   // (ù{\codeincomments{std::vector}}ù)
#include <myfoo.h>  // (ù{\codeincomments{MyFoo}}ù)

Counted<std::string>       cs ("ABC");  // Construct a counted (ù{\codeincomments{string}ù).          
Counted<std::vector<char>> cvc(3, 'a'); // Construct a counted vector of (ù{\codeincomments{char}ù).
Counted<MyFoo>             cmf;         // Construct a counted (ù{\codeincomments{MyFoo}}ù) object.
\end{emcppslisting}
    
\noindent While inheriting constructors are a convenience in nongeneric
programming, they can be an essential tool for generic idioms.

\subsection[Potential Pitfalls]{Potential Pitfalls}\label{potential-pitfalls-ctorinheriting}

\subsubsection[Newly introduced constructors in the base class can silently alter program behavior]{Newly introduced constructors in the base class can silently alter\\[0.5ex] program behavior}\label{newly-introduced-constructors-in-the-base-class-can-silently-alter-program-behavior}

The introduction of a new constructor in a base class might silently
change a program's run-time behavior if that constructor happens to be a
better match during overload resolution of an existing instantiation of
a derived class. Consider a \lstinline!Session! class that initially provides only two constructors:

\begin{emcppshiddenlisting}[emcppsbatch=e9]
class RawSessionHandle;
\end{emcppshiddenlisting}
\begin{emcppslisting}[emcppsbatch=e9]
struct Session
{
    Session();
    explicit Session(RawSessionHandle* rawSessionHandle);
};
\end{emcppslisting}
    
\noindent Now, imagine that a class, \lstinline!AuthenticatedSession!, derived from
\lstinline!Session!, inherits the two constructors of its base class and provides its own constructor that accepts an integral
authentication token:

\begin{emcppslisting}[emcppsbatch=e9]
struct AuthenticatedSession : Session
{
    using Session::Session;
    explicit AuthenticatedSession(long long authToken);
};
\end{emcppslisting}
    
\noindent Finally, consider an instantiation of \lstinline!AuthenticatedSession! in
user-facing code:

\begin{emcppslisting}[emcppsbatch=e9]
AuthenticatedSession authSession(45100);
\end{emcppslisting}
    
\noindent In the example above, \lstinline!authSession! will be initialized by
invoking the constructor accepting a \lstinline!long!~\lstinline!long! (see \featureref{\locationa}{long-long}) 
%``\titleref{long-long}" on page~\pageref{long-long}) 
authentication token. If, however, a new
constructor having the signature \lstinline!Session(int!~\lstinline!fd)! is added to the
base class, it will be invoked instead because it is a better match to the
literal \lstinline!45100! (of type \lstinline!int!) than the constructor
taking a \lstinline!long!~\lstinline!long! supplied explicitly in the derived
class; hence, adding a constructor to a base class might lead to a
potential latent defect that would go unreported at compile
time.

Note that this problem with implicit conversions for function parameters is not unique
to inheriting constructors; any form of \lstinline!using! declaration or
invocation of an overloaded function carries a similar risk. Imposing
stronger typing --- e.g., by using \romeogloss{strong \lstinline!typedef!s} (see \intraref{use-cases-ctorinheriting}{implementing-a-strong-typedef}) 
%\textit{\titleref{use-cases-ctorinheriting}: \titleref{implementing-a-strong-typedef}} on page~\pageref{implementing-a-strong-typedef}) 
--- might sometimes, however, help to prevent such
unfortunate missteps.

\subsubsection[Inheriting \emph{implicit} constructors]{Inheriting {\sfbsubsubsecitalRomeo implicit} constructors}\label{beware-of-inheriting-implicit-constructors}

Inheriting from a class that has implicit constructors can cause
surprises. Consider again the use of inheriting constructors to
implement a \romeogloss{strong \lstinline!typedef!} from \intraref{use-cases-ctorinheriting}{implementing-a-strong-typedef}. 
%\textit{\titleref{use-cases-ctorinheriting}: \titleref{implementing-a-strong-typedef}} on page~\pageref{implementing-a-strong-typedef}. 
This time, however, let's suppose we are
exposing a class,
\lstinline!PointOfInterest!, that associates the name and address of a
given popular tourist attraction:

\begin{emcppslisting}[emcppsbatch=e10]
#include <string>  // (ù{\codeincomments{std::string}}ù)

class PointOfInterest
{
private:
    std::string d_name;
    std::string d_address;

public:
    PointOfInterest(const std::string& name, const std::string& address);
        // Please pass the (ù{\codeincomments{name}}ù) as the *first* and the (ù{\codeincomments{address}}ù) *second*!
};
\end{emcppslisting}
    
\noindent Again imagine that our users are not always careful about inspecting the
function prototype:

\begin{emcppslisting}[emcppsbatch=e10]
PointOfInterest client1(const std::string& name, const std::string& address)
{
    return PointOfInterest(name, address);  // OK
}

int client2(PointOfInterest*   result,                                          
            const std::string& name,                                            
            const std::string& address)
{
    *result = PointOfInterest(address, name);  // Oops! wrong order
    return 0;
}
\end{emcppslisting}
    
\noindent We might think to again use \romeogloss{strong \lstinline!typedef!s} here as we
did for \lstinline!PatientInfo! in \intraref{use-cases-ctorinheriting}{implementing-a-strong-typedef}: 
%\textit{\titleref{use-cases-ctorinheriting}: \titleref{implementing-a-strong-typedef}} on page~\pageref{implementing-a-strong-typedef}:

\begin{emcppshiddenlisting}[emcppsbatch=e11]
#include <string>   // (ù{\codeincomments{std::string}}ù)
\end{emcppshiddenlisting}
\begin{emcppslisting}[emcppsbatch=e11]
struct Name : std::string  // somewhat type-safe alias for a (ù{\codeincomments{std::string}}ù)
{
    using std::string::string;  // Inherit, as is, all of (ù{\codeincomments{std::string}}ù)'s ctors.
    explicit Name(const std::string& s) : std::string(s) { }  // conversion
};

struct Address : std::string  // somewhat type-safe alias for a (ù{\codeincomments{std::string}}ù)
{
    using std::string::string;  // Inherit, as is, all of (ù{\codeincomments{std::string}}ù)'s ctors.
    explicit Address(const std::string& s) : std::string(s) { }  // conversion
};
\end{emcppslisting}
    
\noindent The \lstinline!Name! and \lstinline!Address! types are not interconvertible; they expose the same interfaces as \lstinline!std::string! but are not
implicitly convertible from it:

\begin{emcppslisting}[emcppsbatch=e11]
Name n0 = "Big Tower";  // OK, thanks to inheriting constructors
std::string s0 = n0;    // OK, thanks to public inheritance
Name n1 = s0;           // Error, no implicit conversion from (ù{\codeincomments{std::string}}ù)
Address a0;             // OK, unfortunately a (ù{\codeincomments{std::string}}ù) has a default ctor.
Address a1 = n0;        // Error, no implicit conversion from (ù{\codeincomments{Name}}ù)
Name n2(s0);            // OK, thanks to an (ù{\codeincomments{explicit}}ù) constructor in (ù{\codeincomments{Name}}ù)
Name b3(a0);            // OK, an (ù{\codeincomments{Address}}ù) (unfortunately) is a (ù{\codeincomments{std::string}}ù).
\end{emcppslisting}
    
\noindent We can rework the \lstinline!PointOfInterest! class to use the
\romeogloss{strong \lstinline!typedef!} idiom:

\begin{emcppslisting}[emcppsbatch=e11]
class PointOfInterest
{
private:
    Name    d_name;
    Address d_address;

public:
    PointOfInterest(const Name& name, const Address& address);
};
\end{emcppslisting}
    
\noindent Now if our clients use the base class itself as a parameter, they will
again need to make their intentions known:

\begin{emcppslisting}[emcppsbatch=e11]
PointOfInterest client1(const std::string& name, const std::string& address)    
{                                                                               
    return PointOfInterest(Name(name), Address(address));
} 

int client2(PointOfInterest*   result,                                          
            const std::string& name,                                            
            const std::string& address)                                         
{
   *result = PointOfInterest(Name(name), Address(address)); // Fix forced.     
    return 0;                                                                   
}
\end{emcppslisting}
    
\noindent But suppose that some clients pass the arguments by
\lstinline!const!~\lstinline!char*! instead of\linebreak[4]
\mbox{\lstinline!const!~\lstinline!std::string&!}:

\begin{emcppslisting}[emcppsbatch=e11]
PointOfInterest client3(const char* name, const char* address)
{
    return PointOfInterest(address, name);  // Bug, compiles but runtime error
}
\end{emcppslisting}
    
\noindent In the case of \lstinline!client3! in the code snippet above, passing the arguments through
\emph{does} compile because the \lstinline!const!~\lstinline!char*!
constructors are inherited; hence, there is no attempt to convert
to a \lstinline!std::string! before matching the \emph{implicit} conversion
constructor. Had the \lstinline!std::string! conversion
constructor been declared to be \lstinline!explicit!, the code would not
have compiled. In short, inheriting constructors from types that perform implicit
conversions can seriously undermine the effectiveness of the \romeogloss{strong
\lstinline!typedef!} idiom.

\subsection[Annoyances]{Annoyances}\label{annoyances-inheritingctor}

\subsubsection[Inherited constructors cannot be selected individually]{Inherited constructors cannot be selected individually}\label{inherited-constructors-cannot-be-selected-individually}

The inheriting-constructors feature does not allow the programmer
to select a subset of constructors to inherit; all of the base
class's eligible constructors are always inherited unless a constructor
with the same signature is provided in the derived class. If the
programmer desires to inherit all constructors of a base class except
for perhaps one or two, the straightforward workaround would be to
declare the undesired constructors in the derived class and then use
deleted functions (see \featureref{\locationa}{deleted-functions}) 
% ``\titleref{deleted-functions}" on page~\pageref{deleted-functions}) 
to explicitly exclude them.

For example, suppose we have a general class, \lstinline!Datum!, that can
be constructed from a variety of types:

\begin{emcppslisting}[emcppsbatch=e12]
struct Datum
{
    Datum(bool);
    Datum(char);
    Datum(short);
    Datum(int);
    Datum(long);
    Datum(long long);
};
\end{emcppslisting}
    
\noindent If we wanted to create a version of \lstinline!Datum!, call it
\lstinline!NumericalDatum!, that inherits all but the one constructor
taking a \lstinline!bool!, our derived class would (1) inherit publicly, 
(2) declare the unwanted constructor, and then (3) mark it with
\lstinline!=!\,\lstinline!delete!:

\begin{emcppslisting}[emcppsbatch=e12]
struct NumericalDatum : Datum
{
    using Datum::Datum;             // Inherit all the constructors...
    NumericalDatum(bool) = delete;  // ...except the one taking a (ù{\codeincomments{bool}}ù).
};
\end{emcppslisting}
    
\noindent Note that the subsequent addition of any non-numerical constructor to
\lstinline!Datum! (e.g., a constructor taking \lstinline!std::string!) would
defeat the purpose of \lstinline!NumericalDatum! unless that inherited constructor were explicitly excluded from \lstinline!NumericalDataum! by use of \lstinline!=!\,\lstinline!delete!.

\subsubsection[Access levels of inherited constructors are the same as in base class]{Access levels of inherited constructors are the same as in base class}\label{access-levels-of-inherited-constructors-are-same-as-in-base-class}

Unlike base-class member functions that can be introduced with a
\lstinline!using! directive with an arbitrary access level into the derived
class (as long as they are accessible by the derived class), the access
level of the \lstinline!using! declaration for inherited constructors is
ignored. The inherited constructor overload is instead
accessible \emph{if} the corresponding base-class constructor would be
accessible:

\begin{emcppslisting}[emcppsbatch=e13]
struct Base
{
private:
    Base(int) { }  // This constructor is declared (ù{\codeincomments{private}}ù) in the base class.
    void pvt0() { }
    void pvt1() { }

public:
    Base() { }     // This constructor is declared (ù{\codeincomments{public}}ù) in the base class.
    void pub0() { }
    void pub1() { }
};
\end{emcppslisting}
    
\noindent Note that, when employing \lstinline!using! to (1) inherit constructors or
(2) elevate base-class definitions in the presence of private
inheritance, public clients of the class might find it necessary 
to look at what are ostensibly private implementation details of the
derived class to make proper use of that type through its
public interface:

\begin{emcppslisting}[emcppsbatch=e13]
struct Derived(ù{\footnotemark}ù) : private Base
{
    using Base::Base;  // OK, inherited (ù{\codeincomments{Base()}}ù) as (ù{\codeincomments{public}}ù) constructor
                       // and (ù{\codeincomments{Base(int)}}ù) as (ù{\codeincomments{private}}ù) constructor

private:
    using Base::pub0;  // OK, (ù{\codeincomments{pub0}}ù) is declared (ù{\codeincomments{private}}ù) in derived class.
    using Base::pvt0;  // Error, (ù{\codeincomments{pvt0}}ù) was declared private in base class.

public:
    using Base::pub1;  // OK, (ù{\codeincomments{pub1}}ù) is declared (ù{\codeincomments{public}}ù) in derived class.
    using Base::pvt1;  // Error, (ù{\codeincomments{pvt1}}ù) was declared (ù{\codeincomments{private}}ù) in base class.
};

void client()
{
     Derived x(0);  // Error, Constructor was declared private in base class.
     Derived d;     // OK, constructor was declared (ù{\codeincomments{public}}ù) in base class.
     d.pub0();      // Error, (ù{\codeincomments{pub0}}ù) was declared (ù{\codeincomments{private}}ù) in derived class.
     d.pub1();      // OK, (ù{\codeincomments{pub1}}ù) was declared (ù{\codeincomments{public}}ù) in derived class.
     d.pvt0();      // Error, (ù{\codeincomments{pvt0}}ù) was declared private in base class.
     d.pvt1();      // Error, (ù{\codeincomments{pvt1}}ù) was declared private in base class.
}
\end{emcppslisting}
{\cprotect\footnotetext{Alisdair Meredith, one of the authors of the
Standards paper that proposed this feature (\cite{meredith08}), suggests that
placing the \lstinline!using! declaration for \romeogloss{inheriting
constructors} as the very first member declaration and preceding any
\romeogloss{access specifiers} might be the least confusing location. Programmers might still be confused by
the disparate default access levels of \lstinline!class! versus
  \lstinline!struct!.}}
    
\noindent This C++11 feature was itself created because the previously proposed
solution --- which also involved a couple of features new in C++11, namely
forwarding the arguments to base-class constructors with
forwarding references (see \featureref{\locationc}{forwardingref}) 
% ``\titleref{forwardingref}" on page~\pageref{forwardingref}) 
and variadic
templates (see \featureref{\locationc}{variadictemplate}) 
% ``\titleref{variadictemplate}" on page~\pageref{variadictemplate}) 
--- made somewhat different tradeoffs and was
considered too onerous and fragile to be practically useful:

\begin{emcppslisting}
#include <utility>  // (ù{\codeincomments{std::forward}}ù)

struct Base
{
    Base(int) { }
};

struct Derived : private Base
{
protected:
    template <typename... Args>
    Derived(Args&&... args) : Base(std::forward<Args>(args)...)
    {
    }
};
\end{emcppslisting}
    
\noindent In the example above, we have used forwarding references (see \featureref{\locationc}{forwardingref}) 
% ``\titleref{forwardingref}" on page~\pageref{forwardingref})
to properly delegate the implementation of a constructor that is
declared \mbox{\lstinline!protected!} in the derived class to a \lstinline!public!
constructor of a privately inherited base class. Although this approach
fails to preserve many of the characteristics of the inheriting
constructors (e.g., \lstinline!explicit!, \lstinline!constexpr!,
\lstinline!noexcept!, and so on), the functionality described in the code snippet above is
simply not possible using the C++11 inheriting-constructors feature.

\subsubsection[Flawed initial specification led to diverging early implementations]{Flawed initial specification led to diverging early implementations}

The original specification of inheriting constructors in C++11 had a
significant number of problems with general use.\footnote{For the detailed analysis of the issues that were the consequence of the flawed initial C++11 specification of inheriting constructors, see [PRODUCTION: LINK TO BOOK WEBSITE SUPPLEMENTAL MATERIAL.]} As originally specified,
inherited constructors were treated as if they were redeclared in
the derived class. For C++17, a significant rewording of this feature\footnote{\cite{smith15b}}
happened to instead find the base class
constructors and then define how they are used to construct an instance
of the derived class, as we have presented here. With a final fix in
C++20 with the resolution of CWG issue \#2356,\footnote{\cite{smith18}} a complete
working feature was specified. All of these fixes for C++17 were
accepted as defect reports and thus apply retroactively to C++11 and
C++14. For the major compilers, this was either standardizing already
existing practice or quickly adopting the changes.{\cprotect\footnote{For example, GCC versions above 7.0
and Clang versions above 4.0 all have the modern behavior
fully implemented regardless of which standard version is chosen when
  compiling.}}

\subsection[See Also]{See Also}\label{see-also}

\begin{itemize}
\item{%``\titleref{delegating-constructors}" on page~\pageref{delegating-constructors} â€” 
\seealsoref{delegating-constructors}{\seealsolocationa}Related feature used to call one constructor from another from within the same user-defined type.}
\item{%``\titleref{Defaulted-Special-Member-Functions}" on page~\pageref{Defaulted-Special-Member-Functions} â€” 
\seealsoref{Defaulted-Special-Member-Functions}{\seealsolocationa}Used to implement functions that might otherwise have been suppressed by inherited constructors.}
\item{%``\titleref{deleted-functions}" on page~\pageref{deleted-functions} â€” 
\seealsoref{deleted-functions}{\seealsolocationa}Can be used to exclude inherited constructors that are unwanted entirely.}
\item{%``\titleref{override}" on page~\pageref{override} â€” 
\seealsoref{override}{\seealsolocationa}Used to ensure that a member function intended to override a virtual function actually does so.}
\item{%``\titleref{Default-Member-Initializers}" on page~\pageref{Default-Member-Initializers} â€” 
\seealsoref{Default-Member-Initializers}{\seealsolocationc}Useful in conjunction with this feature when a derived class adds member data.}
\item{`%`\titleref{Default-Member-Initializers}" on page~\pageref{Default-Member-Initializers} â€” 
\seealsoref{Default-Member-Initializers}{\seealsolocationc}Can be used to provide nondefault values for data members in derived classes that make use of inheriting constructors.}
\item{%``\titleref{forwardingref}" on page~\pageref{forwardingref} â€” 
\seealsoref{forwardingref}{\seealsolocationc}Used in alternative (workaround) when access levels differ from those for base-class constructors.}
\item{%``\titleref{variadictemplate}" on page~\pageref{variadictemplate} â€” 
\seealsoref{variadictemplate}{\seealsolocationc}Used in alternative (workaround) when access levels differ from those for base-class constructors.}
\end{itemize}

\subsection[Further Reading]{Further Reading}\label{further-reading}

None so far

%%%%%%%%%%% first para moves to be a final annoyance; remainder moves to supplemental material on website. See folder "For Web," file "inheritingctor-appendix"  
%\subsection[Appendix: C++17 Improvements Made Retroactive to C++11/14]{Appendix: C++17 Improvements Made Retroactive to C++11/14}\label{appendix}\label{c++17-improvements-made-retroactive-to-c++11/14}
%
%The original specification of inheriting constructors in C++11 had a
%significant number of problems with general use. As originally specified,
%inherited constructors were treated as if they were redeclared in
%the derived class. For C++17, a significant rewording of this feature\footnote{\cite{smith15b}}
%happened to instead find the base class
%constructors and then define how they are used to construct an instance
%of the derived class, as we have presented here. With a final fix in
%C++20 with the resolution of CWG issue \#2356,\footnote{\cite{smith18}} a complete
%working feature was specified. All of these fixes for C++17 were
%accepted as defect reports and thus apply retroactively to C++11 and
%C++14. For the major compilers, this was either standardizing already
%existing practice or quickly adopting the changes.{\cprotect\footnote{For example, GCC versions above 7.0
%and Clang versions above 4.0 all have the modern behavior
%fully implemented regardless of which standard version is chosen when
%  compiling.}}
%
%The subsections that follow describe the subtle bugs that came with the previous
%specification, both for completeness and to give a better
%understanding of what to expect on very old compilers, though none fully
%implemented the original specification as written.
%
%\subsubsection[Inheriting constructors declared with a C-style ellipsis]{Inheriting constructors declared with a C-style ellipsis}
%
%Forwarding arguments from a constructor declared using a C-style ellipsis cannot forward correctly. Arguments passed through the ellipsis are not available as named arguments but must instead be accessed through the \lstinline!va_arg! family of macros. Without named arguments, no easily supported way is available to call the base-class constructor with the additional arguments:
%\begin{emcppslisting}
%struct Base
%{
%    Base(int x, ...) { }  // constructor taking C-style variadic args
%};
%
%struct Derived : Base
%{
%    using Base::Base;  // Error, Prior to C++17 fixes, standard wording
%                       // does not allow forwarding C-style variadic args.
%};
%\end{emcppslisting}
%    This problem is sidestepped in C++17 because the base-class constructor becomes available just like any other base-class function made available through a \lstinline!using! declaration in the derived class.
%    
%\subsubsection[Inheriting constructors that rely on friendship to declare function parameters]{Inheriting constructors that rely on friendship to declare\\ function parameters}
%
%When a constructor depends on access to a \lstinline!private! member of a class (e.g., a \lstinline!typedef!), an inheriting constructor does not implicitly grant friendship that the base class might have that makes the constructor valid. For example, consider the following class template, which grants friendship to class \lstinline!B!:
%\begin{emcppslisting}
%template <typename T>
%struct S
%{
%private:
%    typedef int X;
%    friend struct B;
%};
%\end{emcppslisting}
%    Then, we can create a class with a constructor that relies on that friendship. In this case, we consider a constructor template using the dependent member \lstinline!X!, assuming that, in the normal case, \lstinline!X! would be publicly accessible:
%\begin{emcppslisting}
%struct B
%{
%    template <typename T>
%    B(T, typename T::X);
%};
%\end{emcppslisting}
%    Now consider class \lstinline!D! derived from \lstinline!B! and inheriting its constructors:
%\begin{emcppslisting}
%struct D : B
%{
%    using B::B;
%};
%\end{emcppslisting}
%    Without friendship, we cannot construct a \lstinline!D! from an \lstinline!S!, but we can construct a \lstinline!B! from an \lstinline!S!, suggesting something is wrong with the inheritance. Note that the SFINAE rules for templates mean that the inheriting constructor is a problem only if we try to construct an \lstinline!S! with the problem type and does not cause a hard error without that use case. The following example illustrates the problematic usage:
%\begin{emcppslisting}
%S<int> s;   // full specialization of (ù{\codeincomments{S}}ù) for type (ù{\codeincomments{int}}ù)
%B b(s, 2);  // OK, thanks to friendship
%D d(s, 2);  // Error, Prior to C++17 fixes, friendship is not inherited.
%\end{emcppslisting}
%    As C++17 redefines the semantics of the inheriting constructor as if the base classâ€™s constructors were merely exposed in the derived one, friendship is evaluated within the scope of the base class.
%    
%\subsubsection[Inheriting constructor templates would be ill formed for a local class]{Inheriting constructor templates would be ill formed for a local class}
%
%A class declared within a function is a \romeogloss{local class}. Local classes have many restrictions, one of which is that they cannot declare member templates. If we inherit constructors from a base class with constructor templates, even \lstinline!private! ones, the implicit declaration of a constructor template to forward arguments to the base-class constructor would be \romeogloss{ill formed}:
%\begin{emcppslisting}
%struct Base
%{
%    template <typename T>
%    Base(T);
%};
%
%void f()
%{
%    class Local : Base
%    {
%        using Base::Base;  // Error, Prior to C++17 fixes, we cannot redeclare
%                           // the constructor template in local class.
%    };
%}
%\end{emcppslisting}
%    C++17 resolves this by directly exposing the base-class constructors, rather than defining new constructors to forward arguments.
%    
%\subsubsection[SFINAE evaluation context with default function arguments]{SFINAE evaluation context with default function arguments}
%
%Constructors that employ \romeogloss{SFINAE} tricks in default function arguments perform \mbox{\romeogloss{SFINAE}} checks in the wrong context and therefore inherit ill-formed constructors. No such issues occur when these \romeogloss{SFINAE} tricks are performed on default template arguments instead. As an example, consider a class template \lstinline!Wrap! that has a template constructor with a \romeogloss{SFINAE} constraint:
%\begin{emcppslisting}
%struct S { };
%
%template <typename T>
%struct Wrap
%{
%    template <typename U>
%    Wrap(U, typename std::enable_if<
%        std::is_constructible<T, U>::value>::type* = nullptr)
%        // This constructor is enabled only if (ù{\codeincomments{T}}ù) is constructible from (ù{\codeincomments{U}}ù).
%    {
%        std::cout << "SFINAE ctor\n";
%    }
%
%    Wrap(S)
%    {
%        std::cout << "S ctor\n";
%    }
%};
%\end{emcppslisting}
%    If we derive from \lstinline!Wrap! and inherit its constructors, we would expect the \romeogloss{SFINAE} constraint to behave exactly as in the base class, i.e., the template constructor overload would be silently discarded if \lstinline!std::is_constructible<T,!~\lstinline!U>::value! evaluates to \lstinline!false!:
%\begin{emcppslisting}
%template <typename T>
%struct Derived : Wrap<T>
%{
%    using Wrap<T>::Wrap;
%};
%\end{emcppslisting}
%    However, prior to C++17â€™s retroactive fixes, \romeogloss{SFINAE} was triggered only for \lstinline!Wrap!, not for \lstinline!Derived!:
%\begin{emcppslisting}
%void f()
%{
%    S s;
%    Wrap<int> w(s);     // prints (ù{\codeincomments{"S ctor"}}ù)
%    Derived<int> d(s);  // error prior to fixes; prints (ù{\codeincomments{"S ctor"}}ù) afterward
%}
%\end{emcppslisting}
%    
%\subsubsection[Suppression of constructors in the presence of default arguments]{Suppression of constructors in the presence of default arguments}
%
%A constructor having one or more default arguments in the derived class does not suppress any corresponding constructors matching only the nondefaulted arguments in the base class, leading to ambiguities:
%\begin{emcppslisting}
%struct B          // base class
%{
%    B(int, int);  // value constructor with two (required) (ù{\codeincomments{int}}ù) parameters
%};
%
%struct D : B
%{
%    using B::B;
%    D(int, int, int = 0);  // doesn't suppress (ù{\codeincomments{D(int, int)}}ù) from (ù{\codeincomments{B(int, int)}}ù)
%};
%\end{emcppslisting}
%    In the code example above, the original defective behavior was that there would be two overloaded constructors in \lstinline!D!; attempting to construct a \lstinline!D! from two integers became ambiguous. In the corrected behavior, the inheriting \lstinline!D(int,!~\lstinline!int)! from the base-class constructor \lstinline!B(int,!~\lstinline!int)!, whose domain is fully subsumed by the derived classâ€™s explicitly specified constructor \lstinline!D(int,!~\lstinline!int,!~\lstinline!int!~\lstinline!=!~\lstinline!0)!, is suppressed.
%    
%\subsubsection[Suprising behavior with unary constructor templates]{Suprising behavior with unary constructor templates}
%
%Because inherited constructors are redeclarations within the derived class and expect to forward properly to the corresponding base-class constructors, constructor templates may do very surprising things. In particular, a gregarious, templated constructor can appear to cause inheritance of a base-class copy constructor. Consider the following class with a constructor template:
%\begin{emcppslisting}
%struct A
%{
%    A() = default;
%    A(const A&) { std::cout << "copy\n"; }
%
%    template <typename T>
%    A(T) { std::cout << "convert\n"; }
%};
%\end{emcppslisting}
%    This simple class can convert from any type and prints those of its constructors that were called. Now consider we want to make a \romeogloss{strong \lstinline!typedef!} for \lstinline!A!:
%\begin{emcppslisting}
%struct B : A
%{
%    using A::A;  // inherited base class (ù{\codeincomments{A}}ù)'s constructors
%};
%\end{emcppslisting}
%    The problem is that because \lstinline!A! can convert from anything, when \lstinline!B! inherits \lstinline!A!'s constructor template, \lstinline!B! can then use the inherited constructor to construct an instance of \lstinline!B! from \lstinline!A!. Perhaps more surprising, because the definition of the inherited constructor in \lstinline!B! is to initialize the \lstinline!A! subobject with its parameters, the nontemplate inherited constructor will be chosen as the best match, not the templated, converting constructor!\cprotect\footnote{Note that if the template constructor for \lstinline!A! were a \emph{copy} or \emph{move} constructor for \lstinline!A!, then it would be excluded from being an inherited constructor and this odd behavior would be avoided. The by-value parameter of this constructor is also why \lstinline!"copy"! is output twice in this example.
%\begin{emcppslisting}[style=footcode]
%A x;
%B y = x;  // Surprise! This compiles, and it prints (ù{\codeincomments{"copy"}}ù) twice!
%\end{emcppslisting}
%    }
%

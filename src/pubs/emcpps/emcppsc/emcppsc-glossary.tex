% This file should contain the full glossary contents

\newglossaryentry{ABI}{
  name={ABI},
  description={
TODO
}}

\newglossaryentry{ADL}{
  name={ADL},
  description={
TODO
}}

\newglossaryentry{API}{
  name={API},
  description={
TODO
}}

\newglossaryentry{access specifier}{
  name={Access Specifier},
  description={
TODO
}}

\newglossaryentry{acquire/release memory barrier}{
  name={Acquire/Release Memory Barrier},
  description={
TODO
}}

\newglossaryentry{aggregate}{
  name={Aggregate},
  description={
TODO: from standard: An aggregate is an array or a class (Clause 9) with no user-provided constructors (12.1), %[[no brace-or-equal-initializers for non-static data members (9.2)]]{PRIOR TO C++14}, no private or protected non-static data members (Clause 11), no base classes (Clause 10), and no virtual functions (10.3). --- Comments from Josh: *"This should be broken down a bit more per standard version... Specifically, 'no base classes' goes away in c++17, and it should be noted that there was no formal definition prior to c++11. It would also be useful to mention the related concepts of POD, standard-layout type, and literal types"*
}}

\newglossaryentry{aggregate initialization}{
  name={Aggregate Initialization},
  description={
TODO
}}

\newglossaryentry{alias template}{
  name={Alias Template},
  description={
TODO
}}

\newglossaryentry{alignment}{
  name={Alignment},
  description={
The alignment of an \emph{object type} is a \lstinline!std::size\_t! value (always a power of two) representing the number of bytes between successive addresses at which objects of this type can be allocated. It is the reason why \emph{padding} might be introduced between non-static members of a \lstinline!class!.
}}

\newglossaryentry{architectural insulation}{
  name={Architectural Insulation},
  description={
TODO
}}

\newglossaryentry{argument dependent lookup}{
  name={Argument Dependent Lookup},
  description={
TODO
}}

\newglossaryentry{argument-dependent lookup (ADL)}{
  name={Argument-Dependent Lookup (Adl)},
  description={
TODO
}}

\newglossaryentry{as if}{
  name={As If},
  nonumberlist,
  description={
TODO
}}
\AtBeginDocument{\glsadd{as if}}

\newglossaryentry{atomic}{
  name={Atomic},
  description={
TODO
}}

\newglossaryentry{automatic}{
  name={Automatic},
  description={
TODO
}}

\newglossaryentry{automatic storage duration}{
  name={Automatic Storage Duration},
  description={
TODO
}}

\newglossaryentry{barriers}{
  name={Barriers},
  description={
TODO
}}

\longnewglossaryentry{basic source character set}{
  name={Basic Source Character Set},
  description={
TODO (SMD: the basic source character set is the abstract character set that must be available for expressing C++ source code. It's not the same as the source file encoding, which is what it is in C

    from unicode footnote: Implementations are free to map characters outside the basic source character set to sequences of its members, resulting in the possibility of embedding other characters (e.g. emojis) in a C++ source file. 

    @SuperV1234 so are you saying that there are holes that can act as escape sequences?  So like 0xfe means the next character is in play and 0xff means the next 3 characters are in play?  Just don't get it. @SMD shift encodings? I'm not sure if we really want to go there?

    @SMD this is about the ways your editor and compiler can conspire to lie to you. A octets in a u8 literal are not interpreted as unicode. They are interpreted however the compiler interprets source in phase 1 of translation. The fact that the common encoding on Windows is 8 bit complete with no shift characters means that even though your editor will display ðŸ¸, the compiler will see 0xF0 0x9F 0x8D 0xB8, which the compiler will emit as that sequence of bytes, even though the 0xBD is not canonically mapped. 
)
}}

\newglossaryentry{benchmark test}{
  name={Benchmark Test},
  description={
TODO
}}

\newglossaryentry{block scope}{
  name={Block Scope},
  description={
TODO
}}

\newglossaryentry{boilerplate code}{
  name={Boilerplate Code},
  description={
TODO
}}

\newglossaryentry{brace elision}{
  name={Brace Elision},
  description={
TODO
}}

\newglossaryentry{bytes}{
  name={Bytes},
  description={
TODO
}}

\newglossaryentry{c style functions}{
  name={C Style Functions},
  description={
TODO
}}

\newglossaryentry{CI}{
  name={CI},
  description={
TODO
}}

\newglossaryentry{cache hit}{
  name={Cache Hit},
  description={
TODO
}}

\newglossaryentry{cache line}{
  name={Cache Line},
  description={
TODO
}}

\newglossaryentry{cache miss}{
  name={Cache Miss},
  description={
TODO
}}

\newglossaryentry{call operator}{
  name={Call Operator},
  description={
TODO
}}

\newglossaryentry{callable object}{
  name={Callable Object},
  description={
TODO
}}

\newglossaryentry{callback functions}{
  name={Callback Functions},
  description={
TODO
}}

\newglossaryentry{capture default}{
  name={Capture Default},
  description={
TODO
}}

\newglossaryentry{capture init}{
  name={Capture Init},
  description={
TODO
}}

\newglossaryentry{captured by copy}{
  name={Captured By Copy},
  description={
TODO
}}

\newglossaryentry{captured by reference}{
  name={Captured By Reference},
  description={
TODO
}}

\newglossaryentry{captured variable}{
  name={Captured Variable},
  description={
TODO
}}

\newglossaryentry{carry dependency}{
  name={Carry Dependency},
  description={
TODO
}}

\newglossaryentry{character literal}{
  name={Character Literal},
  description={
TODO
}}

\newglossaryentry{class member access expression}{
  name={Class Member Access Expression},
  nonumberlist,
  description={
TODO (include any expression that is used to refer to a class member, such as \lstinline!object.member!, \lstinline!object->member!, \lstinline!object.*member!.)
}}
\AtBeginDocument{\glsadd{class member access expression}}

\newglossaryentry{closure}{
  name={Closure},
  description={
TODO
}}

\newglossaryentry{closure object}{
  name={Closure Object},
  description={
TODO
}}

\newglossaryentry{closure type}{
  name={Closure Type},
  description={
TODO
}}

\newglossaryentry{code bloat}{
  name={Code Bloat},
  description={
TODO
}}

\newglossaryentry{Collatz function}{
  name={Collatz Function},
  nonumberlist,
  description={
TODO
}}
\AtBeginDocument{\glsadd{Collatz function}}

\newglossaryentry{collatz function}{
  name={Collatz Function},
  description={
TODO
}}

\newglossaryentry{Collatz length}{
  name={Collatz Length},
  nonumberlist,
  description={
The Collatz length of a positive integer n is the length of the  Collatz sequence needed to reach 1.  Note that Collatz(1) is 1.
}}
\AtBeginDocument{\glsadd{Collatz length}}

\newglossaryentry{collatz length}{
  name={Collatz Length},
  description={
TODO
}}

\newglossaryentry{Collatz sequence}{
  name={Collatz Sequence},
  nonumberlist,
  description={
Take a positive integer n. If n is even, divide by 2. If n is odd, multiply by 3 and add 1. Iterate this procedure to form the Collatz sequence.
}}
\AtBeginDocument{\glsadd{Collatz sequence}}

\newglossaryentry{collatz sequence}{
  name={Collatz Sequence},
  description={
TODO
}}

\newglossaryentry{compile time coupling}{
  name={Compile Time Coupling},
  description={
TODO
}}

\newglossaryentry{compile time dispatch}{
  name={Compile Time Dispatch},
  description={
TODO
}}

\newglossaryentry{complete type}{
  name={Complete Type},
  description={
TODO
}}

\newglossaryentry{component}{
  name={Component},
  description={
TODO
}}

\newglossaryentry{component local}{
  name={Component Local},
  description={
TODO
}}

\newglossaryentry{components}{
  name={Components},
  description={
TODO
}}

\newglossaryentry{concepts}{
  name={Concepts},
  description={
TODO
}}

\newglossaryentry{concrete class}{
  name={Concrete Class},
  description={
TODO
}}

\newglossaryentry{conditionally supported}{
  name={Conditionally Supported},
  description={
A conforming implementation can choose not to support a feature that is specified as \emcppsglossgloss{conditionally supported}; if used and not supported, however, at least one diagnostic --- stating such lack of support --- is required.
}}

\newglossaryentry{constant expression}{
  name={Constant Expression},
  description={
TODO: An expression that can be evaluated at compile-time.  Mention \lstinline!constexpr! and state that \lstinline!const! variables that are initialized from a compile-time constants are themselves required to be compile-time constants.  New info to me in June 2020, worthwhile to have.
}}

\newglossaryentry{constant initialization}{
  name={Constant Initialization},
  description={
TODO
}}

\newglossaryentry{constexpr context}{
  name={Constexpr Context},
  description={
TODO
}}

\newglossaryentry{contextual conversion to bool}{
  name={Contextual Conversion to \lstinline!bool!},
  description={
A property of certain particular language construct (e.g., an \lstinline!if! expression) that permits conversion from any expression \lstinline!E! to be treated \emcppsglossgloss{as if} a \lstinline!static\_cast! to type bool had been applied --- e.g., \lstinline!if (E)! is definitional equivalent to \lstinline!if (static\_cast<bool>(E))!. %See also [explicit conversion operators]{.xref}.
}}

\newglossaryentry{contextual convertibility to bool}{
  name={Contextual Convertibility To Bool},
  description={
TODO
}}

\newglossaryentry{contextual keyword}{
  name={Contextual Keyword},
  description={
A \emph{``contextual keyword''} is a special identifier that acts like a \emph{keyword} when used in particular contexts. \lstinline!override! is an example as it can be used as a regular identifier outside of member-function declarators.
}}

\newglossaryentry{continuous refactoring}{
  name={Continuous Refactoring},
  description={
TODO
}}

\newglossaryentry{conventional string literals}{
  name={Conventional String Literals},
  description={
TODO
}}

\newglossaryentry{conversion operator}{
  name={Conversion Operator},
  description={
TODO
}}

\newglossaryentry{conversion operators}{
  name={Conversion Operators},
  description={
TODO
}}

\newglossaryentry{converting constructors}{
  name={Converting Constructors},
  description={
TODO
}}

\newglossaryentry{cookie}{
  name={Cookie},
  description={
TODO
}}

\newglossaryentry{copy assignment operator}{
  name={Copy Assignment Operator},
  description={
TODO
}}

\newglossaryentry{copy constructor}{
  name={Copy Constructor},
  description={
TODO
}}

\newglossaryentry{copy operations}{
  name={Copy Operations},
  description={
TODO
}}

\newglossaryentry{copy semantics}{
  name={Copy Semantics},
  description={
An operation on two objects, a destination and a source, has \emcppsglossgloss{copy semantics}
if, after it completes, the \emcppsglossgloss{value} of the source object remains unchanged and the target object
has the same \emcppsglossgloss{value} as does the source.   ..  for some criteria the source and destination are
the same, for a value semantic type that property is value...
}}

\newglossaryentry{critical section}{
  name={Critical Section},
  description={
TODO
}}

\newglossaryentry{curiously recurring template pattern}{
  name={Curiously Recurring Template Pattern},
  description={
TODO
}}

\newglossaryentry{currying}{
  name={Currying},
  description={
TODO
}}

\newglossaryentry{cyclic physical dependency}{
  name={Cyclic Physical Dependency},
  description={
TODO
}}

\newglossaryentry{cyclically dependent}{
  name={Cyclically Dependent},
  description={
TODO
}}

\newglossaryentry{data dependency}{
  name={Data Dependency},
  description={
TODO
}}

\newglossaryentry{data dependency chain}{
  name={Data Dependency Chain},
  description={
TODO
}}

\newglossaryentry{data member}{
  name={Data Member},
  description={
TODO
}}

\newglossaryentry{data race}{
  name={Data Race},
  description={
TODO
}}

\newglossaryentry{data races}{
  name={Data Races},
  description={
TODO
}}

\newglossaryentry{decimal floating point}{
  name={Decimal Floating Point},
  description={
TODO
}}

\newglossaryentry{declaration}{
  name={Declaration},
  description={
TODO
}}

\newglossaryentry{declare}{
  name={Declare},
  description={
TODO
}}

\newglossaryentry{declared type}{
  name={Declared Type},
  description={
The type of the \emcppsglossgloss{entity} named by the given expression.
}}

\newglossaryentry{deduced return type}{
  name={Deduced Return Type},
  description={
TODO
}}

\newglossaryentry{default initialized}{
  name={Default Initialized},
  description={
TODO
}}

\newglossaryentry{define}{
  name={Define},
  description={
TODO
}}

\newglossaryentry{definition}{
  name={Definition},
  description={
TODO
}}

\newglossaryentry{delegating constructor}{
  name={Delegating Constructor},
  description={
TODO
}}

\newglossaryentry{delete}{
  name={Delete},
  description={
TODO
}}

\newglossaryentry{deleted function}{
  name={Deleted Function},
  description={
TODO
}}

\newglossaryentry{dependent type}{
  name={Dependent Type},
  description={
TODO
}}

\newglossaryentry{design pattern}{
  name={Design Pattern},
  description={
TODO
}}

\newglossaryentry{diffusion}{
  name={Diffusion},
  description={
TODO
}}

\newglossaryentry{dimensional unit type}{
  name={Dimensional Unit Type},
  description={
TODO
}}

\newglossaryentry{direct initialization}{
  name={Direct Initialization},
  description={
TODO
}}

\newglossaryentry{direct mapped}{
  name={Direct Mapped},
  description={
TODO
}}

\newglossaryentry{disambiguator}{
  name={Disambiguator},
  description={
TODO
}}

\newglossaryentry{duck typing}{
  name={Duck Typing},
  description={
TODO
}}

\newglossaryentry{dumb data}{
  name={Dumb Data},
  description={
TODO
}}

\newglossaryentry{embedded development}{
  name={Embedded Development},
  description={
TODO
}}

\newglossaryentry{embedded systems}{
  name={Embedded Systems},
  description={
TODO
}}

\newglossaryentry{encapsulation}{
  name={Encapsulation},
  description={
TODO
}}

\newglossaryentry{encoding prefix}{
  name={Encoding Prefix},
  description={
TODO
}}

\newglossaryentry{entity}{
  name={Entity},
  description={
One of the primary building blocks of a C++ program. An entity is one of: \emph{value}, \emph{object}, \emph{reference}, \emph{function}, \emph{enumerator}, \emph{type}, \emph{class member}, \emph{bit-field}, \emph{template}, \emph{template specialization}, \emph{namespace}, \emph{parameter pack}, or \lstinline!this!.
}}

\newglossaryentry{escalating}{
  name={Escalating},
  description={
TODO
}}

\newglossaryentry{exception specification}{
  name={Exception Specification},
  description={
TODO
}}

\newglossaryentry{excess n}{
  name={Excess $\mathbf{n}$},
  description={
TODO
}}

\newglossaryentry{execution character set}{
  name={Execution Character Set},
  description={
TODO
}}

\newglossaryentry{explicit instantiation declaration}{
  name={Explicit Instantiation Declaration},
  description={
TODO
}}

\newglossaryentry{explicit instantiation definition}{
  name={Explicit Instantiation Definition},
  description={
TODO
}}

\newglossaryentry{explicit instantiation directive}{
  name={Explicit Instantiation Directive},
  description={
TODO
}}

\newglossaryentry{explicit specifier}{
  name={Explicit Specifier},
  description={
TODO
}}

\newglossaryentry{explicitly captured}{
  name={Explicitly Captured},
  description={
TODO
}}

\newglossaryentry{explicitly copied}{
  name={Explicitly Copied},
  description={
TODO
}}

\newglossaryentry{expression sfinae}{
  name={Expression SFINAE},
  description={
TODO
}}

\newglossaryentry{extended alignment}{
  name={Extended Alignment},
  description={
TODO
}}

\newglossaryentry{factory function}{
  name={Factory Function},
  description={
TODO
}}

\newglossaryentry{factory operator}{
  name={Factory Operator},
  description={
TODO
}}

\newglossaryentry{false sharing}{
  name={False Sharing},
  description={
TODO
}}

\newglossaryentry{fences}{
  name={Fences},
  description={
TODO
}}

\newglossaryentry{floating point literal}{
  name={Floating Point Literal},
  description={
TODO
}}

\newglossaryentry{floating-point-to-integer conversion}{
  name={Floating Point To Integer Conversion},
  nonumberlist,
  description={
TODO
}}
\AtBeginDocument{\glsadd{floating-point-to-integer conversion}}

\newglossaryentry{floating point to integer conversion}{
  name={Floating Point To Integer Conversion},
  description={
TODO
}}

\newglossaryentry{flow of control}{
  name={Flow Of Control},
  description={
TODO
}}

\newglossaryentry{footprint}{
  name={Footprint},
  description={
TODO
}}

\newglossaryentry{forward class declaration}{
  name={Forward Class Declaration},
  description={
TODO
}}

\newglossaryentry{forward declaration}{
  name={Forward Declaration},
  description={
TODO - mention about enums that this was Impossible prior to C++11 as the compiler could not determine the underlying type without visibility of the enumerators.
}}

\newglossaryentry{forward declare}{
  name={Forward Declare},
  description={
TODO
}}

\newglossaryentry{forward declared}{
  name={Forward Declared},
  description={
TODO
}}

\newglossaryentry{fragmentation}{
  name={Fragmentation},
  description={
TODO
}}

\newglossaryentry{free function}{
  name={Free Function},
  description={
TODO
}}

\newglossaryentry{free operator}{
  name={Free Operator},
  description={
TODO
}}

\newglossaryentry{fully associative}{
  name={Fully Associative},
  description={
TODO
}}

\newglossaryentry{fully constructed}{
  name={Fully Constructed},
  description={
TODO
}}

\newglossaryentry{function object}{
  name={Function Object},
  description={
TODO
}}

\newglossaryentry{function scope}{
  name={Function Scope},
  description={
TODO
}}

\newglossaryentry{functor}{
  name={Functor},
  description={
TODO
}}

\newglossaryentry{functor class}{
  name={Functor Class},
  description={
TODO
}}

\newglossaryentry{functor type}{
  name={Functor Type},
  description={
TODO
}}

\newglossaryentry{fundamental alignment}{
  name={Fundamental Alignment},
  description={
TODO
}}

\newglossaryentry{fundamental integral type}{
  name={Fundamental Integral Type},
  description={
TODO
}}

\newglossaryentry{fundamental types}{
  name={Fundamental Types},
  description={
TODO
}}

\newglossaryentry{general purpose machines}{
  name={General Purpose Machines},
  description={
General-purpose machines are what Big Tech, the financial industry, and many other large companies use exclusively.
}}

\newglossaryentry{generic lambda}{
  name={Generic Lambda},
  description={
TODO
}}

\newglossaryentry{golden file}{
  name={Golden File},
  description={
TODO
}}

\newglossaryentry{header only library}{
  name={Header Only Library},
  description={
TODO
}}

\newglossaryentry{hide}{
  name={Hide or Hiding},
  alts={{hiding},
       },
  description={
Function-name \textbf{hiding} occurs when a member function in a derived class has the same name as one in the base class, but it is not overriding it due to a difference in the function signature or because the member function in the base class is not \texttt{virtual}. The hidden member function will \textbf{not} participate in dynamic dispatch; the member function of the base class will be invoked instead when invoked via a pointer or reference to the base class . The same code would have invoked the derived class's implementation had the member function of the base class had been \textbf{overridden} rather than \textbf{hidden}.
}}

\newglossaryentry{higher order function}{
  name={Higher Order Function},
  description={
TODO
}}

\newglossaryentry{hyrum's law}{
  name={Hyrum'S Law},
  description={
TODO
}}

\newglossaryentry{IFNDR}{
  name={IFNDR},
  description={
see Ill-formed, No Diagnostic Required
}}

\newglossaryentry{id expression}{
  name={Id Expression},
  description={
TODO
}}

\newglossaryentry{ill formed}{
  name={Ill Formed},
  description={
TODO % (`[temp.res]p8`). The program is not valid C++. Generally, the compiler is required to produce a diagnostic (error) message, but see % [^ndr](.glossary).
}}

\newglossaryentry{ill formed, no diagnostic required (IFNDR)}{
  name={Ill Formed, No Diagnostic Required (Ifndr)},
  description={
TODO
}}

\newglossaryentry{ill formed, no diagnostic required}{
  name={Ill-Formed, No Diagnostic Required},
  description={
TODO *No diagnostic required*. The compiler is not mandated by the Standard to produce a diagnostic and the behavior of the code is *undefined*.
}}

\newglossaryentry{implementation defined}{
  name={Implementation Defined},
  description={
TODO
}}

\newglossaryentry{implementation inheritance}{
  name={Implementation Inheritance},
  description={
TODO
}}

\newglossaryentry{implicitly captured}{
  name={Implicitly Captured},
  description={
TODO
}}

\newglossaryentry{in process}{
  name={In Process},
  description={
TODO
}}

\newglossaryentry{inheriting constructors}{
  name={Inheriting Constructors},
  description={
TODO
}}

\newglossaryentry{init capture}{
  name={Init Capture},
  description={
TODO
}}

\newglossaryentry{instantiation time}{
  name={Instantiation Time},
  description={
TODO
}}

\newglossaryentry{insulate}{
  name={Insulate},
  description={
TODO
}}

\newglossaryentry{insulating}{
  name={Insulating},
  description={
TODO
}}

\newglossaryentry{insulation}{
  name={Insulation},
  description={
TODO
}}

\newglossaryentry{integer literal}{
  name={Integer Literal},
  description={
TODO
}}

\newglossaryentry{integer literals}{
  name={Integer Literals},
  description={
TODO
}}

\newglossaryentry{integer-to-floating-point conversion}{
  name={Integer To Floating Point Conversion},
  nonumberlist,
  description={
TODO
}}
\AtBeginDocument{\glsadd{integer-to-floating-point conversion}}

\newglossaryentry{integer to floating point conversion}{
  name={Integer To Floating Point Conversion},
  description={
TODO
}}

\newglossaryentry{integral constant expression}{
  name={Integral Constant Expression},
  description={
TODO
}}

\newglossaryentry{integral promotion}{
  name={Integral Promotion},
  description={
TODO
}}

\newglossaryentry{integral type}{
  name={Integral Type},
  description={
TODO
}}

\newglossaryentry{interface inheritance}{
  name={Interface Inheritance},
  description={
TODO
}}

\newglossaryentry{internal linkage}{
  name={Internal Linkage},
  description={
TODO
}}

\newglossaryentry{intra thread dependency}{
  name={Intra Thread Dependency},
  description={
TODO
}}

\newglossaryentry{join}{
  name={Join},
  nonumberlist,
  description={
TODO
}}
\AtBeginDocument{\glsadd{join}}

\newglossaryentry{lambda body}{
  name={Lambda Body},
  description={
TODO
}}

\newglossaryentry{lambda capture}{
  name={Lambda Capture},
  description={
TODO
}}

\newglossaryentry{lambda closure}{
  name={Lambda Closure},
  description={
TODO
}}

\newglossaryentry{lambda declarator}{
  name={Lambda Declarator},
  description={
TODO
}}

\newglossaryentry{lambda expressions}{
  name={Lambda Expressions},
  description={
TODO
}}

\newglossaryentry{lambda introducer}{
  name={Lambda Introducer},
  description={
TODO
}}

\newglossaryentry{leaks}{
  name={Leaks},
  nonumberlist,
  description={
TODO
}}
\AtBeginDocument{\glsadd{leaks}}

\newglossaryentry{linkage}{
  name={Linkage},
  description={
TODO
}}

\newglossaryentry{literal}{
  name={Literal},
  description={
TODO
}}

\newglossaryentry{literal type}{
  name={Literal Type},
  description={
TODO
}}

\newglossaryentry{local class}{
  name={Local Class},
  description={
TODO
}}

\newglossaryentry{local declaration}{
  name={Local Declaration},
  description={
TODO
}}

\newglossaryentry{local scope}{
  name={Local Scope},
  nonumberlist,
  description={
TODO
}}
\AtBeginDocument{\glsadd{local scope}}

\newglossaryentry{locality of reference}{
  name={Locality Of Reference},
  description={
TODO
}}

\newglossaryentry{logical}{
  name={Logical},
  description={
TODO
}}

\newglossaryentry{long distance friendship}{
  name={Long Distance Friendship},
  description={
TODO
}}

\newglossaryentry{mangled names}{
  name={Mangled Names},
  description={
TODO
}}

\newglossaryentry{mantissa}{
  name={Mantissa},
  description={
TODO
}}

\newglossaryentry{mechanism}{
  name={Mechanism},
  description={
TODO
}}

\newglossaryentry{mechanisms}{
  name={Mechanisms},
  description={
TODO
}}

\newglossaryentry{member}{
  name={Member},
  description={
TODO
}}

\newglossaryentry{member initializer list}{
  name={Member Initializer List},
  description={
TODO
}}

\newglossaryentry{memory fence instruction}{
  name={Memory Fence Instruction},
  description={
TODO
}}

\newglossaryentry{memory leak}{
  name={Memory Leak},
  description={
TODO
}}

\newglossaryentry{message}{
  name={Message},
  description={
TODO
}}

\newglossaryentry{messenger}{
  name={Messenger},
  description={
TODO
}}

\newglossaryentry{meyers singleton}{
  name={Meyers Singleton},
  description={
TODO
}}

\newglossaryentry{mixed mode builds}{
  name={Mixed Mode Builds},
  description={
TODO
}}

\newglossaryentry{modules}{
  name={Modules},
  description={
TODO
}}

\newglossaryentry{most vexing parse}{
  name={Most Vexing Parse},
  description={
TODO
}}

\newglossaryentry{move operations}{
  name={Move Operations},
  description={
TODO
}}

\longnewglossaryentry{move semantics}{
  name={Move Semantics},
  description={
An operation on two objects, a destination and a source, has \emcppsglossgloss{move semantics}
if, after it completes, the target object has the same \emcppsglossgloss{value} that the source object had before
the operation began.  Note that the source object may be modified, and is left in an unspecified state after
the operation completes.

Also note that any operation that has \emcppsglossgloss{copy semantics} also has \emcppsglossgloss{move semantics}.
}}

\newglossaryentry{multithreading context}{
  name={Multithreading Context},
  description={
TODO
}}

\newglossaryentry{naked literal}{
  name={Naked Literal},
  description={
TODO
}}

\newglossaryentry{name mangling}{
  name={Name Mangling},
  description={
TODO
}}

\newglossaryentry{narrow contract}{
  name={Narrow Contract},
  description={
TODO
}}

\newglossaryentry{natural alignment}{
  name={Natural Alignment},
  description={
TODO
}}

\newglossaryentry{nibbles}{
  name={Nibbles},
  description={
TODO
}}

\newglossaryentry{non trivial constructor}{
  name={Non Trivial Constructor},
  description={
TODO
}}

\newglossaryentry{non trivial special member function}{
  name={Non Trivial Special Member Function},
  description={
TODO
}}

\newglossaryentry{nonprimitive functionality}{
  name={Nonprimitive Functionality},
  description={
TODO
}}

\newglossaryentry{nonstatic data member}{
  name={Nonstatic Data Member},
  description={
TODO
}}

\newglossaryentry{null address}{
  name={Null Address},
  description={
TODO
}}

\newglossaryentry{ODR}{
  name={ODR},
  description={
TODO
}}

\newglossaryentry{object invariants}{
  name={Object Invariants},
  description={
TODO
}}

\newglossaryentry{odr used}{
  name={Odr Used},
  description={
TODO
}}

\newglossaryentry{ODR-used}{
  name={Odr-Used},
  description={
TODO
}}

\newglossaryentry{one definition rule}{
  name={One Definition Rule},
  description={
TODO
}}

\newglossaryentry{opaque declaration}{
  name={Opaque Declaration},
  description={
TODO
}}

\newglossaryentry{opaque enumeration}{
  name={Opaque Enumeration},
  description={
TODO
}}

\newglossaryentry{ordered after}{
  name={Ordered After},
  description={
TODO
}}

\newglossaryentry{overload resolution}{
  name={Overload Resolution},
  description={
TODO
}}

\newglossaryentry{overriding}{
  name={Overriding},
  description={
TODO
}}

\newglossaryentry{POD}{
  name={POD},
  description={
TODO
}}

\newglossaryentry{parameter pack}{
  name={Parameter Pack},
  description={
TODO
}}

\newglossaryentry{partial application}{
  name={Partial Application},
  description={
TODO
}}

\newglossaryentry{partial implementation}{
  name={Partial Implementation},
  description={
TODO
}}

\newglossaryentry{partially constructed}{
  name={Partially Constructed},
  description={
TODO
}}

\newglossaryentry{physical}{
  name={Physical},
  description={
TODO
}}

\newglossaryentry{physical design}{
  name={Physical Design},
  description={
TODO
}}

\newglossaryentry{placement new}{
  name={Placement New},
  description={
TODO
}}

\newglossaryentry{pointer to member}{
  name={Pointer To Member},
  description={
TODO
}}

\newglossaryentry{precondition}{
  name={Precondition},
  description={
TODO
}}

\newglossaryentry{predicate}{
  name={Predicate},
  description={
TODO
}}

\newglossaryentry{predicate function}{
  name={Predicate Function},
  description={
TODO
}}

\newglossaryentry{predicate functor}{
  name={Predicate Functor},
  description={
TODO
}}

\newglossaryentry{prepared-argument UDL operator}{
  name={Prepared Argument UDL Operator},
  description={
TODO
}}

\newglossaryentry{prepared argument udl operator}{
  name={Prepared Argument Udl Operator},
  description={
TODO
}}

\newglossaryentry{program stack}{
  name={Program Stack},
  nonumberlist,
  description={
TODO
}}
\AtBeginDocument{\glsadd{program stack}}

\newglossaryentry{protocol}{
  name={Protocol},
  description={
TODO
}}

\newglossaryentry{pure function}{
  name={Pure Function},
  description={
A function that produces no side effects and always returns the same value given the same sequence of argument values.
}}

\newglossaryentry{qualified name}{
  name={Qualified Name},
  description={
TODO
}}

\newglossaryentry{RAII}{
  name={RAII},
  description={
See Resource Acquisiition is Initialization
}}

\newglossaryentry{range}{
  name={Range},
  description={
TODO
}}

\newglossaryentry{raw string literals}{
  name={Raw String Literals},
  description={
TODO
}}

\newglossaryentry{raw UDL operator}{
  name={Raw Udl Operator},
  description={
TODO
}}

\newglossaryentry{raw udl operator}{
  name={Raw Udl Operator},
  description={
TODO
}}

\newglossaryentry{reaching scope}{
  name={Reaching Scope},
  description={
TODO
}}

\newglossaryentry{receiver}{
  name={Receiver},
  description={
TODO
}}

\newglossaryentry{redundant check}{
  name={Redundant Check},
  description={
TODO
}}

\newglossaryentry{reference type}{
  name={Reference Type},
  description={
TODO
}}

\newglossaryentry{release acquire}{
  name={Release Acquire},
  description={
TODO
}}

\newglossaryentry{release consume}{
  name={Release Consume},
  description={
TODO
}}

\newglossaryentry{return type deduction}{
  name={Return Type Deduction},
  description={
TODO
}}

\newglossaryentry{SFINAE}{
  name={SFINAE (Substitution Failure Is Not An Error)},
  description={
See Substitution Failure Is Not An Error
}}

\newglossaryentry{SHA}{
  name={SHA},
  description={
TODO
}}

\newglossaryentry{safe bool idiom}{
  name={Safe bool idiom},
  description={
A technique in class design that suppresses unwanted comparisons made available by the presence of a non-\lstinline!explicit! conversion function to \lstinline!bool!. %See also [explicit conversion operators]{.xref}. TODO: "Given a class \lstinline!C!, the idiom requires \lstinline!C! to provide a (implicit in C++03) conversion operator to return a type that is \emph{contextually convertible to \lstinline!bool!} (e.g., any integral or pointer type) but does not support arithmetic (e.g., a \emcppsglossgloss{pointer to member}), and the presence of non-member template comparison functions that invokes a \lstinline!private! (unimplemented) member function, purposefully causing a compile-time error, should two objects of \lstinline!C! ever be compared -- e.g., using equality or relational operations (valid on \emph{all} pointers types); see %[Karlsson04]{.ref}. An early version of a return type designed for this purpose, known as \lstinline!unspecified\_bool\_type! was implemented in Boost; see %[semashev07]{.ref}."
}}

\newglossaryentry{alignment requirement}{
  name={Scalar Type},
  description={
TODO
}}

\newglossaryentry{scalar type}{
  name={Scalar Type},
  description={
TODO
}}

\newglossaryentry{section}{
  name={Section},
  description={
TODO
}}

\newglossaryentry{sections}{
  name={Sections},
  description={
TODO
}}

\newglossaryentry{sender}{
  name={Sender},
  description={
TODO
}}

\newglossaryentry{set associative}{
  name={Set Associative},
  description={
TODO
}}

\newglossaryentry{side effects}{
  name={Side Effects},
  description={
TODO
}}

\newglossaryentry{signature}{
  name={Signature},
  description={
TODO
}}

\newglossaryentry{signed integer overflow}{
  name={Signed Integer Overflow},
  description={
TODO
}}

\newglossaryentry{simple capture}{
  name={Simple Capture},
  description={
TODO
}}

\newglossaryentry{slicing}{
  name={Slicing},
  description={
TODO
}}

\newglossaryentry{special functions}{
  name={Special Functions},
  description={
TODO
}}

\newglossaryentry{special member function}{
  name={Special Member Function},
  description={
As per the C++17 standard, the following are considered special member functions: \emph{destructors}, \emph{default constructors}, \emph{copy constructors}, \emph{move constructors}, \emph{copy assignment operators}, and \emph{move assignment operators}.
}}

\newglossaryentry{standard conversion}{
  name={Standard Conversion},
  description={
TODO
}}

\newglossaryentry{standard layout types}{
  name={Standard Layout Types},
  description={
TODO
}}

\newglossaryentry{static assertion declarations}{
  name={Static Assertion Declarations},
  description={
TODO
}}

\newglossaryentry{static data space}{
  name={Static Data Space},
  description={
TODO
}}

\newglossaryentry{static duration}{
  name={Static Duration},
  nonumberlist,
  description={
TODO
}}
\AtBeginDocument{\glsadd{static duration}}

\newglossaryentry{static storage duration}{
  name={Static Storage Duration},
  description={
TODO
}}

\newglossaryentry{storage duration}{
  name={Storage Duration},
  nonumberlist,
  description={
TODO
}}
\AtBeginDocument{\glsadd{storage duration}}

\newglossaryentry{string literal}{
  name={String Literal},
  description={
TODO
}}

\newglossaryentry{strong typedef idiom}{
  name={Strong Typedef Idiom},
  description={
TODO
}}

\newglossaryentry{strong typedef}{
  name={Strong \lstinline!typedef!},
  description={
TODO
}}

\newglossaryentry{structural inheritance}{
  name={Structural Inheritance},
  description={
TODO
}}

\newglossaryentry{sum type}{
  name={Sum Type},
  description={
Abstract data type allowing the representation of one of multiple possible alternative types. Each alternative has its own type (and state), and only one alternative can be ``active" at any given point in time. Sum types automatically keep track of which choice is ``active,'' and properly implement value-sematic special member functions (even for non-trivial types). They can be implemented efficiently as a C++ \texttt{class} using a C++ \texttt{union} and a separate (integral) discriminator. This sort of implementation is commonly referred to as a discriminating (or ``tagged'') union.
}}

\newglossaryentry{synchronization operation}{
  name={Synchronization Operation},
  description={
TODO
}}

\newglossaryentry{synchronization paradigm}{
  name={Synchronization Paradigm},
  description={
TODO
}}

\newglossaryentry{syntactic sugar}{
  name={Syntactic Sugar},
  description={
TODO
}}

\newglossaryentry{TLB}{
  name={TLB},
  description={
TODO
}}

\newglossaryentry{template head}{
  name={Template Head},
  description={
TODO
}}

\newglossaryentry{template instantiation time}{
  name={Template Instantiation Time},
  description={
TODO
}}

\newglossaryentry{template template class parameter}{
  name={Template Template Class Parameter},
  description={
TODO
}}

\newglossaryentry{template template parameter}{
  name={Template Template Parameter},
  description={
TODO
}}

\newglossaryentry{templated UDL operator}{
  name={Templated Udl Operator},
  description={
TODO
}}

\newglossaryentry{templated udl operator}{
  name={Templated Udl Operator},
  description={
TODO
}}

\newglossaryentry{test driver}{
  name={Test Driver},
  description={
TODO
}}

\newglossaryentry{thrashing}{
  name={Thrashing},
  description={
TODO
}}

\newglossaryentry{trailing return type}{
  name={Trailing Return Type},
  description={
TODO
}}

\newglossaryentry{translation unit}{
  name={Translation Unit},
  description={
TODO
}}

\newglossaryentry{trivial}{
  name={Trivial},
  description={
TODO
}}

\newglossaryentry{trivial operation}{
  name={Trivial Operation},
  description={
TODO
}}

\newglossaryentry{trivial types}{
  name={Trivial Types},
  description={
TODO
}}

\newglossaryentry{trivially constructible}{
  name={Trivially Constructible},
  description={
TODO
}}

\longnewglossaryentry{trivially copy constructor}{
  name={Trivially Copy Constructor},
  nonumberlist,
  description={
The requirements for the copy constructor of a class \lstinline!T! to be considered trivial are as follows:

%\begin{itemize}
%\item It must not be user-provided;
%\item If defaulted, its signature must be the same as implicitly-defined (exception specification and qualifiers on the argument must match);
%\item  \lstinline!T! must have no \lstinline!virtual! member functions or \lstinline!virtual! base classes;
%\item The copy constructor for every single data member and base class of \lstinline!T! must be trivial (recursively).
%\end{itemize}
}}
\AtBeginDocument{\glsadd{trivially copy constructor}}

\newglossaryentry{trivially copyable}{
  name={Trivially Copyable},
  description={
TODO
}}

\newglossaryentry{true sharing}{
  name={True Sharing},
  description={
TODO
}}

\newglossaryentry{type alias}{
  name={Type Alias},
  description={
TODO
}}

\newglossaryentry{type category}{
  name={Type Category},
  description={
TODO
}}

\newglossaryentry{type erasure}{
  name={Type Erasure},
  description={
TODO
}}

\newglossaryentry{type suffix}{
  name={Type Suffix},
  description={
TODO
}}

\newglossaryentry{type trait}{
  name={Type Trait},
  description={
TODO
}}

\newglossaryentry{type traits}{
  name={Type Traits},
  description={
TODO
}}

\newglossaryentry{UDT}{
  name={UDT},
  description={
TODO
}}

\newglossaryentry{UTF 16}{
  name={UTF 16},
  description={
TODO
}}

\newglossaryentry{UTF 32}{
  name={UTF 32},
  description={
TODO
}}

\newglossaryentry{UTF 8}{
  name={UTF 8},
  description={
TODO
}}

\newglossaryentry{UTF-16}{
  name={UTF-16},
  nonumberlist,
  description={
TODO
}}
\AtBeginDocument{\glsadd{UTF-16}}

\newglossaryentry{UTF-32}{
  name={UTF-32},
  nonumberlist,
  description={
TODO
}}
\AtBeginDocument{\glsadd{UTF-32}}

\newglossaryentry{UTF-8}{
  name={UTF-8},
  nonumberlist,
  description={
TODO
}}
\AtBeginDocument{\glsadd{UTF-8}}

\newglossaryentry{udl operator}{
  name={Udl Operator},
  description={
TODO
}}

\newglossaryentry{UDL operator}{
  name={Udl Operator},
  description={
TODO
}}

\newglossaryentry{udl suffix}{
  name={Udl Suffix},
  description={
TODO
}}

\newglossaryentry{UDL suffix}{
  name={Udl Suffix},
  description={
TODO
}}

\newglossaryentry{udl type category}{
  name={Udl Type Category},
  description={
TODO
}}

\newglossaryentry{UDL type category}{
  name={Udl Type Category},
  description={
TODO
}}

\newglossaryentry{undefined}{
  name={Undefined},
  description={
TODO
}}

\newglossaryentry{undefined behavior}{
  name={Undefined Behavior},
  description={
TODO
}}

\newglossaryentry{undefined symbols}{
  name={Undefined Symbols},
  description={
TODO
}}

\newglossaryentry{underlying type}{
  name={Underlying Type},
  description={
TODO
}}

\newglossaryentry{underlying type (UT)}{
  name={Underlying Type (Ut)},
  description={
TODO
}}

\newglossaryentry{unevaluated contexts}{
  name={Unevaluated Contexts},
  description={
TODO
}}

\newglossaryentry{unnamed namespace}{
  name={Unnamed Namespace},
  description={
TODO
}}

\newglossaryentry{unqualified name lookup}{
  name={Unqualified Name Lookup},
  description={
TODO
}}

\newglossaryentry{user defined literal (UDL)}{
  name={User Defined Literal (Udl)},
  description={
TODO
}}

\newglossaryentry{user defined type}{
  name={User Defined Type},
  description={
TODO
}}

\newglossaryentry{user defined type (UDT)}{
  name={User Defined Type (Udt)},
  description={
TODO
}}

\newglossaryentry{user provided}{
  name={User Provided},
  description={
TODO
}}

\longnewglossaryentry{user provided special member function}{
  name={User Provided Special Member Function},
  description={
In the C++11 standard, a special member function is considered \emcppsglossgloss{user-provided} if it has been explicitly declared by the programmer and not explicitly defaulted or deleted in its first declaration:

%begin{emcppslisting}
%struct S0
%{
%    S0(); // User-provided
%};
%
%struct S1
%{
%    S1() = default; // Not user-provided
%};
%\end{emcppslisting}

One of the requirement for a special member function to be considered \emcppsglossgloss{trivial} is that it is not user-provided. Trivial classes (i.e. with all special member function being trivial) have special semantics (e.g. they can be safely used with \lstinline!std::memcpy!, or copied into a suitable array of \lstinline!char! and back). See %[Generalized PODs]{.xref} for more information.
}}

\newglossaryentry{user provided special member functions}{
  name={User Provided Special Member Functions},
  description={
TODO
}}

\newglossaryentry{user provied}{
  name={User Provied},
  description={
TODO
}}

\newglossaryentry{using declaration}{
  name={Using Declaration},
  description={
TODO
}}

\newglossaryentry{using directive}{
  name={Using Directive},
  description={
TODO
}}

\newglossaryentry{value}{
  name={Value},
  description={
TODO
}}

\newglossaryentry{value category}{
  name={Value Category},
  description={
TODO
}}

\newglossaryentry{value constructor}{
  name={Value Constructor},
  description={
TODO
}}

\newglossaryentry{value semantic}{
  name={Value Semantic},
  description={
TODO
}}

\newglossaryentry{value semantic type}{
  name={Value Semantic Type},
  description={
TODO
}}

\newglossaryentry{variable}{
  name={Variable},
  description={
TODO
}}

\newglossaryentry{variadic function template}{
  name={Variadic Function Template},
  description={
TODO
}}

\newglossaryentry{vocabulary type}{
  name={Vocabulary Type},
  description={
TODO
}}

\newglossaryentry{well formed}{
  name={Well Formed},
  description={
TODO
}}

\newglossaryentry{working set}{
  name={Working Set},
  description={
TODO
}}

\newglossaryentry{zero initialized}{
  name={Zero Initialized},
  description={
TODO
}}

\newglossaryentry{copy initialization}{
  name={copy initialization},
  description={
TODO
}}

\newglossaryentry{expression template}{
  name={expression template},
  description={
TODO
}}

\newglossaryentry{function template argument type deduction}{
  name={function template argument type deduction},
  description={
TODO
}}

\newglossaryentry{inline namespace}{
  name={inline namespace},
  description={
TODO
}}

\newglossaryentry{integral constant}{
  name={integral constant},
  description={
TODO
}}

\newglossaryentry{placeholder type}{
  name={placeholder type},
  description={
TODO
}}

\newglossaryentry{storage class specifier}{
  name={storage class specifier},
  description={
TODO
}}

\newglossaryentry{trivially destructible}{
  name={trivially destructible},
  description={
TODO
}}

\newglossaryentry{variable template}{
  name={variable template},
  description={
TODO
}}
